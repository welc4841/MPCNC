Marlin based on this commit:
commit 398cae762506a43eb27a815f10bee6e2821c6c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 6 18:39:05 2022 -0500

    ðŸ”– Version 2.1.1

git files that changed:

M	Marlin/Configuration.h
M	Marlin/Configuration_adv.h
D	Marlin/src/HAL/AVR/HAL.cpp
D	Marlin/src/HAL/AVR/HAL.h
D	Marlin/src/HAL/AVR/HAL_SPI.cpp
D	Marlin/src/HAL/AVR/MarlinSPI.h
D	Marlin/src/HAL/AVR/MarlinSerial.cpp
D	Marlin/src/HAL/AVR/MarlinSerial.h
D	Marlin/src/HAL/AVR/Servo.cpp
D	Marlin/src/HAL/AVR/ServoTimers.h
D	Marlin/src/HAL/AVR/eeprom.cpp
D	Marlin/src/HAL/AVR/endstop_interrupts.h
D	Marlin/src/HAL/AVR/fast_pwm.cpp
D	Marlin/src/HAL/AVR/fastio.cpp
D	Marlin/src/HAL/AVR/fastio.h
D	Marlin/src/HAL/AVR/fastio/fastio_1280.h
D	Marlin/src/HAL/AVR/fastio/fastio_1281.h
D	Marlin/src/HAL/AVR/fastio/fastio_168.h
D	Marlin/src/HAL/AVR/fastio/fastio_644.h
D	Marlin/src/HAL/AVR/fastio/fastio_AT90USB.h
D	Marlin/src/HAL/AVR/inc/Conditionals_LCD.h
D	Marlin/src/HAL/AVR/inc/Conditionals_adv.h
D	Marlin/src/HAL/AVR/inc/Conditionals_post.h
D	Marlin/src/HAL/AVR/inc/SanityCheck.h
D	Marlin/src/HAL/AVR/math.h
D	Marlin/src/HAL/AVR/pinsDebug.h
D	Marlin/src/HAL/AVR/pinsDebug_Teensyduino.h
D	Marlin/src/HAL/AVR/pinsDebug_plus_70.h
D	Marlin/src/HAL/AVR/spi_pins.h
D	Marlin/src/HAL/AVR/timers.h
D	Marlin/src/HAL/AVR/u8g_com_HAL_AVR_sw_spi.cpp
D	Marlin/src/HAL/DUE/HAL.cpp
D	Marlin/src/HAL/DUE/HAL.h
D	Marlin/src/HAL/DUE/HAL_SPI.cpp
D	Marlin/src/HAL/DUE/InterruptVectors.cpp
D	Marlin/src/HAL/DUE/InterruptVectors.h
D	Marlin/src/HAL/DUE/MarlinSPI.h
D	Marlin/src/HAL/DUE/MarlinSerial.cpp
D	Marlin/src/HAL/DUE/MarlinSerial.h
D	Marlin/src/HAL/DUE/MarlinSerialUSB.cpp
D	Marlin/src/HAL/DUE/MarlinSerialUSB.h
D	Marlin/src/HAL/DUE/MinSerial.cpp
D	Marlin/src/HAL/DUE/Servo.cpp
D	Marlin/src/HAL/DUE/ServoTimers.h
D	Marlin/src/HAL/DUE/Tone.cpp
D	Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_shared_hw_spi.cpp
D	Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_st7920_sw_spi.cpp
D	Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi.cpp
D	Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.cpp
D	Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.h
D	Marlin/src/HAL/DUE/eeprom_flash.cpp
D	Marlin/src/HAL/DUE/eeprom_wired.cpp
D	Marlin/src/HAL/DUE/endstop_interrupts.h
D	Marlin/src/HAL/DUE/fastio.h
D	Marlin/src/HAL/DUE/fastio/G2_PWM.cpp
D	Marlin/src/HAL/DUE/fastio/G2_PWM.h
D	Marlin/src/HAL/DUE/fastio/G2_pins.h
D	Marlin/src/HAL/DUE/inc/Conditionals_LCD.h
D	Marlin/src/HAL/DUE/inc/Conditionals_adv.h
D	Marlin/src/HAL/DUE/inc/Conditionals_post.h
D	Marlin/src/HAL/DUE/inc/SanityCheck.h
D	Marlin/src/HAL/DUE/pinsDebug.h
D	Marlin/src/HAL/DUE/spi_pins.h
D	Marlin/src/HAL/DUE/timers.cpp
D	Marlin/src/HAL/DUE/timers.h
D	Marlin/src/HAL/DUE/upload_extra_script.py
D	Marlin/src/HAL/DUE/usb/arduino_due_x.h
D	Marlin/src/HAL/DUE/usb/compiler.h
D	Marlin/src/HAL/DUE/usb/conf_access.h
D	Marlin/src/HAL/DUE/usb/conf_clock.h
D	Marlin/src/HAL/DUE/usb/conf_usb.h
D	Marlin/src/HAL/DUE/usb/ctrl_access.c
D	Marlin/src/HAL/DUE/usb/ctrl_access.h
D	Marlin/src/HAL/DUE/usb/genclk.h
D	Marlin/src/HAL/DUE/usb/mrepeat.h
D	Marlin/src/HAL/DUE/usb/osc.h
D	Marlin/src/HAL/DUE/usb/pll.h
D	Marlin/src/HAL/DUE/usb/preprocessor.h
D	Marlin/src/HAL/DUE/usb/sbc_protocol.h
D	Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.cpp
D	Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.h
D	Marlin/src/HAL/DUE/usb/spc_protocol.h
D	Marlin/src/HAL/DUE/usb/stringz.h
D	Marlin/src/HAL/DUE/usb/sysclk.c
D	Marlin/src/HAL/DUE/usb/sysclk.h
D	Marlin/src/HAL/DUE/usb/tpaste.h
D	Marlin/src/HAL/DUE/usb/udc.c
D	Marlin/src/HAL/DUE/usb/udc.h
D	Marlin/src/HAL/DUE/usb/udc_desc.h
D	Marlin/src/HAL/DUE/usb/udd.h
D	Marlin/src/HAL/DUE/usb/udi.h
D	Marlin/src/HAL/DUE/usb/udi_cdc.c
D	Marlin/src/HAL/DUE/usb/udi_cdc.h
D	Marlin/src/HAL/DUE/usb/udi_cdc_conf.h
D	Marlin/src/HAL/DUE/usb/udi_cdc_desc.c
D	Marlin/src/HAL/DUE/usb/udi_composite_desc.c
D	Marlin/src/HAL/DUE/usb/udi_msc.c
D	Marlin/src/HAL/DUE/usb/udi_msc.h
D	Marlin/src/HAL/DUE/usb/uotghs_device_due.c
D	Marlin/src/HAL/DUE/usb/uotghs_device_due.h
D	Marlin/src/HAL/DUE/usb/uotghs_otg.h
D	Marlin/src/HAL/DUE/usb/usb_protocol.h
D	Marlin/src/HAL/DUE/usb/usb_protocol_cdc.h
D	Marlin/src/HAL/DUE/usb/usb_protocol_msc.h
D	Marlin/src/HAL/DUE/usb/usb_task.c
D	Marlin/src/HAL/DUE/usb/usb_task.h
D	Marlin/src/HAL/ESP32/FlushableHardwareSerial.cpp
D	Marlin/src/HAL/ESP32/FlushableHardwareSerial.h
D	Marlin/src/HAL/ESP32/HAL.cpp
D	Marlin/src/HAL/ESP32/HAL.h
D	Marlin/src/HAL/ESP32/HAL_SPI.cpp
D	Marlin/src/HAL/ESP32/MarlinSPI.h
D	Marlin/src/HAL/ESP32/Servo.cpp
D	Marlin/src/HAL/ESP32/Servo.h
D	Marlin/src/HAL/ESP32/Tone.cpp
D	Marlin/src/HAL/ESP32/WebSocketSerial.cpp
D	Marlin/src/HAL/ESP32/WebSocketSerial.h
D	Marlin/src/HAL/ESP32/eeprom.cpp
D	Marlin/src/HAL/ESP32/endstop_interrupts.h
D	Marlin/src/HAL/ESP32/esp32.csv
D	Marlin/src/HAL/ESP32/fastio.h
D	Marlin/src/HAL/ESP32/i2s.cpp
D	Marlin/src/HAL/ESP32/i2s.h
D	Marlin/src/HAL/ESP32/inc/Conditionals_LCD.h
D	Marlin/src/HAL/ESP32/inc/Conditionals_adv.h
D	Marlin/src/HAL/ESP32/inc/Conditionals_post.h
D	Marlin/src/HAL/ESP32/inc/SanityCheck.h
D	Marlin/src/HAL/ESP32/ota.cpp
D	Marlin/src/HAL/ESP32/ota.h
D	Marlin/src/HAL/ESP32/servotimers.h
D	Marlin/src/HAL/ESP32/spi_pins.h
D	Marlin/src/HAL/ESP32/spiffs.cpp
D	Marlin/src/HAL/ESP32/spiffs.h
D	Marlin/src/HAL/ESP32/timers.cpp
D	Marlin/src/HAL/ESP32/timers.h
D	Marlin/src/HAL/ESP32/u8g_esp32_spi.cpp
D	Marlin/src/HAL/ESP32/web.cpp
D	Marlin/src/HAL/ESP32/web.h
D	Marlin/src/HAL/ESP32/wifi.cpp
D	Marlin/src/HAL/ESP32/wifi.h
D	Marlin/src/HAL/LINUX/HAL.cpp
D	Marlin/src/HAL/LINUX/HAL.h
D	Marlin/src/HAL/LINUX/MarlinSPI.h
D	Marlin/src/HAL/LINUX/arduino.cpp
D	Marlin/src/HAL/LINUX/eeprom.cpp
D	Marlin/src/HAL/LINUX/fastio.h
D	Marlin/src/HAL/LINUX/hardware/Clock.cpp
D	Marlin/src/HAL/LINUX/hardware/Clock.h
D	Marlin/src/HAL/LINUX/hardware/Gpio.cpp
D	Marlin/src/HAL/LINUX/hardware/Gpio.h
D	Marlin/src/HAL/LINUX/hardware/Heater.cpp
D	Marlin/src/HAL/LINUX/hardware/Heater.h
D	Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.cpp
D	Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.h
D	Marlin/src/HAL/LINUX/hardware/LinearAxis.cpp
D	Marlin/src/HAL/LINUX/hardware/LinearAxis.h
D	Marlin/src/HAL/LINUX/hardware/Timer.cpp
D	Marlin/src/HAL/LINUX/hardware/Timer.h
D	Marlin/src/HAL/LINUX/inc/Conditionals_LCD.h
D	Marlin/src/HAL/LINUX/inc/Conditionals_adv.h
D	Marlin/src/HAL/LINUX/inc/Conditionals_post.h
D	Marlin/src/HAL/LINUX/inc/SanityCheck.h
D	Marlin/src/HAL/LINUX/include/Arduino.h
D	Marlin/src/HAL/LINUX/include/pinmapping.cpp
D	Marlin/src/HAL/LINUX/include/pinmapping.h
D	Marlin/src/HAL/LINUX/include/serial.h
D	Marlin/src/HAL/LINUX/main.cpp
D	Marlin/src/HAL/LINUX/pinsDebug.h
D	Marlin/src/HAL/LINUX/servo_private.h
D	Marlin/src/HAL/LINUX/spi_pins.h
D	Marlin/src/HAL/LINUX/timers.cpp
D	Marlin/src/HAL/LINUX/timers.h
D	Marlin/src/HAL/LPC1768/HAL.cpp
D	Marlin/src/HAL/LPC1768/HAL.h
D	Marlin/src/HAL/LPC1768/HAL_SPI.cpp
D	Marlin/src/HAL/LPC1768/MarlinSPI.h
D	Marlin/src/HAL/LPC1768/MarlinSerial.cpp
D	Marlin/src/HAL/LPC1768/MarlinSerial.h
D	Marlin/src/HAL/LPC1768/MinSerial.cpp
D	Marlin/src/HAL/LPC1768/Servo.h
D	Marlin/src/HAL/LPC1768/eeprom_flash.cpp
D	Marlin/src/HAL/LPC1768/eeprom_sdcard.cpp
D	Marlin/src/HAL/LPC1768/eeprom_wired.cpp
D	Marlin/src/HAL/LPC1768/endstop_interrupts.h
D	Marlin/src/HAL/LPC1768/fast_pwm.cpp
D	Marlin/src/HAL/LPC1768/fastio.h
D	Marlin/src/HAL/LPC1768/inc/Conditionals_LCD.h
D	Marlin/src/HAL/LPC1768/inc/Conditionals_adv.h
D	Marlin/src/HAL/LPC1768/inc/Conditionals_post.h
D	Marlin/src/HAL/LPC1768/inc/SanityCheck.h
D	Marlin/src/HAL/LPC1768/include/SPI.h
D	Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.c
D	Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.h
D	Marlin/src/HAL/LPC1768/include/i2c_util.c
D	Marlin/src/HAL/LPC1768/include/i2c_util.h
D	Marlin/src/HAL/LPC1768/main.cpp
D	Marlin/src/HAL/LPC1768/pinsDebug.h
D	Marlin/src/HAL/LPC1768/spi_pins.h
D	Marlin/src/HAL/LPC1768/tft/tft_spi.cpp
D	Marlin/src/HAL/LPC1768/tft/tft_spi.h
D	Marlin/src/HAL/LPC1768/tft/xpt2046.cpp
D	Marlin/src/HAL/LPC1768/tft/xpt2046.h
D	Marlin/src/HAL/LPC1768/timers.cpp
D	Marlin/src/HAL/LPC1768/timers.h
D	Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.cpp
D	Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.h
D	Marlin/src/HAL/LPC1768/u8g/LCD_defines.h
D	Marlin/src/HAL/LPC1768/u8g/LCD_delay.h
D	Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.c
D	Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.h
D	Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_hw_spi.cpp
D	Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_ssd_hw_i2c.cpp
D	Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_hw_spi.cpp
D	Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_sw_spi.cpp
D	Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_sw_spi.cpp
D	Marlin/src/HAL/LPC1768/upload_extra_script.py
D	Marlin/src/HAL/LPC1768/usb_serial.cpp
D	Marlin/src/HAL/LPC1768/win_usb_driver/lpc176x_usb_driver.inf
D	Marlin/src/HAL/SAMD51/HAL.cpp
D	Marlin/src/HAL/SAMD51/HAL.h
D	Marlin/src/HAL/SAMD51/HAL_SPI.cpp
D	Marlin/src/HAL/SAMD51/MarlinSPI.h
D	Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.cpp
D	Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.h
D	Marlin/src/HAL/SAMD51/QSPIFlash.cpp
D	Marlin/src/HAL/SAMD51/QSPIFlash.h
D	Marlin/src/HAL/SAMD51/SAMD51.h
D	Marlin/src/HAL/SAMD51/Servo.cpp
D	Marlin/src/HAL/SAMD51/ServoTimers.h
D	Marlin/src/HAL/SAMD51/eeprom_flash.cpp
D	Marlin/src/HAL/SAMD51/eeprom_qspi.cpp
D	Marlin/src/HAL/SAMD51/eeprom_wired.cpp
D	Marlin/src/HAL/SAMD51/endstop_interrupts.h
D	Marlin/src/HAL/SAMD51/fastio.h
D	Marlin/src/HAL/SAMD51/inc/Conditionals_LCD.h
D	Marlin/src/HAL/SAMD51/inc/Conditionals_adv.h
D	Marlin/src/HAL/SAMD51/inc/Conditionals_post.h
D	Marlin/src/HAL/SAMD51/inc/SanityCheck.h
D	Marlin/src/HAL/SAMD51/pinsDebug.h
D	Marlin/src/HAL/SAMD51/spi_pins.h
D	Marlin/src/HAL/SAMD51/timers.cpp
D	Marlin/src/HAL/SAMD51/timers.h
D	Marlin/src/HAL/TEENSY31_32/HAL.cpp
D	Marlin/src/HAL/TEENSY31_32/HAL.h
D	Marlin/src/HAL/TEENSY31_32/HAL_SPI.cpp
D	Marlin/src/HAL/TEENSY31_32/MarlinSPI.h
D	Marlin/src/HAL/TEENSY31_32/Servo.cpp
D	Marlin/src/HAL/TEENSY31_32/Servo.h
D	Marlin/src/HAL/TEENSY31_32/eeprom.cpp
D	Marlin/src/HAL/TEENSY31_32/endstop_interrupts.h
D	Marlin/src/HAL/TEENSY31_32/fastio.h
D	Marlin/src/HAL/TEENSY31_32/inc/Conditionals_LCD.h
D	Marlin/src/HAL/TEENSY31_32/inc/Conditionals_adv.h
D	Marlin/src/HAL/TEENSY31_32/inc/Conditionals_post.h
D	Marlin/src/HAL/TEENSY31_32/inc/SanityCheck.h
D	Marlin/src/HAL/TEENSY31_32/pinsDebug.h
D	Marlin/src/HAL/TEENSY31_32/spi_pins.h
D	Marlin/src/HAL/TEENSY31_32/timers.cpp
D	Marlin/src/HAL/TEENSY31_32/timers.h
D	Marlin/src/HAL/TEENSY35_36/HAL.cpp
D	Marlin/src/HAL/TEENSY35_36/HAL.h
D	Marlin/src/HAL/TEENSY35_36/HAL_SPI.cpp
D	Marlin/src/HAL/TEENSY35_36/MarlinSPI.h
D	Marlin/src/HAL/TEENSY35_36/Servo.cpp
D	Marlin/src/HAL/TEENSY35_36/Servo.h
D	Marlin/src/HAL/TEENSY35_36/eeprom.cpp
D	Marlin/src/HAL/TEENSY35_36/endstop_interrupts.h
D	Marlin/src/HAL/TEENSY35_36/fastio.h
D	Marlin/src/HAL/TEENSY35_36/inc/Conditionals_LCD.h
D	Marlin/src/HAL/TEENSY35_36/inc/Conditionals_adv.h
D	Marlin/src/HAL/TEENSY35_36/inc/Conditionals_post.h
D	Marlin/src/HAL/TEENSY35_36/inc/SanityCheck.h
D	Marlin/src/HAL/TEENSY35_36/pinsDebug.h
D	Marlin/src/HAL/TEENSY35_36/spi_pins.h
D	Marlin/src/HAL/TEENSY35_36/timers.cpp
D	Marlin/src/HAL/TEENSY35_36/timers.h
D	Marlin/src/HAL/TEENSY40_41/HAL.cpp
D	Marlin/src/HAL/TEENSY40_41/HAL.h
D	Marlin/src/HAL/TEENSY40_41/HAL_SPI.cpp
D	Marlin/src/HAL/TEENSY40_41/MarlinSPI.h
D	Marlin/src/HAL/TEENSY40_41/Servo.cpp
D	Marlin/src/HAL/TEENSY40_41/Servo.h
D	Marlin/src/HAL/TEENSY40_41/eeprom.cpp
D	Marlin/src/HAL/TEENSY40_41/endstop_interrupts.h
D	Marlin/src/HAL/TEENSY40_41/fastio.h
D	Marlin/src/HAL/TEENSY40_41/inc/Conditionals_LCD.h
D	Marlin/src/HAL/TEENSY40_41/inc/Conditionals_adv.h
D	Marlin/src/HAL/TEENSY40_41/inc/Conditionals_post.h
D	Marlin/src/HAL/TEENSY40_41/inc/SanityCheck.h
D	Marlin/src/HAL/TEENSY40_41/pinsDebug.h
D	Marlin/src/HAL/TEENSY40_41/spi_pins.h
D	Marlin/src/HAL/TEENSY40_41/timers.cpp
D	Marlin/src/HAL/TEENSY40_41/timers.h
M	README.md
M	platformio.ini

git detailed diff:

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 2c16b8f..8227d38 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -1,3 +1,7 @@
+#define SPINDLE_LASER_ENA_PIN PB0 // Heater2
+#define SPINDLE_LASER_PWM_PIN PC9
+#define SPINDLE_LASER_PWM_PIN PC9
+#define SPINDLE_LASER_ENA_PIN PB0 // Heater2
 /**
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
@@ -60,7 +64,7 @@
 // @section info
 
 // Author info of this build printed to the host during boot and M115
-#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
+#define STRING_CONFIG_H_AUTHOR "(V1 Engineering, Ryan, 515D)" // "(none, default config)" // Who made the changes.
 //#define CUSTOM_VERSION_FILE Version.h // Path from the root directory (no quotes)
 
 /**
@@ -78,7 +82,7 @@
 #define SHOW_BOOTSCREEN
 
 // Show the bitmap in Marlin/_Bootscreen.h on startup.
-//#define SHOW_CUSTOM_BOOTSCREEN
+#define SHOW_CUSTOM_BOOTSCREEN
 
 // Show the bitmap in Marlin/_Statusscreen.h on the status screen.
 //#define CUSTOM_STATUS_SCREEN_IMAGE
@@ -87,7 +91,7 @@
 
 // Choose the name from boards.h that matches your setup
 #ifndef MOTHERBOARD
-  #define MOTHERBOARD BOARD_RAMPS_14_EFB
+  #define MOTHERBOARD BOARD_BTT_SKR_PRO_V1_2 // BOARD_RAMPS_14_EFB
 #endif
 
 /**
@@ -98,7 +102,7 @@
  *
  * :[-1, 0, 1, 2, 3, 4, 5, 6, 7]
  */
-#define SERIAL_PORT 0
+#define SERIAL_PORT 1 // 0
 
 /**
  * Serial Port Baud Rate
@@ -120,7 +124,7 @@
  * Currently Ethernet (-2) is only supported on Teensy 4.1 boards.
  * :[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7]
  */
-//#define SERIAL_PORT_2 -1
+#define SERIAL_PORT_2 -1 // -1
 //#define BAUDRATE_2 250000   // :[2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000] Enable to override BAUDRATE
 
 /**
@@ -128,14 +132,14 @@
  * Currently only supported for AVR, DUE, LPC1768/9 and STM32/STM32F1
  * :[-1, 0, 1, 2, 3, 4, 5, 6, 7]
  */
-//#define SERIAL_PORT_3 1
+#define SERIAL_PORT_3 6 // 1
 //#define BAUDRATE_3 250000   // :[2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000] Enable to override BAUDRATE
 
 // Enable the Bluetooth serial interface on AT90USB devices
 //#define BLUETOOTH
 
 // Name displayed in the LCD "Ready" message and Info menu
-//#define CUSTOM_MACHINE_NAME "3D Printer"
+#define CUSTOM_MACHINE_NAME "V1CNC 515D" // "3D Printer"
 
 // Printer's unique ID, used by some programs to differentiate between machines.
 // Choose your own or use a service like https://www.uuidgenerator.net/version4
@@ -156,11 +160,11 @@
  *          TMC5130, TMC5130_STANDALONE, TMC5160, TMC5160_STANDALONE
  * :['A4988', 'A5984', 'DRV8825', 'LV8729', 'TB6560', 'TB6600', 'TMC2100', 'TMC2130', 'TMC2130_STANDALONE', 'TMC2160', 'TMC2160_STANDALONE', 'TMC2208', 'TMC2208_STANDALONE', 'TMC2209', 'TMC2209_STANDALONE', 'TMC26X', 'TMC26X_STANDALONE', 'TMC2660', 'TMC2660_STANDALONE', 'TMC5130', 'TMC5130_STANDALONE', 'TMC5160', 'TMC5160_STANDALONE']
  */
-#define X_DRIVER_TYPE  A4988
-#define Y_DRIVER_TYPE  A4988
-#define Z_DRIVER_TYPE  A4988
-//#define X2_DRIVER_TYPE A4988
-//#define Y2_DRIVER_TYPE A4988
+#define X_DRIVER_TYPE TMC2209 // TMC2209 // A4988
+#define Y_DRIVER_TYPE TMC2209 // TMC2209 // A4988
+#define Z_DRIVER_TYPE TMC2209 // TMC2209 // A4988
+#define X2_DRIVER_TYPE TMC2209 // A4988
+#define Y2_DRIVER_TYPE TMC2209 // A4988
 //#define Z2_DRIVER_TYPE A4988
 //#define Z3_DRIVER_TYPE A4988
 //#define Z4_DRIVER_TYPE A4988
@@ -170,7 +174,7 @@
 //#define U_DRIVER_TYPE  A4988
 //#define V_DRIVER_TYPE  A4988
 //#define W_DRIVER_TYPE  A4988
-#define E0_DRIVER_TYPE A4988
+//#define E0_DRIVER_TYPE A4988
 //#define E1_DRIVER_TYPE A4988
 //#define E2_DRIVER_TYPE A4988
 //#define E3_DRIVER_TYPE A4988
@@ -225,7 +229,7 @@
 
 // This defines the number of extruders
 // :[0, 1, 2, 3, 4, 5, 6, 7, 8]
-#define EXTRUDERS 1
+#define EXTRUDERS 0 // 1
 
 // Generally expected filament diameter (1.75, 2.85, 3.0, ...). Used for Volumetric, Filament Width Sensor, etc.
 #define DEFAULT_NOMINAL_FILAMENT_DIA 1.75
@@ -1033,8 +1037,8 @@
 //#define USE_UMIN_PLUG
 //#define USE_VMIN_PLUG
 //#define USE_WMIN_PLUG
-//#define USE_XMAX_PLUG
-//#define USE_YMAX_PLUG
+#define USE_XMAX_PLUG
+#define USE_YMAX_PLUG
 //#define USE_ZMAX_PLUG
 //#define USE_IMAX_PLUG
 //#define USE_JMAX_PLUG
@@ -1096,7 +1100,7 @@
 // Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).
 #define X_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define Y_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
-#define Z_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
+#define Z_MIN_ENDSTOP_INVERTING true // false // Set to true to invert the logic of the endstop.
 #define I_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define J_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define K_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
@@ -1112,7 +1116,7 @@
 #define U_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define V_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define W_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
-#define Z_MIN_PROBE_ENDSTOP_INVERTING false // Set to true to invert the logic of the probe.
+#define Z_MIN_PROBE_ENDSTOP_INVERTING true // false // Set to true to invert the logic of the probe.
 
 // Enable this feature if all enabled endstop pins are interrupt-capable.
 // This will remove the need to poll the interrupt pins, saving many CPU cycles.
@@ -1160,14 +1164,14 @@
  * Override with M92
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_AXIS_STEPS_PER_UNIT   { 80, 80, 400, 500 }
+#define DEFAULT_AXIS_STEPS_PER_UNIT { 100, 100, 400 } // { 100, 100, 400, 100 } // { 80, 80, 400, 500 }
 
 /**
  * Default Max Feed Rate (linear=mm/s, rotational=Â°/s)
  * Override with M203
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_MAX_FEEDRATE          { 300, 300, 5, 25 }
+#define DEFAULT_MAX_FEEDRATE { 50, 50, 15 } // { 50, 50, 15, 25 } // { 300, 300, 5, 25 }
 
 //#define LIMITED_MAX_FR_EDITING        // Limit edit via M203 or LCD to DEFAULT_MAX_FEEDRATE * 2
 #if ENABLED(LIMITED_MAX_FR_EDITING)
@@ -1180,7 +1184,7 @@
  * Override with M201
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_MAX_ACCELERATION      { 3000, 3000, 100, 10000 }
+#define DEFAULT_MAX_ACCELERATION { 180, 180, 80 } // { 180, 180, 80, 180 } // { 3000, 3000, 100, 10000 }
 
 //#define LIMITED_MAX_ACCEL_EDITING     // Limit edit via M201 or LCD to DEFAULT_MAX_ACCELERATION * 2
 #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
@@ -1195,9 +1199,9 @@
  *   M204 R    Retract Acceleration
  *   M204 T    Travel Acceleration
  */
-#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E acceleration for printing moves
+#define DEFAULT_ACCELERATION 180 // 3000    // X, Y, Z and E acceleration for printing moves
 #define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration for retracts
-#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
+#define DEFAULT_TRAVEL_ACCELERATION 180 // 3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
  * Default Jerk limits (mm/s)
@@ -1237,7 +1241,7 @@
  *   https://blog.kyneticcnc.com/2018/10/computing-junction-deviation-for-marlin.html
  */
 #if DISABLED(CLASSIC_JERK)
-  #define JUNCTION_DEVIATION_MM 0.013 // (mm) Distance from real junction edge
+  #define JUNCTION_DEVIATION_MM 0.04 // 0.013 // (mm) Distance from real junction edge
   #define JD_HANDLE_SMALL_SEGMENTS    // Use curvature estimation instead of just the junction angle
                                       // for small segments (< 1mm) with large junction angles (> 135Â°).
 #endif
@@ -1250,7 +1254,7 @@
  *
  * See https://github.com/synthetos/TinyG/wiki/Jerk-Controlled-Motion-Explained
  */
-//#define S_CURVE_ACCELERATION
+#define S_CURVE_ACCELERATION
 
 //===========================================================================
 //============================= Z Probe Options =============================
@@ -1686,8 +1690,8 @@
 // @section geometry
 
 // The size of the printable area
-#define X_BED_SIZE 200
-#define Y_BED_SIZE 200
+#define X_BED_SIZE 1220 // 200
+#define Y_BED_SIZE 2440 // 200
 
 // Travel limits (linear=mm, rotational=Â°) after homing, corresponding to endstop positions.
 #define X_MIN_POS 0
@@ -1723,7 +1727,7 @@
 #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
   #define MIN_SOFTWARE_ENDSTOP_X
   #define MIN_SOFTWARE_ENDSTOP_Y
-  #define MIN_SOFTWARE_ENDSTOP_Z
+  //#define MIN_SOFTWARE_ENDSTOP_Z
   #define MIN_SOFTWARE_ENDSTOP_I
   #define MIN_SOFTWARE_ENDSTOP_J
   #define MIN_SOFTWARE_ENDSTOP_K
@@ -1733,7 +1737,7 @@
 #endif
 
 // Max software endstops constrain movement within maximum coordinate bounds
-#define MAX_SOFTWARE_ENDSTOPS
+//#define MAX_SOFTWARE_ENDSTOPS
 #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
   #define MAX_SOFTWARE_ENDSTOP_X
   #define MAX_SOFTWARE_ENDSTOP_Y
@@ -1747,7 +1751,7 @@
 #endif
 
 #if EITHER(MIN_SOFTWARE_ENDSTOPS, MAX_SOFTWARE_ENDSTOPS)
-  //#define SOFT_ENDSTOPS_MENU_ITEM  // Enable/Disable software endstops from the LCD
+  #define SOFT_ENDSTOPS_MENU_ITEM    // Enable/Disable software endstops from the LCD
 #endif
 
 /**
@@ -2086,7 +2090,7 @@
 #endif
 
 // Homing speeds (linear=mm/min, rotational=Â°/min)
-#define HOMING_FEEDRATE_MM_M { (50*60), (50*60), (4*60) }
+#define HOMING_FEEDRATE_MM_M { (35*60), (35*60), (4*60) } // { (50*60), (50*60), (4*60) }
 
 // Validate that endstops are triggered on homing moves
 #define VALIDATE_HOMING_ENDSTOPS
@@ -2163,12 +2167,12 @@
  *   M501 - Read settings from EEPROM. (i.e., Throw away unsaved changes)
  *   M502 - Revert settings to "factory" defaults. (Follow with M500 to init the EEPROM.)
  */
-//#define EEPROM_SETTINGS     // Persistent storage with M500 and M501
+#define EEPROM_SETTINGS       // Persistent storage with M500 and M501
 //#define DISABLE_M503        // Saves ~2700 bytes of flash. Disable for release!
 #define EEPROM_CHITCHAT       // Give feedback on EEPROM commands. Disable to save PROGMEM.
 #define EEPROM_BOOT_SILENT    // Keep M503 quiet and only give errors during first load
 #if ENABLED(EEPROM_SETTINGS)
-  //#define EEPROM_AUTO_INIT  // Init EEPROM automatically on any errors.
+  #define EEPROM_AUTO_INIT    // Init EEPROM automatically on any errors.
   //#define EEPROM_INIT_NOW   // Init EEPROM on first boot after a new build.
 #endif
 
@@ -2448,7 +2452,7 @@
  * SD Card support is disabled by default. If your controller has an SD slot,
  * you must uncomment the following option or it won't work.
  */
-//#define SDSUPPORT
+#define SDSUPPORT
 
 /**
  * SD CARD: ENABLE CRC
@@ -2528,7 +2532,7 @@
 //
 // Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.
 //
-//#define INDIVIDUAL_AXIS_HOMING_MENU
+#define INDIVIDUAL_AXIS_HOMING_MENU
 //#define INDIVIDUAL_AXIS_HOMING_SUBMENU
 
 //
@@ -2719,7 +2723,7 @@
 // RepRapDiscount FULL GRAPHIC Smart Controller
 // https://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
 //
-//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
 
 //
 // K.3D Full Graphic Smart Controller
@@ -3333,3 +3337,4 @@
 
 // Disable servo with M282 to reduce power consumption, noise, and heat when not in use
 //#define SERVO_DETACH_GCODE
+#define SHORT_BUILD_VERSION "515D 2.1.1"
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index e5d2352..2847cc6 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -802,8 +802,8 @@
  *   - Use X2_USE_ENDSTOP to set the endstop plug by name. (_XMIN_, _XMAX_, _YMIN_, _YMAX_, _ZMIN_, _ZMAX_)
  */
 #if HAS_X2_STEPPER && DISABLED(DUAL_X_CARRIAGE)
-  //#define INVERT_X2_VS_X_DIR        // X2 direction signal is the opposite of X
-  //#define X_DUAL_ENDSTOPS           // X2 has its own endstop
+  #define INVERT_X2_VS_X_DIR          // X2 direction signal is the opposite of X
+  #define X_DUAL_ENDSTOPS             // X2 has its own endstop
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X2_USE_ENDSTOP    _XMAX_  // X2 endstop board plug. Don't forget to enable USE_*_PLUG.
     #define X2_ENDSTOP_ADJUSTMENT  0  // X2 offset relative to X endstop
@@ -811,8 +811,8 @@
 #endif
 
 #if HAS_DUAL_Y_STEPPERS
-  //#define INVERT_Y2_VS_Y_DIR        // Y2 direction signal is the opposite of Y
-  //#define Y_DUAL_ENDSTOPS           // Y2 has its own endstop
+  #define INVERT_Y2_VS_Y_DIR          // Y2 direction signal is the opposite of Y
+  #define Y_DUAL_ENDSTOPS             // Y2 has its own endstop
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y2_USE_ENDSTOP    _YMAX_  // Y2 endstop board plug. Don't forget to enable USE_*_PLUG.
     #define Y2_ENDSTOP_ADJUSTMENT  0  // Y2 offset relative to Y endstop
@@ -866,8 +866,8 @@
 
 //#define SENSORLESS_BACKOFF_MM  { 2, 2, 0 }  // (linear=mm, rotational=Â°) Backoff from endstops before sensorless homing
 
-#define HOMING_BUMP_MM      { 5, 5, 2 }       // (linear=mm, rotational=Â°) Backoff from endstops after first bump
-#define HOMING_BUMP_DIVISOR { 2, 2, 4 }       // Re-Bump Speed Divisor (Divides the Homing Feedrate)
+#define HOMING_BUMP_MM { 5, 5, 5 } // { 5, 5, 2 }       // (linear=mm, rotational=Â°) Backoff from endstops after first bump
+#define HOMING_BUMP_DIVISOR { 2, 2, 4 } // { 2, 2, 4 }       // Re-Bump Speed Divisor (Divides the Homing Feedrate)
 
 //#define HOMING_BACKOFF_POST_MM { 2, 2, 2 }  // (linear=mm, rotational=Â°) Backoff from endstops after homing
 
@@ -1046,7 +1046,7 @@
 
 // @section motion
 
-#define AXIS_RELATIVE_MODES { false, false, false, false }
+#define AXIS_RELATIVE_MODES { false, false, false } // { false, false, false, false }
 
 // Add a Duplicate option for well-separated conjoined nozzles
 //#define MULTI_NOZZLE_DUPLICATION
@@ -1068,10 +1068,10 @@
  * Set DISABLE_INACTIVE_? 'true' to shut down axis steppers after an idle period.
  * The Deactive Time can be overridden with M18 and M84. Set to 0 for No Timeout.
  */
-#define DEFAULT_STEPPER_DEACTIVE_TIME 120
+#define DEFAULT_STEPPER_DEACTIVE_TIME 1200 // 120
 #define DISABLE_INACTIVE_X true
 #define DISABLE_INACTIVE_Y true
-#define DISABLE_INACTIVE_Z true  // Set 'false' if the nozzle could fall onto your printed part!
+#define DISABLE_INACTIVE_Z false // true  // Set 'false' if the nozzle could fall onto your printed part!
 #define DISABLE_INACTIVE_I true
 #define DISABLE_INACTIVE_J true
 #define DISABLE_INACTIVE_K true
@@ -1221,7 +1221,7 @@
  * vibration and surface artifacts. The algorithm adapts to provide the best possible step smoothing at the
  * lowest stepping frequencies.
  */
-//#define ADAPTIVE_STEP_SMOOTHING
+#define ADAPTIVE_STEP_SMOOTHING
 
 /**
  * Custom Microstepping
@@ -1296,7 +1296,7 @@
 // @section lcd
 
 #if HAS_MANUAL_MOVE_MENU
-  #define MANUAL_FEEDRATE { 50*60, 50*60, 4*60, 2*60 } // (mm/min) Feedrates for manual moves along X, Y, Z, E from panel
+  #define MANUAL_FEEDRATE { 50*60, 50*60, 4*60 } // { 50*60, 50*60, 4*60, 2*60 } // (mm/min) Feedrates for manual moves along X, Y, Z, E from panel
   #define FINE_MANUAL_MOVE 0.025    // (mm) Smallest manual move (< 0.1mm) applying to Z on most machines
   #if IS_ULTIPANEL
     #define MANUAL_E_MOVES_RELATIVE // Display extruder move distance rather than "position"
@@ -1380,7 +1380,7 @@
 
 #if EITHER(HAS_DISPLAY, DWIN_LCD_PROUI)
   // The timeout to return to the status screen from sub-menus
-  //#define LCD_TIMEOUT_TO_STATUS 15000   // (ms)
+  #define LCD_TIMEOUT_TO_STATUS 180000 // 15000   // (ms)
 
   #if ENABLED(SHOW_BOOTSCREEN)
     #define BOOTSCREEN_TIMEOUT 4000       // (ms) Total Duration to display the boot screen(s)
@@ -1481,7 +1481,7 @@
 
   #define SD_PROCEDURE_DEPTH 1              // Increase if you need more nested M32 calls
 
-  #define SD_FINISHED_STEPPERRELEASE true   // Disable steppers when SD Print is finished
+  #define SD_FINISHED_STEPPERRELEASE false // true   // Disable steppers when SD Print is finished
   #define SD_FINISHED_RELEASECOMMAND "M84"  // Use "M84XYE" to keep Z enabled so your bed stays in place
 
   // Reverse SD sort to show "more recent" files first, according to the card's FAT.
@@ -1497,7 +1497,7 @@
 
   //#define MEDIA_MENU_AT_TOP               // Force the media menu to be listed on the top of the main menu
 
-  #define EVENT_GCODE_SD_ABORT "G28XY"      // G-code to run on SD Abort Print (e.g., "G28XY" or "G27")
+  //#define EVENT_GCODE_SD_ABORT "G28XY"      // G-code to run on SD Abort Print (e.g., "G28XY" or "G27")
 
   #if ENABLED(PRINTER_EVENT_LEDS)
     #define PE_LEDS_COMPLETED_TIME  (30*60) // (seconds) Time to keep the LED "done" color before restoring normal illumination
@@ -1595,7 +1595,7 @@
 
   //#define SD_REPRINT_LAST_SELECTED_FILE // On print completion open the LCD Menu and select the same file
 
-  //#define AUTO_REPORT_SD_STATUS         // Auto-report media status with 'M27 S<seconds>'
+  #define AUTO_REPORT_SD_STATUS           // Auto-report media status with 'M27 S<seconds>'
 
   /**
    * Support for USB thumb drives using an Arduino USB Host Shield or
@@ -1680,7 +1680,7 @@
    *
    * :[ 'LCD', 'ONBOARD', 'CUSTOM_CABLE' ]
    */
-  //#define SDCARD_CONNECTION LCD
+  #define SDCARD_CONNECTION ONBOARD // LCD
 
   // Enable if SD detect is rendered useless (e.g., by using an SD extender)
   //#define NO_SD_DETECT
@@ -2009,7 +2009,7 @@
  *
  * Warning: Does not respect endstops!
  */
-//#define BABYSTEPPING
+#define BABYSTEPPING
 #if ENABLED(BABYSTEPPING)
   //#define INTEGRATED_BABYSTEPPING         // EXPERIMENTAL integration of babystepping into the Stepper ISR
   //#define BABYSTEP_WITHOUT_HOMING
@@ -2234,7 +2234,7 @@
   #define MIN_CIRCLE_SEGMENTS    72   // Minimum number of segments in a complete circle
   //#define ARC_SEGMENTS_PER_SEC 50   // Use the feedrate to choose the segment length
   #define N_ARC_CORRECTION       25   // Number of interpolated segments between corrections
-  //#define ARC_P_CIRCLES             // Enable the 'P' parameter to specify complete circles
+  #define ARC_P_CIRCLES               // Enable the 'P' parameter to specify complete circles
   //#define SF_ARC_FIX                // Enable only if using SkeinForge with "Arc Point" fillet procedure
 #endif
 
@@ -2242,7 +2242,7 @@
 //#define BEZIER_CURVE_SUPPORT        // Requires ~2666 bytes
 
 #if EITHER(ARC_SUPPORT, BEZIER_CURVE_SUPPORT)
-  //#define CNC_WORKSPACE_PLANES      // Allow G2/G3/G5 to operate in XY, ZX, or YZ planes
+  #define CNC_WORKSPACE_PLANES        // Allow G2/G3/G5 to operate in XY, ZX, or YZ planes
 #endif
 
 /**
@@ -2386,7 +2386,7 @@
  * Currently handles M108, M112, M410, M876
  * NOTE: Not yet implemented for all platforms.
  */
-//#define EMERGENCY_PARSER
+#define EMERGENCY_PARSER
 
 /**
  * Realtime Reporting (requires EMERGENCY_PARSER)
@@ -2422,7 +2422,7 @@
 #define SERIAL_OVERRUN_PROTECTION
 
 // For serial echo, the number of digits after the decimal point
-//#define SERIAL_FLOAT_PRECISION 4
+#define SERIAL_FLOAT_PRECISION 4 // 4
 
 /**
  * Set the number of proportional font spaces required to fill up a typical character space.
@@ -2788,7 +2788,7 @@
  */
 #if HAS_TRINAMIC_CONFIG
 
-  #define HOLD_MULTIPLIER    0.5  // Scales down the holding current from run current
+  #define HOLD_MULTIPLIER 0.8 // 0.5  // Scales down the holding current from run current
 
   /**
    * Interpolate microsteps to 256
@@ -2797,7 +2797,7 @@
   #define INTERPOLATE      true
 
   #if AXIS_IS_TMC(X)
-    #define X_CURRENT       800        // (mA) RMS current. Multiply by 1.414 for peak current.
+    #define X_CURRENT 900 // 800        // (mA) RMS current. Multiply by 1.414 for peak current.
     #define X_CURRENT_HOME  X_CURRENT  // (mA) RMS current for sensorless homing
     #define X_MICROSTEPS     16        // 0..256
     #define X_RSENSE          0.11
@@ -2807,7 +2807,7 @@
   #endif
 
   #if AXIS_IS_TMC(X2)
-    #define X2_CURRENT      800
+    #define X2_CURRENT 900 // 800
     #define X2_CURRENT_HOME X2_CURRENT
     #define X2_MICROSTEPS    X_MICROSTEPS
     #define X2_RSENSE         0.11
@@ -2817,7 +2817,7 @@
   #endif
 
   #if AXIS_IS_TMC(Y)
-    #define Y_CURRENT       800
+    #define Y_CURRENT 900 // 800
     #define Y_CURRENT_HOME  Y_CURRENT
     #define Y_MICROSTEPS     16
     #define Y_RSENSE          0.11
@@ -2827,7 +2827,7 @@
   #endif
 
   #if AXIS_IS_TMC(Y2)
-    #define Y2_CURRENT      800
+    #define Y2_CURRENT 900 // 800
     #define Y2_CURRENT_HOME Y2_CURRENT
     #define Y2_MICROSTEPS    Y_MICROSTEPS
     #define Y2_RSENSE         0.11
@@ -2837,7 +2837,7 @@
   #endif
 
   #if AXIS_IS_TMC(Z)
-    #define Z_CURRENT       800
+    #define Z_CURRENT 900 // 800
     #define Z_CURRENT_HOME  Z_CURRENT
     #define Z_MICROSTEPS     16
     #define Z_RSENSE          0.11
@@ -3101,15 +3101,15 @@
    * Use Trinamic's ultra quiet stepping mode.
    * When disabled, Marlin will use spreadCycle stepping mode.
    */
-  #define STEALTHCHOP_XY
-  #define STEALTHCHOP_Z
+  //#define STEALTHCHOP_XY
+  //#define STEALTHCHOP_Z
   #define STEALTHCHOP_I
   #define STEALTHCHOP_J
   #define STEALTHCHOP_K
   #define STEALTHCHOP_U
   #define STEALTHCHOP_V
   #define STEALTHCHOP_W
-  #define STEALTHCHOP_E
+  //#define STEALTHCHOP_E
 
   /**
    * Optimize spreadCycle chopper parameters by using predefined parameter sets
@@ -3163,7 +3163,7 @@
    * M912 - Clear stepper driver overtemperature pre-warn condition flag.
    * M122 - Report driver parameters (Requires TMC_DEBUG)
    */
-  //#define MONITOR_DRIVER_STATUS
+  #define MONITOR_DRIVER_STATUS
 
   #if ENABLED(MONITOR_DRIVER_STATUS)
     #define CURRENT_STEP_DOWN     50  // [mA]
@@ -3271,13 +3271,13 @@
    * Beta feature!
    * Create a 50/50 square wave step pulse optimal for stepper drivers.
    */
-  //#define SQUARE_WAVE_STEPPING
+  #define SQUARE_WAVE_STEPPING
 
   /**
    * Enable M122 debugging command for TMC stepper drivers.
    * M122 S0/1 will enable continuous reporting.
    */
-  //#define TMC_DEBUG
+  #define TMC_DEBUG
 
   /**
    * You can set your own advanced settings by filling in predefined functions.
@@ -3396,14 +3396,14 @@
  * See https://marlinfw.org/docs/configuration/2.0.9/laser_spindle.html for more config details.
  */
 //#define SPINDLE_FEATURE
-//#define LASER_FEATURE
+#define LASER_FEATURE
 #if EITHER(SPINDLE_FEATURE, LASER_FEATURE)
-  #define SPINDLE_LASER_ACTIVE_STATE    LOW    // Set to "HIGH" if SPINDLE_LASER_ENA_PIN is active HIGH
+  #define SPINDLE_LASER_ACTIVE_STATE HIGH // LOW    // Set to "HIGH" if SPINDLE_LASER_ENA_PIN is active HIGH
 
   #define SPINDLE_LASER_USE_PWM                // Enable if your controller supports setting the speed/power
   #if ENABLED(SPINDLE_LASER_USE_PWM)
     #define SPINDLE_LASER_PWM_INVERT    false  // Set to "true" if the speed/power goes up when you want it to go slower
-    #define SPINDLE_LASER_FREQUENCY     2500   // (Hz) Spindle/laser frequency (only on supported HALs: AVR, ESP32, and LPC)
+    //#define SPINDLE_LASER_FREQUENCY   2500   // (Hz) Spindle/laser frequency (only on supported HALs: AVR, ESP32, and LPC)
                                                // ESP32: If SPINDLE_LASER_PWM_PIN is onboard then <=78125Hz. For I2S expander
                                                //  the frequency determines the PWM resolution. 2500Hz = 0-100, 977Hz = 0-255, ...
                                                //  (250000 / SPINDLE_LASER_FREQUENCY) = max value.
@@ -3467,7 +3467,7 @@
       #define SPEED_POWER_INTERCEPT       0    // (%) 0-100 i.e., Minimum power percentage
       #define SPEED_POWER_MIN          5000    // (RPM)
       #define SPEED_POWER_MAX         30000    // (RPM) SuperPID router controller 0 - 30,000 RPM
-      #define SPEED_POWER_STARTUP     25000    // (RPM) M3/M4 speed/power default (with no arguments)
+      #define SPEED_POWER_STARTUP 15 // 25000    // (RPM) M3/M4 speed/power default (with no arguments)
     #endif
 
   #else
@@ -3476,7 +3476,7 @@
       #define SPEED_POWER_INTERCEPT       0    // (%) 0-100 i.e., Minimum power percentage
       #define SPEED_POWER_MIN             0    // (%) 0-100
       #define SPEED_POWER_MAX           100    // (%) 0-100
-      #define SPEED_POWER_STARTUP        80    // (%) M3/M4 speed/power default (with no arguments)
+      #define SPEED_POWER_STARTUP 15 // 80    // (%) M3/M4 speed/power default (with no arguments)
     #endif
 
     // Define the minimum and maximum test pulse time values for a laser test fire function
@@ -3519,7 +3519,7 @@
      * CUTTER_MODE_CONTINUOUS. The option allows M3 laser power to be commited without waiting
      * for a planner syncronization
      */
-    //#define LASER_POWER_SYNC
+    #define LASER_POWER_SYNC
 
     /**
      * Scale the laser's power in proportion to the movement rate.
@@ -3528,7 +3528,7 @@
      * - Ramps the power up every N steps to approximate the speed trapezoid.
      * - Due to the limited power resolution this is only approximate.
      */
-    //#define LASER_POWER_TRAP
+    #define LASER_POWER_TRAP
 
     //
     // Laser I2C Ammeter (High precision INA226 low/high side module)
@@ -3662,7 +3662,7 @@
  * Enables G53 and G54-G59.3 commands to select coordinate systems
  * and G92.1 to reset the workspace to native machine space.
  */
-//#define CNC_COORDINATE_SYSTEMS
+#define CNC_COORDINATE_SYSTEMS
 
 // @section reporting
 
@@ -3683,14 +3683,14 @@
 /**
  * Auto-report position with M154 S<seconds>
  */
-//#define AUTO_REPORT_POSITION
+#define AUTO_REPORT_POSITION
 
 /**
  * Include capabilities in M115 output
  */
 #define EXTENDED_CAPABILITIES_REPORT
 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
-  //#define M115_GEOMETRY_REPORT
+  #define M115_GEOMETRY_REPORT
 #endif
 
 // @section security
@@ -3735,11 +3735,11 @@
 // @section reporting
 
 // Extra options for the M114 "Current Position" report
-//#define M114_DETAIL         // Use 'M114` for details to check planner calculations
+#define M114_DETAIL           // Use 'M114` for details to check planner calculations
 //#define M114_REALTIME       // Real current position based on forward kinematics
 //#define M114_LEGACY         // M114 used to synchronize on every call. Enable if needed.
 
-//#define REPORT_FAN_CHANGE   // Report the new fan speed when changed by M106 (and others)
+#define REPORT_FAN_CHANGE     // Report the new fan speed when changed by M106 (and others)
 
 // @section gcode
 
@@ -3776,7 +3776,7 @@
  * High feedrates may cause ringing and harm print quality.
  */
 //#define PAREN_COMMENTS      // Support for parentheses-delimited comments
-//#define GCODE_MOTION_MODES  // Remember the motion mode (G0 G1 G2 G3 G5 G38.X) and apply for X Y Z E F, etc.
+#define GCODE_MOTION_MODES    // Remember the motion mode (G0 G1 G2 G3 G5 G38.X) and apply for X Y Z E F, etc.
 
 // Enable and set a (default) feedrate for all G0 moves
 //#define G0_FEEDRATE 3000 // (mm/min)
@@ -3813,24 +3813,24 @@
 // @section custom main menu
 
 // Custom Menu: Main Menu
-//#define CUSTOM_MENU_MAIN
+#define CUSTOM_MENU_MAIN
 #if ENABLED(CUSTOM_MENU_MAIN)
-  //#define CUSTOM_MENU_MAIN_TITLE "Custom Commands"
+  #define CUSTOM_MENU_MAIN_TITLE "V1 Custom Menu" // "Custom Commands"
   #define CUSTOM_MENU_MAIN_SCRIPT_DONE "M117 User Script Done"
   #define CUSTOM_MENU_MAIN_SCRIPT_AUDIBLE_FEEDBACK
   //#define CUSTOM_MENU_MAIN_SCRIPT_RETURN   // Return to status screen after a script
   #define CUSTOM_MENU_MAIN_ONLY_IDLE         // Only show custom menu when the machine is idle
 
-  #define MAIN_MENU_ITEM_1_DESC "Home & UBL Info"
-  #define MAIN_MENU_ITEM_1_GCODE "G28\nG29 W"
+  #define MAIN_MENU_ITEM_1_DESC "Reset All Coordinates" // "Home & UBL Info"
+  #define MAIN_MENU_ITEM_1_GCODE "G92 X0 Y0 Z0" // "G28\nG29 W"
   //#define MAIN_MENU_ITEM_1_CONFIRM          // Show a confirmation dialog before this action
 
-  #define MAIN_MENU_ITEM_2_DESC "Preheat for " PREHEAT_1_LABEL
-  #define MAIN_MENU_ITEM_2_GCODE "M140 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND)
+  #define MAIN_MENU_ITEM_2_DESC "Home Z Axis" // "Preheat for " PREHEAT_1_LABEL
+  #define MAIN_MENU_ITEM_2_GCODE "G28 Z" // "M140 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND)
   //#define MAIN_MENU_ITEM_2_CONFIRM
 
-  //#define MAIN_MENU_ITEM_3_DESC "Preheat for " PREHEAT_2_LABEL
-  //#define MAIN_MENU_ITEM_3_GCODE "M140 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND)
+  #define MAIN_MENU_ITEM_3_DESC "Home X&Y" // "Preheat for " PREHEAT_2_LABEL
+  #define MAIN_MENU_ITEM_3_GCODE "G28 X Y" // "M140 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND)
   //#define MAIN_MENU_ITEM_3_CONFIRM
 
   //#define MAIN_MENU_ITEM_4_DESC "Heat Bed/Home/Level"
@@ -3923,10 +3923,10 @@
  * Host Prompt Support enables Marlin to use the host for user prompts so
  * filament runout and other processes can be managed from the host side.
  */
-//#define HOST_ACTION_COMMANDS
+#define HOST_ACTION_COMMANDS
 #if ENABLED(HOST_ACTION_COMMANDS)
   //#define HOST_PAUSE_M76                // Tell the host to pause in response to M76
-  //#define HOST_PROMPT_SUPPORT           // Initiate host prompts to get user feedback
+  #define HOST_PROMPT_SUPPORT             // Initiate host prompts to get user feedback
   #if ENABLED(HOST_PROMPT_SUPPORT)
     //#define HOST_STATUS_NOTIFICATIONS   // Send some status messages to the host as notifications
   #endif
@@ -4291,7 +4291,7 @@
 //
 // M42 - Set pin states
 //
-//#define DIRECT_PIN_CONTROL
+#define DIRECT_PIN_CONTROL
 
 //
 // M43 - display pin status, toggle pins, watch pins, watch endstops & toggle LED, test servo probe
diff --git a/Marlin/src/HAL/AVR/HAL.cpp b/Marlin/src/HAL/AVR/HAL.cpp
deleted file mode 100644
index 5382eb3..0000000
--- a/Marlin/src/HAL/AVR/HAL.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __AVR__
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-#include <avr/wdt.h>
-
-#ifdef USBCON
-  DefaultSerial1 MSerial0(false, Serial);
-  #ifdef BLUETOOTH
-    BTSerial btSerial(false, bluetoothSerial);
-  #endif
-#endif
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-// Don't initialize/override variable (which would happen in .init4)
-uint8_t MarlinHAL::reset_reason __attribute__((section(".noinit")));
-
-// ------------------------
-// Public functions
-// ------------------------
-
-__attribute__((naked))             // Don't output function pro- and epilogue
-__attribute__((used))              // Output the function, even if "not used"
-__attribute__((section(".init3"))) // Put in an early user definable section
-void save_reset_reason() {
-  #if ENABLED(OPTIBOOT_RESET_REASON)
-    __asm__ __volatile__(
-      A("STS %0, r2")
-      : "=m"(hal.reset_reason)
-    );
-  #else
-    hal.reset_reason = MCUSR;
-  #endif
-
-  // Clear within 16ms since WDRF bit enables a 16ms watchdog timer -> Boot loop
-  hal.clear_reset_source();
-  wdt_disable();
-}
-
-void MarlinHAL::init() {
-  // Init Servo Pins
-  #define INIT_SERVO(N) OUT_WRITE(SERVO##N##_PIN, LOW)
-  #if HAS_SERVO_0
-    INIT_SERVO(0);
-  #endif
-  #if HAS_SERVO_1
-    INIT_SERVO(1);
-  #endif
-  #if HAS_SERVO_2
-    INIT_SERVO(2);
-  #endif
-  #if HAS_SERVO_3
-    INIT_SERVO(3);
-  #endif
-
-  init_pwm_timers();   // Init user timers to default frequency - 1000HZ
-}
-
-void MarlinHAL::reboot() {
-  #if ENABLED(USE_WATCHDOG)
-    while (1) { /* run out the watchdog */ }
-  #else
-    void (*resetFunc)() = 0;  // Declare resetFunc() at address 0
-    resetFunc();              // Jump to address 0
-  #endif
-}
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  #include <avr/wdt.h>
-  #include "../../MarlinCore.h"
-
-  // Initialize watchdog with 8s timeout, if possible. Otherwise, make it 4s.
-  void MarlinHAL::watchdog_init() {
-    #if ENABLED(WATCHDOG_DURATION_8S) && defined(WDTO_8S)
-      #define WDTO_NS WDTO_8S
-    #else
-      #define WDTO_NS WDTO_4S
-    #endif
-    #if ENABLED(WATCHDOG_RESET_MANUAL)
-      // Enable the watchdog timer, but only for the interrupt.
-      // Take care, as this requires the correct order of operation, with interrupts disabled.
-      // See the datasheet of any AVR chip for details.
-      wdt_reset();
-      cli();
-      _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);
-      _WD_CONTROL_REG = _BV(WDIE) | (WDTO_NS & 0x07) | ((WDTO_NS & 0x08) << 2); // WDTO_NS directly does not work. bit 0-2 are consecutive in the register but the highest value bit is at bit 5
-                                                                                // So worked for up to WDTO_2S
-      sei();
-      wdt_reset();
-    #else
-      wdt_enable(WDTO_NS); // The function handles the upper bit correct.
-    #endif
-    //delay(10000); // test it!
-  }
-
-  //===========================================================================
-  //=================================== ISR ===================================
-  //===========================================================================
-
-  // Watchdog timer interrupt, called if main program blocks >4sec and manual reset is enabled.
-  #if ENABLED(WATCHDOG_RESET_MANUAL)
-    ISR(WDT_vect) {
-      sei();  // With the interrupt driven serial we need to allow interrupts.
-      SERIAL_ERROR_MSG(STR_WATCHDOG_FIRED);
-      minkill();  // interrupt-safe final kill and infinite loop
-    }
-  #endif
-
-  // Reset watchdog. MUST be called at least every 4 seconds after the
-  // first watchdog_init or AVR will go into emergency procedures.
-  void MarlinHAL::watchdog_refresh() { wdt_reset(); }
-
-#endif // USE_WATCHDOG
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#if ENABLED(SDSUPPORT)
-
-  #include "../../sd/SdFatUtil.h"
-  int freeMemory() { return SdFatUtil::FreeRam(); }
-
-#else // !SDSUPPORT
-
-  extern "C" {
-    extern char __bss_end;
-    extern char __heap_start;
-    extern void* __brkval;
-
-    int freeMemory() {
-      int free_memory;
-      if ((int)__brkval == 0)
-        free_memory = ((int)&free_memory) - ((int)&__bss_end);
-      else
-        free_memory = ((int)&free_memory) - ((int)__brkval);
-      return free_memory;
-    }
-  }
-
-#endif // !SDSUPPORT
-
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
deleted file mode 100644
index 1491867..0000000
--- a/Marlin/src/HAL/AVR/HAL.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Arduino AVR
- */
-
-#include "../shared/Marduino.h"
-#include "../shared/HAL_SPI.h"
-#include "fastio.h"
-#include "math.h"
-
-#ifdef USBCON
-  #include <HardwareSerial.h>
-#else
-  #include "MarlinSerial.h"
-#endif
-
-#include <stdint.h>
-#include <util/delay.h>
-#include <avr/eeprom.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/io.h>
-
-//
-// Default graphical display delays
-//
-#if F_CPU >= 20000000
-  #define CPU_ST7920_DELAY_1 150
-  #define CPU_ST7920_DELAY_2   0
-  #define CPU_ST7920_DELAY_3 150
-#elif F_CPU == 16000000
-  #define CPU_ST7920_DELAY_1 125
-  #define CPU_ST7920_DELAY_2   0
-  #define CPU_ST7920_DELAY_3 188
-#endif
-
-#ifndef pgm_read_ptr
-  // Compatibility for avr-libc 1.8.0-4.1 included with Ubuntu for
-  // Windows Subsystem for Linux on Windows 10 as of 10/18/2019
-  #define pgm_read_ptr_far(address_long) (void*)__ELPM_word((uint32_t)(address_long))
-  #define pgm_read_ptr_near(address_short) (void*)__LPM_word((uint16_t)(address_short))
-  #define pgm_read_ptr(address_short) pgm_read_ptr_near(address_short)
-#endif
-
-// ------------------------
-// Defines
-// ------------------------
-
-// AVR PROGMEM extension for sprintf_P
-#define S_FMT "%S"
-
-// AVR PROGMEM extension for string define
-#define PGMSTR(NAM,STR) const char NAM[] PROGMEM = STR
-
-#ifndef CRITICAL_SECTION_START
-  #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
-  #define CRITICAL_SECTION_END()    SREG = _sreg
-#endif
-
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
-#define PWM_FREQUENCY 1000     // Default PWM frequency when set_pwm_duty() is called without set_pwm_frequency()
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef int8_t pin_t;
-
-#define SHARED_SERVOS HAS_SERVOS  // Use shared/servos.cpp
-
-class Servo;
-typedef Servo hal_servo_t;
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#ifdef USBCON
-  #include "../../core/serial_hook.h"
-  typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
-  extern DefaultSerial1 MSerial0;
-  #ifdef BLUETOOTH
-    typedef ForwardSerial1Class< decltype(bluetoothSerial) > BTSerial;
-    extern BTSerial btSerial;
-  #endif
-
-  #define MYSERIAL1 TERN(BLUETOOTH, btSerial, MSerial0)
-#else
-  #if !WITHIN(SERIAL_PORT, -1, 3)
-    #error "SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
-  #endif
-  #define MYSERIAL1 customizedSerial1
-
-  #ifdef SERIAL_PORT_2
-    #if !WITHIN(SERIAL_PORT_2, -1, 3)
-      #error "SERIAL_PORT_2 must be from 0 to 3, or -1 for USB Serial."
-    #endif
-    #define MYSERIAL2 customizedSerial2
-  #endif
-
-  #ifdef SERIAL_PORT_3
-    #if !WITHIN(SERIAL_PORT_3, -1, 3)
-      #error "SERIAL_PORT_3 must be from 0 to 3, or -1 for USB Serial."
-    #endif
-    #define MYSERIAL3 customizedSerial3
-  #endif
-#endif
-
-#ifdef MMU2_SERIAL_PORT
-  #if !WITHIN(MMU2_SERIAL_PORT, -1, 3)
-    #error "MMU2_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
-  #endif
-  #define MMU2_SERIAL mmuSerial
-#endif
-
-#ifdef LCD_SERIAL_PORT
-  #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
-    #error "LCD_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
-  #endif
-  #define LCD_SERIAL lcdSerial
-  #if HAS_DGUS_LCD
-    #define SERIAL_GET_TX_BUFFER_FREE() LCD_SERIAL.get_tx_buffer_free()
-  #endif
-#endif
-
-//
-// ADC
-//
-#define HAL_ADC_VREF        5.0
-#define HAL_ADC_RESOLUTION 10
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-#define HAL_SENSITIVE_PINS 0, 1,
-
-#ifdef __AVR_AT90USB1286__
-  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
-#endif
-
-// AVR compatibility
-#define strtof strtod
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-extern "C" int freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init();          // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return TEST(SREG, SREG_I); }
-  static void isr_on()  { sei(); }
-  static void isr_off() { cli(); }
-
-  static void delay_ms(const int ms) { _delay_ms(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static uint8_t reset_reason;
-  static uint8_t get_reset_source() { return reset_reason; }
-  static void clear_reset_source() { MCUSR = 0; }
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  // Called by Temperature::init once at startup
-  static void adc_init() {
-    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
-    DIDR0 = 0;
-    #ifdef DIDR2
-      DIDR2 = 0;
-    #endif
-  }
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const uint8_t ch) {
-    #ifdef DIDR2
-      if (ch > 7) { SBI(DIDR2, ch & 0x07); return; }
-    #endif
-    SBI(DIDR0, ch);
-  }
-
-  // Begin ADC sampling on the given channel. Called from Temperature::isr!
-  static void adc_start(const uint8_t ch) {
-    #ifdef MUX5
-      ADCSRB = ch > 7 ? _BV(MUX5) : 0;
-    #else
-      ADCSRB = 0;
-    #endif
-    ADMUX = _BV(REFS0) | (ch & 0x07);
-    SBI(ADCSRA, ADSC);
-  }
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return !TEST(ADCSRA, ADSC); }
-
-  // The current value of the ADC register
-  static __typeof__(ADC) adc_value() { return ADC; }
-
-  /**
-   * init_pwm_timers
-   * Set the default frequency for timers 2-5 to 1000HZ
-   */
-  static void init_pwm_timers();
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * Optionally invert the duty cycle [default = false]
-   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
-
-  /**
-   * Set the frequency of the timer for the given pin as close as
-   * possible to the provided desired frequency. Internally calculate
-   * the required waveform generation mode, prescaler, and resolution
-   * values and set timer registers accordingly.
-   * NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
-   * NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST_PWM_FAN Settings)
-   */
-  static void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
-};
diff --git a/Marlin/src/HAL/AVR/HAL_SPI.cpp b/Marlin/src/HAL/AVR/HAL_SPI.cpp
deleted file mode 100644
index dc98f2f..0000000
--- a/Marlin/src/HAL/AVR/HAL_SPI.cpp
+++ /dev/null
@@ -1,254 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Adapted from Arduino Sd2Card Library
- * Copyright (c) 2009 by William Greiman
- */
-
-/**
- * HAL for AVR - SPI functions
- */
-
-#ifdef __AVR__
-
-#include "../../inc/MarlinConfig.h"
-
-void spiBegin() {
-  #if PIN_EXISTS(SD_SS)
-    // Do not init HIGH for boards with pin 4 used as Fans or Heaters or otherwise, not likely to have multiple SPI devices anyway.
-    #if defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__)
-      // SS must be in output mode even it is not chip select
-      SET_OUTPUT(SD_SS_PIN);
-    #else
-      // set SS high - may be chip select for another SPI device
-      OUT_WRITE(SD_SS_PIN, HIGH);
-    #endif
-  #endif
-  SET_OUTPUT(SD_SCK_PIN);
-  SET_INPUT(SD_MISO_PIN);
-  SET_OUTPUT(SD_MOSI_PIN);
-
-  IF_DISABLED(SOFTWARE_SPI, spiInit(SPI_HALF_SPEED));
-}
-
-#if NONE(SOFTWARE_SPI, FORCE_SOFT_SPI)
-
-  // ------------------------
-  // Hardware SPI
-  // ------------------------
-
-  // make sure SPCR rate is in expected bits
-  #if (SPR0 != 0 || SPR1 != 1)
-    #error "unexpected SPCR bits"
-  #endif
-
-  /**
-   * Initialize hardware SPI
-   * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]
-   */
-  void spiInit(uint8_t spiRate) {
-    // See avr processor documentation
-    CBI(
-      #ifdef PRR
-        PRR
-      #elif defined(PRR0)
-        PRR0
-      #endif
-      , PRSPI
-    );
-
-    SPCR = _BV(SPE) | _BV(MSTR) | (spiRate >> 1);
-    SPSR = spiRate & 1 || spiRate == 6 ? 0 : _BV(SPI2X);
-  }
-
-  /** SPI receive a byte */
-  uint8_t spiRec() {
-    SPDR = 0xFF;
-    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-    return SPDR;
-  }
-
-  /** SPI read data  */
-  void spiRead(uint8_t *buf, uint16_t nbyte) {
-    if (nbyte-- == 0) return;
-    SPDR = 0xFF;
-    for (uint16_t i = 0; i < nbyte; i++) {
-      while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-      buf[i] = SPDR;
-      SPDR = 0xFF;
-    }
-    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-    buf[nbyte] = SPDR;
-  }
-
-  /** SPI send a byte */
-  void spiSend(uint8_t b) {
-    SPDR = b;
-    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  }
-
-  /** SPI send block  */
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-    SPDR = token;
-    for (uint16_t i = 0; i < 512; i += 2) {
-      while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-      SPDR = buf[i];
-      while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-      SPDR = buf[i + 1];
-    }
-    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  }
-
-
-  /** begin spi transaction */
-  void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-    // Based on Arduino SPI library
-    // Clock settings are defined as follows. Note that this shows SPI2X
-    // inverted, so the bits form increasing numbers. Also note that
-    // fosc/64 appears twice
-    // SPR1 SPR0 ~SPI2X Freq
-    //   0    0     0   fosc/2
-    //   0    0     1   fosc/4
-    //   0    1     0   fosc/8
-    //   0    1     1   fosc/16
-    //   1    0     0   fosc/32
-    //   1    0     1   fosc/64
-    //   1    1     0   fosc/64
-    //   1    1     1   fosc/128
-
-    // We find the fastest clock that is less than or equal to the
-    // given clock rate. The clock divider that results in clock_setting
-    // is 2 ^^ (clock_div + 1). If nothing is slow enough, we'll use the
-    // slowest (128 == 2 ^^ 7, so clock_div = 6).
-    uint8_t clockDiv;
-
-    // When the clock is known at compiletime, use this if-then-else
-    // cascade, which the compiler knows how to completely optimize
-    // away. When clock is not known, use a loop instead, which generates
-    // shorter code.
-    if (__builtin_constant_p(spiClock)) {
-      if (spiClock >= F_CPU / 2)       clockDiv = 0;
-      else if (spiClock >= F_CPU / 4)  clockDiv = 1;
-      else if (spiClock >= F_CPU / 8)  clockDiv = 2;
-      else if (spiClock >= F_CPU / 16) clockDiv = 3;
-      else if (spiClock >= F_CPU / 32) clockDiv = 4;
-      else if (spiClock >= F_CPU / 64) clockDiv = 5;
-      else                             clockDiv = 6;
-    }
-    else {
-      uint32_t clockSetting = F_CPU / 2;
-      clockDiv = 0;
-      while (clockDiv < 6 && spiClock < clockSetting) {
-        clockSetting /= 2;
-        clockDiv++;
-      }
-    }
-
-    // Compensate for the duplicate fosc/64
-    if (clockDiv == 6) clockDiv = 7;
-
-    // Invert the SPI2X bit
-    clockDiv ^= 0x1;
-
-    SPCR = _BV(SPE) | _BV(MSTR) | ((bitOrder == LSBFIRST) ? _BV(DORD) : 0) |
-      (dataMode << CPHA) | ((clockDiv >> 1) << SPR0);
-    SPSR = clockDiv | 0x01;
-  }
-
-
-#else // SOFTWARE_SPI || FORCE_SOFT_SPI
-
-  // ------------------------
-  // Software SPI
-  // ------------------------
-
-  // nop to tune soft SPI timing
-  #define nop asm volatile ("\tnop\n")
-
-  void spiInit(uint8_t) { /* do nothing */ }
-
-  // Begin SPI transaction, set clock, bit order, data mode
-  void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) { /* do nothing */ }
-
-  // Soft SPI receive byte
-  uint8_t spiRec() {
-    uint8_t data = 0;
-    // no interrupts during byte receive - about 8Âµs
-    cli();
-    // output pin high - like sending 0xFF
-    WRITE(SD_MOSI_PIN, HIGH);
-
-    LOOP_L_N(i, 8) {
-      WRITE(SD_SCK_PIN, HIGH);
-
-      nop; // adjust so SCK is nice
-      nop;
-
-      data <<= 1;
-
-      if (READ(SD_MISO_PIN)) data |= 1;
-
-      WRITE(SD_SCK_PIN, LOW);
-    }
-
-    sei();
-    return data;
-  }
-
-  // Soft SPI read data
-  void spiRead(uint8_t *buf, uint16_t nbyte) {
-    for (uint16_t i = 0; i < nbyte; i++)
-      buf[i] = spiRec();
-  }
-
-  // Soft SPI send byte
-  void spiSend(uint8_t data) {
-    // no interrupts during byte send - about 8Âµs
-    cli();
-    LOOP_L_N(i, 8) {
-      WRITE(SD_SCK_PIN, LOW);
-      WRITE(SD_MOSI_PIN, data & 0x80);
-      data <<= 1;
-      WRITE(SD_SCK_PIN, HIGH);
-    }
-
-    nop; // hold SCK high for a few ns
-    nop;
-    nop;
-    nop;
-
-    WRITE(SD_SCK_PIN, LOW);
-
-    sei();
-  }
-
-  // Soft SPI send block
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-    spiSend(token);
-    for (uint16_t i = 0; i < 512; i++)
-      spiSend(buf[i]);
-  }
-
-#endif // SOFTWARE_SPI || FORCE_SOFT_SPI
-
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/MarlinSPI.h b/Marlin/src/HAL/AVR/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/AVR/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/AVR/MarlinSerial.cpp b/Marlin/src/HAL/AVR/MarlinSerial.cpp
deleted file mode 100644
index 9864624..0000000
--- a/Marlin/src/HAL/AVR/MarlinSerial.cpp
+++ /dev/null
@@ -1,652 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * MarlinSerial.cpp - Hardware serial library for Wiring
- * Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
- *
- * Modified 23 November 2006 by David A. Mellis
- * Modified 28 September 2010 by Mark Sproul
- * Modified 14 February 2016 by Andreas Hardtung (added tx buffer)
- * Modified 01 October 2017 by Eduardo JosÃ© Tagle (added XON/XOFF)
- * Modified 10 June 2018 by Eduardo JosÃ© Tagle (See #10991)
- * Templatized 01 October 2018 by Eduardo JosÃ© Tagle to allow multiple instances
- */
-
-#ifdef __AVR__
-
-// Disable HardwareSerial.cpp to support chips without a UART (Attiny, etc.)
-
-#include "../../inc/MarlinConfig.h"
-
-#if !defined(USBCON) && (defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H))
-
-#include "MarlinSerial.h"
-#include "../../MarlinCore.h"
-
-#if ENABLED(DIRECT_STEPPING)
-  #include "../../feature/direct_stepping.h"
-#endif
-
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_r MarlinSerial<Cfg>::rx_buffer = { 0, 0, { 0 } };
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_t MarlinSerial<Cfg>::tx_buffer = { 0 };
-template<typename Cfg> bool     MarlinSerial<Cfg>::_written = false;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::xon_xoff_state = MarlinSerial<Cfg>::XON_XOFF_CHAR_SENT | MarlinSerial<Cfg>::XON_CHAR;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_dropped_bytes = 0;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_buffer_overruns = 0;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_framing_errors = 0;
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::rx_max_enqueued = 0;
-
-// A SW memory barrier, to ensure GCC does not overoptimize loops
-#define sw_barrier() asm volatile("": : :"memory");
-
-#include "../../feature/e_parser.h"
-
-// "Atomically" read the RX head index value without disabling interrupts:
-// This MUST be called with RX interrupts enabled, and CAN'T be called
-// from the RX ISR itself!
-template<typename Cfg>
-FORCE_INLINE typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::atomic_read_rx_head() {
-  if (Cfg::RX_SIZE > 256) {
-    // Keep reading until 2 consecutive reads return the same value,
-    // meaning there was no update in-between caused by an interrupt.
-    // This works because serial RX interrupts happen at a slower rate
-    // than successive reads of a variable, so 2 consecutive reads with
-    // the same value means no interrupt updated it.
-    ring_buffer_pos_t vold, vnew = rx_buffer.head;
-    sw_barrier();
-    do {
-      vold = vnew;
-      vnew = rx_buffer.head;
-      sw_barrier();
-    } while (vold != vnew);
-    return vnew;
-  }
-  else {
-    // With an 8bit index, reads are always atomic. No need for special handling
-    return rx_buffer.head;
-  }
-}
-
-template<typename Cfg>
-volatile bool MarlinSerial<Cfg>::rx_tail_value_not_stable = false;
-template<typename Cfg>
-volatile uint16_t MarlinSerial<Cfg>::rx_tail_value_backup = 0;
-
-// Set RX tail index, taking into account the RX ISR could interrupt
-//  the write to this variable in the middle - So a backup strategy
-//  is used to ensure reads of the correct values.
-//    -Must NOT be called from the RX ISR -
-template<typename Cfg>
-FORCE_INLINE void MarlinSerial<Cfg>::atomic_set_rx_tail(typename MarlinSerial<Cfg>::ring_buffer_pos_t value) {
-  if (Cfg::RX_SIZE > 256) {
-    // Store the new value in the backup
-    rx_tail_value_backup = value;
-    sw_barrier();
-    // Flag we are about to change the true value
-    rx_tail_value_not_stable = true;
-    sw_barrier();
-    // Store the new value
-    rx_buffer.tail = value;
-    sw_barrier();
-    // Signal the new value is completely stored into the value
-    rx_tail_value_not_stable = false;
-    sw_barrier();
-  }
-  else
-    rx_buffer.tail = value;
-}
-
-// Get the RX tail index, taking into account the read could be
-//  interrupting in the middle of the update of that index value
-//    -Called from the RX ISR -
-template<typename Cfg>
-FORCE_INLINE typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::atomic_read_rx_tail() {
-  if (Cfg::RX_SIZE > 256) {
-    // If the true index is being modified, return the backup value
-    if (rx_tail_value_not_stable) return rx_tail_value_backup;
-  }
-  // The true index is stable, return it
-  return rx_buffer.tail;
-}
-
-// (called with RX interrupts disabled)
-template<typename Cfg>
-FORCE_INLINE void MarlinSerial<Cfg>::store_rxd_char() {
-
-  static EmergencyParser::State emergency_state; // = EP_RESET
-
-  // This must read the R_UCSRA register before reading the received byte to detect error causes
-  if (Cfg::DROPPED_RX && B_DOR && !++rx_dropped_bytes) --rx_dropped_bytes;
-  if (Cfg::RX_OVERRUNS && B_DOR && !++rx_buffer_overruns) --rx_buffer_overruns;
-  if (Cfg::RX_FRAMING_ERRORS && B_FE && !++rx_framing_errors) --rx_framing_errors;
-
-  // Read the character from the USART
-  uint8_t c = R_UDR;
-
-  #if ENABLED(DIRECT_STEPPING)
-    if (page_manager.maybe_store_rxd_char(c)) return;
-  #endif
-
-  // Get the tail - Nothing can alter its value while this ISR is executing, but there's
-  // a chance that this ISR interrupted the main process while it was updating the index.
-  // The backup mechanism ensures the correct value is always returned.
-  const ring_buffer_pos_t t = atomic_read_rx_tail();
-
-  // Get the head pointer - This ISR is the only one that modifies its value, so it's safe to read here
-  ring_buffer_pos_t h = rx_buffer.head;
-
-  // Get the next element
-  ring_buffer_pos_t i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-  if (Cfg::EMERGENCYPARSER) emergency_parser.update(emergency_state, c);
-
-  // If the character is to be stored at the index just before the tail
-  // (such that the head would advance to the current tail), the RX FIFO is
-  // full, so don't write the character or advance the head.
-  if (i != t) {
-    rx_buffer.buffer[h] = c;
-    h = i;
-  }
-  else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-    --rx_dropped_bytes;
-
-  if (Cfg::MAX_RX_QUEUED) {
-    // Calculate count of bytes stored into the RX buffer
-    const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-    // Keep track of the maximum count of enqueued bytes
-    NOLESS(rx_max_enqueued, rx_count);
-  }
-
-  if (Cfg::XONOFF) {
-    // If the last char that was sent was an XON
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XON_CHAR) {
-
-      // Bytes stored into the RX buffer
-      const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-      // If over 12.5% of RX buffer capacity, send XOFF before running out of
-      // RX buffer space .. 325 bytes @ 250kbits/s needed to let the host react
-      // and stop sending bytes. This translates to 13mS propagation time.
-      if (rx_count >= (Cfg::RX_SIZE) / 8) {
-
-        // At this point, definitely no TX interrupt was executing, since the TX ISR can't be preempted.
-        // Don't enable the TX interrupt here as a means to trigger the XOFF char, because if it happens
-        // to be in the middle of trying to disable the RX interrupt in the main program, eventually the
-        // enabling of the TX interrupt could be undone. The ONLY reliable thing this can do to ensure
-        // the sending of the XOFF char is to send it HERE AND NOW.
-
-        // About to send the XOFF char
-        xon_xoff_state = XOFF_CHAR | XON_XOFF_CHAR_SENT;
-
-        // Wait until the TX register becomes empty and send it - Here there could be a problem
-        // - While waiting for the TX register to empty, the RX register could receive a new
-        //   character. This must also handle that situation!
-        while (!B_UDRE) {
-
-          if (B_RXC) {
-            // A char arrived while waiting for the TX buffer to be empty - Receive and process it!
-
-            i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-            // Read the character from the USART
-            c = R_UDR;
-
-            if (Cfg::EMERGENCYPARSER) emergency_parser.update(emergency_state, c);
-
-            // If the character is to be stored at the index just before the tail
-            // (such that the head would advance to the current tail), the FIFO is
-            // full, so don't write the character or advance the head.
-            if (i != t) {
-              rx_buffer.buffer[h] = c;
-              h = i;
-            }
-            else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-              --rx_dropped_bytes;
-          }
-          sw_barrier();
-        }
-
-        R_UDR = XOFF_CHAR;
-
-        // Clear the TXC bit -- "can be cleared by writing a one to its bit
-        // location". This makes sure flush() won't return until the bytes
-        // actually got written
-        B_TXC = 1;
-
-        // At this point there could be a race condition between the write() function
-        // and this sending of the XOFF char. This interrupt could happen between the
-        // wait to be empty TX buffer loop and the actual write of the character. Since
-        // the TX buffer is full because it's sending the XOFF char, the only way to be
-        // sure the write() function will succeed is to wait for the XOFF char to be
-        // completely sent. Since an extra character could be received during the wait
-        // it must also be handled!
-        while (!B_UDRE) {
-
-          if (B_RXC) {
-            // A char arrived while waiting for the TX buffer to be empty - Receive and process it!
-
-            i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-            // Read the character from the USART
-            c = R_UDR;
-
-            if (Cfg::EMERGENCYPARSER)
-              emergency_parser.update(emergency_state, c);
-
-            // If the character is to be stored at the index just before the tail
-            // (such that the head would advance to the current tail), the FIFO is
-            // full, so don't write the character or advance the head.
-            if (i != t) {
-              rx_buffer.buffer[h] = c;
-              h = i;
-            }
-            else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-              --rx_dropped_bytes;
-          }
-          sw_barrier();
-        }
-
-        // At this point everything is ready. The write() function won't
-        // have any issues writing to the UART TX register if it needs to!
-      }
-    }
-  }
-
-  // Store the new head value - The main loop will retry until the value is stable
-  rx_buffer.head = h;
-}
-
-// (called with TX irqs disabled)
-template<typename Cfg>
-FORCE_INLINE void MarlinSerial<Cfg>::_tx_udr_empty_irq() {
-  if (Cfg::TX_SIZE > 0) {
-    // Read positions
-    uint8_t t = tx_buffer.tail;
-    const uint8_t h = tx_buffer.head;
-
-    if (Cfg::XONOFF) {
-      // If an XON char is pending to be sent, do it now
-      if (xon_xoff_state == XON_CHAR) {
-
-        // Send the character
-        R_UDR = XON_CHAR;
-
-        // clear the TXC bit -- "can be cleared by writing a one to its bit
-        // location". This makes sure flush() won't return until the bytes
-        // actually got written
-        B_TXC = 1;
-
-        // Remember we sent it.
-        xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-
-        // If nothing else to transmit, just disable TX interrupts.
-        if (h == t) B_UDRIE = 0; // (Non-atomic, could be reenabled by the main program, but eventually this will succeed)
-
-        return;
-      }
-    }
-
-    // If nothing to transmit, just disable TX interrupts. This could
-    // happen as the result of the non atomicity of the disabling of RX
-    // interrupts that could end reenabling TX interrupts as a side effect.
-    if (h == t) {
-      B_UDRIE = 0; // (Non-atomic, could be reenabled by the main program, but eventually this will succeed)
-      return;
-    }
-
-    // There is something to TX, Send the next byte
-    const uint8_t c = tx_buffer.buffer[t];
-    t = (t + 1) & (Cfg::TX_SIZE - 1);
-    R_UDR = c;
-    tx_buffer.tail = t;
-
-    // Clear the TXC bit (by writing a one to its bit location).
-    // Ensures flush() won't return until the bytes are actually written/
-    B_TXC = 1;
-
-    // Disable interrupts if there is nothing to transmit following this byte
-    if (h == t) B_UDRIE = 0; // (Non-atomic, could be reenabled by the main program, but eventually this will succeed)
-  }
-}
-
-// Public Methods
-template<typename Cfg>
-void MarlinSerial<Cfg>::begin(const long baud) {
-  uint16_t baud_setting;
-  bool useU2X = true;
-
-  #if F_CPU == 16000000UL && SERIAL_PORT == 0
-    // Hard-coded exception for compatibility with the bootloader shipped
-    // with the Duemilanove and previous boards, and the firmware on the
-    // 8U2 on the Uno and Mega 2560.
-    if (baud == 57600) useU2X = false;
-  #endif
-
-  R_UCSRA = 0;
-  if (useU2X) {
-    B_U2X = 1;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  }
-  else
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  R_UBRRH = baud_setting >> 8;
-  R_UBRRL = baud_setting;
-
-  B_RXEN = 1;
-  B_TXEN = 1;
-  B_RXCIE = 1;
-  if (Cfg::TX_SIZE > 0) B_UDRIE = 0;
-  _written = false;
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::end() {
-  B_RXEN = 0;
-  B_TXEN = 0;
-  B_RXCIE = 0;
-  B_UDRIE = 0;
-}
-
-template<typename Cfg>
-int MarlinSerial<Cfg>::peek() {
-  const ring_buffer_pos_t h = atomic_read_rx_head(), t = rx_buffer.tail;
-  return h == t ? -1 : rx_buffer.buffer[t];
-}
-
-template<typename Cfg>
-int MarlinSerial<Cfg>::read() {
-  const ring_buffer_pos_t h = atomic_read_rx_head();
-
-  // Read the tail. Main thread owns it, so it is safe to directly read it
-  ring_buffer_pos_t t = rx_buffer.tail;
-
-  // If nothing to read, return now
-  if (h == t) return -1;
-
-  // Get the next char
-  const int v = rx_buffer.buffer[t];
-  t = (ring_buffer_pos_t)(t + 1) & (Cfg::RX_SIZE - 1);
-
-  // Advance tail - Making sure the RX ISR will always get an stable value, even
-  // if it interrupts the writing of the value of that variable in the middle.
-  atomic_set_rx_tail(t);
-
-  if (Cfg::XONOFF) {
-    // If the XOFF char was sent, or about to be sent...
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XOFF_CHAR) {
-      // Get count of bytes in the RX buffer
-      const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-      if (rx_count < (Cfg::RX_SIZE) / 10) {
-        if (Cfg::TX_SIZE > 0) {
-          // Signal we want an XON character to be sent.
-          xon_xoff_state = XON_CHAR;
-          // Enable TX ISR. Non atomic, but it will eventually enable them
-          B_UDRIE = 1;
-        }
-        else {
-          // If not using TX interrupts, we must send the XON char now
-          xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-          while (!B_UDRE) sw_barrier();
-          R_UDR = XON_CHAR;
-        }
-      }
-    }
-  }
-
-  return v;
-}
-
-template<typename Cfg>
-typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::available() {
-  const ring_buffer_pos_t h = atomic_read_rx_head(), t = rx_buffer.tail;
-  return (ring_buffer_pos_t)(Cfg::RX_SIZE + h - t) & (Cfg::RX_SIZE - 1);
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::flush() {
-
-  // Set the tail to the head:
-  //  - Read the RX head index in a safe way. (See atomic_read_rx_head.)
-  //  - Set the tail, making sure the RX ISR will always get a stable value, even
-  //    if it interrupts the writing of the value of that variable in the middle.
-  atomic_set_rx_tail(atomic_read_rx_head());
-
-  if (Cfg::XONOFF) {
-    // If the XOFF char was sent, or about to be sent...
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XOFF_CHAR) {
-      if (Cfg::TX_SIZE > 0) {
-        // Signal we want an XON character to be sent.
-        xon_xoff_state = XON_CHAR;
-        // Enable TX ISR. Non atomic, but it will eventually enable it.
-        B_UDRIE = 1;
-      }
-      else {
-        // If not using TX interrupts, we must send the XON char now
-        xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-        while (!B_UDRE) sw_barrier();
-        R_UDR = XON_CHAR;
-      }
-    }
-  }
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::write(const uint8_t c) {
-  if (Cfg::TX_SIZE == 0) {
-
-    _written = true;
-    while (!B_UDRE) sw_barrier();
-    R_UDR = c;
-
-  }
-  else {
-
-    _written = true;
-
-    // If the TX interrupts are disabled and the data register
-    // is empty, just write the byte to the data register and
-    // be done. This shortcut helps significantly improve the
-    // effective datarate at high (>500kbit/s) bitrates, where
-    // interrupt overhead becomes a slowdown.
-    // Yes, there is a race condition between the sending of the
-    // XOFF char at the RX ISR, but it is properly handled there
-    if (!B_UDRIE && B_UDRE) {
-      R_UDR = c;
-
-      // clear the TXC bit -- "can be cleared by writing a one to its bit
-      // location". This makes sure flush() won't return until the bytes
-      // actually got written
-      B_TXC = 1;
-      return;
-    }
-
-    const uint8_t i = (tx_buffer.head + 1) & (Cfg::TX_SIZE - 1);
-
-    // If global interrupts are disabled (as the result of being called from an ISR)...
-    if (!hal.isr_state()) {
-
-      // Make room by polling if it is possible to transmit, and do so!
-      while (i == tx_buffer.tail) {
-
-        // If we can transmit another byte, do it.
-        if (B_UDRE) _tx_udr_empty_irq();
-
-        // Make sure compiler rereads tx_buffer.tail
-        sw_barrier();
-      }
-    }
-    else {
-      // Interrupts are enabled, just wait until there is space
-      while (i == tx_buffer.tail) sw_barrier();
-    }
-
-    // Store new char. head is always safe to move
-    tx_buffer.buffer[tx_buffer.head] = c;
-    tx_buffer.head = i;
-
-    // Enable TX ISR - Non atomic, but it will eventually enable TX ISR
-    B_UDRIE = 1;
-  }
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::flushTX() {
-
-  if (Cfg::TX_SIZE == 0) {
-    // No bytes written, no need to flush. This special case is needed since there's
-    // no way to force the TXC (transmit complete) bit to 1 during initialization.
-    if (!_written) return;
-
-    // Wait until everything was transmitted
-    while (!B_TXC) sw_barrier();
-
-    // At this point nothing is queued anymore (DRIE is disabled) and
-    // the hardware finished transmission (TXC is set).
-
-  }
-  else {
-
-    // No bytes written, no need to flush. This special case is needed since there's
-    // no way to force the TXC (transmit complete) bit to 1 during initialization.
-    if (!_written) return;
-
-    // If global interrupts are disabled (as the result of being called from an ISR)...
-    if (!hal.isr_state()) {
-
-      // Wait until everything was transmitted - We must do polling, as interrupts are disabled
-      while (tx_buffer.head != tx_buffer.tail || !B_TXC) {
-
-        // If there is more space, send an extra character
-        if (B_UDRE) _tx_udr_empty_irq();
-
-        sw_barrier();
-      }
-
-    }
-    else {
-      // Wait until everything was transmitted
-      while (tx_buffer.head != tx_buffer.tail || !B_TXC) sw_barrier();
-    }
-
-    // At this point nothing is queued anymore (DRIE is disabled) and
-    // the hardware finished transmission (TXC is set).
-  }
-}
-
-// Hookup ISR handlers
-ISR(SERIAL_REGNAME(USART, SERIAL_PORT, _RX_vect)) {
-  MarlinSerial<MarlinSerialCfg<SERIAL_PORT>>::store_rxd_char();
-}
-
-ISR(SERIAL_REGNAME(USART, SERIAL_PORT, _UDRE_vect)) {
-  MarlinSerial<MarlinSerialCfg<SERIAL_PORT>>::_tx_udr_empty_irq();
-}
-
-// Because of the template definition above, it's required to instantiate the template to have all methods generated
-template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT> >;
-MSerialT1 customizedSerial1(MSerialT1::HasEmergencyParser);
-
-#ifdef SERIAL_PORT_2
-
-  // Hookup ISR handlers
-  ISR(SERIAL_REGNAME(USART, SERIAL_PORT_2, _RX_vect)) {
-    MarlinSerial<MarlinSerialCfg<SERIAL_PORT_2>>::store_rxd_char();
-  }
-
-  ISR(SERIAL_REGNAME(USART, SERIAL_PORT_2, _UDRE_vect)) {
-    MarlinSerial<MarlinSerialCfg<SERIAL_PORT_2>>::_tx_udr_empty_irq();
-  }
-
-  template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT_2> >;
-  MSerialT2 customizedSerial2(MSerialT2::HasEmergencyParser);
-
-#endif // SERIAL_PORT_2
-
-#ifdef SERIAL_PORT_3
-
-  // Hookup ISR handlers
-  ISR(SERIAL_REGNAME(USART, SERIAL_PORT_3, _RX_vect)) {
-    MarlinSerial<MarlinSerialCfg<SERIAL_PORT_3>>::store_rxd_char();
-  }
-
-  ISR(SERIAL_REGNAME(USART, SERIAL_PORT_3, _UDRE_vect)) {
-    MarlinSerial<MarlinSerialCfg<SERIAL_PORT_3>>::_tx_udr_empty_irq();
-  }
-
-  template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT_3> >;
-  MSerialT3 customizedSerial3(MSerialT3::HasEmergencyParser);
-
-#endif // SERIAL_PORT_3
-
-#ifdef MMU2_SERIAL_PORT
-
-  ISR(SERIAL_REGNAME(USART, MMU2_SERIAL_PORT, _RX_vect)) {
-    MarlinSerial<MMU2SerialCfg<MMU2_SERIAL_PORT>>::store_rxd_char();
-  }
-
-  ISR(SERIAL_REGNAME(USART, MMU2_SERIAL_PORT, _UDRE_vect)) {
-    MarlinSerial<MMU2SerialCfg<MMU2_SERIAL_PORT>>::_tx_udr_empty_irq();
-  }
-
-  template class MarlinSerial< MMU2SerialCfg<MMU2_SERIAL_PORT> >;
-  MSerialMMU2 mmuSerial(MSerialMMU2::HasEmergencyParser);
-
-#endif // MMU2_SERIAL_PORT
-
-#ifdef LCD_SERIAL_PORT
-
-  ISR(SERIAL_REGNAME(USART, LCD_SERIAL_PORT, _RX_vect)) {
-    MarlinSerial<LCDSerialCfg<LCD_SERIAL_PORT>>::store_rxd_char();
-  }
-
-  ISR(SERIAL_REGNAME(USART, LCD_SERIAL_PORT, _UDRE_vect)) {
-    MarlinSerial<LCDSerialCfg<LCD_SERIAL_PORT>>::_tx_udr_empty_irq();
-  }
-
-  template class MarlinSerial< LCDSerialCfg<LCD_SERIAL_PORT> >;
-  MSerialLCD lcdSerial(MSerialLCD::HasEmergencyParser);
-
-  #if HAS_DGUS_LCD
-    template<typename Cfg>
-    typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::get_tx_buffer_free() {
-      const ring_buffer_pos_t t = tx_buffer.tail,  // next byte to send.
-                              h = tx_buffer.head;  // next pos for queue.
-      int ret = t - h - 1;
-      if (ret < 0) ret += Cfg::TX_SIZE + 1;
-      return ret;
-    }
-  #endif
-
-#endif // LCD_SERIAL_PORT
-
-#endif // !USBCON && (UBRRH || UBRR0H || UBRR1H || UBRR2H || UBRR3H)
-
-// For AT90USB targets use the UART for BT interfacing
-#if defined(USBCON) && ENABLED(BLUETOOTH)
-  MSerialBT bluetoothSerial(false);
-#endif
-
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/MarlinSerial.h b/Marlin/src/HAL/AVR/MarlinSerial.h
deleted file mode 100644
index 7eb7600..0000000
--- a/Marlin/src/HAL/AVR/MarlinSerial.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * MarlinSerial.h - Hardware serial library for Wiring
- * Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
- *
- * Modified 28 September 2010 by Mark Sproul
- * Modified 14 February 2016 by Andreas Hardtung (added tx buffer)
- * Modified 01 October 2017 by Eduardo JosÃ© Tagle (added XON/XOFF)
- * Templatized 01 October 2018 by Eduardo JosÃ© Tagle to allow multiple instances
- */
-
-#include <WString.h>
-
-#include "../../inc/MarlinConfigPre.h"
-#include "../../core/serial_hook.h"
-
-#ifndef SERIAL_PORT
-  #define SERIAL_PORT 0
-#endif
-
-#ifndef USBCON
-
-  // The presence of the UBRRH register is used to detect a UART.
-  #define UART_PRESENT(port) ((port == 0 && (defined(UBRRH) || defined(UBRR0H))) || \
-                              (port == 1 && defined(UBRR1H)) || (port == 2 && defined(UBRR2H)) || \
-                              (port == 3 && defined(UBRR3H)))
-
-  // These are macros to build serial port register names for the selected SERIAL_PORT (C preprocessor
-  // requires two levels of indirection to expand macro values properly)
-  #define SERIAL_REGNAME(registerbase,number,suffix) _SERIAL_REGNAME(registerbase,number,suffix)
-  #if SERIAL_PORT == 0 && (!defined(UBRR0H) || !defined(UDR0)) // use un-numbered registers if necessary
-    #define _SERIAL_REGNAME(registerbase,number,suffix) registerbase##suffix
-  #else
-    #define _SERIAL_REGNAME(registerbase,number,suffix) registerbase##number##suffix
-  #endif
-
-  // Registers used by MarlinSerial class (expanded depending on selected serial port)
-
-  // Templated 8bit register (generic)
-  #define UART_REGISTER_DECL_BASE(registerbase, suffix) \
-    template<int portNr> struct R_##registerbase##x##suffix {}
-
-  // Templated 8bit register (specialization for each port)
-  #define UART_REGISTER_DECL(port, registerbase, suffix) \
-    template<> struct R_##registerbase##x##suffix<port> { \
-      constexpr R_##registerbase##x##suffix(int) {} \
-      FORCE_INLINE void operator=(uint8_t newVal) const { SERIAL_REGNAME(registerbase,port,suffix) = newVal; } \
-      FORCE_INLINE operator uint8_t() const { return SERIAL_REGNAME(registerbase,port,suffix); } \
-    }
-
-  // Templated 1bit register (generic)
-  #define UART_BIT_DECL_BASE(registerbase, suffix, bit) \
-    template<int portNr>struct B_##bit##x {}
-
-  // Templated 1bit register (specialization for each port)
-  #define UART_BIT_DECL(port, registerbase, suffix, bit) \
-    template<> struct B_##bit##x<port> { \
-      constexpr B_##bit##x(int) {} \
-      FORCE_INLINE void operator=(int newVal) const { \
-        if (newVal) \
-          SBI(SERIAL_REGNAME(registerbase,port,suffix),SERIAL_REGNAME(bit,port,)); \
-        else \
-          CBI(SERIAL_REGNAME(registerbase,port,suffix),SERIAL_REGNAME(bit,port,)); \
-      } \
-      FORCE_INLINE operator bool() const { return TEST(SERIAL_REGNAME(registerbase,port,suffix),SERIAL_REGNAME(bit,port,)); } \
-    }
-
-  #define UART_DECL_BASE() \
-    UART_REGISTER_DECL_BASE(UCSR,A);\
-    UART_REGISTER_DECL_BASE(UDR,);\
-    UART_REGISTER_DECL_BASE(UBRR,H);\
-    UART_REGISTER_DECL_BASE(UBRR,L);\
-    UART_BIT_DECL_BASE(UCSR,B,RXEN);\
-    UART_BIT_DECL_BASE(UCSR,B,TXEN);\
-    UART_BIT_DECL_BASE(UCSR,A,TXC);\
-    UART_BIT_DECL_BASE(UCSR,B,RXCIE);\
-    UART_BIT_DECL_BASE(UCSR,A,UDRE);\
-    UART_BIT_DECL_BASE(UCSR,A,FE);\
-    UART_BIT_DECL_BASE(UCSR,A,DOR);\
-    UART_BIT_DECL_BASE(UCSR,B,UDRIE);\
-    UART_BIT_DECL_BASE(UCSR,A,RXC);\
-    UART_BIT_DECL_BASE(UCSR,A,U2X)
-
-  #define UART_DECL(port) \
-    UART_REGISTER_DECL(port,UCSR,A);\
-    UART_REGISTER_DECL(port,UDR,);\
-    UART_REGISTER_DECL(port,UBRR,H);\
-    UART_REGISTER_DECL(port,UBRR,L);\
-    UART_BIT_DECL(port,UCSR,B,RXEN);\
-    UART_BIT_DECL(port,UCSR,B,TXEN);\
-    UART_BIT_DECL(port,UCSR,A,TXC);\
-    UART_BIT_DECL(port,UCSR,B,RXCIE);\
-    UART_BIT_DECL(port,UCSR,A,UDRE);\
-    UART_BIT_DECL(port,UCSR,A,FE);\
-    UART_BIT_DECL(port,UCSR,A,DOR);\
-    UART_BIT_DECL(port,UCSR,B,UDRIE);\
-    UART_BIT_DECL(port,UCSR,A,RXC);\
-    UART_BIT_DECL(port,UCSR,A,U2X)
-
-  // Declare empty templates
-  UART_DECL_BASE();
-
-  // And all the specializations for each possible serial port
-  #if UART_PRESENT(0)
-    UART_DECL(0);
-  #endif
-  #if UART_PRESENT(1)
-    UART_DECL(1);
-  #endif
-  #if UART_PRESENT(2)
-    UART_DECL(2);
-  #endif
-  #if UART_PRESENT(3)
-    UART_DECL(3);
-  #endif
-
-  #define BYTE 0
-
-  // Templated type selector
-  template<bool b, typename T, typename F> struct TypeSelector { typedef T type;} ;
-  template<typename T, typename F> struct TypeSelector<false, T, F> { typedef F type; };
-
-  template<typename Cfg>
-  class MarlinSerial {
-  protected:
-    // Registers
-    static constexpr R_UCSRxA<Cfg::PORT> R_UCSRA = 0;
-    static constexpr R_UDRx<Cfg::PORT>   R_UDR   = 0;
-    static constexpr R_UBRRxH<Cfg::PORT> R_UBRRH = 0;
-    static constexpr R_UBRRxL<Cfg::PORT> R_UBRRL = 0;
-
-    // Bits
-    static constexpr B_RXENx<Cfg::PORT>  B_RXEN  = 0;
-    static constexpr B_TXENx<Cfg::PORT>  B_TXEN  = 0;
-    static constexpr B_TXCx<Cfg::PORT>   B_TXC   = 0;
-    static constexpr B_RXCIEx<Cfg::PORT> B_RXCIE = 0;
-    static constexpr B_UDREx<Cfg::PORT>  B_UDRE  = 0;
-    static constexpr B_FEx<Cfg::PORT>    B_FE    = 0;
-    static constexpr B_DORx<Cfg::PORT>   B_DOR   = 0;
-    static constexpr B_UDRIEx<Cfg::PORT> B_UDRIE = 0;
-    static constexpr B_RXCx<Cfg::PORT>   B_RXC   = 0;
-    static constexpr B_U2Xx<Cfg::PORT>   B_U2X   = 0;
-
-    // Base size of type on buffer size
-    typedef typename TypeSelector<(Cfg::RX_SIZE>256), uint16_t, uint8_t>::type ring_buffer_pos_t;
-
-    struct ring_buffer_r {
-      volatile ring_buffer_pos_t head, tail;
-      unsigned char buffer[Cfg::RX_SIZE];
-    };
-
-    struct ring_buffer_t {
-      volatile uint8_t head, tail;
-      unsigned char buffer[Cfg::TX_SIZE];
-    };
-
-    static ring_buffer_r rx_buffer;
-    static ring_buffer_t tx_buffer;
-    static bool _written;
-
-    static constexpr uint8_t XON_XOFF_CHAR_SENT = 0x80,  // XON / XOFF Character was sent
-                             XON_XOFF_CHAR_MASK = 0x1F;  // XON / XOFF character to send
-
-    // XON / XOFF character definitions
-    static constexpr uint8_t XON_CHAR  = 17, XOFF_CHAR = 19;
-    static uint8_t xon_xoff_state,
-                   rx_dropped_bytes,
-                   rx_buffer_overruns,
-                   rx_framing_errors;
-    static ring_buffer_pos_t rx_max_enqueued;
-
-    FORCE_INLINE static ring_buffer_pos_t atomic_read_rx_head();
-
-    static volatile bool rx_tail_value_not_stable;
-    static volatile uint16_t rx_tail_value_backup;
-
-    FORCE_INLINE static void atomic_set_rx_tail(ring_buffer_pos_t value);
-    FORCE_INLINE static ring_buffer_pos_t atomic_read_rx_tail();
-
-  public:
-    FORCE_INLINE static void store_rxd_char();
-    FORCE_INLINE static void _tx_udr_empty_irq();
-
-  public:
-    static void begin(const long);
-    static void end();
-    static int peek();
-    static int read();
-    static void flush();
-    static ring_buffer_pos_t available();
-    static void write(const uint8_t c);
-    static void flushTX();
-    #if HAS_DGUS_LCD
-      static ring_buffer_pos_t get_tx_buffer_free();
-    #endif
-
-    enum { HasEmergencyParser = Cfg::EMERGENCYPARSER };
-    static bool emergency_parser_enabled() { return Cfg::EMERGENCYPARSER; }
-
-    FORCE_INLINE static uint8_t dropped() { return Cfg::DROPPED_RX ? rx_dropped_bytes : 0; }
-    FORCE_INLINE static uint8_t buffer_overruns() { return Cfg::RX_OVERRUNS ? rx_buffer_overruns : 0; }
-    FORCE_INLINE static uint8_t framing_errors() { return Cfg::RX_FRAMING_ERRORS ? rx_framing_errors : 0; }
-    FORCE_INLINE static ring_buffer_pos_t rxMaxEnqueued() { return Cfg::MAX_RX_QUEUED ? rx_max_enqueued : 0; }
-  };
-
-  template <uint8_t serial>
-  struct MarlinSerialCfg {
-    static constexpr int PORT               = serial;
-    static constexpr unsigned int RX_SIZE   = RX_BUFFER_SIZE;
-    static constexpr unsigned int TX_SIZE   = TX_BUFFER_SIZE;
-    static constexpr bool XONOFF            = ENABLED(SERIAL_XON_XOFF);
-    static constexpr bool EMERGENCYPARSER   = ENABLED(EMERGENCY_PARSER);
-    static constexpr bool DROPPED_RX        = ENABLED(SERIAL_STATS_DROPPED_RX);
-    static constexpr bool RX_OVERRUNS       = ENABLED(SERIAL_STATS_RX_BUFFER_OVERRUNS);
-    static constexpr bool RX_FRAMING_ERRORS = ENABLED(SERIAL_STATS_RX_FRAMING_ERRORS);
-    static constexpr bool MAX_RX_QUEUED     = ENABLED(SERIAL_STATS_MAX_RX_QUEUED);
-  };
-
-  typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT> > > MSerialT1;
-  extern MSerialT1 customizedSerial1;
-
-  #ifdef SERIAL_PORT_2
-    typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT_2> > > MSerialT2;
-    extern MSerialT2 customizedSerial2;
-  #endif
-
-  #ifdef SERIAL_PORT_3
-    typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT_3> > > MSerialT3;
-    extern MSerialT3 customizedSerial3;
-  #endif
-
-#endif // !USBCON
-
-#ifdef MMU2_SERIAL_PORT
-  template <uint8_t serial>
-  struct MMU2SerialCfg {
-    static constexpr int PORT               = serial;
-    static constexpr unsigned int RX_SIZE   = 32;
-    static constexpr unsigned int TX_SIZE   = 32;
-    static constexpr bool XONOFF            = false;
-    static constexpr bool EMERGENCYPARSER   = false;
-    static constexpr bool DROPPED_RX        = false;
-    static constexpr bool RX_FRAMING_ERRORS = false;
-    static constexpr bool MAX_RX_QUEUED     = false;
-    static constexpr bool RX_OVERRUNS       = false;
-  };
-
-  typedef Serial1Class< MarlinSerial< MMU2SerialCfg<MMU2_SERIAL_PORT> > > MSerialMMU2;
-  extern MSerialMMU2 mmuSerial;
-#endif
-
-#ifdef LCD_SERIAL_PORT
-
-  template <uint8_t serial>
-  struct LCDSerialCfg {
-    static constexpr int PORT               = serial;
-    static constexpr unsigned int RX_SIZE   = TERN(HAS_DGUS_LCD, DGUS_RX_BUFFER_SIZE,  64);
-    static constexpr unsigned int TX_SIZE   = TERN(HAS_DGUS_LCD, DGUS_TX_BUFFER_SIZE, 128);
-    static constexpr bool XONOFF            = false;
-    static constexpr bool EMERGENCYPARSER   = ENABLED(EMERGENCY_PARSER);
-    static constexpr bool DROPPED_RX        = false;
-    static constexpr bool RX_FRAMING_ERRORS = false;
-    static constexpr bool MAX_RX_QUEUED     = false;
-    static constexpr bool RX_OVERRUNS       = BOTH(HAS_DGUS_LCD, SERIAL_STATS_RX_BUFFER_OVERRUNS);
-  };
-
-  typedef Serial1Class< MarlinSerial< LCDSerialCfg<LCD_SERIAL_PORT> > > MSerialLCD;
-  extern MSerialLCD lcdSerial;
-#endif
-
-// Use the UART for Bluetooth in AT90USB configurations
-#if defined(USBCON) && ENABLED(BLUETOOTH)
-  typedef Serial1Class<HardwareSerial> MSerialBT;
-  extern MSerialBT bluetoothSerial;
-#endif
diff --git a/Marlin/src/HAL/AVR/Servo.cpp b/Marlin/src/HAL/AVR/Servo.cpp
deleted file mode 100644
index 0a1ef53..0000000
--- a/Marlin/src/HAL/AVR/Servo.cpp
+++ /dev/null
@@ -1,226 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * servo.cpp - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
- * Copyright (c) 2009 Michael Margolis.  All right reserved.
- */
-
-/**
- * A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.
- * The servos are pulsed in the background using the value most recently written using the write() method
- *
- * Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
- * Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.
- *
- * The methods are:
- *
- * Servo - Class for manipulating servo motors connected to Arduino pins.
- *
- * attach(pin)           - Attach a servo motor to an i/o pin.
- * attach(pin, min, max) - Attach to a pin, setting min and max values in microseconds
- *                         Default min is 544, max is 2400
- *
- * write()               - Set the servo angle in degrees. (Invalid angles â€”over MIN_PULSE_WIDTHâ€” are treated as Âµs.)
- * writeMicroseconds()   - Set the servo pulse width in microseconds.
- * move(pin, angle)      - Sequence of attach(pin), write(angle), safe_delay(servo_delay[servoIndex]).
- *                         With DEACTIVATE_SERVOS_AFTER_MOVE it detaches after servo_delay[servoIndex].
- * read()                - Get the last-written servo pulse width as an angle between 0 and 180.
- * readMicroseconds()    - Get the last-written servo pulse width in microseconds.
- * attached()            - Return true if a servo is attached.
- * detach()              - Stop an attached servo from pulsing its i/o pin.
- */
-
-#ifdef __AVR__
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include <avr/interrupt.h>
-
-#include "../shared/servo.h"
-#include "../shared/servo_private.h"
-
-static volatile int8_t Channel[_Nbr_16timers];              // counter for the servo being pulsed for each timer (or -1 if refresh interval)
-
-
-/************ static functions common to all instances ***********************/
-
-static inline void handle_interrupts(const timer16_Sequence_t timer, volatile uint16_t* TCNTn, volatile uint16_t* OCRnA) {
-  int8_t cho = Channel[timer];                                        // Handle the prior Channel[timer] first
-  if (cho < 0)                                                        // Channel -1 indicates the refresh interval completed...
-    *TCNTn = 0;                                                       // ...so reset the timer
-  else if (SERVO_INDEX(timer, cho) < ServoCount)                      // prior channel handled?
-    extDigitalWrite(SERVO(timer, cho).Pin.nbr, LOW);                  // pulse the prior channel LOW
-
-  Channel[timer] = ++cho;                                             // Handle the next channel (or 0)
-  if (cho < SERVOS_PER_TIMER && SERVO_INDEX(timer, cho) < ServoCount) {
-    *OCRnA = *TCNTn + SERVO(timer, cho).ticks;                        // set compare to current ticks plus duration
-    if (SERVO(timer, cho).Pin.isActive)                               // activated?
-      extDigitalWrite(SERVO(timer, cho).Pin.nbr, HIGH);               // yes: pulse HIGH
-  }
-  else {
-    // finished all channels so wait for the refresh period to expire before starting over
-    const unsigned int cval = ((unsigned)*TCNTn) + 32 / (SERVO_TIMER_PRESCALER), // allow 32 cycles to ensure the next OCR1A not missed
-                       ival = (unsigned int)usToTicks(REFRESH_INTERVAL); // at least REFRESH_INTERVAL has elapsed
-    *OCRnA = max(cval, ival);
-
-    Channel[timer] = -1;                                              // reset the timer counter to 0 on the next call
-  }
-}
-
-#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
-
-  // Interrupt handlers for Arduino
-  #ifdef _useTimer1
-    SIGNAL(TIMER1_COMPA_vect) { handle_interrupts(_timer1, &TCNT1, &OCR1A); }
-  #endif
-
-  #ifdef _useTimer3
-    SIGNAL(TIMER3_COMPA_vect) { handle_interrupts(_timer3, &TCNT3, &OCR3A); }
-  #endif
-
-  #ifdef _useTimer4
-    SIGNAL(TIMER4_COMPA_vect) { handle_interrupts(_timer4, &TCNT4, &OCR4A); }
-  #endif
-
-  #ifdef _useTimer5
-    SIGNAL(TIMER5_COMPA_vect) { handle_interrupts(_timer5, &TCNT5, &OCR5A); }
-  #endif
-
-#else // WIRING
-
-  // Interrupt handlers for Wiring
-  #ifdef _useTimer1
-    void Timer1Service() { handle_interrupts(_timer1, &TCNT1, &OCR1A); }
-  #endif
-  #ifdef _useTimer3
-    void Timer3Service() { handle_interrupts(_timer3, &TCNT3, &OCR3A); }
-  #endif
-
-#endif // WIRING
-
-/****************** end of static functions ******************************/
-
-void initISR(const timer16_Sequence_t timer_index) {
-  switch (timer_index) {
-    default: break;
-
-    #ifdef _useTimer1
-      case _timer1:
-        TCCR1A = 0;             // normal counting mode
-        TCCR1B = _BV(CS11);     // set prescaler of 8
-        TCNT1 = 0;              // clear the timer count
-        #if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
-          SBI(TIFR, OCF1A);      // clear any pending interrupts;
-          SBI(TIMSK, OCIE1A);    // enable the output compare interrupt
-        #else
-          // here if not ATmega8 or ATmega128
-          SBI(TIFR1, OCF1A);     // clear any pending interrupts;
-          SBI(TIMSK1, OCIE1A);   // enable the output compare interrupt
-        #endif
-        #ifdef WIRING
-          timerAttach(TIMER1OUTCOMPAREA_INT, Timer1Service);
-        #endif
-        break;
-    #endif
-
-    #ifdef _useTimer3
-      case _timer3:
-        TCCR3A = 0;             // normal counting mode
-        TCCR3B = _BV(CS31);     // set prescaler of 8
-        TCNT3 = 0;              // clear the timer count
-        #ifdef __AVR_ATmega128__
-          SBI(TIFR, OCF3A);     // clear any pending interrupts;
-          SBI(ETIMSK, OCIE3A);  // enable the output compare interrupt
-        #else
-          SBI(TIFR3, OCF3A);   // clear any pending interrupts;
-          SBI(TIMSK3, OCIE3A); // enable the output compare interrupt
-        #endif
-        #ifdef WIRING
-          timerAttach(TIMER3OUTCOMPAREA_INT, Timer3Service);  // for Wiring platform only
-        #endif
-        break;
-    #endif
-
-    #ifdef _useTimer4
-      case _timer4:
-        TCCR4A = 0;             // normal counting mode
-        TCCR4B = _BV(CS41);     // set prescaler of 8
-        TCNT4 = 0;              // clear the timer count
-        TIFR4 = _BV(OCF4A);     // clear any pending interrupts;
-        TIMSK4 = _BV(OCIE4A);   // enable the output compare interrupt
-        break;
-    #endif
-
-    #ifdef _useTimer5
-      case _timer5:
-        TCCR5A = 0;             // normal counting mode
-        TCCR5B = _BV(CS51);     // set prescaler of 8
-        TCNT5 = 0;              // clear the timer count
-        TIFR5 = _BV(OCF5A);     // clear any pending interrupts;
-        TIMSK5 = _BV(OCIE5A);   // enable the output compare interrupt
-        break;
-    #endif
-  }
-}
-
-void finISR(const timer16_Sequence_t timer_index) {
-  // Disable use of the given timer
-  #ifdef WIRING
-    switch (timer_index) {
-      default: break;
-
-      case _timer1:
-        CBI(
-          #if defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)
-            TIMSK1
-          #else
-            TIMSK
-          #endif
-          , OCIE1A    // disable timer 1 output compare interrupt
-        );
-        timerDetach(TIMER1OUTCOMPAREA_INT);
-        break;
-
-      case _timer3:
-        CBI(
-          #if defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)
-            TIMSK3
-          #else
-            ETIMSK
-          #endif
-          , OCIE3A    // disable the timer3 output compare A interrupt
-        );
-        timerDetach(TIMER3OUTCOMPAREA_INT);
-        break;
-    }
-  #else // !WIRING
-    // For arduino - in future: call here to a currently undefined function to reset the timer
-    UNUSED(timer_index);
-  #endif
-}
-
-#endif // HAS_SERVOS
-
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/ServoTimers.h b/Marlin/src/HAL/AVR/ServoTimers.h
deleted file mode 100644
index 436b281..0000000
--- a/Marlin/src/HAL/AVR/ServoTimers.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * ServoTimers.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
- * Copyright (c) 2009 Michael Margolis.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/**
- * Defines for 16 bit timers used with  Servo library
- *
- * If _useTimerX is defined then TimerX is a 16 bit timer on the current board
- * timer16_Sequence_t enumerates the sequence that the timers should be allocated
- * _Nbr_16timers indicates how many 16 bit timers are available.
- */
-
-/**
- * AVR Only definitions
- * --------------------
- */
-
-#define TRIM_DURATION           2   // compensation ticks to trim adjust for digitalWrite delays
-#define SERVO_TIMER_PRESCALER   8   // timer prescaler
-
-// Say which 16 bit timers can be used and in what order
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-  //#define _useTimer1
-  #define _useTimer4
-  #if NUM_SERVOS > SERVOS_PER_TIMER
-    #define _useTimer3
-    #if !HAS_MOTOR_CURRENT_PWM && SERVOS > 2 * SERVOS_PER_TIMER
-      #define _useTimer5 // Timer 5 is used for motor current PWM and can't be used for servos.
-    #endif
-  #endif
-#elif defined(__AVR_ATmega32U4__)
-  #define _useTimer3
-#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)
-  #define _useTimer3
-#elif defined(__AVR_ATmega128__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega2561__)
-  #define _useTimer3
-#else
-  // everything else
-#endif
-
-typedef enum {
-  #ifdef _useTimer1
-    _timer1,
-  #endif
-  #ifdef _useTimer3
-    _timer3,
-  #endif
-  #ifdef _useTimer4
-    _timer4,
-  #endif
-  #ifdef _useTimer5
-    _timer5,
-  #endif
-  _Nbr_16timers
-} timer16_Sequence_t;
diff --git a/Marlin/src/HAL/AVR/eeprom.cpp b/Marlin/src/HAL/AVR/eeprom.cpp
deleted file mode 100644
index 8d084de..0000000
--- a/Marlin/src/HAL/AVR/eeprom.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __AVR__
-
-#include "../../inc/MarlinConfig.h"
-
-#if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
-
-/**
- * PersistentStore for Arduino-style EEPROM interface
- * with implementations supplied by the framework.
- */
-
-#include "../shared/eeprom_api.h"
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-bool PersistentStore::access_start()  { return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;  // always assume success for AVR's
-}
-
-#endif // EEPROM_SETTINGS || SD_FIRMWARE_UPDATE
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/endstop_interrupts.h b/Marlin/src/HAL/AVR/endstop_interrupts.h
deleted file mode 100644
index 5511aa4..0000000
--- a/Marlin/src/HAL/AVR/endstop_interrupts.h
+++ /dev/null
@@ -1,351 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate either an
- * 'external interrupt' or a 'pin change interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-#include <stdint.h>
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-/**
- * Patch for pins_arduino.h (...\Arduino\hardware\arduino\avr\variants\mega\pins_arduino.h)
- *
- * These macros for the Arduino MEGA do not include the two connected pins on Port J (D14, D15).
- * So we extend them here because these are the normal pins for Y_MIN and Y_MAX on RAMPS.
- * There are more PCI-enabled processor pins on Port J, but they are not connected to Arduino MEGA.
- */
-#if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)
-
-  #define digitalPinHasPCICR(p)   (WITHIN(p, 10, 15) || WITHIN(p, 50, 53) || WITHIN(p, 62, 69))
-
-  #undef  digitalPinToPCICR
-  #define digitalPinToPCICR(p)    (digitalPinHasPCICR(p) ? (&PCICR) : nullptr)
-
-  #undef  digitalPinToPCICRbit
-  #define digitalPinToPCICRbit(p) (WITHIN(p, 10, 13) || WITHIN(p, 50, 53) ? 0 : \
-                                   WITHIN(p, 14, 15) ? 1 : \
-                                   WITHIN(p, 62, 69) ? 2 : \
-                                   0)
-
-  #undef  digitalPinToPCMSK
-  #define digitalPinToPCMSK(p)    (WITHIN(p, 10, 13) || WITHIN(p, 50, 53) ? (&PCMSK0) : \
-                                   WITHIN(p, 14, 15) ? (&PCMSK1) : \
-                                   WITHIN(p, 62, 69) ? (&PCMSK2) : \
-                                   nullptr)
-
-  #undef  digitalPinToPCMSKbit
-  #define digitalPinToPCMSKbit(p) (WITHIN(p, 10, 13) ? ((p) - 6) : \
-                                   (p) == 14 || (p) == 51 ? 2 : \
-                                   (p) == 15 || (p) == 52 ? 1 : \
-                                   (p) == 50 ? 3 : \
-                                   (p) == 53 ? 0 : \
-                                   WITHIN(p, 62, 69) ? ((p) - 62) : \
-                                   0)
-
-#elif defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324A__) || \
-      defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega324PB__) || \
-      defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284__) || \
-      defined(__AVR_ATmega1284P__)
-
-  #define digitalPinHasPCICR(p)   WITHIN(p, 0, NUM_DIGITAL_PINS)
-
-#else
-
-  #error "Unsupported AVR variant!"
-
-#endif
-
-
-// Install Pin change interrupt for a pin. Can be called multiple times.
-void pciSetup(const int8_t pin) {
-  if (digitalPinHasPCICR(pin)) {
-    SBI(*digitalPinToPCMSK(pin), digitalPinToPCMSKbit(pin));  // enable pin
-    SBI(PCIFR, digitalPinToPCICRbit(pin)); // clear any outstanding interrupt
-    SBI(PCICR, digitalPinToPCICRbit(pin)); // enable interrupt for the group
-  }
-}
-
-// Handlers for pin change interrupts
-#ifdef PCINT0_vect
-  ISR(PCINT0_vect) { endstop_ISR(); }
-#endif
-
-#ifdef PCINT1_vect
-  ISR(PCINT1_vect, ISR_ALIASOF(PCINT0_vect));
-#endif
-
-#ifdef PCINT2_vect
-  ISR(PCINT2_vect, ISR_ALIASOF(PCINT0_vect));
-#endif
-
-#ifdef PCINT3_vect
-  ISR(PCINT3_vect, ISR_ALIASOF(PCINT0_vect));
-#endif
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  #if HAS_X_MAX
-    #if (digitalPinToInterrupt(X_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(X_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(X_MAX_PIN), "X_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(X_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_X_MIN
-    #if (digitalPinToInterrupt(X_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(X_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(X_MIN_PIN), "X_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(X_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Y_MAX
-    #if (digitalPinToInterrupt(Y_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Y_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Y_MAX_PIN), "Y_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Y_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Y_MIN
-    #if (digitalPinToInterrupt(Y_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Y_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Y_MIN_PIN), "Y_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Y_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Z_MAX
-    #if (digitalPinToInterrupt(Z_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z_MAX_PIN), "Z_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Z_MIN
-    #if (digitalPinToInterrupt(Z_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z_MIN_PIN), "Z_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_I_MAX
-    #if (digitalPinToInterrupt(I_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(I_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(I_MAX_PIN), "I_MAX_PIN is not interrupt-capable");
-      pciSetup(I_MAX_PIN);
-    #endif
-  #elif HAS_I_MIN
-    #if (digitalPinToInterrupt(I_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(I_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(I_MIN_PIN), "I_MIN_PIN is not interrupt-capable");
-      pciSetup(I_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_J_MAX
-    #if (digitalPinToInterrupt(J_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(J_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(J_MAX_PIN), "J_MAX_PIN is not interrupt-capable");
-      pciSetup(J_MAX_PIN);
-    #endif
-  #elif HAS_J_MIN
-    #if (digitalPinToInterrupt(J_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(J_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(J_MIN_PIN), "J_MIN_PIN is not interrupt-capable");
-      pciSetup(J_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_K_MAX
-    #if (digitalPinToInterrupt(K_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(K_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(K_MAX_PIN), "K_MAX_PIN is not interrupt-capable");
-      pciSetup(K_MAX_PIN);
-    #endif
-  #elif HAS_K_MIN
-    #if (digitalPinToInterrupt(K_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(K_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(K_MIN_PIN), "K_MIN_PIN is not interrupt-capable");
-      pciSetup(K_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_U_MAX
-    #if (digitalPinToInterrupt(U_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(U_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(U_MAX_PIN), "U_MAX_PIN is not interrupt-capable");
-      pciSetup(U_MAX_PIN);
-    #endif
-  #elif HAS_U_MIN
-    #if (digitalPinToInterrupt(U_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(U_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(U_MIN_PIN), "U_MIN_PIN is not interrupt-capable");
-      pciSetup(U_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_V_MAX
-    #if (digitalPinToInterrupt(V_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(V_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(V_MAX_PIN), "V_MAX_PIN is not interrupt-capable");
-      pciSetup(V_MAX_PIN);
-    #endif
-  #elif HAS_V_MIN
-    #if (digitalPinToInterrupt(V_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(V_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(V_MIN_PIN), "V_MIN_PIN is not interrupt-capable");
-      pciSetup(V_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_W_MAX
-    #if (digitalPinToInterrupt(W_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(W_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(W_MAX_PIN), "W_MAX_PIN is not interrupt-capable");
-      pciSetup(W_MAX_PIN);
-    #endif
-  #elif HAS_W_MIN
-    #if (digitalPinToInterrupt(W_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(W_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(W_MIN_PIN), "W_MIN_PIN is not interrupt-capable");
-      pciSetup(W_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_X2_MAX
-    #if (digitalPinToInterrupt(X2_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(X2_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(X2_MAX_PIN), "X2_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(X2_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_X2_MIN
-    #if (digitalPinToInterrupt(X2_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(X2_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(X2_MIN_PIN), "X2_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(X2_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Y2_MAX
-    #if (digitalPinToInterrupt(Y2_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Y2_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Y2_MAX_PIN), "Y2_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Y2_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Y2_MIN
-    #if (digitalPinToInterrupt(Y2_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Y2_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Y2_MIN_PIN), "Y2_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Y2_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Z2_MAX
-    #if (digitalPinToInterrupt(Z2_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z2_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z2_MAX_PIN), "Z2_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z2_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Z2_MIN
-    #if (digitalPinToInterrupt(Z2_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z2_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z2_MIN_PIN), "Z2_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z2_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Z3_MAX
-    #if (digitalPinToInterrupt(Z3_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z3_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z3_MAX_PIN), "Z3_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z3_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Z3_MIN
-    #if (digitalPinToInterrupt(Z3_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z3_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z3_MIN_PIN), "Z3_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z3_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Z4_MAX
-    #if (digitalPinToInterrupt(Z4_MAX_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z4_MAX_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z4_MAX_PIN), "Z4_MAX_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z4_MAX_PIN);
-    #endif
-  #endif
-  #if HAS_Z4_MIN
-    #if (digitalPinToInterrupt(Z4_MIN_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z4_MIN_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z4_MIN_PIN), "Z4_MIN_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z4_MIN_PIN);
-    #endif
-  #endif
-  #if HAS_Z_MIN_PROBE_PIN
-    #if (digitalPinToInterrupt(Z_MIN_PROBE_PIN) != NOT_AN_INTERRUPT)
-      _ATTACH(Z_MIN_PROBE_PIN);
-    #else
-      static_assert(digitalPinHasPCICR(Z_MIN_PROBE_PIN), "Z_MIN_PROBE_PIN is not interrupt-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue.");
-      pciSetup(Z_MIN_PROBE_PIN);
-    #endif
-  #endif
-
-  // If we arrive here without raising an assertion, each pin has either an EXT-interrupt or a PCI.
-}
diff --git a/Marlin/src/HAL/AVR/fast_pwm.cpp b/Marlin/src/HAL/AVR/fast_pwm.cpp
deleted file mode 100644
index 0a38417..0000000
--- a/Marlin/src/HAL/AVR/fast_pwm.cpp
+++ /dev/null
@@ -1,222 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __AVR__
-
-#include "../../inc/MarlinConfig.h"
-
-struct Timer {
-  volatile uint8_t* TCCRnQ[3];  // max 3 TCCR registers per timer
-  volatile uint16_t* OCRnQ[3];  // max 3 OCR registers per timer
-  volatile uint16_t* ICRn;      // max 1 ICR register per timer
-  uint8_t n;                    // the timer number [0->5]
-  uint8_t q;                    // the timer output [0->2] (A->C)
-  bool isPWM;                   // True if pin is a "hardware timer"
-  bool isProtected;             // True if timer is protected
-};
-
-// Macros for the Timer structure
-#define _SET_WGMnQ(T, V) do{ \
-    *(T.TCCRnQ)[0] = (*(T.TCCRnQ)[0] & ~(0x3 << 0)) | (( int(V)       & 0x3) << 0); \
-    *(T.TCCRnQ)[1] = (*(T.TCCRnQ)[1] & ~(0x3 << 3)) | (((int(V) >> 2) & 0x3) << 3); \
-  }while(0)
-
-// Set TCCR CS bits
-#define _SET_CSn(T, V) (*(T.TCCRnQ)[1] = (*(T.TCCRnQ[1]) & ~(0x7 << 0)) | ((int(V) & 0x7) << 0))
-
-// Set TCCR COM bits
-#define _SET_COMnQ(T, Q, V) (*(T.TCCRnQ)[0] = (*(T.TCCRnQ)[0] & ~(0x3 << (6-2*(Q)))) | (int(V) << (6-2*(Q))))
-
-// Set OCRnQ register
-#define _SET_OCRnQ(T, Q, V) (*(T.OCRnQ)[Q] = int(V) & 0xFFFF)
-
-// Set ICRn register (one per timer)
-#define _SET_ICRn(T, V) (*(T.ICRn) = int(V) & 0xFFFF)
-
-/**
- * Return a Timer struct describing a pin's timer.
- */
-const Timer get_pwm_timer(const pin_t pin) {
-
-  uint8_t q = 0;
-
-  switch (digitalPinToTimer(pin)) {
-    #ifdef TCCR0A
-      IF_DISABLED(AVR_AT90USB1286_FAMILY, case TIMER0A:)
-    #endif
-    #ifdef TCCR1A
-      case TIMER1A: case TIMER1B:
-    #endif
-
-    break;    // Protect reserved timers (TIMER0 & TIMER1)
-
-    #ifdef TCCR0A
-      case TIMER0B:   // Protected timer, but allow setting the duty cycle on OCR0B for pin D4 only
-        return Timer({ { &TCCR0A, nullptr, nullptr }, { (uint16_t*)&OCR0A, (uint16_t*)&OCR0B, nullptr }, nullptr, 0, 1, true, true });
-    #endif
-
-    #if HAS_TCCR2
-      case TIMER2:
-        return Timer({ { &TCCR2, nullptr, nullptr }, { (uint16_t*)&OCR2, nullptr, nullptr }, nullptr, 2, 0, true, false });
-    #elif ENABLED(USE_OCR2A_AS_TOP)
-      case TIMER2A: break; // Protect TIMER2A since its OCR is used by TIMER2B
-      case TIMER2B:
-        return Timer({ { &TCCR2A, &TCCR2B, nullptr }, { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, nullptr }, nullptr, 2, 1, true, false });
-    #elif defined(TCCR2A)
-      case TIMER2B: ++q; case TIMER2A:
-        return Timer({ { &TCCR2A, &TCCR2B, nullptr }, { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, nullptr }, nullptr, 2, q, true, false });
-    #endif
-
-    #ifdef OCR3C
-      case TIMER3C: ++q; case TIMER3B: ++q; case TIMER3A:
-        return Timer({ { &TCCR3A, &TCCR3B, &TCCR3C }, { &OCR3A, &OCR3B, &OCR3C  }, &ICR3, 3, q, true, false });
-    #elif defined(OCR3B)
-      case TIMER3B: ++q; case TIMER3A:
-        return Timer({ { &TCCR3A, &TCCR3B, nullptr }, { &OCR3A, &OCR3B, nullptr }, &ICR3, 3, q, true, false });
-    #endif
-
-    #ifdef TCCR4A
-      case TIMER4C: ++q; case TIMER4B: ++q; case TIMER4A:
-        return Timer({ { &TCCR4A, &TCCR4B, &TCCR4C }, { &OCR4A, &OCR4B, &OCR4C }, &ICR4, 4, q, true, false });
-    #endif
-
-    #ifdef TCCR5A
-      case TIMER5C: ++q; case TIMER5B: ++q; case TIMER5A:
-        return Timer({ { &TCCR5A, &TCCR5B, &TCCR5C }, { &OCR5A, &OCR5B, &OCR5C }, &ICR5, 5, q, true, false });
-    #endif
-  }
-
-  return Timer();
-}
-
-void MarlinHAL::set_pwm_frequency(const pin_t pin, const uint16_t f_desired) {
-  const Timer timer = get_pwm_timer(pin);
-  if (timer.isProtected || !timer.isPWM) return; // Don't proceed if protected timer or not recognized
-
-  const bool is_timer2 = timer.n == 2;
-  const uint16_t maxtop = is_timer2 ? 0xFF : 0xFFFF;
-
-  uint16_t res = 0xFF;        // resolution (TOP value)
-  uint8_t j = CS_NONE;        // prescaler index
-  uint8_t wgm = WGM_PWM_PC_8; // waveform generation mode
-
-  // Calculating the prescaler and resolution to use to achieve closest frequency
-  if (f_desired != 0) {
-    constexpr uint16_t prescaler[] = { 1, 8, (32), 64, (128), 256, 1024 };  // (*) are Timer 2 only
-    uint16_t f = (F_CPU) / (2 * 1024 * maxtop) + 1;           // Start with the lowest non-zero frequency achievable (1 or 31)
-
-    LOOP_L_N(i, COUNT(prescaler)) {                           // Loop through all prescaler values
-      const uint16_t p = prescaler[i];
-      uint16_t res_fast_temp, res_pc_temp;
-      if (is_timer2) {
-        #if ENABLED(USE_OCR2A_AS_TOP)                         // No resolution calculation for TIMER2 unless enabled USE_OCR2A_AS_TOP
-          const uint16_t rft = (F_CPU) / (p * f_desired);
-          res_fast_temp = rft - 1;
-          res_pc_temp = rft / 2;
-        #else
-          res_fast_temp = res_pc_temp = maxtop;
-        #endif
-      }
-      else {
-        if (p == 32 || p == 128) continue;                    // Skip TIMER2 specific prescalers when not TIMER2
-        const uint16_t rft = (F_CPU) / (p * f_desired);
-        res_fast_temp = rft - 1;
-        res_pc_temp = rft / 2;
-      }
-
-      LIMIT(res_fast_temp, 1U, maxtop);
-      LIMIT(res_pc_temp, 1U, maxtop);
-
-      // Calculate frequencies of test prescaler and resolution values
-      const uint32_t f_diff      = _MAX(f, f_desired) - _MIN(f, f_desired),
-                     f_fast_temp = (F_CPU) / (p * (1 + res_fast_temp)),
-                     f_fast_diff = _MAX(f_fast_temp, f_desired) - _MIN(f_fast_temp, f_desired),
-                     f_pc_temp   = (F_CPU) / (2 * p * res_pc_temp),
-                     f_pc_diff   = _MAX(f_pc_temp, f_desired) - _MIN(f_pc_temp, f_desired);
-
-      if (f_fast_diff < f_diff && f_fast_diff <= f_pc_diff) { // FAST values are closest to desired f
-        // Set the Wave Generation Mode to FAST PWM
-        wgm = is_timer2 ? uint8_t(TERN(USE_OCR2A_AS_TOP, WGM2_FAST_PWM_OCR2A, WGM2_FAST_PWM)) : uint8_t(WGM_FAST_PWM_ICRn);
-        // Remember this combination
-        f = f_fast_temp; res = res_fast_temp; j = i + 1;
-      }
-      else if (f_pc_diff < f_diff) {                          // PHASE CORRECT values are closes to desired f
-        // Set the Wave Generation Mode to PWM PHASE CORRECT
-        wgm = is_timer2 ? uint8_t(TERN(USE_OCR2A_AS_TOP, WGM2_PWM_PC_OCR2A, WGM2_PWM_PC)) : uint8_t(WGM_PWM_PC_ICRn);
-        f = f_pc_temp; res = res_pc_temp; j = i + 1;
-      }
-    }
-  }
-
-  _SET_WGMnQ(timer, wgm);
-  _SET_CSn(timer, j);
-
-  if (is_timer2) {
-    TERN_(USE_OCR2A_AS_TOP, _SET_OCRnQ(timer, 0, res)); // Set OCR2A value (TOP) = res
-  }
-  else
-    _SET_ICRn(timer, res);                              // Set ICRn value (TOP) = res
-}
-
-void MarlinHAL::set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size/*=255*/, const bool invert/*=false*/) {
-  // If v is 0 or v_size (max), digitalWrite to LOW or HIGH.
-  // Note that digitalWrite also disables PWM output for us (sets COM bit to 0)
-  if (v == 0)
-    digitalWrite(pin, invert);
-  else if (v == v_size)
-    digitalWrite(pin, !invert);
-  else {
-    const Timer timer = get_pwm_timer(pin);
-    if (timer.isPWM) {
-      if (timer.n == 0) {
-        _SET_COMnQ(timer, timer.q, COM_CLEAR_SET);  // Only allow a TIMER0B select...
-        _SET_OCRnQ(timer, timer.q, v);              // ...and OCR0B duty update. For output pin D4 no frequency changes are permitted.
-      }
-      else if (!timer.isProtected) {
-        const uint16_t top = timer.n == 2 ? TERN(USE_OCR2A_AS_TOP, *timer.OCRnQ[0], 255) : *timer.ICRn;
-        _SET_COMnQ(timer, SUM_TERN(HAS_TCCR2, timer.q, timer.q == 2), COM_CLEAR_SET + invert);   // COM20 is on bit 4 of TCCR2, so +1 for q==2
-        _SET_OCRnQ(timer, timer.q, uint16_t(uint32_t(v) * top / v_size)); // Scale 8/16-bit v to top value
-      }
-    }
-    else
-      digitalWrite(pin, v < v_size / 2 ? LOW : HIGH);
-  }
-}
-
-void MarlinHAL::init_pwm_timers() {
-  // Init some timer frequencies to a default 1KHz
-  const pin_t pwm_pin[] = {
-    #ifdef __AVR_ATmega2560__
-      10, 5, 6, 46
-    #elif defined(__AVR_ATmega1280__)
-      12, 31
-    #elif defined(__AVR_ATmega644__) || defined(__AVR_ATmega1284__)
-      15, 6
-    #elif defined(__AVR_AT90USB1286__) || defined(__AVR_mega64) || defined(__AVR_mega128)
-      16, 24
-    #endif
-  };
-
-  LOOP_L_N(i, COUNT(pwm_pin))
-    set_pwm_frequency(pwm_pin[i], 1000);
-}
-
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/fastio.cpp b/Marlin/src/HAL/AVR/fastio.cpp
deleted file mode 100644
index 5c6ef18..0000000
--- a/Marlin/src/HAL/AVR/fastio.cpp
+++ /dev/null
@@ -1,288 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Fast I/O for extended pins
- */
-
-#ifdef __AVR__
-
-#include "fastio.h"
-
-#ifdef FASTIO_EXT_START
-
-#include "../shared/Marduino.h"
-
-#define _IS_EXT(P) WITHIN(P, FASTIO_EXT_START, FASTIO_EXT_END)
-
-void extDigitalWrite(const int8_t pin, const uint8_t state) {
-  #define _WCASE(N) case N: WRITE(N, state); break
-  switch (pin) {
-    default: digitalWrite(pin, state);
-    #if _IS_EXT(70)
-      _WCASE(70);
-    #endif
-    #if _IS_EXT(71)
-      _WCASE(71);
-    #endif
-    #if _IS_EXT(72)
-      _WCASE(72);
-    #endif
-    #if _IS_EXT(73)
-      _WCASE(73);
-    #endif
-    #if _IS_EXT(74)
-      _WCASE(74);
-    #endif
-    #if _IS_EXT(75)
-      _WCASE(75);
-    #endif
-    #if _IS_EXT(76)
-      _WCASE(76);
-    #endif
-    #if _IS_EXT(77)
-      _WCASE(77);
-    #endif
-    #if _IS_EXT(78)
-      _WCASE(78);
-    #endif
-    #if _IS_EXT(79)
-      _WCASE(79);
-    #endif
-    #if _IS_EXT(80)
-      _WCASE(80);
-    #endif
-    #if _IS_EXT(81)
-      _WCASE(81);
-    #endif
-    #if _IS_EXT(82)
-      _WCASE(82);
-    #endif
-    #if _IS_EXT(83)
-      _WCASE(83);
-    #endif
-    #if _IS_EXT(84)
-      _WCASE(84);
-    #endif
-    #if _IS_EXT(85)
-      _WCASE(85);
-    #endif
-    #if _IS_EXT(86)
-      _WCASE(86);
-    #endif
-    #if _IS_EXT(87)
-      _WCASE(87);
-    #endif
-    #if _IS_EXT(88)
-      _WCASE(88);
-    #endif
-    #if _IS_EXT(89)
-      _WCASE(89);
-    #endif
-    #if _IS_EXT(90)
-      _WCASE(90);
-    #endif
-    #if _IS_EXT(91)
-      _WCASE(91);
-    #endif
-    #if _IS_EXT(92)
-      _WCASE(92);
-    #endif
-    #if _IS_EXT(93)
-      _WCASE(93);
-    #endif
-    #if _IS_EXT(94)
-      _WCASE(94);
-    #endif
-    #if _IS_EXT(95)
-      _WCASE(95);
-    #endif
-    #if _IS_EXT(96)
-      _WCASE(96);
-    #endif
-    #if _IS_EXT(97)
-      _WCASE(97);
-    #endif
-    #if _IS_EXT(98)
-      _WCASE(98);
-    #endif
-    #if _IS_EXT(99)
-      _WCASE(99);
-    #endif
-    #if _IS_EXT(100)
-      _WCASE(100);
-    #endif
-  }
-}
-
-uint8_t extDigitalRead(const int8_t pin) {
-  #define _RCASE(N) case N: return READ(N)
-  switch (pin) {
-    default: return digitalRead(pin);
-    #if _IS_EXT(70)
-      _RCASE(70);
-    #endif
-    #if _IS_EXT(71)
-      _RCASE(71);
-    #endif
-    #if _IS_EXT(72)
-      _RCASE(72);
-    #endif
-    #if _IS_EXT(73)
-      _RCASE(73);
-    #endif
-    #if _IS_EXT(74)
-      _RCASE(74);
-    #endif
-    #if _IS_EXT(75)
-      _RCASE(75);
-    #endif
-    #if _IS_EXT(76)
-      _RCASE(76);
-    #endif
-    #if _IS_EXT(77)
-      _RCASE(77);
-    #endif
-    #if _IS_EXT(78)
-      _RCASE(78);
-    #endif
-    #if _IS_EXT(79)
-      _RCASE(79);
-    #endif
-    #if _IS_EXT(80)
-      _RCASE(80);
-    #endif
-    #if _IS_EXT(81)
-      _RCASE(81);
-    #endif
-    #if _IS_EXT(82)
-      _RCASE(82);
-    #endif
-    #if _IS_EXT(83)
-      _RCASE(83);
-    #endif
-    #if _IS_EXT(84)
-      _RCASE(84);
-    #endif
-    #if _IS_EXT(85)
-      _RCASE(85);
-    #endif
-    #if _IS_EXT(86)
-      _RCASE(86);
-    #endif
-    #if _IS_EXT(87)
-      _RCASE(87);
-    #endif
-    #if _IS_EXT(88)
-      _RCASE(88);
-    #endif
-    #if _IS_EXT(89)
-      _RCASE(89);
-    #endif
-    #if _IS_EXT(90)
-      _RCASE(90);
-    #endif
-    #if _IS_EXT(91)
-      _RCASE(91);
-    #endif
-    #if _IS_EXT(92)
-      _RCASE(92);
-    #endif
-    #if _IS_EXT(93)
-      _RCASE(93);
-    #endif
-    #if _IS_EXT(94)
-      _RCASE(94);
-    #endif
-    #if _IS_EXT(95)
-      _RCASE(95);
-    #endif
-    #if _IS_EXT(96)
-      _RCASE(96);
-    #endif
-    #if _IS_EXT(97)
-      _RCASE(97);
-    #endif
-    #if _IS_EXT(98)
-      _RCASE(98);
-    #endif
-    #if _IS_EXT(99)
-      _RCASE(99);
-    #endif
-    #if _IS_EXT(100)
-      _RCASE(100);
-    #endif
-  }
-}
-
-#if 0
-/**
- * Set Timer 5 PWM frequency in Hz, from 3.8Hz up to ~16MHz
- * with a minimum resolution of 100 steps.
- *
- * DC values -1.0 to 1.0. Negative duty cycle inverts the pulse.
- */
-uint16_t set_pwm_frequency_hz(const_float_t hz, const float dca, const float dcb, const float dcc) {
-  float count = 0;
-  if (hz > 0 && (dca || dcb || dcc)) {
-    count = float(F_CPU) / hz;            // 1x prescaler, TOP for 16MHz base freq.
-    uint16_t prescaler;                   // Range of 30.5Hz (65535) 64.5kHz (>31)
-
-         if (count >= 255. * 256.) { prescaler = 1024; SET_CS(5, PRESCALER_1024); }
-    else if (count >= 255. * 64.)  { prescaler = 256;  SET_CS(5,  PRESCALER_256); }
-    else if (count >= 255. * 8.)   { prescaler = 64;   SET_CS(5,   PRESCALER_64); }
-    else if (count >= 255.)        { prescaler = 8;    SET_CS(5,    PRESCALER_8); }
-    else                           { prescaler = 1;    SET_CS(5,    PRESCALER_1); }
-
-    count /= float(prescaler);
-    const float pwm_top = round(count);   // Get the rounded count
-
-    ICR5 = (uint16_t)pwm_top - 1;         // Subtract 1 for TOP
-    OCR5A = pwm_top * ABS(dca);           // Update and scale DCs
-    OCR5B = pwm_top * ABS(dcb);
-    OCR5C = pwm_top * ABS(dcc);
-    _SET_COM(5, A, dca ? (dca < 0 ? COM_SET_CLEAR : COM_CLEAR_SET) : COM_NORMAL); // Set compare modes
-    _SET_COM(5, B, dcb ? (dcb < 0 ? COM_SET_CLEAR : COM_CLEAR_SET) : COM_NORMAL);
-    _SET_COM(5, C, dcc ? (dcc < 0 ? COM_SET_CLEAR : COM_CLEAR_SET) : COM_NORMAL);
-
-    SET_WGM(5, FAST_PWM_ICRn);            // Fast PWM with ICR5 as TOP
-
-    //SERIAL_ECHOLNPGM("Timer 5 Settings:");
-    //SERIAL_ECHOLNPGM("  Prescaler=", prescaler);
-    //SERIAL_ECHOLNPGM("        TOP=", ICR5);
-    //SERIAL_ECHOLNPGM("      OCR5A=", OCR5A);
-    //SERIAL_ECHOLNPGM("      OCR5B=", OCR5B);
-    //SERIAL_ECHOLNPGM("      OCR5C=", OCR5C);
-  }
-  else {
-    // Restore the default for Timer 5
-    SET_WGM(5, PWM_PC_8);                 // PWM 8-bit (Phase Correct)
-    SET_COMS(5, NORMAL, NORMAL, NORMAL);  // Do nothing
-    SET_CS(5, PRESCALER_64);              // 16MHz / 64 = 250kHz
-    OCR5A = OCR5B = OCR5C = 0;
-  }
-  return round(count);
-}
-#endif
-
-#endif // FASTIO_EXT_START
-#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/fastio.h b/Marlin/src/HAL/AVR/fastio.h
deleted file mode 100644
index 51d3b31..0000000
--- a/Marlin/src/HAL/AVR/fastio.h
+++ /dev/null
@@ -1,350 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for AVR
- * Use direct port manipulation to save scads of processor time.
- * Contributed by Triffid_Hunter and modified by Kliment, thinkyhead, Bob-the-Kuhn, et.al.
- */
-
-#include <avr/io.h>
-
-#if defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1286P__) || defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB646P__) || defined(__AVR_AT90USB647__)
-  #define AVR_AT90USB1286_FAMILY 1
-#elif defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__)
-  #define AVR_ATmega1284_FAMILY 1
-#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-  #define AVR_ATmega2560_FAMILY 1
-#elif defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)
-  #define AVR_ATmega2561_FAMILY 1
-#elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__)
-  #define AVR_ATmega328_FAMILY 1
-#endif
-
-/**
- * Include Ports and Functions
- */
-#if AVR_ATmega328_FAMILY
-  #include "fastio/fastio_168.h"
-#elif AVR_ATmega1284_FAMILY
-  #include "fastio/fastio_644.h"
-#elif AVR_ATmega2560_FAMILY
-  #include "fastio/fastio_1280.h"
-#elif AVR_AT90USB1286_FAMILY
-  #include "fastio/fastio_AT90USB.h"
-#elif AVR_ATmega2561_FAMILY
-  #include "fastio/fastio_1281.h"
-#else
-  #error "No FastIO definition for the selected AVR Board."
-#endif
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(PIN); WRITE(PIN, HIGH); WRITE(PIN, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/cpp/Stringification.html
- */
-
-#define _READ(IO)             TEST(DIO ## IO ## _RPORT, DIO ## IO ## _PIN)
-
-#define _WRITE_NC(IO,V) do{ \
-  if (V) SBI(DIO ## IO ## _WPORT, DIO ## IO ## _PIN); \
-  else   CBI(DIO ## IO ## _WPORT, DIO ## IO ## _PIN); \
-}while(0)
-
-#define _WRITE_C(IO,V) do{ \
-  uint8_t port_bits = DIO ## IO ## _WPORT;                  /* Get a mask from the current port bits */ \
-  if (V) port_bits = ~port_bits;                            /* For setting bits, invert the mask */ \
-  DIO ## IO ## _RPORT = port_bits & _BV(DIO ## IO ## _PIN); /* Atomically toggle the output port bits */ \
-}while(0)
-
-#define _WRITE(IO,V)          do{ if (&(DIO ## IO ## _RPORT) < (uint8_t*)0x100) _WRITE_NC(IO,V); else _WRITE_C(IO,V); }while(0)
-
-#define _TOGGLE(IO)           (DIO ## IO ## _RPORT = _BV(DIO ## IO ## _PIN))
-
-#define _SET_INPUT(IO)        CBI(DIO ## IO ## _DDR, DIO ## IO ## _PIN)
-#define _SET_OUTPUT(IO)       SBI(DIO ## IO ## _DDR, DIO ## IO ## _PIN)
-
-#define _IS_INPUT(IO)         !TEST(DIO ## IO ## _DDR, DIO ## IO ## _PIN)
-#define _IS_OUTPUT(IO)        TEST(DIO ## IO ## _DDR, DIO ## IO ## _PIN)
-
-// digitalRead/Write wrappers
-#ifdef FASTIO_EXT_START
-  void extDigitalWrite(const int8_t pin, const uint8_t state);
-  uint8_t extDigitalRead(const int8_t pin);
-#else
-  #define extDigitalWrite(IO,V) digitalWrite(IO,V)
-  #define extDigitalRead(IO)    digitalRead(IO)
-#endif
-
-#define READ(IO)              _READ(IO)
-#define WRITE(IO,V)           _WRITE(IO,V)
-#define TOGGLE(IO)            _TOGGLE(IO)
-
-#define SET_INPUT(IO)         _SET_INPUT(IO)
-#define SET_INPUT_PULLUP(IO)  do{ _SET_INPUT(IO); _WRITE(IO, HIGH); }while(0)
-#define SET_INPUT_PULLDOWN    SET_INPUT
-#define SET_OUTPUT(IO)        _SET_OUTPUT(IO)
-#define SET_PWM               SET_OUTPUT
-
-#define IS_INPUT(IO)          _IS_INPUT(IO)
-#define IS_OUTPUT(IO)         _IS_OUTPUT(IO)
-
-#define OUT_WRITE(IO,V)       do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-/**
- * Timer and Interrupt Control
- */
-
-// Waveform Generation Modes
-enum WaveGenMode : uint8_t {
-  WGM_NORMAL,          //  0
-  WGM_PWM_PC_8,        //  1
-  WGM_PWM_PC_9,        //  2
-  WGM_PWM_PC_10,       //  3
-  WGM_CTC_OCRnA,       //  4  COM OCnx
-  WGM_FAST_PWM_8,      //  5
-  WGM_FAST_PWM_9,      //  6
-  WGM_FAST_PWM_10,     //  7
-  WGM_PWM_PC_FC_ICRn,  //  8
-  WGM_PWM_PC_FC_OCRnA, //  9  COM OCnA
-  WGM_PWM_PC_ICRn,     // 10
-  WGM_PWM_PC_OCRnA,    // 11  COM OCnA
-  WGM_CTC_ICRn,        // 12  COM OCnx
-  WGM_reserved,        // 13
-  WGM_FAST_PWM_ICRn,   // 14  COM OCnA
-  WGM_FAST_PWM_OCRnA   // 15  COM OCnA
-};
-
-// Wavefore Generation Modes (Timer 2 only)
-enum WaveGenMode2 : uint8_t {
-  WGM2_NORMAL,         // 0
-  WGM2_PWM_PC,         // 1
-  WGM2_CTC_OCR2A,      // 2
-  WGM2_FAST_PWM,       // 3
-  WGM2_reserved_1,     // 4
-  WGM2_PWM_PC_OCR2A,   // 5
-  WGM2_reserved_2,     // 6
-  WGM2_FAST_PWM_OCR2A, // 7
-};
-
-// Compare Modes
-enum CompareMode : uint8_t {
-  COM_NORMAL,          //  0
-  COM_TOGGLE,          //  1  Non-PWM: OCnx ... Both PWM (WGM 9,11,14,15): OCnA only ... else NORMAL
-  COM_CLEAR_SET,       //  2  Non-PWM: OCnx ... Fast PWM: OCnx/Bottom ... PF-FC: OCnx Up/Down
-  COM_SET_CLEAR        //  3  Non-PWM: OCnx ... Fast PWM: OCnx/Bottom ... PF-FC: OCnx Up/Down
-};
-
-// Clock Sources
-enum ClockSource : uint8_t {
-  CS_NONE,             //  0
-  CS_PRESCALER_1,      //  1
-  CS_PRESCALER_8,      //  2
-  CS_PRESCALER_64,     //  3
-  CS_PRESCALER_256,    //  4
-  CS_PRESCALER_1024,   //  5
-  CS_EXT_FALLING,      //  6
-  CS_EXT_RISING        //  7
-};
-
-// Clock Sources (Timer 2 only)
-enum ClockSource2 : uint8_t {
-  CS2_NONE,            //  0
-  CS2_PRESCALER_1,     //  1
-  CS2_PRESCALER_8,     //  2
-  CS2_PRESCALER_32,    //  3
-  CS2_PRESCALER_64,    //  4
-  CS2_PRESCALER_128,   //  5
-  CS2_PRESCALER_256,   //  6
-  CS2_PRESCALER_1024   //  7
-};
-
-// Get interrupt bits in an orderly way
-// Ex: cs = GET_CS(0); coma1 = GET_COM(A,1);
-#define GET_WGM(T)   (((TCCR##T##A >> WGM##T##0) & 0x3) | ((TCCR##T##B >> WGM##T##2 << 2) & 0xC))
-#define GET_CS(T)    ((TCCR##T##B >> CS##T##0) & 0x7)
-#define GET_COM(T,Q) ((TCCR##T##Q >> COM##T##Q##0) & 0x3)
-#define GET_COMA(T)  GET_COM(T,A)
-#define GET_COMB(T)  GET_COM(T,B)
-#define GET_COMC(T)  GET_COM(T,C)
-#define GET_ICNC(T)  (!!(TCCR##T##B & _BV(ICNC##T)))
-#define GET_ICES(T)  (!!(TCCR##T##B & _BV(ICES##T)))
-#define GET_FOC(T,Q) (!!(TCCR##T##C & _BV(FOC##T##Q)))
-#define GET_FOCA(T)  GET_FOC(T,A)
-#define GET_FOCB(T)  GET_FOC(T,B)
-#define GET_FOCC(T)  GET_FOC(T,C)
-
-// Set Wave Generation Mode bits
-// Ex: SET_WGM(5,CTC_ICRn);
-#define _SET_WGM(T,V) do{ \
-    TCCR##T##A = (TCCR##T##A & ~(0x3 << WGM##T##0)) | (( int(V)       & 0x3) << WGM##T##0); \
-    TCCR##T##B = (TCCR##T##B & ~(0x3 << WGM##T##2)) | (((int(V) >> 2) & 0x3) << WGM##T##2); \
-  }while(0)
-#define SET_WGM(T,V) _SET_WGM(T,WGM_##V)
-
-// Set Clock Select bits
-// Ex: SET_CS3(PRESCALER_64);
-#ifdef TCCR2
-  #define HAS_TCCR2 1
-#endif
-#define _SET_CS(T,V) (TCCR##T##B = (TCCR##T##B & ~(0x7 << CS##T##0)) | ((int(V) & 0x7) << CS##T##0))
-#define _SET_CS0(V) _SET_CS(0,V)
-#define _SET_CS1(V) _SET_CS(1,V)
-#define _SET_CS3(V) _SET_CS(3,V)
-#define _SET_CS4(V) _SET_CS(4,V)
-#define _SET_CS5(V) _SET_CS(5,V)
-#define SET_CS0(V) _SET_CS0(CS_##V)
-#define SET_CS1(V) _SET_CS1(CS_##V)
-
-#if HAS_TCCR2
-  #define _SET_CS2(V) (TCCR2 = (TCCR2 & ~(0x7 << CS20)) | (int(V) << CS20))
-  #define SET_CS2(V) _SET_CS2(CS2_##V)
-#else
-  #define _SET_CS2(V) _SET_CS(2,V)
-  #define SET_CS2(V) _SET_CS2(CS_##V)
-#endif
-
-#define SET_CS3(V) _SET_CS3(CS_##V)
-#define SET_CS4(V) _SET_CS4(CS_##V)
-#define SET_CS5(V) _SET_CS5(CS_##V)
-#define SET_CS(T,V) SET_CS##T(V)
-
-// Set Compare Mode bits
-// Ex: SET_COMS(4,CLEAR_SET,CLEAR_SET,CLEAR_SET);
-#define _SET_COM(T,Q,V) (TCCR##T##Q = (TCCR##T##Q & ~(0x3 << COM##T##Q##0)) | (int(V) << COM##T##Q##0))
-#define SET_COM(T,Q,V) _SET_COM(T,Q,COM_##V)
-#define SET_COMA(T,V) SET_COM(T,A,V)
-#define SET_COMB(T,V) SET_COM(T,B,V)
-#define SET_COMC(T,V) SET_COM(T,C,V)
-#define SET_COMS(T,V1,V2,V3) do{ SET_COMA(T,V1); SET_COMB(T,V2); SET_COMC(T,V3); }while(0)
-
-// Set Noise Canceler bit
-// Ex: SET_ICNC(2,1)
-#define SET_ICNC(T,V) (TCCR##T##B = (V) ? TCCR##T##B | _BV(ICNC##T) : TCCR##T##B & ~_BV(ICNC##T))
-
-// Set Input Capture Edge Select bit
-// Ex: SET_ICES(5,0)
-#define SET_ICES(T,V) (TCCR##T##B = (V) ? TCCR##T##B | _BV(ICES##T) : TCCR##T##B & ~_BV(ICES##T))
-
-// Set Force Output Compare bit
-// Ex: SET_FOC(3,A,1)
-#define SET_FOC(T,Q,V) (TCCR##T##C = (V) ? TCCR##T##C | _BV(FOC##T##Q) : TCCR##T##C & ~_BV(FOC##T##Q))
-#define SET_FOCA(T,V) SET_FOC(T,A,V)
-#define SET_FOCB(T,V) SET_FOC(T,B,V)
-#define SET_FOCC(T,V) SET_FOC(T,C,V)
-
-#if 0
-
-/**
- * PWM availability macros
- */
-
-// Determine which hardware PWMs are already in use
-#define _PWM_CHK_FAN_B(P) (P == E0_AUTO_FAN_PIN || P == E1_AUTO_FAN_PIN || P == E2_AUTO_FAN_PIN || P == E3_AUTO_FAN_PIN || P == E4_AUTO_FAN_PIN || P == E5_AUTO_FAN_PIN || P == E6_AUTO_FAN_PIN || P == E7_AUTO_FAN_PIN || P == CHAMBER_AUTO_FAN_PIN || P == COOLER_AUTO_FAN_PIN)
-#if PIN_EXISTS(CONTROLLER_FAN)
-  #define PWM_CHK_FAN_B(P) (_PWM_CHK_FAN_B(P) || P == CONTROLLER_FAN_PIN)
-#else
-  #define PWM_CHK_FAN_B(P) _PWM_CHK_FAN_B(P)
-#endif
-
-#if ANY_PIN(FAN, FAN1, FAN2, FAN3, FAN4, FAN5, FAN6, FAN7)
-  #if PIN_EXISTS(FAN7)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN || P == FAN3_PIN || P == FAN4_PIN || P == FAN5_PIN || P == FAN6_PIN || P == FAN7_PIN)
-  #elif PIN_EXISTS(FAN6)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN || P == FAN3_PIN || P == FAN4_PIN || P == FAN5_PIN || P == FAN6_PIN)
-  #elif PIN_EXISTS(FAN5)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN || P == FAN3_PIN || P == FAN4_PIN || P == FAN5_PIN)
-  #elif PIN_EXISTS(FAN4)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN || P == FAN3_PIN || P == FAN4_PIN)
-  #elif PIN_EXISTS(FAN3)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN || P == FAN3_PIN)
-  #elif PIN_EXISTS(FAN2)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN || P == FAN2_PIN)
-  #elif PIN_EXISTS(FAN1)
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN || P == FAN1_PIN)
-  #else
-    #define PWM_CHK_FAN_A(P) (P == FAN0_PIN)
-  #endif
-#else
-  #define PWM_CHK_FAN_A(P) false
-#endif
-
-#if HAS_MOTOR_CURRENT_PWM
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-    #define PWM_CHK_MOTOR_CURRENT(P) (P == MOTOR_CURRENT_PWM_E || P == MOTOR_CURRENT_PWM_Z || P == MOTOR_CURRENT_PWM_XY)
-  #elif PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-    #define PWM_CHK_MOTOR_CURRENT(P) (P == MOTOR_CURRENT_PWM_E || P == MOTOR_CURRENT_PWM_Z)
-  #else
-    #define PWM_CHK_MOTOR_CURRENT(P) (P == MOTOR_CURRENT_PWM_E)
-  #endif
-#else
-  #define PWM_CHK_MOTOR_CURRENT(P) false
-#endif
-
-#ifdef NUM_SERVOS
-  #if AVR_ATmega2560_FAMILY
-    #define PWM_CHK_SERVO(P) (P == 5 || (NUM_SERVOS > 12 && P == 6) || (NUM_SERVOS > 24 && P == 46))  // PWMS 3A, 4A & 5A
-  #elif AVR_ATmega2561_FAMILY
-    #define PWM_CHK_SERVO(P)   (P == 5)  // PWM3A
-  #elif AVR_ATmega1284_FAMILY
-    #define PWM_CHK_SERVO(P)   false
-  #elif AVR_AT90USB1286_FAMILY
-    #define PWM_CHK_SERVO(P)   (P == 16) // PWM3A
-  #elif AVR_ATmega328_FAMILY
-    #define PWM_CHK_SERVO(P)   false
-  #endif
-#else
-  #define PWM_CHK_SERVO(P) false
-#endif
-
-#if ENABLED(BARICUDA)
-  #if HAS_HEATER_1 && HAS_HEATER_2
-    #define PWM_CHK_HEATER(P) (P == HEATER_1_PIN || P == HEATER_2_PIN)
-  #elif HAS_HEATER_1
-    #define PWM_CHK_HEATER(P) (P == HEATER_1_PIN)
-  #endif
-#else
-    #define PWM_CHK_HEATER(P) false
-#endif
-
-#define PWM_CHK(P) (PWM_CHK_HEATER(P) || PWM_CHK_SERVO(P) || PWM_CHK_MOTOR_CURRENT(P) || PWM_CHK_FAN_A(P) || PWM_CHK_FAN_B(P))
-
-#endif // PWM_CHK is not used in Marlin
-
-// define which hardware PWMs are available for the current CPU
-// all timer 1 PWMS deleted from this list because they are never available
-#if AVR_ATmega2560_FAMILY
-  #define PWM_PIN(P)  ((P >= 2 && P <= 10) || P == 13 || P == 44 || P == 45 || P == 46)
-#elif AVR_ATmega2561_FAMILY
-  #define PWM_PIN(P)  ((P >= 2 && P <= 6) || P == 9)
-#elif AVR_ATmega1284_FAMILY
-  #define PWM_PIN(P)  (P == 3 || P == 4 || P == 14 || P == 15)
-#elif AVR_AT90USB1286_FAMILY
-  #define PWM_PIN(P)  (P == 0 || P == 1 || P == 14 || P == 15 || P == 16 || P == 24)
-#elif AVR_ATmega328_FAMILY
-  #define PWM_PIN(P)  (P == 3 || P == 5 || P == 6 || P == 11)
-#else
-  #error "unknown CPU"
-#endif
diff --git a/Marlin/src/HAL/AVR/fastio/fastio_1280.h b/Marlin/src/HAL/AVR/fastio/fastio_1280.h
deleted file mode 100644
index f482f82..0000000
--- a/Marlin/src/HAL/AVR/fastio/fastio_1280.h
+++ /dev/null
@@ -1,1114 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Pin mapping for the 1280 and 2560
- *
- *   Hardware Pin  : 02 03 06 07 01 05 15 16 17 18 23 24 25 26 64 63 13 12 46 45 44 43 78 77 76 75 74 73 72 71 60 59 58 57 56 55 54 53 50 70 52 51 42 41 40 39 38 37 36 35 22 21 20 19 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 | 04 08 09 10 11 14 27 28 29 30 31 32 33 34 47 48 49 61 62 65 66 67 68 69 79 80 81 98 99 100
- *   Port          : E0 E1 E4 E5 G5 E3 H3 H4 H5 H6 B4 B5 B6 B7 J1 J0 H1 H0 D3 D2 D1 D0 A0 A1 A2 A3 A4 A5 A6 A7 C7 C6 C5 C4 C3 C2 C1 C0 D7 G2 G1 G0 L7 L6 L5 L4 L3 L2 L1 L0 B3 B2 B1 B0 F0 F1 F2 F3 F4 F5 F6 F7 K0 K1 K2 K3 K4 K5 K6 K7 | E2 E6 E7 xx xx H2 H7 G3 G4 xx xx xx xx xx D4 D5 D6 xx xx J2 J3 J4 J5 J6 J7 xx xx xx xx xx
- *   Logical Pin   : 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 | 78 79 80 xx xx 84 85 71 70 xx xx xx xx xx 81 82 83 xx xx 72 73 75 76 77 74 xx xx xx xx xx
- */
-
-#include "../fastio.h"
-
-// change for your board
-#define DEBUG_LED   DIO21
-
-// UART
-#define RXD         DIO0
-#define TXD         DIO1
-
-// SPI
-#define SCK         DIO52
-#define MISO        DIO50
-#define MOSI        DIO51
-#define SS          DIO53
-
-// TWI (I2C)
-#define SCL         DIO21
-#define SDA         DIO20
-
-// Timers and PWM
-#define OC0A        DIO13
-#define OC0B        DIO4
-#define OC1A        DIO11
-#define OC1B        DIO12
-#define OC2A        DIO10
-#define OC2B        DIO9
-#define OC3A        DIO5
-#define OC3B        DIO2
-#define OC3C        DIO3
-#define OC4A        DIO6
-#define OC4B        DIO7
-#define OC4C        DIO8
-#define OC5A        DIO46
-#define OC5B        DIO45
-#define OC5C        DIO44
-
-// Digital I/O
-
-#define DIO0_PIN    PINE0
-#define DIO0_RPORT  PINE
-#define DIO0_WPORT  PORTE
-#define DIO0_DDR    DDRE
-#define DIO0_PWM    nullptr
-
-#define DIO1_PIN    PINE1
-#define DIO1_RPORT  PINE
-#define DIO1_WPORT  PORTE
-#define DIO1_DDR    DDRE
-#define DIO1_PWM    nullptr
-
-#define DIO2_PIN    PINE4
-#define DIO2_RPORT  PINE
-#define DIO2_WPORT  PORTE
-#define DIO2_DDR    DDRE
-#define DIO2_PWM    &OCR3BL
-
-#define DIO3_PIN    PINE5
-#define DIO3_RPORT  PINE
-#define DIO3_WPORT  PORTE
-#define DIO3_DDR    DDRE
-#define DIO3_PWM    &OCR3CL
-
-#define DIO4_PIN    PING5
-#define DIO4_RPORT  PING
-#define DIO4_WPORT  PORTG
-#define DIO4_DDR    DDRG
-#define DIO4_PWM    &OCR0B
-
-#define DIO5_PIN    PINE3
-#define DIO5_RPORT  PINE
-#define DIO5_WPORT  PORTE
-#define DIO5_DDR    DDRE
-#define DIO5_PWM    &OCR3AL
-
-#define DIO6_PIN    PINH3
-#define DIO6_RPORT  PINH
-#define DIO6_WPORT  PORTH
-#define DIO6_DDR    DDRH
-#define DIO6_PWM    &OCR4AL
-
-#define DIO7_PIN    PINH4
-#define DIO7_RPORT  PINH
-#define DIO7_WPORT  PORTH
-#define DIO7_DDR    DDRH
-#define DIO7_PWM    &OCR4BL
-
-#define DIO8_PIN    PINH5
-#define DIO8_RPORT  PINH
-#define DIO8_WPORT  PORTH
-#define DIO8_DDR    DDRH
-#define DIO8_PWM    &OCR4CL
-
-#define DIO9_PIN    PINH6
-#define DIO9_RPORT  PINH
-#define DIO9_WPORT  PORTH
-#define DIO9_DDR    DDRH
-#define DIO9_PWM    &OCR2B
-
-#define DIO10_PIN   PINB4
-#define DIO10_RPORT PINB
-#define DIO10_WPORT PORTB
-#define DIO10_DDR   DDRB
-#define DIO10_PWM   &OCR2A
-
-#define DIO11_PIN   PINB5
-#define DIO11_RPORT PINB
-#define DIO11_WPORT PORTB
-#define DIO11_DDR   DDRB
-#define DIO11_PWM   nullptr
-
-#define DIO12_PIN   PINB6
-#define DIO12_RPORT PINB
-#define DIO12_WPORT PORTB
-#define DIO12_DDR   DDRB
-#define DIO12_PWM   nullptr
-
-#define DIO13_PIN   PINB7
-#define DIO13_RPORT PINB
-#define DIO13_WPORT PORTB
-#define DIO13_DDR   DDRB
-#define DIO13_PWM   &OCR0A
-
-#define DIO14_PIN   PINJ1
-#define DIO14_RPORT PINJ
-#define DIO14_WPORT PORTJ
-#define DIO14_DDR   DDRJ
-#define DIO14_PWM   nullptr
-
-#define DIO15_PIN   PINJ0
-#define DIO15_RPORT PINJ
-#define DIO15_WPORT PORTJ
-#define DIO15_DDR   DDRJ
-#define DIO15_PWM   nullptr
-
-#define DIO16_PIN   PINH1
-#define DIO16_RPORT PINH
-#define DIO16_WPORT PORTH
-#define DIO16_DDR   DDRH
-#define DIO16_PWM   nullptr
-
-#define DIO17_PIN   PINH0
-#define DIO17_RPORT PINH
-#define DIO17_WPORT PORTH
-#define DIO17_DDR   DDRH
-#define DIO17_PWM   nullptr
-
-#define DIO18_PIN   PIND3
-#define DIO18_RPORT PIND
-#define DIO18_WPORT PORTD
-#define DIO18_DDR   DDRD
-#define DIO18_PWM   nullptr
-
-#define DIO19_PIN   PIND2
-#define DIO19_RPORT PIND
-#define DIO19_WPORT PORTD
-#define DIO19_DDR   DDRD
-#define DIO19_PWM   nullptr
-
-#define DIO20_PIN   PIND1
-#define DIO20_RPORT PIND
-#define DIO20_WPORT PORTD
-#define DIO20_DDR   DDRD
-#define DIO20_PWM   nullptr
-
-#define DIO21_PIN   PIND0
-#define DIO21_RPORT PIND
-#define DIO21_WPORT PORTD
-#define DIO21_DDR   DDRD
-#define DIO21_PWM   nullptr
-
-#define DIO22_PIN   PINA0
-#define DIO22_RPORT PINA
-#define DIO22_WPORT PORTA
-#define DIO22_DDR   DDRA
-#define DIO22_PWM   nullptr
-
-#define DIO23_PIN   PINA1
-#define DIO23_RPORT PINA
-#define DIO23_WPORT PORTA
-#define DIO23_DDR   DDRA
-#define DIO23_PWM   nullptr
-
-#define DIO24_PIN   PINA2
-#define DIO24_RPORT PINA
-#define DIO24_WPORT PORTA
-#define DIO24_DDR   DDRA
-#define DIO24_PWM   nullptr
-
-#define DIO25_PIN   PINA3
-#define DIO25_RPORT PINA
-#define DIO25_WPORT PORTA
-#define DIO25_DDR   DDRA
-#define DIO25_PWM   nullptr
-
-#define DIO26_PIN   PINA4
-#define DIO26_RPORT PINA
-#define DIO26_WPORT PORTA
-#define DIO26_DDR   DDRA
-#define DIO26_PWM   nullptr
-
-#define DIO27_PIN   PINA5
-#define DIO27_RPORT PINA
-#define DIO27_WPORT PORTA
-#define DIO27_DDR   DDRA
-#define DIO27_PWM   nullptr
-
-#define DIO28_PIN   PINA6
-#define DIO28_RPORT PINA
-#define DIO28_WPORT PORTA
-#define DIO28_DDR   DDRA
-#define DIO28_PWM   nullptr
-
-#define DIO29_PIN   PINA7
-#define DIO29_RPORT PINA
-#define DIO29_WPORT PORTA
-#define DIO29_DDR   DDRA
-#define DIO29_PWM   nullptr
-
-#define DIO30_PIN   PINC7
-#define DIO30_RPORT PINC
-#define DIO30_WPORT PORTC
-#define DIO30_DDR   DDRC
-#define DIO30_PWM   nullptr
-
-#define DIO31_PIN   PINC6
-#define DIO31_RPORT PINC
-#define DIO31_WPORT PORTC
-#define DIO31_DDR   DDRC
-#define DIO31_PWM   nullptr
-
-#define DIO32_PIN   PINC5
-#define DIO32_RPORT PINC
-#define DIO32_WPORT PORTC
-#define DIO32_DDR   DDRC
-#define DIO32_PWM   nullptr
-
-#define DIO33_PIN   PINC4
-#define DIO33_RPORT PINC
-#define DIO33_WPORT PORTC
-#define DIO33_DDR   DDRC
-#define DIO33_PWM   nullptr
-
-#define DIO34_PIN   PINC3
-#define DIO34_RPORT PINC
-#define DIO34_WPORT PORTC
-#define DIO34_DDR   DDRC
-#define DIO34_PWM   nullptr
-
-#define DIO35_PIN   PINC2
-#define DIO35_RPORT PINC
-#define DIO35_WPORT PORTC
-#define DIO35_DDR   DDRC
-#define DIO35_PWM   nullptr
-
-#define DIO36_PIN   PINC1
-#define DIO36_RPORT PINC
-#define DIO36_WPORT PORTC
-#define DIO36_DDR   DDRC
-#define DIO36_PWM   nullptr
-
-#define DIO37_PIN   PINC0
-#define DIO37_RPORT PINC
-#define DIO37_WPORT PORTC
-#define DIO37_DDR   DDRC
-#define DIO37_PWM   nullptr
-
-#define DIO38_PIN   PIND7
-#define DIO38_RPORT PIND
-#define DIO38_WPORT PORTD
-#define DIO38_DDR   DDRD
-#define DIO38_PWM   nullptr
-
-#define DIO39_PIN   PING2
-#define DIO39_RPORT PING
-#define DIO39_WPORT PORTG
-#define DIO39_DDR   DDRG
-#define DIO39_PWM   nullptr
-
-#define DIO40_PIN   PING1
-#define DIO40_RPORT PING
-#define DIO40_WPORT PORTG
-#define DIO40_DDR   DDRG
-#define DIO40_PWM   nullptr
-
-#define DIO41_PIN   PING0
-#define DIO41_RPORT PING
-#define DIO41_WPORT PORTG
-#define DIO41_DDR   DDRG
-#define DIO41_PWM   nullptr
-
-#define DIO42_PIN   PINL7
-#define DIO42_RPORT PINL
-#define DIO42_WPORT PORTL
-#define DIO42_DDR   DDRL
-#define DIO42_PWM   nullptr
-
-#define DIO43_PIN   PINL6
-#define DIO43_RPORT PINL
-#define DIO43_WPORT PORTL
-#define DIO43_DDR   DDRL
-#define DIO43_PWM   nullptr
-
-#define DIO44_PIN   PINL5
-#define DIO44_RPORT PINL
-#define DIO44_WPORT PORTL
-#define DIO44_DDR   DDRL
-#define DIO44_PWM   &OCR5CL
-
-#define DIO45_PIN   PINL4
-#define DIO45_RPORT PINL
-#define DIO45_WPORT PORTL
-#define DIO45_DDR   DDRL
-#define DIO45_PWM   &OCR5BL
-
-#define DIO46_PIN   PINL3
-#define DIO46_RPORT PINL
-#define DIO46_WPORT PORTL
-#define DIO46_DDR   DDRL
-#define DIO46_PWM   &OCR5AL
-
-#define DIO47_PIN   PINL2
-#define DIO47_RPORT PINL
-#define DIO47_WPORT PORTL
-#define DIO47_DDR   DDRL
-#define DIO47_PWM   nullptr
-
-#define DIO48_PIN   PINL1
-#define DIO48_RPORT PINL
-#define DIO48_WPORT PORTL
-#define DIO48_DDR   DDRL
-#define DIO48_PWM   nullptr
-
-#define DIO49_PIN   PINL0
-#define DIO49_RPORT PINL
-#define DIO49_WPORT PORTL
-#define DIO49_DDR   DDRL
-#define DIO49_PWM   nullptr
-
-#define DIO50_PIN   PINB3
-#define DIO50_RPORT PINB
-#define DIO50_WPORT PORTB
-#define DIO50_DDR   DDRB
-#define DIO50_PWM   nullptr
-
-#define DIO51_PIN   PINB2
-#define DIO51_RPORT PINB
-#define DIO51_WPORT PORTB
-#define DIO51_DDR   DDRB
-#define DIO51_PWM   nullptr
-
-#define DIO52_PIN   PINB1
-#define DIO52_RPORT PINB
-#define DIO52_WPORT PORTB
-#define DIO52_DDR   DDRB
-#define DIO52_PWM   nullptr
-
-#define DIO53_PIN   PINB0
-#define DIO53_RPORT PINB
-#define DIO53_WPORT PORTB
-#define DIO53_DDR   DDRB
-#define DIO53_PWM   nullptr
-
-#define DIO54_PIN   PINF0
-#define DIO54_RPORT PINF
-#define DIO54_WPORT PORTF
-#define DIO54_DDR   DDRF
-#define DIO54_PWM   nullptr
-
-#define DIO55_PIN   PINF1
-#define DIO55_RPORT PINF
-#define DIO55_WPORT PORTF
-#define DIO55_DDR   DDRF
-#define DIO55_PWM   nullptr
-
-#define DIO56_PIN   PINF2
-#define DIO56_RPORT PINF
-#define DIO56_WPORT PORTF
-#define DIO56_DDR   DDRF
-#define DIO56_PWM   nullptr
-
-#define DIO57_PIN   PINF3
-#define DIO57_RPORT PINF
-#define DIO57_WPORT PORTF
-#define DIO57_DDR   DDRF
-#define DIO57_PWM   nullptr
-
-#define DIO58_PIN   PINF4
-#define DIO58_RPORT PINF
-#define DIO58_WPORT PORTF
-#define DIO58_DDR   DDRF
-#define DIO58_PWM   nullptr
-
-#define DIO59_PIN   PINF5
-#define DIO59_RPORT PINF
-#define DIO59_WPORT PORTF
-#define DIO59_DDR   DDRF
-#define DIO59_PWM   nullptr
-
-#define DIO60_PIN   PINF6
-#define DIO60_RPORT PINF
-#define DIO60_WPORT PORTF
-#define DIO60_DDR   DDRF
-#define DIO60_PWM   nullptr
-
-#define DIO61_PIN   PINF7
-#define DIO61_RPORT PINF
-#define DIO61_WPORT PORTF
-#define DIO61_DDR   DDRF
-#define DIO61_PWM   nullptr
-
-#define DIO62_PIN   PINK0
-#define DIO62_RPORT PINK
-#define DIO62_WPORT PORTK
-#define DIO62_DDR   DDRK
-#define DIO62_PWM   nullptr
-
-#define DIO63_PIN   PINK1
-#define DIO63_RPORT PINK
-#define DIO63_WPORT PORTK
-#define DIO63_DDR   DDRK
-#define DIO63_PWM   nullptr
-
-#define DIO64_PIN   PINK2
-#define DIO64_RPORT PINK
-#define DIO64_WPORT PORTK
-#define DIO64_DDR   DDRK
-#define DIO64_PWM   nullptr
-
-#define DIO65_PIN   PINK3
-#define DIO65_RPORT PINK
-#define DIO65_WPORT PORTK
-#define DIO65_DDR   DDRK
-#define DIO65_PWM   nullptr
-
-#define DIO66_PIN   PINK4
-#define DIO66_RPORT PINK
-#define DIO66_WPORT PORTK
-#define DIO66_DDR   DDRK
-#define DIO66_PWM   nullptr
-
-#define DIO67_PIN   PINK5
-#define DIO67_RPORT PINK
-#define DIO67_WPORT PORTK
-#define DIO67_DDR   DDRK
-#define DIO67_PWM   nullptr
-
-#define DIO68_PIN   PINK6
-#define DIO68_RPORT PINK
-#define DIO68_WPORT PORTK
-#define DIO68_DDR   DDRK
-#define DIO68_PWM   nullptr
-
-#define DIO69_PIN   PINK7
-#define DIO69_RPORT PINK
-#define DIO69_WPORT PORTK
-#define DIO69_DDR   DDRK
-#define DIO69_PWM   nullptr
-
-//#define FASTIO_EXT_START 70
-//#define FASTIO_EXT_END   85
-
-#define DIO70_PIN   PING4
-#define DIO70_RPORT PING
-#define DIO70_WPORT PORTG
-#define DIO70_DDR   DDRG
-#define DIO70_PWM   nullptr
-
-#define DIO71_PIN   PING3
-#define DIO71_RPORT PING
-#define DIO71_WPORT PORTG
-#define DIO71_DDR   DDRG
-#define DIO71_PWM   nullptr
-
-#define DIO72_PIN   PINJ2
-#define DIO72_RPORT PINJ
-#define DIO72_WPORT PORTJ
-#define DIO72_DDR   DDRJ
-#define DIO72_PWM   nullptr
-
-#define DIO73_PIN   PINJ3
-#define DIO73_RPORT PINJ
-#define DIO73_WPORT PORTJ
-#define DIO73_DDR   DDRJ
-#define DIO73_PWM   nullptr
-
-#define DIO74_PIN   PINJ7
-#define DIO74_RPORT PINJ
-#define DIO74_WPORT PORTJ
-#define DIO74_DDR   DDRJ
-#define DIO74_PWM   nullptr
-
-#define DIO75_PIN   PINJ4
-#define DIO75_RPORT PINJ
-#define DIO75_WPORT PORTJ
-#define DIO75_DDR   DDRJ
-#define DIO75_PWM   nullptr
-
-#define DIO76_PIN   PINJ5
-#define DIO76_RPORT PINJ
-#define DIO76_WPORT PORTJ
-#define DIO76_DDR   DDRJ
-#define DIO76_PWM   nullptr
-
-#define DIO77_PIN   PINJ6
-#define DIO77_RPORT PINJ
-#define DIO77_WPORT PORTJ
-#define DIO77_DDR   DDRJ
-#define DIO77_PWM   nullptr
-
-#define DIO78_PIN   PINE2
-#define DIO78_RPORT PINE
-#define DIO78_WPORT PORTE
-#define DIO78_DDR   DDRE
-#define DIO78_PWM   nullptr
-
-#define DIO79_PIN   PINE6
-#define DIO79_RPORT PINE
-#define DIO79_WPORT PORTE
-#define DIO79_DDR   DDRE
-#define DIO79_PWM   nullptr
-
-#define DIO80_PIN   PINE7
-#define DIO80_RPORT PINE
-#define DIO80_WPORT PORTE
-#define DIO80_DDR   DDRE
-#define DIO80_PWM   nullptr
-
-#define DIO81_PIN   PIND4
-#define DIO81_RPORT PIND
-#define DIO81_WPORT PORTD
-#define DIO81_DDR   DDRD
-#define DIO81_PWM   nullptr
-
-#define DIO82_PIN   PIND5
-#define DIO82_RPORT PIND
-#define DIO82_WPORT PORTD
-#define DIO82_DDR   DDRD
-#define DIO82_PWM   nullptr
-
-#define DIO83_PIN   PIND6
-#define DIO83_RPORT PIND
-#define DIO83_WPORT PORTD
-#define DIO83_DDR   DDRD
-#define DIO83_PWM   nullptr
-
-#define DIO84_PIN   PINH2
-#define DIO84_RPORT PINH
-#define DIO84_WPORT PORTH
-#define DIO84_DDR   DDRH
-#define DIO84_PWM   nullptr
-
-#define DIO85_PIN   PINH7
-#define DIO85_RPORT PINH
-#define DIO85_WPORT PORTH
-#define DIO85_DDR   DDRH
-#define DIO85_PWM   nullptr
-
-#undef PA0
-#define PA0_PIN     PINA0
-#define PA0_RPORT   PINA
-#define PA0_WPORT   PORTA
-#define PA0_DDR     DDRA
-#define PA0_PWM     nullptr
-#undef PA1
-#define PA1_PIN     PINA1
-#define PA1_RPORT   PINA
-#define PA1_WPORT   PORTA
-#define PA1_DDR     DDRA
-#define PA1_PWM     nullptr
-#undef PA2
-#define PA2_PIN     PINA2
-#define PA2_RPORT   PINA
-#define PA2_WPORT   PORTA
-#define PA2_DDR     DDRA
-#define PA2_PWM     nullptr
-#undef PA3
-#define PA3_PIN     PINA3
-#define PA3_RPORT   PINA
-#define PA3_WPORT   PORTA
-#define PA3_DDR     DDRA
-#define PA3_PWM     nullptr
-#undef PA4
-#define PA4_PIN     PINA4
-#define PA4_RPORT   PINA
-#define PA4_WPORT   PORTA
-#define PA4_DDR     DDRA
-#define PA4_PWM     nullptr
-#undef PA5
-#define PA5_PIN     PINA5
-#define PA5_RPORT   PINA
-#define PA5_WPORT   PORTA
-#define PA5_DDR     DDRA
-#define PA5_PWM     nullptr
-#undef PA6
-#define PA6_PIN     PINA6
-#define PA6_RPORT   PINA
-#define PA6_WPORT   PORTA
-#define PA6_DDR     DDRA
-#define PA6_PWM     nullptr
-#undef PA7
-#define PA7_PIN     PINA7
-#define PA7_RPORT   PINA
-#define PA7_WPORT   PORTA
-#define PA7_DDR     DDRA
-#define PA7_PWM     nullptr
-
-#undef PB0
-#define PB0_PIN     PINB0
-#define PB0_RPORT   PINB
-#define PB0_WPORT   PORTB
-#define PB0_DDR     DDRB
-#define PB0_PWM     nullptr
-#undef PB1
-#define PB1_PIN     PINB1
-#define PB1_RPORT   PINB
-#define PB1_WPORT   PORTB
-#define PB1_DDR     DDRB
-#define PB1_PWM     nullptr
-#undef PB2
-#define PB2_PIN     PINB2
-#define PB2_RPORT   PINB
-#define PB2_WPORT   PORTB
-#define PB2_DDR     DDRB
-#define PB2_PWM     nullptr
-#undef PB3
-#define PB3_PIN     PINB3
-#define PB3_RPORT   PINB
-#define PB3_WPORT   PORTB
-#define PB3_DDR     DDRB
-#define PB3_PWM     nullptr
-#undef PB4
-#define PB4_PIN     PINB4
-#define PB4_RPORT   PINB
-#define PB4_WPORT   PORTB
-#define PB4_DDR     DDRB
-#define PB4_PWM     &OCR2A
-#undef PB5
-#define PB5_PIN     PINB5
-#define PB5_RPORT   PINB
-#define PB5_WPORT   PORTB
-#define PB5_DDR     DDRB
-#define PB5_PWM     nullptr
-#undef PB6
-#define PB6_PIN     PINB6
-#define PB6_RPORT   PINB
-#define PB6_WPORT   PORTB
-#define PB6_DDR     DDRB
-#define PB6_PWM     nullptr
-#undef PB7
-#define PB7_PIN     PINB7
-#define PB7_RPORT   PINB
-#define PB7_WPORT   PORTB
-#define PB7_DDR     DDRB
-#define PB7_PWM     &OCR0A
-
-#undef PC0
-#define PC0_PIN     PINC0
-#define PC0_RPORT   PINC
-#define PC0_WPORT   PORTC
-#define PC0_DDR     DDRC
-#define PC0_PWM     nullptr
-#undef PC1
-#define PC1_PIN     PINC1
-#define PC1_RPORT   PINC
-#define PC1_WPORT   PORTC
-#define PC1_DDR     DDRC
-#define PC1_PWM     nullptr
-#undef PC2
-#define PC2_PIN     PINC2
-#define PC2_RPORT   PINC
-#define PC2_WPORT   PORTC
-#define PC2_DDR     DDRC
-#define PC2_PWM     nullptr
-#undef PC3
-#define PC3_PIN     PINC3
-#define PC3_RPORT   PINC
-#define PC3_WPORT   PORTC
-#define PC3_DDR     DDRC
-#define PC3_PWM     nullptr
-#undef PC4
-#define PC4_PIN     PINC4
-#define PC4_RPORT   PINC
-#define PC4_WPORT   PORTC
-#define PC4_DDR     DDRC
-#define PC4_PWM     nullptr
-#undef PC5
-#define PC5_PIN     PINC5
-#define PC5_RPORT   PINC
-#define PC5_WPORT   PORTC
-#define PC5_DDR     DDRC
-#define PC5_PWM     nullptr
-#undef PC6
-#define PC6_PIN     PINC6
-#define PC6_RPORT   PINC
-#define PC6_WPORT   PORTC
-#define PC6_DDR     DDRC
-#define PC6_PWM     nullptr
-#undef PC7
-#define PC7_PIN     PINC7
-#define PC7_RPORT   PINC
-#define PC7_WPORT   PORTC
-#define PC7_DDR     DDRC
-#define PC7_PWM     nullptr
-
-#undef PD0
-#define PD0_PIN     PIND0
-#define PD0_RPORT   PIND
-#define PD0_WPORT   PORTD
-#define PD0_DDR     DDRD
-#define PD0_PWM     nullptr
-#undef PD1
-#define PD1_PIN     PIND1
-#define PD1_RPORT   PIND
-#define PD1_WPORT   PORTD
-#define PD1_DDR     DDRD
-#define PD1_PWM     nullptr
-#undef PD2
-#define PD2_PIN     PIND2
-#define PD2_RPORT   PIND
-#define PD2_WPORT   PORTD
-#define PD2_DDR     DDRD
-#define PD2_PWM     nullptr
-#undef PD3
-#define PD3_PIN     PIND3
-#define PD3_RPORT   PIND
-#define PD3_WPORT   PORTD
-#define PD3_DDR     DDRD
-#define PD3_PWM     nullptr
-#undef PD4
-#define PD4_PIN     PIND4
-#define PD4_RPORT   PIND
-#define PD4_WPORT   PORTD
-#define PD4_DDR     DDRD
-#define PD4_PWM     nullptr
-#undef PD5
-#define PD5_PIN     PIND5
-#define PD5_RPORT   PIND
-#define PD5_WPORT   PORTD
-#define PD5_DDR     DDRD
-#define PD5_PWM     nullptr
-#undef PD6
-#define PD6_PIN     PIND6
-#define PD6_RPORT   PIND
-#define PD6_WPORT   PORTD
-#define PD6_DDR     DDRD
-#define PD6_PWM     nullptr
-#undef PD7
-#define PD7_PIN     PIND7
-#define PD7_RPORT   PIND
-#define PD7_WPORT   PORTD
-#define PD7_DDR     DDRD
-#define PD7_PWM     nullptr
-
-#undef PE0
-#define PE0_PIN     PINE0
-#define PE0_RPORT   PINE
-#define PE0_WPORT   PORTE
-#define PE0_DDR     DDRE
-#define PE0_PWM     nullptr
-#undef PE1
-#define PE1_PIN     PINE1
-#define PE1_RPORT   PINE
-#define PE1_WPORT   PORTE
-#define PE1_DDR     DDRE
-#define PE1_PWM     nullptr
-#undef PE2
-#define PE2_PIN     PINE2
-#define PE2_RPORT   PINE
-#define PE2_WPORT   PORTE
-#define PE2_DDR     DDRE
-#define PE2_PWM     nullptr
-#undef PE3
-#define PE3_PIN     PINE3
-#define PE3_RPORT   PINE
-#define PE3_WPORT   PORTE
-#define PE3_DDR     DDRE
-#define PE3_PWM     &OCR3AL
-#undef PE4
-#define PE4_PIN     PINE4
-#define PE4_RPORT   PINE
-#define PE4_WPORT   PORTE
-#define PE4_DDR     DDRE
-#define PE4_PWM     &OCR3BL
-#undef PE5
-#define PE5_PIN     PINE5
-#define PE5_RPORT   PINE
-#define PE5_WPORT   PORTE
-#define PE5_DDR     DDRE
-#define PE5_PWM     &OCR3CL
-#undef PE6
-#define PE6_PIN     PINE6
-#define PE6_RPORT   PINE
-#define PE6_WPORT   PORTE
-#define PE6_DDR     DDRE
-#define PE6_PWM     nullptr
-#undef PE7
-#define PE7_PIN     PINE7
-#define PE7_RPORT   PINE
-#define PE7_WPORT   PORTE
-#define PE7_DDR     DDRE
-#define PE7_PWM     nullptr
-
-#undef PF0
-#define PF0_PIN     PINF0
-#define PF0_RPORT   PINF
-#define PF0_WPORT   PORTF
-#define PF0_DDR     DDRF
-#define PF0_PWM     nullptr
-#undef PF1
-#define PF1_PIN     PINF1
-#define PF1_RPORT   PINF
-#define PF1_WPORT   PORTF
-#define PF1_DDR     DDRF
-#define PF1_PWM     nullptr
-#undef PF2
-#define PF2_PIN     PINF2
-#define PF2_RPORT   PINF
-#define PF2_WPORT   PORTF
-#define PF2_DDR     DDRF
-#define PF2_PWM     nullptr
-#undef PF3
-#define PF3_PIN     PINF3
-#define PF3_RPORT   PINF
-#define PF3_WPORT   PORTF
-#define PF3_DDR     DDRF
-#define PF3_PWM     nullptr
-#undef PF4
-#define PF4_PIN     PINF4
-#define PF4_RPORT   PINF
-#define PF4_WPORT   PORTF
-#define PF4_DDR     DDRF
-#define PF4_PWM     nullptr
-#undef PF5
-#define PF5_PIN     PINF5
-#define PF5_RPORT   PINF
-#define PF5_WPORT   PORTF
-#define PF5_DDR     DDRF
-#define PF5_PWM     nullptr
-#undef PF6
-#define PF6_PIN     PINF6
-#define PF6_RPORT   PINF
-#define PF6_WPORT   PORTF
-#define PF6_DDR     DDRF
-#define PF6_PWM     nullptr
-#undef PF7
-#define PF7_PIN     PINF7
-#define PF7_RPORT   PINF
-#define PF7_WPORT   PORTF
-#define PF7_DDR     DDRF
-#define PF7_PWM     nullptr
-
-#undef PG0
-#define PG0_PIN     PING0
-#define PG0_RPORT   PING
-#define PG0_WPORT   PORTG
-#define PG0_DDR     DDRG
-#define PG0_PWM     nullptr
-#undef PG1
-#define PG1_PIN     PING1
-#define PG1_RPORT   PING
-#define PG1_WPORT   PORTG
-#define PG1_DDR     DDRG
-#define PG1_PWM     nullptr
-#undef PG2
-#define PG2_PIN     PING2
-#define PG2_RPORT   PING
-#define PG2_WPORT   PORTG
-#define PG2_DDR     DDRG
-#define PG2_PWM     nullptr
-#undef PG3
-#define PG3_PIN     PING3
-#define PG3_RPORT   PING
-#define PG3_WPORT   PORTG
-#define PG3_DDR     DDRG
-#define PG3_PWM     nullptr
-#undef PG4
-#define PG4_PIN     PING4
-#define PG4_RPORT   PING
-#define PG4_WPORT   PORTG
-#define PG4_DDR     DDRG
-#define PG4_PWM     nullptr
-#undef PG5
-#define PG5_PIN     PING5
-#define PG5_RPORT   PING
-#define PG5_WPORT   PORTG
-#define PG5_DDR     DDRG
-#define PG5_PWM     &OCR0B
-
-#undef PH0
-#define PH0_PIN     PINH0
-#define PH0_RPORT   PINH
-#define PH0_WPORT   PORTH
-#define PH0_DDR     DDRH
-#define PH0_PWM     nullptr
-#undef PH1
-#define PH1_PIN     PINH1
-#define PH1_RPORT   PINH
-#define PH1_WPORT   PORTH
-#define PH1_DDR     DDRH
-#define PH1_PWM     nullptr
-#undef PH2
-#define PH2_PIN     PINH2
-#define PH2_RPORT   PINH
-#define PH2_WPORT   PORTH
-#define PH2_DDR     DDRH
-#define PH2_PWM     nullptr
-#undef PH3
-#define PH3_PIN     PINH3
-#define PH3_RPORT   PINH
-#define PH3_WPORT   PORTH
-#define PH3_DDR     DDRH
-#define PH3_PWM     &OCR4AL
-#undef PH4
-#define PH4_PIN     PINH4
-#define PH4_RPORT   PINH
-#define PH4_WPORT   PORTH
-#define PH4_DDR     DDRH
-#define PH4_PWM     &OCR4BL
-#undef PH5
-#define PH5_PIN     PINH5
-#define PH5_RPORT   PINH
-#define PH5_WPORT   PORTH
-#define PH5_DDR     DDRH
-#define PH5_PWM     &OCR4CL
-#undef PH6
-#define PH6_PIN     PINH6
-#define PH6_RPORT   PINH
-#define PH6_WPORT   PORTH
-#define PH6_DDR     DDRH
-#define PH6_PWM     &OCR2B
-#undef PH7
-#define PH7_PIN     PINH7
-#define PH7_RPORT   PINH
-#define PH7_WPORT   PORTH
-#define PH7_DDR     DDRH
-#define PH7_PWM     nullptr
-
-#undef PJ0
-#define PJ0_PIN     PINJ0
-#define PJ0_RPORT   PINJ
-#define PJ0_WPORT   PORTJ
-#define PJ0_DDR     DDRJ
-#define PJ0_PWM     nullptr
-#undef PJ1
-#define PJ1_PIN     PINJ1
-#define PJ1_RPORT   PINJ
-#define PJ1_WPORT   PORTJ
-#define PJ1_DDR     DDRJ
-#define PJ1_PWM     nullptr
-#undef PJ2
-#define PJ2_PIN     PINJ2
-#define PJ2_RPORT   PINJ
-#define PJ2_WPORT   PORTJ
-#define PJ2_DDR     DDRJ
-#define PJ2_PWM     nullptr
-#undef PJ3
-#define PJ3_PIN     PINJ3
-#define PJ3_RPORT   PINJ
-#define PJ3_WPORT   PORTJ
-#define PJ3_DDR     DDRJ
-#define PJ3_PWM     nullptr
-#undef PJ4
-#define PJ4_PIN     PINJ4
-#define PJ4_RPORT   PINJ
-#define PJ4_WPORT   PORTJ
-#define PJ4_DDR     DDRJ
-#define PJ4_PWM     nullptr
-#undef PJ5
-#define PJ5_PIN     PINJ5
-#define PJ5_RPORT   PINJ
-#define PJ5_WPORT   PORTJ
-#define PJ5_DDR     DDRJ
-#define PJ5_PWM     nullptr
-#undef PJ6
-#define PJ6_PIN     PINJ6
-#define PJ6_RPORT   PINJ
-#define PJ6_WPORT   PORTJ
-#define PJ6_DDR     DDRJ
-#define PJ6_PWM     nullptr
-#undef PJ7
-#define PJ7_PIN     PINJ7
-#define PJ7_RPORT   PINJ
-#define PJ7_WPORT   PORTJ
-#define PJ7_DDR     DDRJ
-#define PJ7_PWM     nullptr
-
-#undef PK0
-#define PK0_PIN     PINK0
-#define PK0_RPORT   PINK
-#define PK0_WPORT   PORTK
-#define PK0_DDR     DDRK
-#define PK0_PWM     nullptr
-#undef PK1
-#define PK1_PIN     PINK1
-#define PK1_RPORT   PINK
-#define PK1_WPORT   PORTK
-#define PK1_DDR     DDRK
-#define PK1_PWM     nullptr
-#undef PK2
-#define PK2_PIN     PINK2
-#define PK2_RPORT   PINK
-#define PK2_WPORT   PORTK
-#define PK2_DDR     DDRK
-#define PK2_PWM     nullptr
-#undef PK3
-#define PK3_PIN     PINK3
-#define PK3_RPORT   PINK
-#define PK3_WPORT   PORTK
-#define PK3_DDR     DDRK
-#define PK3_PWM     nullptr
-#undef PK4
-#define PK4_PIN     PINK4
-#define PK4_RPORT   PINK
-#define PK4_WPORT   PORTK
-#define PK4_DDR     DDRK
-#define PK4_PWM     nullptr
-#undef PK5
-#define PK5_PIN     PINK5
-#define PK5_RPORT   PINK
-#define PK5_WPORT   PORTK
-#define PK5_DDR     DDRK
-#define PK5_PWM     nullptr
-#undef PK6
-#define PK6_PIN     PINK6
-#define PK6_RPORT   PINK
-#define PK6_WPORT   PORTK
-#define PK6_DDR     DDRK
-#define PK6_PWM     nullptr
-#undef PK7
-#define PK7_PIN     PINK7
-#define PK7_RPORT   PINK
-#define PK7_WPORT   PORTK
-#define PK7_DDR     DDRK
-#define PK7_PWM     nullptr
-
-#undef PL0
-#define PL0_PIN     PINL0
-#define PL0_RPORT   PINL
-#define PL0_WPORT   PORTL
-#define PL0_DDR     DDRL
-#define PL0_PWM     nullptr
-#undef PL1
-#define PL1_PIN     PINL1
-#define PL1_RPORT   PINL
-#define PL1_WPORT   PORTL
-#define PL1_DDR     DDRL
-#define PL1_PWM     nullptr
-#undef PL2
-#define PL2_PIN     PINL2
-#define PL2_RPORT   PINL
-#define PL2_WPORT   PORTL
-#define PL2_DDR     DDRL
-#define PL2_PWM     nullptr
-#undef PL3
-#define PL3_PIN     PINL3
-#define PL3_RPORT   PINL
-#define PL3_WPORT   PORTL
-#define PL3_DDR     DDRL
-#define PL3_PWM     &OCR5AL
-#undef PL4
-#define PL4_PIN     PINL4
-#define PL4_RPORT   PINL
-#define PL4_WPORT   PORTL
-#define PL4_DDR     DDRL
-#define PL4_PWM     &OCR5BL
-#undef PL5
-#define PL5_PIN     PINL5
-#define PL5_RPORT   PINL
-#define PL5_WPORT   PORTL
-#define PL5_DDR     DDRL
-#define PL5_PWM     &OCR5CL
-#undef PL6
-#define PL6_PIN     PINL6
-#define PL6_RPORT   PINL
-#define PL6_WPORT   PORTL
-#define PL6_DDR     DDRL
-#define PL6_PWM     nullptr
-#undef PL7
-#define PL7_PIN     PINL7
-#define PL7_RPORT   PINL
-#define PL7_WPORT   PORTL
-#define PL7_DDR     DDRL
-#define PL7_PWM     nullptr
diff --git a/Marlin/src/HAL/AVR/fastio/fastio_1281.h b/Marlin/src/HAL/AVR/fastio/fastio_1281.h
deleted file mode 100644
index e0bc5e2..0000000
--- a/Marlin/src/HAL/AVR/fastio/fastio_1281.h
+++ /dev/null
@@ -1,715 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Pin mapping for the 1281 and 2561
- *
- *   Logical Pin: 38 39 40 41 42 43 44 45 16 10 11 12 06 07 08 09 30 31 32 33 34 35 36 37 17 18 19 20 21 22 23 24 00 01 13 05 02 03 14 15 46 47 48 49 50 51 52 53 25 26 27 28 29 04
- *   Port:        A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 C0 C1 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7 E0 E1 E2 E3 E4 E5 E6 E7 F0 F1 F2 F3 F4 F5 F6 F7 G0 G1 G2 G3 G4 G5
- */
-
-#include "../fastio.h"
-
-// change for your board
-#define DEBUG_LED   DIO46
-
-// UART
-#define RXD         DIO0
-#define TXD         DIO1
-
-// SPI
-#define SCK         DIO10
-#define MISO        DIO12
-#define MOSI        DIO11
-#define SS          DIO16
-
-// TWI (I2C)
-#define SCL         DIO17
-#define SDA         DIO18
-
-// Timers and PWM
-#define OC0A        DIO9
-#define OC0B        DIO4
-#define OC1A        DIO7
-#define OC1B        DIO8
-#define OC2A        DIO6
-#define OC3A        DIO5
-#define OC3B        DIO2
-#define OC3C        DIO3
-
-// Digital I/O
-
-#define DIO0_PIN    PINE0
-#define DIO0_RPORT  PINE
-#define DIO0_WPORT  PORTE
-#define DIO0_DDR    DDRE
-#define DIO0_PWM    nullptr
-
-#define DIO1_PIN    PINE1
-#define DIO1_RPORT  PINE
-#define DIO1_WPORT  PORTE
-#define DIO1_DDR    DDRE
-#define DIO1_PWM    nullptr
-
-#define DIO2_PIN    PINE4
-#define DIO2_RPORT  PINE
-#define DIO2_WPORT  PORTE
-#define DIO2_DDR    DDRE
-#define DIO2_PWM    &OCR3BL
-
-#define DIO3_PIN    PINE5
-#define DIO3_RPORT  PINE
-#define DIO3_WPORT  PORTE
-#define DIO3_DDR    DDRE
-#define DIO3_PWM    &OCR3CL
-
-#define DIO4_PIN    PING5
-#define DIO4_RPORT  PING
-#define DIO4_WPORT  PORTG
-#define DIO4_DDR    DDRG
-#define DIO4_PWM    &OCR0B
-
-#define DIO5_PIN    PINE3
-#define DIO5_RPORT  PINE
-#define DIO5_WPORT  PORTE
-#define DIO5_DDR    DDRE
-#define DIO5_PWM    &OCR3AL
-
-#define DIO6_PIN    PINB4
-#define DIO6_RPORT  PINB
-#define DIO6_WPORT  PORTB
-#define DIO6_DDR    DDRB
-#define DIO6_PWM    &OCR2AL
-
-#define DIO7_PIN    PINB5
-#define DIO7_RPORT  PINB
-#define DIO7_WPORT  PORTB
-#define DIO7_DDR    DDRB
-#define DIO7_PWM    &OCR1AL
-
-#define DIO8_PIN    PINB6
-#define DIO8_RPORT  PINB
-#define DIO8_WPORT  PORTB
-#define DIO8_DDR    DDRB
-#define DIO8_PWM    &OCR1BL
-
-#define DIO9_PIN    PINB7
-#define DIO9_RPORT  PINB
-#define DIO9_WPORT  PORTB
-#define DIO9_DDR    DDRB
-#define DIO9_PWM    &OCR0AL
-
-#define DIO10_PIN   PINB1
-#define DIO10_RPORT PINB
-#define DIO10_WPORT PORTB
-#define DIO10_DDR   DDRB
-#define DIO10_PWM   nullptr
-
-#define DIO11_PIN   PINB2
-#define DIO11_RPORT PINB
-#define DIO11_WPORT PORTB
-#define DIO11_DDR   DDRB
-#define DIO11_PWM   nullptr
-
-#define DIO12_PIN   PINB3
-#define DIO12_RPORT PINB
-#define DIO12_WPORT PORTB
-#define DIO12_DDR   DDRB
-#define DIO12_PWM   nullptr
-
-#define DIO13_PIN   PINE2
-#define DIO13_RPORT PINE
-#define DIO13_WPORT PORTE
-#define DIO13_DDR   DDRE
-#define DIO13_PWM   nullptr
-
-#define DIO14_PIN   PINE6
-#define DIO14_RPORT PINE
-#define DIO14_WPORT PORTE
-#define DIO14_DDR   DDRE
-#define DIO14_PWM   nullptr
-
-#define DIO15_PIN   PINE7
-#define DIO15_RPORT PINE
-#define DIO15_WPORT PORTE
-#define DIO15_DDR   DDRE
-#define DIO15_PWM   nullptr
-
-#define DIO16_PIN   PINB0
-#define DIO16_RPORT PINB
-#define DIO16_WPORT PORTB
-#define DIO16_DDR   DDRB
-#define DIO16_PWM   nullptr
-
-#define DIO17_PIN   PIND0
-#define DIO17_RPORT PIND
-#define DIO17_WPORT PORTD
-#define DIO17_DDR   DDRD
-#define DIO17_PWM   nullptr
-
-#define DIO18_PIN   PIND1
-#define DIO18_RPORT PIND
-#define DIO18_WPORT PORTD
-#define DIO18_DDR   DDRD
-#define DIO18_PWM   nullptr
-
-#define DIO19_PIN   PIND2
-#define DIO19_RPORT PIND
-#define DIO19_WPORT PORTD
-#define DIO19_DDR   DDRD
-#define DIO19_PWM   nullptr
-
-#define DIO20_PIN   PIND3
-#define DIO20_RPORT PIND
-#define DIO20_WPORT PORTD
-#define DIO20_DDR   DDRD
-#define DIO20_PWM   nullptr
-
-#define DIO21_PIN   PIND4
-#define DIO21_RPORT PIND
-#define DIO21_WPORT PORTD
-#define DIO21_DDR   DDRD
-#define DIO21_PWM   nullptr
-
-#define DIO22_PIN   PIND5
-#define DIO22_RPORT PIND
-#define DIO22_WPORT PORTD
-#define DIO22_DDR   DDRD
-#define DIO22_PWM   nullptr
-
-#define DIO23_PIN   PIND6
-#define DIO23_RPORT PIND
-#define DIO23_WPORT PORTD
-#define DIO23_DDR   DDRD
-#define DIO23_PWM   nullptr
-
-#define DIO24_PIN   PIND7
-#define DIO24_RPORT PIND
-#define DIO24_WPORT PORTD
-#define DIO24_DDR   DDRD
-#define DIO24_PWM   nullptr
-
-#define DIO25_PIN   PING0
-#define DIO25_RPORT PING
-#define DIO25_WPORT PORTG
-#define DIO25_DDR   DDRG
-#define DIO25_PWM   nullptr
-
-#define DIO26_PIN   PING1
-#define DIO26_RPORT PING
-#define DIO26_WPORT PORTG
-#define DIO26_DDR   DDRG
-#define DIO26_PWM   nullptr
-
-#define DIO27_PIN   PING2
-#define DIO27_RPORT PING
-#define DIO27_WPORT PORTG
-#define DIO27_DDR   DDRG
-#define DIO27_PWM   nullptr
-
-#define DIO28_PIN   PING3
-#define DIO28_RPORT PING
-#define DIO28_WPORT PORTG
-#define DIO28_DDR   DDRG
-#define DIO28_PWM   nullptr
-
-#define DIO29_PIN   PING4
-#define DIO29_RPORT PING
-#define DIO29_WPORT PORTG
-#define DIO29_DDR   DDRG
-#define DIO29_PWM   nullptr
-
-#define DIO30_PIN   PINC0
-#define DIO30_RPORT PINC
-#define DIO30_WPORT PORTC
-#define DIO30_DDR   DDRC
-#define DIO30_PWM   nullptr
-
-#define DIO31_PIN   PINC1
-#define DIO31_RPORT PINC
-#define DIO31_WPORT PORTC
-#define DIO31_DDR   DDRC
-#define DIO31_PWM   nullptr
-
-#define DIO32_PIN   PINC2
-#define DIO32_RPORT PINC
-#define DIO32_WPORT PORTC
-#define DIO32_DDR   DDRC
-#define DIO32_PWM   nullptr
-
-#define DIO33_PIN   PINC3
-#define DIO33_RPORT PINC
-#define DIO33_WPORT PORTC
-#define DIO33_DDR   DDRC
-#define DIO33_PWM   nullptr
-
-#define DIO34_PIN   PINC4
-#define DIO34_RPORT PINC
-#define DIO34_WPORT PORTC
-#define DIO34_DDR   DDRC
-#define DIO34_PWM   nullptr
-
-#define DIO35_PIN   PINC5
-#define DIO35_RPORT PINC
-#define DIO35_WPORT PORTC
-#define DIO35_DDR   DDRC
-#define DIO35_PWM   nullptr
-
-#define DIO36_PIN   PINC6
-#define DIO36_RPORT PINC
-#define DIO36_WPORT PORTC
-#define DIO36_DDR   DDRC
-#define DIO36_PWM   nullptr
-
-#define DIO37_PIN   PINC7
-#define DIO37_RPORT PINC
-#define DIO37_WPORT PORTC
-#define DIO37_DDR   DDRC
-#define DIO37_PWM   nullptr
-
-#define DIO38_PIN   PINA0
-#define DIO38_RPORT PINA
-#define DIO38_WPORT PORTA
-#define DIO38_DDR   DDRA
-#define DIO38_PWM   nullptr
-
-#define DIO39_PIN   PINA1
-#define DIO39_RPORT PINA
-#define DIO39_WPORT PORTA
-#define DIO39_DDR   DDRA
-#define DIO39_PWM   nullptr
-
-#define DIO40_PIN   PINA2
-#define DIO40_RPORT PINA
-#define DIO40_WPORT PORTA
-#define DIO40_DDR   DDRA
-#define DIO40_PWM   nullptr
-
-#define DIO41_PIN   PINA3
-#define DIO41_RPORT PINA
-#define DIO41_WPORT PORTA
-#define DIO41_DDR   DDRA
-#define DIO41_PWM   nullptr
-
-#define DIO42_PIN   PINA4
-#define DIO42_RPORT PINA
-#define DIO42_WPORT PORTA
-#define DIO42_DDR   DDRA
-#define DIO42_PWM   nullptr
-
-#define DIO43_PIN   PINA5
-#define DIO43_RPORT PINA
-#define DIO43_WPORT PORTA
-#define DIO43_DDR   DDRA
-#define DIO43_PWM   nullptr
-
-#define DIO44_PIN   PINA6
-#define DIO44_RPORT PINA
-#define DIO44_WPORT PORTA
-#define DIO44_DDR   DDRA
-#define DIO44_PWM   nullptr
-
-#define DIO45_PIN   PINA7
-#define DIO45_RPORT PINA
-#define DIO45_WPORT PORTA
-#define DIO45_DDR   DDRA
-#define DIO45_PWM   nullptr
-
-#define DIO46_PIN   PINF0
-#define DIO46_RPORT PINF
-#define DIO46_WPORT PORTF
-#define DIO46_DDR   DDRF
-#define DIO46_PWM   nullptr
-
-#define DIO47_PIN   PINF1
-#define DIO47_RPORT PINF
-#define DIO47_WPORT PORTF
-#define DIO47_DDR   DDRF
-#define DIO47_PWM   nullptr
-
-#define DIO48_PIN   PINF2
-#define DIO48_RPORT PINF
-#define DIO48_WPORT PORTF
-#define DIO48_DDR   DDRF
-#define DIO48_PWM   nullptr
-
-#define DIO49_PIN   PINF3
-#define DIO49_RPORT PINF
-#define DIO49_WPORT PORTF
-#define DIO49_DDR   DDRF
-#define DIO49_PWM   nullptr
-
-#define DIO50_PIN   PINF4
-#define DIO50_RPORT PINF
-#define DIO50_WPORT PORTF
-#define DIO50_DDR   DDRF
-#define DIO50_PWM   nullptr
-
-#define DIO51_PIN   PINF5
-#define DIO51_RPORT PINF
-#define DIO51_WPORT PORTF
-#define DIO51_DDR   DDRF
-#define DIO51_PWM   nullptr
-
-#define DIO52_PIN   PINF6
-#define DIO52_RPORT PINF
-#define DIO52_WPORT PORTF
-#define DIO52_DDR   DDRF
-#define DIO52_PWM   nullptr
-
-#define DIO53_PIN   PINF7
-#define DIO53_RPORT PINF
-#define DIO53_WPORT PORTF
-#define DIO53_DDR   DDRF
-#define DIO53_PWM   nullptr
-
-#undef PA0
-#define PA0_PIN     PINA0
-#define PA0_RPORT   PINA
-#define PA0_WPORT   PORTA
-#define PA0_DDR     DDRA
-#define PA0_PWM     nullptr
-#undef PA1
-#define PA1_PIN     PINA1
-#define PA1_RPORT   PINA
-#define PA1_WPORT   PORTA
-#define PA1_DDR     DDRA
-#define PA1_PWM     nullptr
-#undef PA2
-#define PA2_PIN     PINA2
-#define PA2_RPORT   PINA
-#define PA2_WPORT   PORTA
-#define PA2_DDR     DDRA
-#define PA2_PWM     nullptr
-#undef PA3
-#define PA3_PIN     PINA3
-#define PA3_RPORT   PINA
-#define PA3_WPORT   PORTA
-#define PA3_DDR     DDRA
-#define PA3_PWM     nullptr
-#undef PA4
-#define PA4_PIN     PINA4
-#define PA4_RPORT   PINA
-#define PA4_WPORT   PORTA
-#define PA4_DDR     DDRA
-#define PA4_PWM     nullptr
-#undef PA5
-#define PA5_PIN     PINA5
-#define PA5_RPORT   PINA
-#define PA5_WPORT   PORTA
-#define PA5_DDR     DDRA
-#define PA5_PWM     nullptr
-#undef PA6
-#define PA6_PIN     PINA6
-#define PA6_RPORT   PINA
-#define PA6_WPORT   PORTA
-#define PA6_DDR     DDRA
-#define PA6_PWM     nullptr
-#undef PA7
-#define PA7_PIN     PINA7
-#define PA7_RPORT   PINA
-#define PA7_WPORT   PORTA
-#define PA7_DDR     DDRA
-#define PA7_PWM     nullptr
-
-#undef PB0
-#define PB0_PIN     PINB0
-#define PB0_RPORT   PINB
-#define PB0_WPORT   PORTB
-#define PB0_DDR     DDRB
-#define PB0_PWM     nullptr
-#undef PB1
-#define PB1_PIN     PINB1
-#define PB1_RPORT   PINB
-#define PB1_WPORT   PORTB
-#define PB1_DDR     DDRB
-#define PB1_PWM     nullptr
-#undef PB2
-#define PB2_PIN     PINB2
-#define PB2_RPORT   PINB
-#define PB2_WPORT   PORTB
-#define PB2_DDR     DDRB
-#define PB2_PWM     nullptr
-#undef PB3
-#define PB3_PIN     PINB3
-#define PB3_RPORT   PINB
-#define PB3_WPORT   PORTB
-#define PB3_DDR     DDRB
-#define PB3_PWM     nullptr
-#undef PB4
-#define PB4_PIN     PINB4
-#define PB4_RPORT   PINB
-#define PB4_WPORT   PORTB
-#define PB4_DDR     DDRB
-#define PB4_PWM     &OCR2A
-#undef PB5
-#define PB5_PIN     PINB5
-#define PB5_RPORT   PINB
-#define PB5_WPORT   PORTB
-#define PB5_DDR     DDRB
-#define PB5_PWM     nullptr
-#undef PB6
-#define PB6_PIN     PINB6
-#define PB6_RPORT   PINB
-#define PB6_WPORT   PORTB
-#define PB6_DDR     DDRB
-#define PB6_PWM     nullptr
-#undef PB7
-#define PB7_PIN     PINB7
-#define PB7_RPORT   PINB
-#define PB7_WPORT   PORTB
-#define PB7_DDR     DDRB
-#define PB7_PWM     &OCR0A
-
-#undef PC0
-#define PC0_PIN     PINC0
-#define PC0_RPORT   PINC
-#define PC0_WPORT   PORTC
-#define PC0_DDR     DDRC
-#define PC0_PWM     nullptr
-#undef PC1
-#define PC1_PIN     PINC1
-#define PC1_RPORT   PINC
-#define PC1_WPORT   PORTC
-#define PC1_DDR     DDRC
-#define PC1_PWM     nullptr
-#undef PC2
-#define PC2_PIN     PINC2
-#define PC2_RPORT   PINC
-#define PC2_WPORT   PORTC
-#define PC2_DDR     DDRC
-#define PC2_PWM     nullptr
-#undef PC3
-#define PC3_PIN     PINC3
-#define PC3_RPORT   PINC
-#define PC3_WPORT   PORTC
-#define PC3_DDR     DDRC
-#define PC3_PWM     nullptr
-#undef PC4
-#define PC4_PIN     PINC4
-#define PC4_RPORT   PINC
-#define PC4_WPORT   PORTC
-#define PC4_DDR     DDRC
-#define PC4_PWM     nullptr
-#undef PC5
-#define PC5_PIN     PINC5
-#define PC5_RPORT   PINC
-#define PC5_WPORT   PORTC
-#define PC5_DDR     DDRC
-#define PC5_PWM     nullptr
-#undef PC6
-#define PC6_PIN     PINC6
-#define PC6_RPORT   PINC
-#define PC6_WPORT   PORTC
-#define PC6_DDR     DDRC
-#define PC6_PWM     nullptr
-#undef PC7
-#define PC7_PIN     PINC7
-#define PC7_RPORT   PINC
-#define PC7_WPORT   PORTC
-#define PC7_DDR     DDRC
-#define PC7_PWM     nullptr
-
-#undef PD0
-#define PD0_PIN     PIND0
-#define PD0_RPORT   PIND
-#define PD0_WPORT   PORTD
-#define PD0_DDR     DDRD
-#define PD0_PWM     nullptr
-#undef PD1
-#define PD1_PIN     PIND1
-#define PD1_RPORT   PIND
-#define PD1_WPORT   PORTD
-#define PD1_DDR     DDRD
-#define PD1_PWM     nullptr
-#undef PD2
-#define PD2_PIN     PIND2
-#define PD2_RPORT   PIND
-#define PD2_WPORT   PORTD
-#define PD2_DDR     DDRD
-#define PD2_PWM     nullptr
-#undef PD3
-#define PD3_PIN     PIND3
-#define PD3_RPORT   PIND
-#define PD3_WPORT   PORTD
-#define PD3_DDR     DDRD
-#define PD3_PWM     nullptr
-#undef PD4
-#define PD4_PIN     PIND4
-#define PD4_RPORT   PIND
-#define PD4_WPORT   PORTD
-#define PD4_DDR     DDRD
-#define PD4_PWM     nullptr
-#undef PD5
-#define PD5_PIN     PIND5
-#define PD5_RPORT   PIND
-#define PD5_WPORT   PORTD
-#define PD5_DDR     DDRD
-#define PD5_PWM     nullptr
-#undef PD6
-#define PD6_PIN     PIND6
-#define PD6_RPORT   PIND
-#define PD6_WPORT   PORTD
-#define PD6_DDR     DDRD
-#define PD6_PWM     nullptr
-#undef PD7
-#define PD7_PIN     PIND7
-#define PD7_RPORT   PIND
-#define PD7_WPORT   PORTD
-#define PD7_DDR     DDRD
-#define PD7_PWM     nullptr
-
-#undef PE0
-#define PE0_PIN     PINE0
-#define PE0_RPORT   PINE
-#define PE0_WPORT   PORTE
-#define PE0_DDR     DDRE
-#define PE0_PWM     nullptr
-#undef PE1
-#define PE1_PIN     PINE1
-#define PE1_RPORT   PINE
-#define PE1_WPORT   PORTE
-#define PE1_DDR     DDRE
-#define PE1_PWM     nullptr
-#undef PE2
-#define PE2_PIN     PINE2
-#define PE2_RPORT   PINE
-#define PE2_WPORT   PORTE
-#define PE2_DDR     DDRE
-#define PE2_PWM     nullptr
-#undef PE3
-#define PE3_PIN     PINE3
-#define PE3_RPORT   PINE
-#define PE3_WPORT   PORTE
-#define PE3_DDR     DDRE
-#define PE3_PWM     &OCR3AL
-#undef PE4
-#define PE4_PIN     PINE4
-#define PE4_RPORT   PINE
-#define PE4_WPORT   PORTE
-#define PE4_DDR     DDRE
-#define PE4_PWM     &OCR3BL
-#undef PE5
-#define PE5_PIN     PINE5
-#define PE5_RPORT   PINE
-#define PE5_WPORT   PORTE
-#define PE5_DDR     DDRE
-#define PE5_PWM     &OCR3CL
-#undef PE6
-#define PE6_PIN     PINE6
-#define PE6_RPORT   PINE
-#define PE6_WPORT   PORTE
-#define PE6_DDR     DDRE
-#define PE6_PWM     nullptr
-#undef PE7
-#define PE7_PIN     PINE7
-#define PE7_RPORT   PINE
-#define PE7_WPORT   PORTE
-#define PE7_DDR     DDRE
-#define PE7_PWM     nullptr
-
-#undef PF0
-#define PF0_PIN     PINF0
-#define PF0_RPORT   PINF
-#define PF0_WPORT   PORTF
-#define PF0_DDR     DDRF
-#define PF0_PWM     nullptr
-#undef PF1
-#define PF1_PIN     PINF1
-#define PF1_RPORT   PINF
-#define PF1_WPORT   PORTF
-#define PF1_DDR     DDRF
-#define PF1_PWM     nullptr
-#undef PF2
-#define PF2_PIN     PINF2
-#define PF2_RPORT   PINF
-#define PF2_WPORT   PORTF
-#define PF2_DDR     DDRF
-#define PF2_PWM     nullptr
-#undef PF3
-#define PF3_PIN     PINF3
-#define PF3_RPORT   PINF
-#define PF3_WPORT   PORTF
-#define PF3_DDR     DDRF
-#define PF3_PWM     nullptr
-#undef PF4
-#define PF4_PIN     PINF4
-#define PF4_RPORT   PINF
-#define PF4_WPORT   PORTF
-#define PF4_DDR     DDRF
-#define PF4_PWM     nullptr
-#undef PF5
-#define PF5_PIN     PINF5
-#define PF5_RPORT   PINF
-#define PF5_WPORT   PORTF
-#define PF5_DDR     DDRF
-#define PF5_PWM     nullptr
-#undef PF6
-#define PF6_PIN     PINF6
-#define PF6_RPORT   PINF
-#define PF6_WPORT   PORTF
-#define PF6_DDR     DDRF
-#define PF6_PWM     nullptr
-#undef PF7
-#define PF7_PIN     PINF7
-#define PF7_RPORT   PINF
-#define PF7_WPORT   PORTF
-#define PF7_DDR     DDRF
-#define PF7_PWM     nullptr
-
-#undef PG0
-#define PG0_PIN     PING0
-#define PG0_RPORT   PING
-#define PG0_WPORT   PORTG
-#define PG0_DDR     DDRG
-#define PG0_PWM     nullptr
-#undef PG1
-#define PG1_PIN     PING1
-#define PG1_RPORT   PING
-#define PG1_WPORT   PORTG
-#define PG1_DDR     DDRG
-#define PG1_PWM     nullptr
-#undef PG2
-#define PG2_PIN     PING2
-#define PG2_RPORT   PING
-#define PG2_WPORT   PORTG
-#define PG2_DDR     DDRG
-#define PG2_PWM     nullptr
-#undef PG3
-#define PG3_PIN     PING3
-#define PG3_RPORT   PING
-#define PG3_WPORT   PORTG
-#define PG3_DDR     DDRG
-#define PG3_PWM     nullptr
-#undef PG4
-#define PG4_PIN     PING4
-#define PG4_RPORT   PING
-#define PG4_WPORT   PORTG
-#define PG4_DDR     DDRG
-#define PG4_PWM     nullptr
-#undef PG5
-#define PG5_PIN     PING5
-#define PG5_RPORT   PING
-#define PG5_WPORT   PORTG
-#define PG5_DDR     DDRG
-#define PG5_PWM     &OCR0B
diff --git a/Marlin/src/HAL/AVR/fastio/fastio_168.h b/Marlin/src/HAL/AVR/fastio/fastio_168.h
deleted file mode 100644
index 8cfdd1e..0000000
--- a/Marlin/src/HAL/AVR/fastio/fastio_168.h
+++ /dev/null
@@ -1,357 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Pin mapping for the 168, 328, and 328P
- *
- *   Logical Pin: 08 09 10 11 12 13 14 15 16 17 18 19 20 21 00 01 02 03 04 05 06 07
- *   Port:        B0 B1 B2 B3 B4 B5 C0 C1 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7
- */
-
-#include "../fastio.h"
-
-#define DEBUG_LED   AIO5
-
-// UART
-#define RXD         DIO0
-#define TXD         DIO1
-
-// SPI
-#define SCK         DIO13
-#define MISO        DIO12
-#define MOSI        DIO11
-#define SS          DIO10
-
-// TWI (I2C)
-#define SCL         AIO5
-#define SDA         AIO4
-
-// Timers and PWM
-#define OC0A        DIO6
-#define OC0B        DIO5
-#define OC1A        DIO9
-#define OC1B        DIO10
-#define OC2A        DIO11
-#define OC2B        DIO3
-
-// Digital I/O
-
-#define DIO0_PIN    PIND0
-#define DIO0_RPORT  PIND
-#define DIO0_WPORT  PORTD
-#define DIO0_DDR    DDRD
-#define DIO0_PWM    nullptr
-
-#define DIO1_PIN    PIND1
-#define DIO1_RPORT  PIND
-#define DIO1_WPORT  PORTD
-#define DIO1_DDR    DDRD
-#define DIO1_PWM    nullptr
-
-#define DIO2_PIN    PIND2
-#define DIO2_RPORT  PIND
-#define DIO2_WPORT  PORTD
-#define DIO2_DDR    DDRD
-#define DIO2_PWM    nullptr
-
-#define DIO3_PIN    PIND3
-#define DIO3_RPORT  PIND
-#define DIO3_WPORT  PORTD
-#define DIO3_DDR    DDRD
-#define DIO3_PWM    &OCR2B
-
-#define DIO4_PIN    PIND4
-#define DIO4_RPORT  PIND
-#define DIO4_WPORT  PORTD
-#define DIO4_DDR    DDRD
-#define DIO4_PWM    nullptr
-
-#define DIO5_PIN    PIND5
-#define DIO5_RPORT  PIND
-#define DIO5_WPORT  PORTD
-#define DIO5_DDR    DDRD
-#define DIO5_PWM    &OCR0B
-
-#define DIO6_PIN    PIND6
-#define DIO6_RPORT  PIND
-#define DIO6_WPORT  PORTD
-#define DIO6_DDR    DDRD
-#define DIO6_PWM    &OCR0A
-
-#define DIO7_PIN    PIND7
-#define DIO7_RPORT  PIND
-#define DIO7_WPORT  PORTD
-#define DIO7_DDR    DDRD
-#define DIO7_PWM    nullptr
-
-#define DIO8_PIN    PINB0
-#define DIO8_RPORT  PINB
-#define DIO8_WPORT  PORTB
-#define DIO8_DDR    DDRB
-#define DIO8_PWM    nullptr
-
-#define DIO9_PIN    PINB1
-#define DIO9_RPORT  PINB
-#define DIO9_WPORT  PORTB
-#define DIO9_DDR    DDRB
-#define DIO9_PWM    nullptr
-
-#define DIO10_PIN   PINB2
-#define DIO10_RPORT PINB
-#define DIO10_WPORT PORTB
-#define DIO10_DDR   DDRB
-#define DIO10_PWM   nullptr
-
-#define DIO11_PIN   PINB3
-#define DIO11_RPORT PINB
-#define DIO11_WPORT PORTB
-#define DIO11_DDR   DDRB
-#define DIO11_PWM   &OCR2A
-
-#define DIO12_PIN   PINB4
-#define DIO12_RPORT PINB
-#define DIO12_WPORT PORTB
-#define DIO12_DDR   DDRB
-#define DIO12_PWM   nullptr
-
-#define DIO13_PIN   PINB5
-#define DIO13_RPORT PINB
-#define DIO13_WPORT PORTB
-#define DIO13_DDR   DDRB
-#define DIO13_PWM   nullptr
-
-#define DIO14_PIN   PINC0
-#define DIO14_RPORT PINC
-#define DIO14_WPORT PORTC
-#define DIO14_DDR   DDRC
-#define DIO14_PWM   nullptr
-
-#define DIO15_PIN   PINC1
-#define DIO15_RPORT PINC
-#define DIO15_WPORT PORTC
-#define DIO15_DDR   DDRC
-#define DIO15_PWM   nullptr
-
-#define DIO16_PIN   PINC2
-#define DIO16_RPORT PINC
-#define DIO16_WPORT PORTC
-#define DIO16_DDR   DDRC
-#define DIO16_PWM   nullptr
-
-#define DIO17_PIN   PINC3
-#define DIO17_RPORT PINC
-#define DIO17_WPORT PORTC
-#define DIO17_DDR   DDRC
-#define DIO17_PWM   nullptr
-
-#define DIO18_PIN   PINC4
-#define DIO18_RPORT PINC
-#define DIO18_WPORT PORTC
-#define DIO18_DDR   DDRC
-#define DIO18_PWM   nullptr
-
-#define DIO19_PIN   PINC5
-#define DIO19_RPORT PINC
-#define DIO19_WPORT PORTC
-#define DIO19_DDR   DDRC
-#define DIO19_PWM   nullptr
-
-#define DIO20_PIN   PINC6
-#define DIO20_RPORT PINC
-#define DIO20_WPORT PORTC
-#define DIO20_DDR   DDRC
-#define DIO20_PWM   nullptr
-
-#define DIO21_PIN   PINC7
-#define DIO21_RPORT PINC
-#define DIO21_WPORT PORTC
-#define DIO21_DDR   DDRC
-#define DIO21_PWM   nullptr
-
-#undef PB0
-#define PB0_PIN     PINB0
-#define PB0_RPORT   PINB
-#define PB0_WPORT   PORTB
-#define PB0_DDR     DDRB
-#define PB0_PWM     nullptr
-
-#undef PB1
-#define PB1_PIN     PINB1
-#define PB1_RPORT   PINB
-#define PB1_WPORT   PORTB
-#define PB1_DDR     DDRB
-#define PB1_PWM     nullptr
-
-#undef PB2
-#define PB2_PIN     PINB2
-#define PB2_RPORT   PINB
-#define PB2_WPORT   PORTB
-#define PB2_DDR     DDRB
-#define PB2_PWM     nullptr
-
-#undef PB3
-#define PB3_PIN     PINB3
-#define PB3_RPORT   PINB
-#define PB3_WPORT   PORTB
-#define PB3_DDR     DDRB
-#define PB3_PWM     &OCR2A
-
-#undef PB4
-#define PB4_PIN     PINB4
-#define PB4_RPORT   PINB
-#define PB4_WPORT   PORTB
-#define PB4_DDR     DDRB
-#define PB4_PWM     nullptr
-
-#undef PB5
-#define PB5_PIN     PINB5
-#define PB5_RPORT   PINB
-#define PB5_WPORT   PORTB
-#define PB5_DDR     DDRB
-#define PB5_PWM     nullptr
-
-#undef PB6
-#define PB6_PIN     PINB6
-#define PB6_RPORT   PINB
-#define PB6_WPORT   PORTB
-#define PB6_DDR     DDRB
-#define PB6_PWM     nullptr
-
-#undef PB7
-#define PB7_PIN     PINB7
-#define PB7_RPORT   PINB
-#define PB7_WPORT   PORTB
-#define PB7_DDR     DDRB
-#define PB7_PWM     nullptr
-
-#undef PC0
-#define PC0_PIN     PINC0
-#define PC0_RPORT   PINC
-#define PC0_WPORT   PORTC
-#define PC0_DDR     DDRC
-#define PC0_PWM     nullptr
-
-#undef PC1
-#define PC1_PIN     PINC1
-#define PC1_RPORT   PINC
-#define PC1_WPORT   PORTC
-#define PC1_DDR     DDRC
-#define PC1_PWM     nullptr
-
-#undef PC2
-#define PC2_PIN     PINC2
-#define PC2_RPORT   PINC
-#define PC2_WPORT   PORTC
-#define PC2_DDR     DDRC
-#define PC2_PWM     nullptr
-
-#undef PC3
-#define PC3_PIN     PINC3
-#define PC3_RPORT   PINC
-#define PC3_WPORT   PORTC
-#define PC3_DDR     DDRC
-#define PC3_PWM     nullptr
-
-#undef PC4
-#define PC4_PIN     PINC4
-#define PC4_RPORT   PINC
-#define PC4_WPORT   PORTC
-#define PC4_DDR     DDRC
-#define PC4_PWM     nullptr
-
-#undef PC5
-#define PC5_PIN     PINC5
-#define PC5_RPORT   PINC
-#define PC5_WPORT   PORTC
-#define PC5_DDR     DDRC
-#define PC5_PWM     nullptr
-
-#undef PC6
-#define PC6_PIN     PINC6
-#define PC6_RPORT   PINC
-#define PC6_WPORT   PORTC
-#define PC6_DDR     DDRC
-#define PC6_PWM     nullptr
-
-#undef PC7
-#define PC7_PIN     PINC7
-#define PC7_RPORT   PINC
-#define PC7_WPORT   PORTC
-#define PC7_DDR     DDRC
-#define PC7_PWM     nullptr
-
-#undef PD0
-#define PD0_PIN     PIND0
-#define PD0_RPORT   PIND
-#define PD0_WPORT   PORTD
-#define PD0_DDR     DDRD
-#define PD0_PWM     nullptr
-
-#undef PD1
-#define PD1_PIN     PIND1
-#define PD1_RPORT   PIND
-#define PD1_WPORT   PORTD
-#define PD1_DDR     DDRD
-#define PD1_PWM     nullptr
-
-#undef PD2
-#define PD2_PIN     PIND2
-#define PD2_RPORT   PIND
-#define PD2_WPORT   PORTD
-#define PD2_DDR     DDRD
-#define PD2_PWM     nullptr
-
-#undef PD3
-#define PD3_PIN     PIND3
-#define PD3_RPORT   PIND
-#define PD3_WPORT   PORTD
-#define PD3_DDR     DDRD
-#define PD3_PWM     &OCR2B
-
-#undef PD4
-#define PD4_PIN     PIND4
-#define PD4_RPORT   PIND
-#define PD4_WPORT   PORTD
-#define PD4_DDR     DDRD
-#define PD4_PWM     nullptr
-
-#undef PD5
-#define PD5_PIN     PIND5
-#define PD5_RPORT   PIND
-#define PD5_WPORT   PORTD
-#define PD5_DDR     DDRD
-#define PD5_PWM     &OCR0B
-
-#undef PD6
-#define PD6_PIN     PIND6
-#define PD6_RPORT   PIND
-#define PD6_WPORT   PORTD
-#define PD6_DDR     DDRD
-#define PD6_PWM     &OCR0A
-
-#undef PD7
-#define PD7_PIN     PIND7
-#define PD7_RPORT   PIND
-#define PD7_WPORT   PORTD
-#define PD7_DDR     DDRD
-#define PD7_PWM     nullptr
diff --git a/Marlin/src/HAL/AVR/fastio/fastio_644.h b/Marlin/src/HAL/AVR/fastio/fastio_644.h
deleted file mode 100644
index f4a9427..0000000
--- a/Marlin/src/HAL/AVR/fastio/fastio_644.h
+++ /dev/null
@@ -1,552 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Pin mapping for the 644, 644p, 644pa, and 1284p
- *
- *   Logical Pin: 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
- *   Port:        B0 B1 B2 B3 B4 B5 B6 B7 D0 D1 D2 D3 D4 D5 D6 D7 C0 C1 C2 C3 C4 C5 C6 C7 A7 A6 A5 A4 A3 A2 A1 A0
- */
-
-/**                        ATMega644
- *
- *                        +---\/---+
- *            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
- *            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
- *       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
- *        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
- *        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
- *       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
- *       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
- *        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
- *                  RST  9|        |32  AREF
- *                  VCC 10|        |31  GND
- *                  GND 11|        |30  AVCC
- *                XTAL2 12|        |29  PC7 (D 23)
- *                XTAL1 13|        |28  PC6 (D 22)
- *       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
- *       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
- *  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
- *  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
- *       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
- *       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
- *       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
- *                        +--------+
- */
-
-#include "../fastio.h"
-
-#define DEBUG_LED   DIO0
-
-// UART
-#define RXD         DIO8
-#define TXD         DIO9
-#define RXD0        DIO8
-#define TXD0        DIO9
-
-#define RXD1        DIO10
-#define TXD1        DIO11
-
-// SPI
-#define SCK         DIO7
-#define MISO        DIO6
-#define MOSI        DIO5
-#define SS          DIO4
-
-// TWI (I2C)
-#define SCL         DIO16
-#define SDA         DIO17
-
-// Timers and PWM
-#define OC0A        DIO3
-#define OC0B        DIO4
-#define OC1A        DIO13
-#define OC1B        DIO12
-#define OC2A        DIO15
-#define OC2B        DIO14
-
-// Digital I/O
-
-#define DIO0_PIN    PINB0
-#define DIO0_RPORT  PINB
-#define DIO0_WPORT  PORTB
-#define DIO0_DDR    DDRB
-#define DIO0_PWM    nullptr
-
-#define DIO1_PIN    PINB1
-#define DIO1_RPORT  PINB
-#define DIO1_WPORT  PORTB
-#define DIO1_DDR    DDRB
-#define DIO1_PWM    nullptr
-
-#define DIO2_PIN    PINB2
-#define DIO2_RPORT  PINB
-#define DIO2_WPORT  PORTB
-#define DIO2_DDR    DDRB
-#define DIO2_PWM    nullptr
-
-#define DIO3_PIN    PINB3
-#define DIO3_RPORT  PINB
-#define DIO3_WPORT  PORTB
-#define DIO3_DDR    DDRB
-#define DIO3_PWM    &OCR0A
-
-#define DIO4_PIN    PINB4
-#define DIO4_RPORT  PINB
-#define DIO4_WPORT  PORTB
-#define DIO4_DDR    DDRB
-#define DIO4_PWM    &OCR0B
-
-#define DIO5_PIN    PINB5
-#define DIO5_RPORT  PINB
-#define DIO5_WPORT  PORTB
-#define DIO5_DDR    DDRB
-#define DIO5_PWM    nullptr
-
-#define DIO6_PIN    PINB6
-#define DIO6_RPORT  PINB
-#define DIO6_WPORT  PORTB
-#define DIO6_DDR    DDRB
-#define DIO6_PWM    nullptr
-
-#define DIO7_PIN    PINB7
-#define DIO7_RPORT  PINB
-#define DIO7_WPORT  PORTB
-#define DIO7_DDR    DDRB
-#define DIO7_PWM    nullptr
-
-#define DIO8_PIN    PIND0
-#define DIO8_RPORT  PIND
-#define DIO8_WPORT  PORTD
-#define DIO8_DDR    DDRD
-#define DIO8_PWM    nullptr
-
-#define DIO9_PIN    PIND1
-#define DIO9_RPORT  PIND
-#define DIO9_WPORT  PORTD
-#define DIO9_DDR    DDRD
-#define DIO9_PWM    nullptr
-
-#define DIO10_PIN   PIND2
-#define DIO10_RPORT PIND
-#define DIO10_WPORT PORTD
-#define DIO10_DDR   DDRD
-#define DIO10_PWM   nullptr
-
-#define DIO11_PIN   PIND3
-#define DIO11_RPORT PIND
-#define DIO11_WPORT PORTD
-#define DIO11_DDR   DDRD
-#define DIO11_PWM   nullptr
-
-#define DIO12_PIN   PIND4
-#define DIO12_RPORT PIND
-#define DIO12_WPORT PORTD
-#define DIO12_DDR   DDRD
-#define DIO12_PWM   &OCR1B
-
-#define DIO13_PIN   PIND5
-#define DIO13_RPORT PIND
-#define DIO13_WPORT PORTD
-#define DIO13_DDR   DDRD
-#define DIO13_PWM   &OCR1A
-
-#define DIO14_PIN   PIND6
-#define DIO14_RPORT PIND
-#define DIO14_WPORT PORTD
-#define DIO14_DDR   DDRD
-#define DIO14_PWM   &OCR2B
-
-#define DIO15_PIN   PIND7
-#define DIO15_RPORT PIND
-#define DIO15_WPORT PORTD
-#define DIO15_DDR   DDRD
-#define DIO15_PWM   &OCR2A
-
-#define DIO16_PIN   PINC0
-#define DIO16_RPORT PINC
-#define DIO16_WPORT PORTC
-#define DIO16_DDR   DDRC
-#define DIO16_PWM   nullptr
-
-#define DIO17_PIN   PINC1
-#define DIO17_RPORT PINC
-#define DIO17_WPORT PORTC
-#define DIO17_DDR   DDRC
-#define DIO17_PWM   nullptr
-
-#define DIO18_PIN   PINC2
-#define DIO18_RPORT PINC
-#define DIO18_WPORT PORTC
-#define DIO18_DDR   DDRC
-#define DIO18_PWM   nullptr
-
-#define DIO19_PIN   PINC3
-#define DIO19_RPORT PINC
-#define DIO19_WPORT PORTC
-#define DIO19_DDR   DDRC
-#define DIO19_PWM   nullptr
-
-#define DIO20_PIN   PINC4
-#define DIO20_RPORT PINC
-#define DIO20_WPORT PORTC
-#define DIO20_DDR   DDRC
-#define DIO20_PWM   nullptr
-
-#define DIO21_PIN   PINC5
-#define DIO21_RPORT PINC
-#define DIO21_WPORT PORTC
-#define DIO21_DDR   DDRC
-#define DIO21_PWM   nullptr
-
-#define DIO22_PIN   PINC6
-#define DIO22_RPORT PINC
-#define DIO22_WPORT PORTC
-#define DIO22_DDR   DDRC
-#define DIO22_PWM   nullptr
-
-#define DIO23_PIN   PINC7
-#define DIO23_RPORT PINC
-#define DIO23_WPORT PORTC
-#define DIO23_DDR   DDRC
-#define DIO23_PWM   nullptr
-
-#define DIO24_PIN   PINA7
-#define DIO24_RPORT PINA
-#define DIO24_WPORT PORTA
-#define DIO24_DDR   DDRA
-#define DIO24_PWM   nullptr
-
-#define DIO25_PIN   PINA6
-#define DIO25_RPORT PINA
-#define DIO25_WPORT PORTA
-#define DIO25_DDR   DDRA
-#define DIO25_PWM   nullptr
-
-#define DIO26_PIN   PINA5
-#define DIO26_RPORT PINA
-#define DIO26_WPORT PORTA
-#define DIO26_DDR   DDRA
-#define DIO26_PWM   nullptr
-
-#define DIO27_PIN   PINA4
-#define DIO27_RPORT PINA
-#define DIO27_WPORT PORTA
-#define DIO27_DDR   DDRA
-#define DIO27_PWM   nullptr
-
-#define DIO28_PIN   PINA3
-#define DIO28_RPORT PINA
-#define DIO28_WPORT PORTA
-#define DIO28_DDR   DDRA
-#define DIO28_PWM   nullptr
-
-#define DIO29_PIN   PINA2
-#define DIO29_RPORT PINA
-#define DIO29_WPORT PORTA
-#define DIO29_DDR   DDRA
-#define DIO29_PWM   nullptr
-
-#define DIO30_PIN   PINA1
-#define DIO30_RPORT PINA
-#define DIO30_WPORT PORTA
-#define DIO30_DDR   DDRA
-#define DIO30_PWM   nullptr
-
-#define DIO31_PIN   PINA0
-#define DIO31_RPORT PINA
-#define DIO31_WPORT PORTA
-#define DIO31_DDR   DDRA
-#define DIO31_PWM   nullptr
-
-#define AIO0_PIN    PINA0
-#define AIO0_RPORT  PINA
-#define AIO0_WPORT  PORTA
-#define AIO0_DDR    DDRA
-#define AIO0_PWM    nullptr
-
-#define AIO1_PIN    PINA1
-#define AIO1_RPORT  PINA
-#define AIO1_WPORT  PORTA
-#define AIO1_DDR    DDRA
-#define AIO1_PWM    nullptr
-
-#define AIO2_PIN    PINA2
-#define AIO2_RPORT  PINA
-#define AIO2_WPORT  PORTA
-#define AIO2_DDR    DDRA
-#define AIO2_PWM    nullptr
-
-#define AIO3_PIN    PINA3
-#define AIO3_RPORT  PINA
-#define AIO3_WPORT  PORTA
-#define AIO3_DDR    DDRA
-#define AIO3_PWM    nullptr
-
-#define AIO4_PIN    PINA4
-#define AIO4_RPORT  PINA
-#define AIO4_WPORT  PORTA
-#define AIO4_DDR    DDRA
-#define AIO4_PWM    nullptr
-
-#define AIO5_PIN    PINA5
-#define AIO5_RPORT  PINA
-#define AIO5_WPORT  PORTA
-#define AIO5_DDR    DDRA
-#define AIO5_PWM    nullptr
-
-#define AIO6_PIN    PINA6
-#define AIO6_RPORT  PINA
-#define AIO6_WPORT  PORTA
-#define AIO6_DDR    DDRA
-#define AIO6_PWM    nullptr
-
-#define AIO7_PIN    PINA7
-#define AIO7_RPORT  PINA
-#define AIO7_WPORT  PORTA
-#define AIO7_DDR    DDRA
-#define AIO7_PWM    nullptr
-
-#undef PA0
-#define PA0_PIN     PINA0
-#define PA0_RPORT   PINA
-#define PA0_WPORT   PORTA
-#define PA0_DDR     DDRA
-#define PA0_PWM     nullptr
-
-#undef PA1
-#define PA1_PIN     PINA1
-#define PA1_RPORT   PINA
-#define PA1_WPORT   PORTA
-#define PA1_DDR     DDRA
-#define PA1_PWM     nullptr
-
-#undef PA2
-#define PA2_PIN     PINA2
-#define PA2_RPORT   PINA
-#define PA2_WPORT   PORTA
-#define PA2_DDR     DDRA
-#define PA2_PWM     nullptr
-
-#undef PA3
-#define PA3_PIN     PINA3
-#define PA3_RPORT   PINA
-#define PA3_WPORT   PORTA
-#define PA3_DDR     DDRA
-#define PA3_PWM     nullptr
-
-#undef PA4
-#define PA4_PIN     PINA4
-#define PA4_RPORT   PINA
-#define PA4_WPORT   PORTA
-#define PA4_DDR     DDRA
-#define PA4_PWM     nullptr
-
-#undef PA5
-#define PA5_PIN     PINA5
-#define PA5_RPORT   PINA
-#define PA5_WPORT   PORTA
-#define PA5_DDR     DDRA
-#define PA5_PWM     nullptr
-
-#undef PA6
-#define PA6_PIN     PINA6
-#define PA6_RPORT   PINA
-#define PA6_WPORT   PORTA
-#define PA6_DDR     DDRA
-#define PA6_PWM     nullptr
-
-#undef PA7
-#define PA7_PIN     PINA7
-#define PA7_RPORT   PINA
-#define PA7_WPORT   PORTA
-#define PA7_DDR     DDRA
-#define PA7_PWM     nullptr
-
-#undef PB0
-#define PB0_PIN     PINB0
-#define PB0_RPORT   PINB
-#define PB0_WPORT   PORTB
-#define PB0_DDR     DDRB
-#define PB0_PWM     nullptr
-
-#undef PB1
-#define PB1_PIN     PINB1
-#define PB1_RPORT   PINB
-#define PB1_WPORT   PORTB
-#define PB1_DDR     DDRB
-#define PB1_PWM     nullptr
-
-#undef PB2
-#define PB2_PIN     PINB2
-#define PB2_RPORT   PINB
-#define PB2_WPORT   PORTB
-#define PB2_DDR     DDRB
-#define PB2_PWM     nullptr
-
-#undef PB3
-#define PB3_PIN     PINB3
-#define PB3_RPORT   PINB
-#define PB3_WPORT   PORTB
-#define PB3_DDR     DDRB
-#define PB3_PWM     &OCR0A
-
-#undef PB4
-#define PB4_PIN     PINB4
-#define PB4_RPORT   PINB
-#define PB4_WPORT   PORTB
-#define PB4_DDR     DDRB
-#define PB4_PWM     &OCR0B
-
-#undef PB5
-#define PB5_PIN     PINB5
-#define PB5_RPORT   PINB
-#define PB5_WPORT   PORTB
-#define PB5_DDR     DDRB
-#define PB5_PWM     nullptr
-
-#undef PB6
-#define PB6_PIN     PINB6
-#define PB6_RPORT   PINB
-#define PB6_WPORT   PORTB
-#define PB6_DDR     DDRB
-#define PB6_PWM     nullptr
-
-#undef PB7
-#define PB7_PIN     PINB7
-#define PB7_RPORT   PINB
-#define PB7_WPORT   PORTB
-#define PB7_DDR     DDRB
-#define PB7_PWM     nullptr
-
-#undef PC0
-#define PC0_PIN     PINC0
-#define PC0_RPORT   PINC
-#define PC0_WPORT   PORTC
-#define PC0_DDR     DDRC
-#define PC0_PWM     nullptr
-
-#undef PC1
-#define PC1_PIN     PINC1
-#define PC1_RPORT   PINC
-#define PC1_WPORT   PORTC
-#define PC1_DDR     DDRC
-#define PC1_PWM     nullptr
-
-#undef PC2
-#define PC2_PIN     PINC2
-#define PC2_RPORT   PINC
-#define PC2_WPORT   PORTC
-#define PC2_DDR     DDRC
-#define PC2_PWM     nullptr
-
-#undef PC3
-#define PC3_PIN     PINC3
-#define PC3_RPORT   PINC
-#define PC3_WPORT   PORTC
-#define PC3_DDR     DDRC
-#define PC3_PWM     nullptr
-
-#undef PC4
-#define PC4_PIN     PINC4
-#define PC4_RPORT   PINC
-#define PC4_WPORT   PORTC
-#define PC4_DDR     DDRC
-#define PC4_PWM     nullptr
-
-#undef PC5
-#define PC5_PIN     PINC5
-#define PC5_RPORT   PINC
-#define PC5_WPORT   PORTC
-#define PC5_DDR     DDRC
-#define PC5_PWM     nullptr
-
-#undef PC6
-#define PC6_PIN     PINC6
-#define PC6_RPORT   PINC
-#define PC6_WPORT   PORTC
-#define PC6_DDR     DDRC
-#define PC6_PWM     nullptr
-
-#undef PC7
-#define PC7_PIN     PINC7
-#define PC7_RPORT   PINC
-#define PC7_WPORT   PORTC
-#define PC7_DDR     DDRC
-#define PC7_PWM     nullptr
-
-#undef PD0
-#define PD0_PIN     PIND0
-#define PD0_RPORT   PIND
-#define PD0_WPORT   PORTD
-#define PD0_DDR     DDRD
-#define PD0_PWM     nullptr
-
-#undef PD1
-#define PD1_PIN     PIND1
-#define PD1_RPORT   PIND
-#define PD1_WPORT   PORTD
-#define PD1_DDR     DDRD
-#define PD1_PWM     nullptr
-
-#undef PD2
-#define PD2_PIN     PIND2
-#define PD2_RPORT   PIND
-#define PD2_WPORT   PORTD
-#define PD2_DDR     DDRD
-#define PD2_PWM     nullptr
-
-#undef PD3
-#define PD3_PIN     PIND3
-#define PD3_RPORT   PIND
-#define PD3_WPORT   PORTD
-#define PD3_DDR     DDRD
-#define PD3_PWM     nullptr
-
-#undef PD4
-#define PD4_PIN     PIND4
-#define PD4_RPORT   PIND
-#define PD4_WPORT   PORTD
-#define PD4_DDR     DDRD
-#define PD4_PWM     nullptr
-
-#undef PD5
-#define PD5_PIN     PIND5
-#define PD5_RPORT   PIND
-#define PD5_WPORT   PORTD
-#define PD5_DDR     DDRD
-#define PD5_PWM     nullptr
-
-#undef PD6
-#define PD6_PIN     PIND6
-#define PD6_RPORT   PIND
-#define PD6_WPORT   PORTD
-#define PD6_DDR     DDRD
-#define PD6_PWM     &OCR2B
-
-#undef PD7
-#define PD7_PIN     PIND7
-#define PD7_RPORT   PIND
-#define PD7_WPORT   PORTD
-#define PD7_DDR     DDRD
-#define PD7_PWM     &OCR2A
diff --git a/Marlin/src/HAL/AVR/fastio/fastio_AT90USB.h b/Marlin/src/HAL/AVR/fastio/fastio_AT90USB.h
deleted file mode 100644
index 51d400b..0000000
--- a/Marlin/src/HAL/AVR/fastio/fastio_AT90USB.h
+++ /dev/null
@@ -1,697 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Pin mapping (Teensy) for AT90USB646, 647, 1286, and 1287
- *
- *   Logical Pin: 28 29 30 31 32 33 34 35 20 21 22 23 24 25 26 27 10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07 08 09(46*47)36 37 18 19 38 39 40 41 42 43 44 45
- *   Port:        A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 C0 C1 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7 E0 E1 E2 E3 E4 E5 E6 E7 F0 F1 F2 F3 F4 F5 F6 F7
- *            The logical pins 46 and 47 are not supported by Teensyduino, but are supported below as E2 and E3
- */
-
-#include "../fastio.h"
-
-// change for your board
-#define DEBUG_LED   DIO31 /* led D5 red */
-
-// SPI
-#define SCK         DIO21  //  9
-#define MISO        DIO23  // 11
-#define MOSI        DIO22  // 10
-#define SS          DIO20  //  8
-
-// Digital I/O
-
-#define DIO0_PIN    PIND0
-#define DIO0_RPORT  PIND
-#define DIO0_WPORT  PORTD
-#define DIO0_PWM    0
-#define DIO0_DDR    DDRD
-
-#define DIO1_PIN    PIND1
-#define DIO1_RPORT  PIND
-#define DIO1_WPORT  PORTD
-#define DIO1_PWM    0
-#define DIO1_DDR    DDRD
-
-#define DIO2_PIN    PIND2
-#define DIO2_RPORT  PIND
-#define DIO2_WPORT  PORTD
-#define DIO2_PWM    0
-#define DIO2_DDR    DDRD
-
-#define DIO3_PIN    PIND3
-#define DIO3_RPORT  PIND
-#define DIO3_WPORT  PORTD
-#define DIO3_PWM    0
-#define DIO3_DDR    DDRD
-
-#define DIO4_PIN    PIND4
-#define DIO4_RPORT  PIND
-#define DIO4_WPORT  PORTD
-#define DIO4_PWM    0
-#define DIO4_DDR    DDRD
-
-#define DIO5_PIN    PIND5
-#define DIO5_RPORT  PIND
-#define DIO5_WPORT  PORTD
-#define DIO5_PWM    0
-#define DIO5_DDR    DDRD
-
-#define DIO6_PIN    PIND6
-#define DIO6_RPORT  PIND
-#define DIO6_WPORT  PORTD
-#define DIO6_PWM    0
-#define DIO6_DDR    DDRD
-
-#define DIO7_PIN    PIND7
-#define DIO7_RPORT  PIND
-#define DIO7_WPORT  PORTD
-#define DIO7_PWM    0
-#define DIO7_DDR    DDRD
-
-#define DIO8_PIN    PINE0
-#define DIO8_RPORT  PINE
-#define DIO8_WPORT  PORTE
-#define DIO8_PWM    0
-#define DIO8_DDR    DDRE
-
-#define DIO9_PIN    PINE1
-#define DIO9_RPORT  PINE
-#define DIO9_WPORT  PORTE
-#define DIO9_PWM    0
-#define DIO9_DDR    DDRE
-
-#define DIO10_PIN   PINC0
-#define DIO10_RPORT PINC
-#define DIO10_WPORT PORTC
-#define DIO10_PWM   0
-#define DIO10_DDR   DDRC
-
-#define DIO11_PIN   PINC1
-#define DIO11_RPORT PINC
-#define DIO11_WPORT PORTC
-#define DIO11_PWM   0
-#define DIO11_DDR   DDRC
-
-#define DIO12_PIN   PINC2
-#define DIO12_RPORT PINC
-#define DIO12_WPORT PORTC
-#define DIO12_PWM   0
-#define DIO12_DDR   DDRC
-
-#define DIO13_PIN   PINC3
-#define DIO13_RPORT PINC
-#define DIO13_WPORT PORTC
-#define DIO13_PWM   0
-#define DIO13_DDR   DDRC
-
-#define DIO14_PIN   PINC4
-#define DIO14_RPORT PINC
-#define DIO14_WPORT PORTC
-#define DIO14_PWM   0 // OC3C
-#define DIO14_DDR   DDRC
-
-#define DIO15_PIN   PINC5
-#define DIO15_RPORT PINC
-#define DIO15_WPORT PORTC
-#define DIO15_PWM   0 // OC3B
-#define DIO15_DDR   DDRC
-
-#define DIO16_PIN   PINC6
-#define DIO16_RPORT PINC
-#define DIO16_WPORT PORTC
-#define DIO16_PWM   0 // OC3A
-#define DIO16_DDR   DDRC
-
-#define DIO17_PIN   PINC7
-#define DIO17_RPORT PINC
-#define DIO17_WPORT PORTC
-#define DIO17_PWM   0
-#define DIO17_DDR   DDRC
-
-#define DIO18_PIN   PINE6
-#define DIO18_RPORT PINE
-#define DIO18_WPORT PORTE
-#define DIO18_PWM   0
-#define DIO18_DDR   DDRE
-
-#define DIO19_PIN   PINE7
-#define DIO19_RPORT PINE
-#define DIO19_WPORT PORTE
-#define DIO19_PWM   0
-#define DIO19_DDR   DDRE
-
-#define DIO20_PIN   PINB0
-#define DIO20_RPORT PINB
-#define DIO20_WPORT PORTB
-#define DIO20_PWM   0
-#define DIO20_DDR   DDRB
-
-#define DIO21_PIN   PINB1
-#define DIO21_RPORT PINB
-#define DIO21_WPORT PORTB
-#define DIO21_PWM   0
-#define DIO21_DDR   DDRB
-
-#define DIO22_PIN   PINB2
-#define DIO22_RPORT PINB
-#define DIO22_WPORT PORTB
-#define DIO22_PWM   0
-#define DIO22_DDR   DDRB
-
-#define DIO23_PIN   PINB3
-#define DIO23_RPORT PINB
-#define DIO23_WPORT PORTB
-#define DIO23_PWM   0
-#define DIO23_DDR   DDRB
-
-#define DIO24_PIN   PINB4
-#define DIO24_RPORT PINB
-#define DIO24_WPORT PORTB
-#define DIO24_PWM   0 // OC2A
-#define DIO24_DDR   DDRB
-
-#define DIO25_PIN   PINB5
-#define DIO25_RPORT PINB
-#define DIO25_WPORT PORTB
-#define DIO25_PWM   0 // OC1A
-#define DIO25_DDR   DDRB
-
-#define DIO26_PIN   PINB6
-#define DIO26_RPORT PINB
-#define DIO26_WPORT PORTB
-#define DIO26_PWM   0 // OC1B
-#define DIO26_DDR   DDRB
-
-#define DIO27_PIN   PINB7
-#define DIO27_RPORT PINB
-#define DIO27_WPORT PORTB
-#define DIO27_PWM   0 // OC1C
-#define DIO27_DDR   DDRB
-
-#define DIO28_PIN   PINA0
-#define DIO28_RPORT PINA
-#define DIO28_WPORT PORTA
-#define DIO28_PWM   0
-#define DIO28_DDR   DDRA
-
-#define DIO29_PIN   PINA1
-#define DIO29_RPORT PINA
-#define DIO29_WPORT PORTA
-#define DIO29_PWM   0
-#define DIO29_DDR   DDRA
-
-#define DIO30_PIN   PINA2
-#define DIO30_RPORT PINA
-#define DIO30_WPORT PORTA
-#define DIO30_PWM   0
-#define DIO30_DDR   DDRA
-
-#define DIO31_PIN   PINA3
-#define DIO31_RPORT PINA
-#define DIO31_WPORT PORTA
-#define DIO31_PWM   0
-#define DIO31_DDR   DDRA
-
-#define DIO32_PIN   PINA4
-#define DIO32_RPORT PINA
-#define DIO32_WPORT PORTA
-#define DIO32_PWM   0
-#define DIO32_DDR   DDRA
-
-#define DIO33_PIN   PINA5
-#define DIO33_RPORT PINA
-#define DIO33_WPORT PORTA
-#define DIO33_PWM   0
-#define DIO33_DDR   DDRA
-
-#define DIO34_PIN   PINA6
-#define DIO34_RPORT PINA
-#define DIO34_WPORT PORTA
-#define DIO34_PWM   0
-#define DIO34_DDR   DDRA
-
-#define DIO35_PIN   PINA7
-#define DIO35_RPORT PINA
-#define DIO35_WPORT PORTA
-#define DIO35_PWM   0
-#define DIO35_DDR   DDRA
-
-#define DIO36_PIN   PINE4
-#define DIO36_RPORT PINE
-#define DIO36_WPORT PORTE
-#define DIO36_PWM   0
-#define DIO36_DDR   DDRE
-
-#define DIO37_PIN   PINE5
-#define DIO37_RPORT PINE
-#define DIO37_WPORT PORTE
-#define DIO37_PWM   0
-#define DIO37_DDR   DDRE
-
-#define DIO38_PIN   PINF0
-#define DIO38_RPORT PINF
-#define DIO38_WPORT PORTF
-#define DIO38_PWM   0
-#define DIO38_DDR   DDRF
-
-#define DIO39_PIN   PINF1
-#define DIO39_RPORT PINF
-#define DIO39_WPORT PORTF
-#define DIO39_PWM   0
-#define DIO39_DDR   DDRF
-
-#define DIO40_PIN   PINF2
-#define DIO40_RPORT PINF
-#define DIO40_WPORT PORTF
-#define DIO40_PWM   0
-#define DIO40_DDR   DDRF
-
-#define DIO41_PIN   PINF3
-#define DIO41_RPORT PINF
-#define DIO41_WPORT PORTF
-#define DIO41_PWM   0
-#define DIO41_DDR   DDRF
-
-#define DIO42_PIN   PINF4
-#define DIO42_RPORT PINF
-#define DIO42_WPORT PORTF
-#define DIO42_PWM   0
-#define DIO42_DDR   DDRF
-
-#define DIO43_PIN   PINF5
-#define DIO43_RPORT PINF
-#define DIO43_WPORT PORTF
-#define DIO43_PWM   0
-#define DIO43_DDR   DDRF
-
-#define DIO44_PIN   PINF6
-#define DIO44_RPORT PINF
-#define DIO44_WPORT PORTF
-#define DIO44_PWM   0
-#define DIO44_DDR   DDRF
-
-#define DIO45_PIN   PINF7
-#define DIO45_RPORT PINF
-#define DIO45_WPORT PORTF
-#define DIO45_PWM   0
-#define DIO45_DDR   DDRF
-
-#define AIO0_PIN    PINF0
-#define AIO0_RPORT  PINF
-#define AIO0_WPORT  PORTF
-#define AIO0_PWM    0
-#define AIO0_DDR    DDRF
-
-#define AIO1_PIN    PINF1
-#define AIO1_RPORT  PINF
-#define AIO1_WPORT  PORTF
-#define AIO1_PWM    0
-#define AIO1_DDR    DDRF
-
-#define AIO2_PIN    PINF2
-#define AIO2_RPORT  PINF
-#define AIO2_WPORT  PORTF
-#define AIO2_PWM    0
-#define AIO2_DDR    DDRF
-
-#define AIO3_PIN    PINF3
-#define AIO3_RPORT  PINF
-#define AIO3_WPORT  PORTF
-#define AIO3_PWM    0
-#define AIO3_DDR    DDRF
-
-#define AIO4_PIN    PINF4
-#define AIO4_RPORT  PINF
-#define AIO4_WPORT  PORTF
-#define AIO4_PWM    0
-#define AIO4_DDR    DDRF
-
-#define AIO5_PIN    PINF5
-#define AIO5_RPORT  PINF
-#define AIO5_WPORT  PORTF
-#define AIO5_PWM    0
-#define AIO5_DDR    DDRF
-
-#define AIO6_PIN    PINF6
-#define AIO6_RPORT  PINF
-#define AIO6_WPORT  PORTF
-#define AIO6_PWM    0
-#define AIO6_DDR    DDRF
-
-#define AIO7_PIN    PINF7
-#define AIO7_RPORT  PINF
-#define AIO7_WPORT  PORTF
-#define AIO7_PWM    0
-#define AIO7_DDR    DDRF
-
-//-- Begin not supported by Teensyduino
-//-- don't use Arduino functions on these pins pinMode/digitalWrite/etc
-#define DIO46_PIN   PINE2
-#define DIO46_RPORT PINE
-#define DIO46_WPORT PORTE
-#define DIO46_PWM   0
-#define DIO46_DDR   DDRE
-
-#define DIO47_PIN   PINE3
-#define DIO47_RPORT PINE
-#define DIO47_WPORT PORTE
-#define DIO47_PWM   0
-#define DIO47_DDR   DDRE
-
-#define TEENSY_E2   46
-#define TEENSY_E3   47
-
-//-- end not supported by Teensyduino
-
-#undef PA0
-#define PA0_PIN     PINA0
-#define PA0_RPORT   PINA
-#define PA0_WPORT   PORTA
-#define PA0_PWM     0
-#define PA0_DDR     DDRA
-#undef PA1
-#define PA1_PIN     PINA1
-#define PA1_RPORT   PINA
-#define PA1_WPORT   PORTA
-#define PA1_PWM     0
-#define PA1_DDR     DDRA
-#undef PA2
-#define PA2_PIN     PINA2
-#define PA2_RPORT   PINA
-#define PA2_WPORT   PORTA
-#define PA2_PWM     0
-#define PA2_DDR     DDRA
-#undef PA3
-#define PA3_PIN     PINA3
-#define PA3_RPORT   PINA
-#define PA3_WPORT   PORTA
-#define PA3_PWM     0
-#define PA3_DDR     DDRA
-#undef PA4
-#define PA4_PIN     PINA4
-#define PA4_RPORT   PINA
-#define PA4_WPORT   PORTA
-#define PA4_PWM     0
-#define PA4_DDR     DDRA
-#undef PA5
-#define PA5_PIN     PINA5
-#define PA5_RPORT   PINA
-#define PA5_WPORT   PORTA
-#define PA5_PWM     0
-#define PA5_DDR     DDRA
-#undef PA6
-#define PA6_PIN     PINA6
-#define PA6_RPORT   PINA
-#define PA6_WPORT   PORTA
-#define PA6_PWM     0
-#define PA6_DDR     DDRA
-#undef PA7
-#define PA7_PIN     PINA7
-#define PA7_RPORT   PINA
-#define PA7_WPORT   PORTA
-#define PA7_PWM     0
-#define PA7_DDR     DDRA
-
-#undef PB0
-#define PB0_PIN     PINB0
-#define PB0_RPORT   PINB
-#define PB0_WPORT   PORTB
-#define PB0_PWM     0
-#define PB0_DDR     DDRB
-#undef PB1
-#define PB1_PIN     PINB1
-#define PB1_RPORT   PINB
-#define PB1_WPORT   PORTB
-#define PB1_PWM     0
-#define PB1_DDR     DDRB
-#undef PB2
-#define PB2_PIN     PINB2
-#define PB2_RPORT   PINB
-#define PB2_WPORT   PORTB
-#define PB2_PWM     0
-#define PB2_DDR     DDRB
-#undef PB3
-#define PB3_PIN     PINB3
-#define PB3_RPORT   PINB
-#define PB3_WPORT   PORTB
-#define PB3_PWM     0
-#define PB3_DDR     DDRB
-#undef PB4
-#define PB4_PIN     PINB4
-#define PB4_RPORT   PINB
-#define PB4_WPORT   PORTB
-#define PB4_PWM     0
-#define PB4_DDR     DDRB
-#undef PB5
-#define PB5_PIN     PINB5
-#define PB5_RPORT   PINB
-#define PB5_WPORT   PORTB
-#define PB5_PWM     0
-#define PB5_DDR     DDRB
-#undef PB6
-#define PB6_PIN     PINB6
-#define PB6_RPORT   PINB
-#define PB6_WPORT   PORTB
-#define PB6_PWM     0
-#define PB6_DDR     DDRB
-#undef PB7
-#define PB7_PIN     PINB7
-#define PB7_RPORT   PINB
-#define PB7_WPORT   PORTB
-#define PB7_PWM     0
-#define PB7_DDR     DDRB
-
-#undef PC0
-#define PC0_PIN     PINC0
-#define PC0_RPORT   PINC
-#define PC0_WPORT   PORTC
-#define PC0_PWM     0
-#define PC0_DDR     DDRC
-#undef PC1
-#define PC1_PIN     PINC1
-#define PC1_RPORT   PINC
-#define PC1_WPORT   PORTC
-#define PC1_PWM     0
-#define PC1_DDR     DDRC
-#undef PC2
-#define PC2_PIN     PINC2
-#define PC2_RPORT   PINC
-#define PC2_WPORT   PORTC
-#define PC2_PWM     0
-#define PC2_DDR     DDRC
-#undef PC3
-#define PC3_PIN     PINC3
-#define PC3_RPORT   PINC
-#define PC3_WPORT   PORTC
-#define PC3_PWM     0
-#define PC3_DDR     DDRC
-#undef PC4
-#define PC4_PIN     PINC4
-#define PC4_RPORT   PINC
-#define PC4_WPORT   PORTC
-#define PC4_PWM     0
-#define PC4_DDR     DDRC
-#undef PC5
-#define PC5_PIN     PINC5
-#define PC5_RPORT   PINC
-#define PC5_WPORT   PORTC
-#define PC5_PWM     0
-#define PC5_DDR     DDRC
-#undef PC6
-#define PC6_PIN     PINC6
-#define PC6_RPORT   PINC
-#define PC6_WPORT   PORTC
-#define PC6_PWM     0
-#define PC6_DDR     DDRC
-#undef PC7
-#define PC7_PIN     PINC7
-#define PC7_RPORT   PINC
-#define PC7_WPORT   PORTC
-#define PC7_PWM     0
-#define PC7_DDR     DDRC
-
-#undef PD0
-#define PD0_PIN     PIND0
-#define PD0_RPORT   PIND
-#define PD0_WPORT   PORTD
-#define PD0_PWM     0 // OC0B
-#define PD0_DDR     DDRD
-#undef PD1
-#define PD1_PIN     PIND1
-#define PD1_RPORT   PIND
-#define PD1_WPORT   PORTD
-#define PD1_PWM     0 // OC2B
-#define PD1_DDR     DDRD
-#undef PD2
-#define PD2_PIN     PIND2
-#define PD2_RPORT   PIND
-#define PD2_WPORT   PORTD
-#define PD2_PWM     0
-#define PD2_DDR     DDRD
-#undef PD3
-#define PD3_PIN     PIND3
-#define PD3_RPORT   PIND
-#define PD3_WPORT   PORTD
-#define PD3_PWM     0
-#define PD3_DDR     DDRD
-#undef PD4
-#define PD4_PIN     PIND4
-#define PD4_RPORT   PIND
-#define PD4_WPORT   PORTD
-#define PD4_PWM     0
-#define PD4_DDR     DDRD
-#undef PD5
-#define PD5_PIN     PIND5
-#define PD5_RPORT   PIND
-#define PD5_WPORT   PORTD
-#define PD5_PWM     0
-#define PD5_DDR     DDRD
-#undef PD6
-#define PD6_PIN     PIND6
-#define PD6_RPORT   PIND
-#define PD6_WPORT   PORTD
-#define PD6_PWM     0
-#define PD6_DDR     DDRD
-#undef PD7
-#define PD7_PIN     PIND7
-#define PD7_RPORT   PIND
-#define PD7_WPORT   PORTD
-#define PD7_PWM     0
-#define PD7_DDR     DDRD
-
-#undef PE0
-#define PE0_PIN     PINE0
-#define PE0_RPORT   PINE
-#define PE0_WPORT   PORTE
-#define PE0_PWM     0
-#define PE0_DDR     DDRE
-#undef PE1
-#define PE1_PIN     PINE1
-#define PE1_RPORT   PINE
-#define PE1_WPORT   PORTE
-#define PE1_PWM     0
-#define PE1_DDR     DDRE
-#undef PE2
-#define PE2_PIN     PINE2
-#define PE2_RPORT   PINE
-#define PE2_WPORT   PORTE
-#define PE2_PWM     0
-#define PE2_DDR     DDRE
-#undef PE3
-#define PE3_PIN     PINE3
-#define PE3_RPORT   PINE
-#define PE3_WPORT   PORTE
-#define PE3_PWM     0
-#define PE3_DDR     DDRE
-#undef PE4
-#define PE4_PIN     PINE4
-#define PE4_RPORT   PINE
-#define PE4_WPORT   PORTE
-#define PE4_PWM     0
-#define PE4_DDR     DDRE
-#undef PE5
-#define PE5_PIN     PINE5
-#define PE5_RPORT   PINE
-#define PE5_WPORT   PORTE
-#define PE5_PWM     0
-#define PE5_DDR     DDRE
-#undef PE6
-#define PE6_PIN     PINE6
-#define PE6_RPORT   PINE
-#define PE6_WPORT   PORTE
-#define PE6_PWM     0
-#define PE6_DDR     DDRE
-#undef PE7
-#define PE7_PIN     PINE7
-#define PE7_RPORT   PINE
-#define PE7_WPORT   PORTE
-#define PE7_PWM     0
-#define PE7_DDR     DDRE
-
-#undef PF0
-#define PF0_PIN     PINF0
-#define PF0_RPORT   PINF
-#define PF0_WPORT   PORTF
-#define PF0_PWM     0
-#define PF0_DDR     DDRF
-#undef PF1
-#define PF1_PIN     PINF1
-#define PF1_RPORT   PINF
-#define PF1_WPORT   PORTF
-#define PF1_PWM     0
-#define PF1_DDR     DDRF
-#undef PF2
-#define PF2_PIN     PINF2
-#define PF2_RPORT   PINF
-#define PF2_WPORT   PORTF
-#define PF2_PWM     0
-#define PF2_DDR     DDRF
-#undef PF3
-#define PF3_PIN     PINF3
-#define PF3_RPORT   PINF
-#define PF3_WPORT   PORTF
-#define PF3_PWM     0
-#define PF3_DDR     DDRF
-#undef PF4
-#define PF4_PIN     PINF4
-#define PF4_RPORT   PINF
-#define PF4_WPORT   PORTF
-#define PF4_PWM     0
-#define PF4_DDR     DDRF
-#undef PF5
-#define PF5_PIN     PINF5
-#define PF5_RPORT   PINF
-#define PF5_WPORT   PORTF
-#define PF5_PWM     0
-#define PF5_DDR     DDRF
-#undef PF6
-#define PF6_PIN     PINF6
-#define PF6_RPORT   PINF
-#define PF6_WPORT   PORTF
-#define PF6_PWM     0
-#define PF6_DDR     DDRF
-#undef PF7
-#define PF7_PIN     PINF7
-#define PF7_RPORT   PINF
-#define PF7_WPORT   PORTF
-#define PF7_PWM     0
-#define PF7_DDR     DDRF
-
-
-/**
- * Some of the pin mapping functions of the Teensduino extension to the Arduino IDE
- * do not function the same as the other Arduino extensions.
- */
-
-//digitalPinToTimer(pin) function works like Arduino but Timers are not defined
-#define TIMER0B 1
-#define TIMER1A 7
-#define TIMER1B 8
-#define TIMER1C 9
-#define TIMER2A 6
-#define TIMER2B 2
-#define TIMER3A 5
-#define TIMER3B 4
-#define TIMER3C 3
diff --git a/Marlin/src/HAL/AVR/inc/Conditionals_LCD.h b/Marlin/src/HAL/AVR/inc/Conditionals_LCD.h
deleted file mode 100644
index a611ccd..0000000
--- a/Marlin/src/HAL/AVR/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/AVR."
-#endif
diff --git a/Marlin/src/HAL/AVR/inc/Conditionals_adv.h b/Marlin/src/HAL/AVR/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/AVR/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/AVR/inc/Conditionals_post.h b/Marlin/src/HAL/AVR/inc/Conditionals_post.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/AVR/inc/Conditionals_post.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/AVR/inc/SanityCheck.h b/Marlin/src/HAL/AVR/inc/SanityCheck.h
deleted file mode 100644
index 89425ca..0000000
--- a/Marlin/src/HAL/AVR/inc/SanityCheck.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test AVR-specific configuration values for errors at compile-time.
- */
-
-/**
- * Check for common serial pin conflicts
- */
-#define CHECK_SERIAL_PIN(N) ( \
-     X_STOP_PIN == N || Y_STOP_PIN == N || Z_STOP_PIN == N \
-  || X_MIN_PIN  == N || Y_MIN_PIN  == N || Z_MIN_PIN  == N \
-  || X_MAX_PIN  == N || Y_MAX_PIN  == N || Z_MAX_PIN  == N \
-  || X_STEP_PIN == N || Y_STEP_PIN == N || Z_STEP_PIN == N \
-  || X_DIR_PIN  == N || Y_DIR_PIN  == N || Z_DIR_PIN  == N \
-  || X_ENA_PIN  == N || Y_ENA_PIN  == N || Z_ENA_PIN  == N \
-  || BTN_EN1    == N || BTN_EN2    == N \
-)
-#if CONF_SERIAL_IS(0)
-  // D0-D1. No known conflicts.
-#endif
-#if NOT_TARGET(__AVR_ATmega644P__, __AVR_ATmega1284P__)
-  #if CONF_SERIAL_IS(1) && (CHECK_SERIAL_PIN(18) || CHECK_SERIAL_PIN(19))
-    #error "Serial Port 1 pin D18 and/or D19 conflicts with another pin on the board."
-  #endif
-#else
-  #if CONF_SERIAL_IS(1) && (CHECK_SERIAL_PIN(10) || CHECK_SERIAL_PIN(11))
-    #error "Serial Port 1 pin D10 and/or D11 conflicts with another pin on the board."
-  #endif
-#endif
-#if CONF_SERIAL_IS(2) && (CHECK_SERIAL_PIN(16) || CHECK_SERIAL_PIN(17))
-  #error "Serial Port 2 pin D16 and/or D17 conflicts with another pin on the board."
-#endif
-#if CONF_SERIAL_IS(3) && (CHECK_SERIAL_PIN(14) || CHECK_SERIAL_PIN(15))
-  #error "Serial Port 3 pin D14 and/or D15 conflicts with another pin on the board."
-#endif
-#undef CHECK_SERIAL_PIN
-
-/**
- * Checks for FAST PWM
- */
-#if ALL(FAST_PWM_FAN, USE_OCR2A_AS_TOP, HAS_TCCR2)
-  #error "USE_OCR2A_AS_TOP does not apply to devices with a single output TIMER2."
-#endif
-
-/**
- * Checks for SOFT PWM
- */
-#if HAS_FAN0 && FAN_PIN == 9 && DISABLED(FAN_SOFT_PWM) && ENABLED(SPEAKER)
-  #error "FAN_PIN 9 Hardware PWM uses Timer 2 which conflicts with Arduino AVR Tone Timer (for SPEAKER)."
-  #error "Disable SPEAKER or enable FAN_SOFT_PWM."
-#endif
-
-/**
- * Sanity checks for Spindle / Laser PWM
- */
-#if ENABLED(SPINDLE_LASER_USE_PWM)
-  #include "../ServoTimers.h"   // Needed to check timer availability (_useTimer3)
-  #if SPINDLE_LASER_PWM_PIN == 4 || WITHIN(SPINDLE_LASER_PWM_PIN, 11, 13)
-    #error "Counter/Timer for SPINDLE_LASER_PWM_PIN is used by a system interrupt."
-  #elif NUM_SERVOS > 0 && defined(_useTimer3) && (WITHIN(SPINDLE_LASER_PWM_PIN, 2, 3) || SPINDLE_LASER_PWM_PIN == 5)
-    #error "Counter/Timer for SPINDLE_LASER_PWM_PIN is used by the servo system."
-  #endif
-#elif SPINDLE_LASER_FREQUENCY
-  #error "SPINDLE_LASER_FREQUENCY requires SPINDLE_LASER_USE_PWM."
-#endif
-
-/**
- * The Trinamic library includes SoftwareSerial.h, leading to a compile error.
- */
-#if BOTH(HAS_TRINAMIC_CONFIG, ENDSTOP_INTERRUPTS_FEATURE)
-  #error "TMCStepper includes SoftwareSerial.h which is incompatible with ENDSTOP_INTERRUPTS_FEATURE. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-#endif
-
-#if BOTH(HAS_TMC_SW_SERIAL, MONITOR_DRIVER_STATUS)
-  #error "MONITOR_DRIVER_STATUS causes performance issues when used with SoftwareSerial-connected drivers. Disable MONITOR_DRIVER_STATUS or use hardware serial to continue."
-#endif
-
-/**
- * Postmortem debugging
- */
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not supported on AVR boards."
-#endif
-
-#if USING_PULLDOWNS
-  #error "PULLDOWN pin mode is not available on AVR boards."
-#endif
diff --git a/Marlin/src/HAL/AVR/math.h b/Marlin/src/HAL/AVR/math.h
deleted file mode 100644
index 7dd1018..0000000
--- a/Marlin/src/HAL/AVR/math.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Optimized math functions for AVR
- */
-
-// intRes = longIn1 * longIn2 >> 24
-// uses:
-// A[tmp] to store 0
-// B[tmp] to store bits 16-23 of the 48bit result. The top bit is used to round the two byte result.
-// note that the lower two bytes and the upper byte of the 48bit result are not calculated.
-// this can cause the result to be out by one as the lower bytes may cause carries into the upper ones.
-// B A are bits 24-39 and are the returned value
-// C B A is longIn1
-// D C B A is longIn2
-//
-FORCE_INLINE static uint16_t MultiU24X32toH16(uint32_t longIn1, uint32_t longIn2) {
-  uint8_t tmp1;
-  uint8_t tmp2;
-  uint16_t intRes;
-  __asm__ __volatile__(
-    A("clr %[tmp1]")
-    A("mul %A[longIn1], %B[longIn2]")
-    A("mov %[tmp2], r1")
-    A("mul %B[longIn1], %C[longIn2]")
-    A("movw %A[intRes], r0")
-    A("mul %C[longIn1], %C[longIn2]")
-    A("add %B[intRes], r0")
-    A("mul %C[longIn1], %B[longIn2]")
-    A("add %A[intRes], r0")
-    A("adc %B[intRes], r1")
-    A("mul %A[longIn1], %C[longIn2]")
-    A("add %[tmp2], r0")
-    A("adc %A[intRes], r1")
-    A("adc %B[intRes], %[tmp1]")
-    A("mul %B[longIn1], %B[longIn2]")
-    A("add %[tmp2], r0")
-    A("adc %A[intRes], r1")
-    A("adc %B[intRes], %[tmp1]")
-    A("mul %C[longIn1], %A[longIn2]")
-    A("add %[tmp2], r0")
-    A("adc %A[intRes], r1")
-    A("adc %B[intRes], %[tmp1]")
-    A("mul %B[longIn1], %A[longIn2]")
-    A("add %[tmp2], r1")
-    A("adc %A[intRes], %[tmp1]")
-    A("adc %B[intRes], %[tmp1]")
-    A("lsr %[tmp2]")
-    A("adc %A[intRes], %[tmp1]")
-    A("adc %B[intRes], %[tmp1]")
-    A("mul %D[longIn2], %A[longIn1]")
-    A("add %A[intRes], r0")
-    A("adc %B[intRes], r1")
-    A("mul %D[longIn2], %B[longIn1]")
-    A("add %B[intRes], r0")
-    A("clr r1")
-      : [intRes] "=&r" (intRes),
-        [tmp1] "=&r" (tmp1),
-        [tmp2] "=&r" (tmp2)
-      : [longIn1] "d" (longIn1),
-        [longIn2] "d" (longIn2)
-      : "cc"
-  );
-  return intRes;
-}
-
-// intRes = intIn1 * intIn2 >> 16
-// uses:
-// r26 to store 0
-// r27 to store the byte 1 of the 24 bit result
-FORCE_INLINE static uint16_t MultiU16X8toH16(uint8_t charIn1, uint16_t intIn2) {
-  uint8_t tmp;
-  uint16_t intRes;
-  __asm__ __volatile__ (
-    A("clr %[tmp]")
-    A("mul %[charIn1], %B[intIn2]")
-    A("movw %A[intRes], r0")
-    A("mul %[charIn1], %A[intIn2]")
-    A("add %A[intRes], r1")
-    A("adc %B[intRes], %[tmp]")
-    A("lsr r0")
-    A("adc %A[intRes], %[tmp]")
-    A("adc %B[intRes], %[tmp]")
-    A("clr r1")
-      : [intRes] "=&r" (intRes),
-        [tmp] "=&r" (tmp)
-      : [charIn1] "d" (charIn1),
-        [intIn2] "d" (intIn2)
-      : "cc"
-  );
-  return intRes;
-}
diff --git a/Marlin/src/HAL/AVR/pinsDebug.h b/Marlin/src/HAL/AVR/pinsDebug.h
deleted file mode 100644
index dab4e44..0000000
--- a/Marlin/src/HAL/AVR/pinsDebug.h
+++ /dev/null
@@ -1,400 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * PWM print routines for Atmel 8 bit AVR CPUs
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#define NUMBER_PINS_TOTAL NUM_DIGITAL_PINS
-
-#if MB(BQ_ZUM_MEGA_3D, MIGHTYBOARD_REVE, MINIRAMBO, SCOOVO_X9H, TRIGORILLA_14)
-  #define AVR_ATmega2560_FAMILY_PLUS_70 1
-#endif
-
-#if AVR_AT90USB1286_FAMILY
-
-  // Working with Teensyduino extension so need to re-define some things
-  #include "pinsDebug_Teensyduino.h"
-  // Can't use the "digitalPinToPort" function from the Teensyduino type IDEs
-  // portModeRegister takes a different argument
-  #define digitalPinToTimer_DEBUG(p) digitalPinToTimer(p)
-  #define digitalPinToBitMask_DEBUG(p) digitalPinToBitMask(p)
-  #define digitalPinToPort_DEBUG(p) digitalPinToPort(p)
-  #define GET_PINMODE(pin) (*portModeRegister(pin) & digitalPinToBitMask_DEBUG(pin))
-
-#elif AVR_ATmega2560_FAMILY_PLUS_70   // So we can access/display all the pins on boards using more than 70
-
-  #include "pinsDebug_plus_70.h"
-  #define digitalPinToTimer_DEBUG(p) digitalPinToTimer_plus_70(p)
-  #define digitalPinToBitMask_DEBUG(p) digitalPinToBitMask_plus_70(p)
-  #define digitalPinToPort_DEBUG(p) digitalPinToPort_plus_70(p)
-  bool GET_PINMODE(int8_t pin) {return *portModeRegister(digitalPinToPort_DEBUG(pin)) & digitalPinToBitMask_DEBUG(pin); }
-
-#else
-
-  #define digitalPinToTimer_DEBUG(p) digitalPinToTimer(p)
-  #define digitalPinToBitMask_DEBUG(p) digitalPinToBitMask(p)
-  #define digitalPinToPort_DEBUG(p) digitalPinToPort(p)
-  bool GET_PINMODE(int8_t pin) {return *portModeRegister(digitalPinToPort_DEBUG(pin)) & digitalPinToBitMask_DEBUG(pin); }
-  #define GET_ARRAY_PIN(p) pgm_read_byte(&pin_array[p].pin)
-
-#endif
-
-#define VALID_PIN(pin) (pin >= 0 && pin < NUM_DIGITAL_PINS ? 1 : 0)
-#if AVR_ATmega1284_FAMILY
-  #define DIGITAL_PIN_TO_ANALOG_PIN(P) int(analogInputToDigitalPin(0) - (P))
-  #define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(7) && (P) <= analogInputToDigitalPin(0))
-#else
-  #define DIGITAL_PIN_TO_ANALOG_PIN(P) int((P) - analogInputToDigitalPin(0))
-  #define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && ((P) <= analogInputToDigitalPin(15) || (P) <= analogInputToDigitalPin(7)))
-#endif
-#define GET_ARRAY_PIN(p) pgm_read_byte(&pin_array[p].pin)
-#define MULTI_NAME_PAD 26 // space needed to be pretty if not first name assigned to a pin
-
-void PRINT_ARRAY_NAME(uint8_t x) {
-  PGM_P const name_mem_pointer = (PGM_P)pgm_read_ptr(&pin_array[x].name);
-  LOOP_L_N(y, MAX_NAME_LENGTH) {
-    char temp_char = pgm_read_byte(name_mem_pointer + y);
-    if (temp_char != 0)
-      SERIAL_CHAR(temp_char);
-    else {
-      LOOP_L_N(i, MAX_NAME_LENGTH - y) SERIAL_CHAR(' ');
-      break;
-    }
-  }
-}
-
-#define GET_ARRAY_IS_DIGITAL(x)   pgm_read_byte(&pin_array[x].is_digital)
-
-
-#if defined(__AVR_ATmega1284P__)  // 1284 IDE extensions set this to the number of
-  #undef NUM_DIGITAL_PINS         // digital only pins while all other CPUs have it
-  #define NUM_DIGITAL_PINS 32     // set to digital only + digital/analog
-#endif
-
-#define PWM_PRINT(V) do{ sprintf_P(buffer, PSTR("PWM:  %4d"), V); SERIAL_ECHO(buffer); }while(0)
-#define PWM_CASE(N,Z)                                           \
-  case TIMER##N##Z:                                             \
-    if (TCCR##N##A & (_BV(COM##N##Z##1) | _BV(COM##N##Z##0))) { \
-      PWM_PRINT(OCR##N##Z);                                     \
-      return true;                                              \
-    } else return false
-
-#define ABTEST(N) defined(TCCR##N##A) && defined(COM##N##A1)
-
-/**
- * Print a pin's PWM status.
- * Return true if it's currently a PWM pin.
- */
-static bool pwm_status(uint8_t pin) {
-  char buffer[20];   // for the sprintf statements
-
-  switch (digitalPinToTimer_DEBUG(pin)) {
-
-    #if ABTEST(0)
-      #ifdef TIMER0A
-        #if !AVR_AT90USB1286_FAMILY  // not available in Teensyduino type IDEs
-          PWM_CASE(0, A);
-        #endif
-      #endif
-      PWM_CASE(0, B);
-    #endif
-
-    #if ABTEST(1)
-      PWM_CASE(1, A);
-      PWM_CASE(1, B);
-      #if defined(COM1C1) && defined(TIMER1C)
-        PWM_CASE(1, C);
-      #endif
-    #endif
-
-    #if ABTEST(2)
-      PWM_CASE(2, A);
-      PWM_CASE(2, B);
-    #endif
-
-    #if ABTEST(3)
-      PWM_CASE(3, A);
-      PWM_CASE(3, B);
-      #ifdef COM3C1
-        PWM_CASE(3, C);
-      #endif
-    #endif
-
-    #ifdef TCCR4A
-      PWM_CASE(4, A);
-      PWM_CASE(4, B);
-      PWM_CASE(4, C);
-    #endif
-
-    #if ABTEST(5)
-      PWM_CASE(5, A);
-      PWM_CASE(5, B);
-      PWM_CASE(5, C);
-    #endif
-
-    case NOT_ON_TIMER:
-    default:
-      return false;
-  }
-  SERIAL_ECHO_SP(2);
-} // pwm_status
-
-
-const volatile uint8_t* const PWM_other[][3] PROGMEM = {
-    { &TCCR0A, &TCCR0B, &TIMSK0 },
-    { &TCCR1A, &TCCR1B, &TIMSK1 },
-  #if ABTEST(2)
-    { &TCCR2A, &TCCR2B, &TIMSK2 },
-  #endif
-  #if ABTEST(3)
-    { &TCCR3A, &TCCR3B, &TIMSK3 },
-  #endif
-  #ifdef TCCR4A
-    { &TCCR4A, &TCCR4B, &TIMSK4 },
-  #endif
-  #if ABTEST(5)
-    { &TCCR5A, &TCCR5B, &TIMSK5 },
-  #endif
-};
-
-
-const volatile uint8_t* const PWM_OCR[][3] PROGMEM = {
-
-  #ifdef TIMER0A
-    { &OCR0A, &OCR0B, 0 },
-  #else
-    { 0, &OCR0B, 0 },
-  #endif
-
-  #if defined(COM1C1) && defined(TIMER1C)
-   { (const uint8_t*)&OCR1A, (const uint8_t*)&OCR1B, (const uint8_t*)&OCR1C },
-  #else
-   { (const uint8_t*)&OCR1A, (const uint8_t*)&OCR1B, 0 },
-  #endif
-
-  #if ABTEST(2)
-    { &OCR2A, &OCR2B, 0 },
-  #endif
-
-  #if ABTEST(3)
-    #ifdef COM3C1
-      { (const uint8_t*)&OCR3A, (const uint8_t*)&OCR3B, (const uint8_t*)&OCR3C },
-    #else
-      { (const uint8_t*)&OCR3A, (const uint8_t*)&OCR3B, 0 },
-    #endif
-  #endif
-
-  #ifdef TCCR4A
-    { (const uint8_t*)&OCR4A, (const uint8_t*)&OCR4B, (const uint8_t*)&OCR4C },
-  #endif
-
-  #if ABTEST(5)
-    { (const uint8_t*)&OCR5A, (const uint8_t*)&OCR5B, (const uint8_t*)&OCR5C },
-  #endif
-};
-
-
-#define TCCR_A(T)   pgm_read_word(&PWM_other[T][0])
-#define TCCR_B(T)   pgm_read_word(&PWM_other[T][1])
-#define TIMSK(T)    pgm_read_word(&PWM_other[T][2])
-#define CS_0       0
-#define CS_1       1
-#define CS_2       2
-#define WGM_0      0
-#define WGM_1      1
-#define WGM_2      3
-#define WGM_3      4
-#define TOIE       0
-
-#define OCR_VAL(T, L)   pgm_read_word(&PWM_OCR[T][L])
-
-static void err_is_counter()     { SERIAL_ECHOPGM("   non-standard PWM mode"); }
-static void err_is_interrupt()   { SERIAL_ECHOPGM("   compare interrupt enabled"); }
-static void err_prob_interrupt() { SERIAL_ECHOPGM("   overflow interrupt enabled"); }
-static void print_is_also_tied() { SERIAL_ECHOPGM(" is also tied to this pin"); SERIAL_ECHO_SP(14); }
-
-inline void com_print(const uint8_t N, const uint8_t Z) {
-  const uint8_t *TCCRA = (uint8_t*)TCCR_A(N);
-  SERIAL_ECHOPGM("    COM", AS_DIGIT(N));
-  SERIAL_CHAR(Z);
-  SERIAL_ECHOPGM(": ", int((*TCCRA >> (6 - Z * 2)) & 0x03));
-}
-
-void timer_prefix(uint8_t T, char L, uint8_t N) {  // T - timer    L - pwm  N - WGM bit layout
-  char buffer[20];   // for the sprintf statements
-  const uint8_t *TCCRB = (uint8_t*)TCCR_B(T),
-                *TCCRA = (uint8_t*)TCCR_A(T);
-  uint8_t WGM = (((*TCCRB & _BV(WGM_2)) >> 1) | (*TCCRA & (_BV(WGM_0) | _BV(WGM_1))));
-  if (N == 4) WGM |= ((*TCCRB & _BV(WGM_3)) >> 1);
-
-  SERIAL_ECHOPGM("    TIMER", AS_DIGIT(T));
-  SERIAL_CHAR(L);
-  SERIAL_ECHO_SP(3);
-
-  if (N == 3) {
-    const uint8_t *OCRVAL8 = (uint8_t*)OCR_VAL(T, L - 'A');
-    PWM_PRINT(*OCRVAL8);
-  }
-  else {
-    const uint16_t *OCRVAL16 = (uint16_t*)OCR_VAL(T, L - 'A');
-    PWM_PRINT(*OCRVAL16);
-  }
-  SERIAL_ECHOPGM("    WGM: ", WGM);
-  com_print(T,L);
-  SERIAL_ECHOPGM("    CS: ", (*TCCRB & (_BV(CS_0) | _BV(CS_1) | _BV(CS_2)) ));
-  SERIAL_ECHOPGM("    TCCR", AS_DIGIT(T), "A: ", *TCCRA);
-  SERIAL_ECHOPGM("    TCCR", AS_DIGIT(T), "B: ", *TCCRB);
-
-  const uint8_t *TMSK = (uint8_t*)TIMSK(T);
-  SERIAL_ECHOPGM("    TIMSK", AS_DIGIT(T), ": ", *TMSK);
-
-  const uint8_t OCIE = L - 'A' + 1;
-  if (N == 3) { if (WGM == 0 || WGM == 2 || WGM ==  4 || WGM ==  6) err_is_counter(); }
-  else        { if (WGM == 0 || WGM == 4 || WGM == 12 || WGM == 13) err_is_counter(); }
-  if (TEST(*TMSK, OCIE)) err_is_interrupt();
-  if (TEST(*TMSK, TOIE)) err_prob_interrupt();
-}
-
-static void pwm_details(uint8_t pin) {
-  switch (digitalPinToTimer_DEBUG(pin)) {
-
-    #if ABTEST(0)
-      #ifdef TIMER0A
-        #if !AVR_AT90USB1286_FAMILY  // not available in Teensyduino type IDEs
-          case TIMER0A: timer_prefix(0, 'A', 3); break;
-        #endif
-      #endif
-      case TIMER0B: timer_prefix(0, 'B', 3); break;
-    #endif
-
-    #if ABTEST(1)
-      case TIMER1A: timer_prefix(1, 'A', 4); break;
-      case TIMER1B: timer_prefix(1, 'B', 4); break;
-      #if defined(COM1C1) && defined(TIMER1C)
-        case TIMER1C: timer_prefix(1, 'C', 4); break;
-      #endif
-    #endif
-
-    #if ABTEST(2)
-      case TIMER2A: timer_prefix(2, 'A', 3); break;
-      case TIMER2B: timer_prefix(2, 'B', 3); break;
-    #endif
-
-    #if ABTEST(3)
-      case TIMER3A: timer_prefix(3, 'A', 4); break;
-      case TIMER3B: timer_prefix(3, 'B', 4); break;
-      #ifdef COM3C1
-        case TIMER3C: timer_prefix(3, 'C', 4); break;
-      #endif
-    #endif
-
-    #ifdef TCCR4A
-      case TIMER4A: timer_prefix(4, 'A', 4); break;
-      case TIMER4B: timer_prefix(4, 'B', 4); break;
-      case TIMER4C: timer_prefix(4, 'C', 4); break;
-    #endif
-
-    #if ABTEST(5)
-      case TIMER5A: timer_prefix(5, 'A', 4); break;
-      case TIMER5B: timer_prefix(5, 'B', 4); break;
-      case TIMER5C: timer_prefix(5, 'C', 4); break;
-    #endif
-
-    case NOT_ON_TIMER: break;
-
-  }
-  SERIAL_ECHOPGM("  ");
-
-  // on pins that have two PWMs, print info on second PWM
-  #if AVR_ATmega2560_FAMILY || AVR_AT90USB1286_FAMILY
-    // looking for port B7 - PWMs 0A and 1C
-    if (digitalPinToPort_DEBUG(pin) == 'B' - 64 && 0x80 == digitalPinToBitMask_DEBUG(pin)) {
-      #if !AVR_AT90USB1286_FAMILY
-        SERIAL_ECHOPGM("\n .");
-        SERIAL_ECHO_SP(18);
-        SERIAL_ECHOPGM("TIMER1C");
-        print_is_also_tied();
-        timer_prefix(1, 'C', 4);
-      #else
-        SERIAL_ECHOPGM("\n .");
-        SERIAL_ECHO_SP(18);
-        SERIAL_ECHOPGM("TIMER0A");
-        print_is_also_tied();
-        timer_prefix(0, 'A', 3);
-      #endif
-    }
-  #else
-    UNUSED(print_is_also_tied);
-  #endif
-} // pwm_details
-
-#ifndef digitalRead_mod                   // Use Teensyduino's version of digitalRead - it doesn't disable the PWMs
-  int digitalRead_mod(const int8_t pin) { // same as digitalRead except the PWM stop section has been removed
-    const uint8_t port = digitalPinToPort_DEBUG(pin);
-    return (port != NOT_A_PIN) && (*portInputRegister(port) & digitalPinToBitMask_DEBUG(pin)) ? HIGH : LOW;
-  }
-#endif
-
-#ifndef PRINT_PORT
-
-  void print_port(int8_t pin) {   // print port number
-    #ifdef digitalPinToPort_DEBUG
-      uint8_t x;
-      SERIAL_ECHOPGM("  Port: ");
-      #if AVR_AT90USB1286_FAMILY
-        x = (pin == 46 || pin == 47) ? 'E' : digitalPinToPort_DEBUG(pin) + 64;
-      #else
-        x = digitalPinToPort_DEBUG(pin) + 64;
-      #endif
-      SERIAL_CHAR(x);
-
-      #if AVR_AT90USB1286_FAMILY
-        if (pin == 46)
-          x = '2';
-        else if (pin == 47)
-          x = '3';
-        else {
-          uint8_t temp = digitalPinToBitMask_DEBUG(pin);
-          for (x = '0'; x < '9' && temp != 1; x++) temp >>= 1;
-        }
-      #else
-        uint8_t temp = digitalPinToBitMask_DEBUG(pin);
-        for (x = '0'; x < '9' && temp != 1; x++) temp >>= 1;
-      #endif
-      SERIAL_CHAR(x);
-    #else
-      SERIAL_ECHO_SP(10);
-    #endif
-  }
-
-  #define PRINT_PORT(p) print_port(p)
-
-#endif
-
-#define PRINT_PIN(p) do{ sprintf_P(buffer, PSTR("%3d "), p); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR(" (A%2d)  "), DIGITAL_PIN_TO_ANALOG_PIN(pin)); SERIAL_ECHO(buffer); }while(0)
-
-#undef ABTEST
diff --git a/Marlin/src/HAL/AVR/pinsDebug_Teensyduino.h b/Marlin/src/HAL/AVR/pinsDebug_Teensyduino.h
deleted file mode 100644
index 582ae79..0000000
--- a/Marlin/src/HAL/AVR/pinsDebug_Teensyduino.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-//
-//  some of the pin mapping functions of the Teensduino extension to the Arduino IDE
-//  do not function the same as the other Arduino extensions
-//
-
-
-#define TEENSYDUINO_IDE
-
-//digitalPinToTimer(pin) function works like Arduino but Timers are not defined
-#define TIMER0B 1
-#define TIMER1A 7
-#define TIMER1B 8
-#define TIMER1C 9
-#define TIMER2A 6
-#define TIMER2B 2
-#define TIMER3A 5
-#define TIMER3B 4
-#define TIMER3C 3
-
-// digitalPinToPort function just returns the pin number so need to create our own
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-#define PE 5
-#define PF 6
-
-#undef digitalPinToPort
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] = {
-  PD, // 0  - PD0 - INT0 - PWM
-  PD, // 1  - PD1 - INT1 - PWM
-  PD, // 2  - PD2 - INT2 - RX
-  PD, // 3  - PD3 - INT3 - TX
-  PD, // 4  - PD4
-  PD, // 5  - PD5
-  PD, // 6  - PD6
-  PD, // 7  - PD7
-  PE, // 8  - PE0
-  PE, // 9  - PE1
-  PC, // 10 - PC0
-  PC, // 11 - PC1
-  PC, // 12 - PC2
-  PC, // 13 - PC3
-  PC, // 14 - PC4 - PWM
-  PC, // 15 - PC5 - PWM
-  PC, // 16 - PC6 - PWM
-  PC, // 17 - PC7
-  PE, // 18 - PE6 - INT6
-  PE, // 19 - PE7 - INT7
-  PB, // 20 - PB0
-  PB, // 21 - PB1
-  PB, // 22 - PB2
-  PB, // 23 - PB3
-  PB, // 24 - PB4 - PWM
-  PB, // 25 - PB5 - PWM
-  PB, // 26 - PB6 - PWM
-  PB, // 27 - PB7 - PWM
-  PA, // 28 - PA0
-  PA, // 29 - PA1
-  PA, // 30 - PA2
-  PA, // 31 - PA3
-  PA, // 32 - PA4
-  PA, // 33 - PA5
-  PA, // 34 - PA6
-  PA, // 35 - PA7
-  PE, // 36 - PE4 - INT4
-  PE, // 37 - PE5 - INT5
-  PF, // 38 - PF0 - A0
-  PF, // 39 - PF1 - A1
-  PF, // 40 - PF2 - A2
-  PF, // 41 - PF3 - A3
-  PF, // 42 - PF4 - A4
-  PF, // 43 - PF5 - A5
-  PF, // 44 - PF6 - A6
-  PF, // 45 - PF7 - A7
-  PE, // 46 - PE2 (not defined in teensyduino)
-  PE, // 47 - PE3 (not defined in teensyduino)
-};
-
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-
-// digitalPinToBitMask(pin) is OK
-
-#define digitalRead_mod(p)  extDigitalRead(p)   // Teensyduino's version of digitalRead doesn't
-                                                // disable the PWMs so we can use it as is
-
-// portModeRegister(pin) is OK
diff --git a/Marlin/src/HAL/AVR/pinsDebug_plus_70.h b/Marlin/src/HAL/AVR/pinsDebug_plus_70.h
deleted file mode 100644
index d9aa44c..0000000
--- a/Marlin/src/HAL/AVR/pinsDebug_plus_70.h
+++ /dev/null
@@ -1,332 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Structures for 2560 family boards that use more than 70 pins
- */
-
-#if MB(BQ_ZUM_MEGA_3D, MINIRAMBO, SCOOVO_X9H, TRIGORILLA_14)
-  #undef NUM_DIGITAL_PINS
-  #define NUM_DIGITAL_PINS            85
-#elif MB(MIGHTYBOARD_REVE)
-  #undef NUM_DIGITAL_PINS
-  #define NUM_DIGITAL_PINS            80
-#endif
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-#define PE 5
-#define PF 6
-#define PG 7
-#define PH 8
-#define PJ 10
-#define PK 11
-#define PL 12
-
-const uint8_t PROGMEM digital_pin_to_port_PGM_plus_70[] = {
-  // PORTLIST
-  // ------------------------
-  PE  , // PE 0 ** 0 ** USART0_RX
-  PE  , // PE 1 ** 1 ** USART0_TX
-  PE  , // PE 4 ** 2 ** PWM2
-  PE  , // PE 5 ** 3 ** PWM3
-  PG  , // PG 5 ** 4 ** PWM4
-  PE  , // PE 3 ** 5 ** PWM5
-  PH  , // PH 3 ** 6 ** PWM6
-  PH  , // PH 4 ** 7 ** PWM7
-  PH  , // PH 5 ** 8 ** PWM8
-  PH  , // PH 6 ** 9 ** PWM9
-  PB  , // PB 4 ** 10 ** PWM10
-  PB  , // PB 5 ** 11 ** PWM11
-  PB  , // PB 6 ** 12 ** PWM12
-  PB  , // PB 7 ** 13 ** PWM13
-  PJ  , // PJ 1 ** 14 ** USART3_TX
-  PJ  , // PJ 0 ** 15 ** USART3_RX
-  PH  , // PH 1 ** 16 ** USART2_TX
-  PH  , // PH 0 ** 17 ** USART2_RX
-  PD  , // PD 3 ** 18 ** USART1_TX
-  PD  , // PD 2 ** 19 ** USART1_RX
-  PD  , // PD 1 ** 20 ** I2C_SDA
-  PD  , // PD 0 ** 21 ** I2C_SCL
-  PA  , // PA 0 ** 22 ** D22
-  PA  , // PA 1 ** 23 ** D23
-  PA  , // PA 2 ** 24 ** D24
-  PA  , // PA 3 ** 25 ** D25
-  PA  , // PA 4 ** 26 ** D26
-  PA  , // PA 5 ** 27 ** D27
-  PA  , // PA 6 ** 28 ** D28
-  PA  , // PA 7 ** 29 ** D29
-  PC  , // PC 7 ** 30 ** D30
-  PC  , // PC 6 ** 31 ** D31
-  PC  , // PC 5 ** 32 ** D32
-  PC  , // PC 4 ** 33 ** D33
-  PC  , // PC 3 ** 34 ** D34
-  PC  , // PC 2 ** 35 ** D35
-  PC  , // PC 1 ** 36 ** D36
-  PC  , // PC 0 ** 37 ** D37
-  PD  , // PD 7 ** 38 ** D38
-  PG  , // PG 2 ** 39 ** D39
-  PG  , // PG 1 ** 40 ** D40
-  PG  , // PG 0 ** 41 ** D41
-  PL  , // PL 7 ** 42 ** D42
-  PL  , // PL 6 ** 43 ** D43
-  PL  , // PL 5 ** 44 ** D44
-  PL  , // PL 4 ** 45 ** D45
-  PL  , // PL 3 ** 46 ** D46
-  PL  , // PL 2 ** 47 ** D47
-  PL  , // PL 1 ** 48 ** D48
-  PL  , // PL 0 ** 49 ** D49
-  PB  , // PB 3 ** 50 ** SPI_MISO
-  PB  , // PB 2 ** 51 ** SPI_MOSI
-  PB  , // PB 1 ** 52 ** SPI_SCK
-  PB  , // PB 0 ** 53 ** SPI_SS
-  PF  , // PF 0 ** 54 ** A0
-  PF  , // PF 1 ** 55 ** A1
-  PF  , // PF 2 ** 56 ** A2
-  PF  , // PF 3 ** 57 ** A3
-  PF  , // PF 4 ** 58 ** A4
-  PF  , // PF 5 ** 59 ** A5
-  PF  , // PF 6 ** 60 ** A6
-  PF  , // PF 7 ** 61 ** A7
-  PK  , // PK 0 ** 62 ** A8
-  PK  , // PK 1 ** 63 ** A9
-  PK  , // PK 2 ** 64 ** A10
-  PK  , // PK 3 ** 65 ** A11
-  PK  , // PK 4 ** 66 ** A12
-  PK  , // PK 5 ** 67 ** A13
-  PK  , // PK 6 ** 68 ** A14
-  PK  , // PK 7 ** 69 ** A15
-  PG  , // PG 4 ** 70 **
-  PG  , // PG 3 ** 71 **
-  PJ  , // PJ 2 ** 72 **
-  PJ  , // PJ 3 ** 73 **
-  PJ  , // PJ 7 ** 74 **
-  PJ  , // PJ 4 ** 75 **
-  PJ  , // PJ 5 ** 76 **
-  PJ  , // PJ 6 ** 77 **
-  PE  , // PE 2 ** 78 **
-  PE  , // PE 6 ** 79 **
-  PE  , // PE 7 ** 80 **
-  PD  , // PD 4 ** 81 **
-  PD  , // PD 5 ** 82 **
-  PD  , // PD 6 ** 83 **
-  PH  , // PH 2 ** 84 **
-  PH  , // PH 7 ** 85 **
-};
-
-#define digitalPinToPort_plus_70(P) ( pgm_read_byte( digital_pin_to_port_PGM_plus_70 + (P) ) )
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM_plus_70[] = {
-  // PIN IN PORT
-  // ------------------------
-  _BV( 0 )  , // PE 0 ** 0 ** USART0_RX
-  _BV( 1 )  , // PE 1 ** 1 ** USART0_TX
-  _BV( 4 )  , // PE 4 ** 2 ** PWM2
-  _BV( 5 )  , // PE 5 ** 3 ** PWM3
-  _BV( 5 )  , // PG 5 ** 4 ** PWM4
-  _BV( 3 )  , // PE 3 ** 5 ** PWM5
-  _BV( 3 )  , // PH 3 ** 6 ** PWM6
-  _BV( 4 )  , // PH 4 ** 7 ** PWM7
-  _BV( 5 )  , // PH 5 ** 8 ** PWM8
-  _BV( 6 )  , // PH 6 ** 9 ** PWM9
-  _BV( 4 )  , // PB 4 ** 10 ** PWM10
-  _BV( 5 )  , // PB 5 ** 11 ** PWM11
-  _BV( 6 )  , // PB 6 ** 12 ** PWM12
-  _BV( 7 )  , // PB 7 ** 13 ** PWM13
-  _BV( 1 )  , // PJ 1 ** 14 ** USART3_TX
-  _BV( 0 )  , // PJ 0 ** 15 ** USART3_RX
-  _BV( 1 )  , // PH 1 ** 16 ** USART2_TX
-  _BV( 0 )  , // PH 0 ** 17 ** USART2_RX
-  _BV( 3 )  , // PD 3 ** 18 ** USART1_TX
-  _BV( 2 )  , // PD 2 ** 19 ** USART1_RX
-  _BV( 1 )  , // PD 1 ** 20 ** I2C_SDA
-  _BV( 0 )  , // PD 0 ** 21 ** I2C_SCL
-  _BV( 0 )  , // PA 0 ** 22 ** D22
-  _BV( 1 )  , // PA 1 ** 23 ** D23
-  _BV( 2 )  , // PA 2 ** 24 ** D24
-  _BV( 3 )  , // PA 3 ** 25 ** D25
-  _BV( 4 )  , // PA 4 ** 26 ** D26
-  _BV( 5 )  , // PA 5 ** 27 ** D27
-  _BV( 6 )  , // PA 6 ** 28 ** D28
-  _BV( 7 )  , // PA 7 ** 29 ** D29
-  _BV( 7 )  , // PC 7 ** 30 ** D30
-  _BV( 6 )  , // PC 6 ** 31 ** D31
-  _BV( 5 )  , // PC 5 ** 32 ** D32
-  _BV( 4 )  , // PC 4 ** 33 ** D33
-  _BV( 3 )  , // PC 3 ** 34 ** D34
-  _BV( 2 )  , // PC 2 ** 35 ** D35
-  _BV( 1 )  , // PC 1 ** 36 ** D36
-  _BV( 0 )  , // PC 0 ** 37 ** D37
-  _BV( 7 )  , // PD 7 ** 38 ** D38
-  _BV( 2 )  , // PG 2 ** 39 ** D39
-  _BV( 1 )  , // PG 1 ** 40 ** D40
-  _BV( 0 )  , // PG 0 ** 41 ** D41
-  _BV( 7 )  , // PL 7 ** 42 ** D42
-  _BV( 6 )  , // PL 6 ** 43 ** D43
-  _BV( 5 )  , // PL 5 ** 44 ** D44
-  _BV( 4 )  , // PL 4 ** 45 ** D45
-  _BV( 3 )  , // PL 3 ** 46 ** D46
-  _BV( 2 )  , // PL 2 ** 47 ** D47
-  _BV( 1 )  , // PL 1 ** 48 ** D48
-  _BV( 0 )  , // PL 0 ** 49 ** D49
-  _BV( 3 )  , // PB 3 ** 50 ** SPI_MISO
-  _BV( 2 )  , // PB 2 ** 51 ** SPI_MOSI
-  _BV( 1 )  , // PB 1 ** 52 ** SPI_SCK
-  _BV( 0 )  , // PB 0 ** 53 ** SPI_SS
-  _BV( 0 )  , // PF 0 ** 54 ** A0
-  _BV( 1 )  , // PF 1 ** 55 ** A1
-  _BV( 2 )  , // PF 2 ** 56 ** A2
-  _BV( 3 )  , // PF 3 ** 57 ** A3
-  _BV( 4 )  , // PF 4 ** 58 ** A4
-  _BV( 5 )  , // PF 5 ** 59 ** A5
-  _BV( 6 )  , // PF 6 ** 60 ** A6
-  _BV( 7 )  , // PF 7 ** 61 ** A7
-  _BV( 0 )  , // PK 0 ** 62 ** A8
-  _BV( 1 )  , // PK 1 ** 63 ** A9
-  _BV( 2 )  , // PK 2 ** 64 ** A10
-  _BV( 3 )  , // PK 3 ** 65 ** A11
-  _BV( 4 )  , // PK 4 ** 66 ** A12
-  _BV( 5 )  , // PK 5 ** 67 ** A13
-  _BV( 6 )  , // PK 6 ** 68 ** A14
-  _BV( 7 )  , // PK 7 ** 69 ** A15
-  _BV( 4 )  , // PG 4 ** 70 **
-  _BV( 3 )  , // PG 3 ** 71 **
-  _BV( 2 )  , // PJ 2 ** 72 **
-  _BV( 3 )  , // PJ 3 ** 73 **
-  _BV( 7 )  , // PJ 7 ** 74 **
-  _BV( 4 )  , // PJ 4 ** 75 **
-  _BV( 5 )  , // PJ 5 ** 76 **
-  _BV( 6 )  , // PJ 6 ** 77 **
-  _BV( 2 )  , // PE 2 ** 78 **
-  _BV( 6 )  , // PE 6 ** 79 **
-  _BV( 7 )  , // PE 7 ** 80 **
-  _BV( 4 )  , // PD 4 ** 81 **
-  _BV( 5 )  , // PD 5 ** 82 **
-  _BV( 6 )  , // PD 6 ** 83 **
-  _BV( 2 )  , // PH 2 ** 84 **
-  _BV( 7 )  , // PH 7 ** 85 **
-};
-
-#define digitalPinToBitMask_plus_70(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM_plus_70 + (P) ) )
-
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM_plus_70[] = {
-  // TIMERS
-  // ------------------------
-  NOT_ON_TIMER  , // PE 0 ** 0 ** USART0_RX
-  NOT_ON_TIMER  , // PE 1 ** 1 ** USART0_TX
-  TIMER3B , // PE 4 ** 2 ** PWM2
-  TIMER3C , // PE 5 ** 3 ** PWM3
-  TIMER0B , // PG 5 ** 4 ** PWM4
-  TIMER3A , // PE 3 ** 5 ** PWM5
-  TIMER4A , // PH 3 ** 6 ** PWM6
-  TIMER4B , // PH 4 ** 7 ** PWM7
-  TIMER4C , // PH 5 ** 8 ** PWM8
-  TIMER2B , // PH 6 ** 9 ** PWM9
-  TIMER2A , // PB 4 ** 10 ** PWM10
-  TIMER1A , // PB 5 ** 11 ** PWM11
-  TIMER1B , // PB 6 ** 12 ** PWM12
-  TIMER0A , // PB 7 ** 13 ** PWM13
-  NOT_ON_TIMER  , // PJ 1 ** 14 ** USART3_TX
-  NOT_ON_TIMER  , // PJ 0 ** 15 ** USART3_RX
-  NOT_ON_TIMER  , // PH 1 ** 16 ** USART2_TX
-  NOT_ON_TIMER  , // PH 0 ** 17 ** USART2_RX
-  NOT_ON_TIMER  , // PD 3 ** 18 ** USART1_TX
-  NOT_ON_TIMER  , // PD 2 ** 19 ** USART1_RX
-  NOT_ON_TIMER  , // PD 1 ** 20 ** I2C_SDA
-  NOT_ON_TIMER  , // PD 0 ** 21 ** I2C_SCL
-  NOT_ON_TIMER  , // PA 0 ** 22 ** D22
-  NOT_ON_TIMER  , // PA 1 ** 23 ** D23
-  NOT_ON_TIMER  , // PA 2 ** 24 ** D24
-  NOT_ON_TIMER  , // PA 3 ** 25 ** D25
-  NOT_ON_TIMER  , // PA 4 ** 26 ** D26
-  NOT_ON_TIMER  , // PA 5 ** 27 ** D27
-  NOT_ON_TIMER  , // PA 6 ** 28 ** D28
-  NOT_ON_TIMER  , // PA 7 ** 29 ** D29
-  NOT_ON_TIMER  , // PC 7 ** 30 ** D30
-  NOT_ON_TIMER  , // PC 6 ** 31 ** D31
-  NOT_ON_TIMER  , // PC 5 ** 32 ** D32
-  NOT_ON_TIMER  , // PC 4 ** 33 ** D33
-  NOT_ON_TIMER  , // PC 3 ** 34 ** D34
-  NOT_ON_TIMER  , // PC 2 ** 35 ** D35
-  NOT_ON_TIMER  , // PC 1 ** 36 ** D36
-  NOT_ON_TIMER  , // PC 0 ** 37 ** D37
-  NOT_ON_TIMER  , // PD 7 ** 38 ** D38
-  NOT_ON_TIMER  , // PG 2 ** 39 ** D39
-  NOT_ON_TIMER  , // PG 1 ** 40 ** D40
-  NOT_ON_TIMER  , // PG 0 ** 41 ** D41
-  NOT_ON_TIMER  , // PL 7 ** 42 ** D42
-  NOT_ON_TIMER  , // PL 6 ** 43 ** D43
-  TIMER5C , // PL 5 ** 44 ** D44
-  TIMER5B , // PL 4 ** 45 ** D45
-  TIMER5A , // PL 3 ** 46 ** D46
-  NOT_ON_TIMER  , // PL 2 ** 47 ** D47
-  NOT_ON_TIMER  , // PL 1 ** 48 ** D48
-  NOT_ON_TIMER  , // PL 0 ** 49 ** D49
-  NOT_ON_TIMER  , // PB 3 ** 50 ** SPI_MISO
-  NOT_ON_TIMER  , // PB 2 ** 51 ** SPI_MOSI
-  NOT_ON_TIMER  , // PB 1 ** 52 ** SPI_SCK
-  NOT_ON_TIMER  , // PB 0 ** 53 ** SPI_SS
-  NOT_ON_TIMER  , // PF 0 ** 54 ** A0
-  NOT_ON_TIMER  , // PF 1 ** 55 ** A1
-  NOT_ON_TIMER  , // PF 2 ** 56 ** A2
-  NOT_ON_TIMER  , // PF 3 ** 57 ** A3
-  NOT_ON_TIMER  , // PF 4 ** 58 ** A4
-  NOT_ON_TIMER  , // PF 5 ** 59 ** A5
-  NOT_ON_TIMER  , // PF 6 ** 60 ** A6
-  NOT_ON_TIMER  , // PF 7 ** 61 ** A7
-  NOT_ON_TIMER  , // PK 0 ** 62 ** A8
-  NOT_ON_TIMER  , // PK 1 ** 63 ** A9
-  NOT_ON_TIMER  , // PK 2 ** 64 ** A10
-  NOT_ON_TIMER  , // PK 3 ** 65 ** A11
-  NOT_ON_TIMER  , // PK 4 ** 66 ** A12
-  NOT_ON_TIMER  , // PK 5 ** 67 ** A13
-  NOT_ON_TIMER  , // PK 6 ** 68 ** A14
-  NOT_ON_TIMER  , // PK 7 ** 69 ** A15
-  NOT_ON_TIMER  , // PG 4 ** 70 **
-  NOT_ON_TIMER  , // PG 3 ** 71 **
-  NOT_ON_TIMER  , // PJ 2 ** 72 **
-  NOT_ON_TIMER  , // PJ 3 ** 73 **
-  NOT_ON_TIMER  , // PJ 7 ** 74 **
-  NOT_ON_TIMER  , // PJ 4 ** 75 **
-  NOT_ON_TIMER  , // PJ 5 ** 76 **
-  NOT_ON_TIMER  , // PJ 6 ** 77 **
-  NOT_ON_TIMER  , // PE 2 ** 78 **
-  NOT_ON_TIMER  , // PE 6 ** 79 **
-};
-
-#define digitalPinToTimer_plus_70(P) ( pgm_read_byte( digital_pin_to_timer_PGM_plus_70 + (P) ) )
-
-/**
- *  Interrupts that are not implemented
- *
- *  INT6    E6 79
- *  INT7    E7 80
- *  PCINT11 J2 72
- *  PCINT12 J3 73
- *  PCINT13 J4 75
- *  PCINT14 J5 76
- *  PCINT15 J6 77
- */
diff --git a/Marlin/src/HAL/AVR/spi_pins.h b/Marlin/src/HAL/AVR/spi_pins.h
deleted file mode 100644
index 8319729..0000000
--- a/Marlin/src/HAL/AVR/spi_pins.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Define SPI Pins: SCK, MISO, MOSI, SS
- */
-#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__)
-  #define AVR_SCK_PIN  13
-  #define AVR_MISO_PIN 12
-  #define AVR_MOSI_PIN 11
-  #define AVR_SS_PIN   10
-#elif defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__)
-  #define AVR_SCK_PIN  7
-  #define AVR_MISO_PIN 6
-  #define AVR_MOSI_PIN 5
-  #define AVR_SS_PIN   4
-#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-  #define AVR_SCK_PIN  52
-  #define AVR_MISO_PIN 50
-  #define AVR_MOSI_PIN 51
-  #define AVR_SS_PIN   53
-#elif defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__)
-  #define AVR_SCK_PIN  21
-  #define AVR_MISO_PIN 23
-  #define AVR_MOSI_PIN 22
-  #define AVR_SS_PIN   20
-#elif defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)
-  #define AVR_SCK_PIN  10
-  #define AVR_MISO_PIN 12
-  #define AVR_MOSI_PIN 11
-  #define AVR_SS_PIN   16
-#endif
-
-#ifndef SD_SCK_PIN
-  #define SD_SCK_PIN  AVR_SCK_PIN
-#endif
-#ifndef SD_MISO_PIN
-  #define SD_MISO_PIN AVR_MISO_PIN
-#endif
-#ifndef SD_MOSI_PIN
-  #define SD_MOSI_PIN AVR_MOSI_PIN
-#endif
-#ifndef SD_SS_PIN
-  #define SD_SS_PIN   AVR_SS_PIN
-#endif
diff --git a/Marlin/src/HAL/AVR/timers.h b/Marlin/src/HAL/AVR/timers.h
deleted file mode 100644
index 33c3880..0000000
--- a/Marlin/src/HAL/AVR/timers.h
+++ /dev/null
@@ -1,260 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef uint16_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFF
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define HAL_TIMER_RATE          ((F_CPU) / 8)    // i.e., 2MHz or 2.5MHz
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         1
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         0
-#endif
-
-#define TEMP_TIMER_FREQUENCY    ((F_CPU) / 64.0 / 256.0)
-
-#define STEPPER_TIMER_RATE      HAL_TIMER_RATE
-#define STEPPER_TIMER_PRESCALE  8
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // Cannot be of type double
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT()  SBI(TIMSK1, OCIE1A)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() CBI(TIMSK1, OCIE1A)
-#define STEPPER_ISR_ENABLED()             TEST(TIMSK1, OCIE1A)
-
-#define ENABLE_TEMPERATURE_INTERRUPT()     SBI(TIMSK0, OCIE0A)
-#define DISABLE_TEMPERATURE_INTERRUPT()    CBI(TIMSK0, OCIE0A)
-#define TEMPERATURE_ISR_ENABLED()         TEST(TIMSK0, OCIE0A)
-
-FORCE_INLINE void HAL_timer_start(const uint8_t timer_num, const uint32_t) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      // waveform generation = 0100 = CTC
-      SET_WGM(1, CTC_OCRnA);
-
-      // output mode = 00 (disconnected)
-      SET_COMA(1, NORMAL);
-
-      // Set the timer pre-scaler
-      // Generally we use a divider of 8, resulting in a 2MHz timer
-      // frequency on a 16MHz MCU. If you are going to change this, be
-      // sure to regenerate speed_lookuptable.h with
-      // create_speed_lookuptable.py
-      SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
-
-      // Init Stepper ISR to 122 Hz for quick starting
-      // (F_CPU) / (STEPPER_TIMER_PRESCALE) / frequency
-      OCR1A = 0x4000;
-      TCNT1 = 0;
-      break;
-
-    case MF_TIMER_TEMP:
-      // Use timer0 for temperature measurement
-      // Interleave temperature interrupt with millies interrupt
-      OCR0A = 128;
-      break;
-  }
-}
-
-#define TIMER_OCR_1             OCR1A
-#define TIMER_COUNTER_1         TCNT1
-
-#define TIMER_OCR_0             OCR0A
-#define TIMER_COUNTER_0         TCNT0
-
-#define _CAT(a,V...) a##V
-#define HAL_timer_set_compare(timer, compare) (_CAT(TIMER_OCR_, timer) = compare)
-#define HAL_timer_get_compare(timer) _CAT(TIMER_OCR_, timer)
-#define HAL_timer_get_count(timer) _CAT(TIMER_COUNTER_, timer)
-
-/**
- * On AVR there is no hardware prioritization and preemption of
- * interrupts, so this emulates it. The UART has first priority
- * (otherwise, characters will be lost due to UART overflow).
- * Then: Stepper, Endstops, Temperature, and -finally- all others.
- */
-#define HAL_timer_isr_prologue(T) NOOP
-#define HAL_timer_isr_epilogue(T) NOOP
-
-#ifndef HAL_STEP_TIMER_ISR
-
-/* 18 cycles maximum latency */
-#define HAL_STEP_TIMER_ISR() \
-extern "C" void TIMER1_COMPA_vect() __attribute__ ((signal, naked, used, externally_visible)); \
-extern "C" void TIMER1_COMPA_vect_bottom() asm ("TIMER1_COMPA_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
-void TIMER1_COMPA_vect() { \
-  __asm__ __volatile__ ( \
-    A("push r16")                      /* 2 Save R16 */ \
-    A("in r16, __SREG__")              /* 1 Get SREG */ \
-    A("push r16")                      /* 2 Save SREG into stack */ \
-    A("lds r16, %[timsk0]")            /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
-    A("push r16")                      /* 2 Save TIMSK0 into the stack */ \
-    A("andi r16,~%[msk0]")             /* 1 Disable the temperature ISR */ \
-    A("sts %[timsk0], r16")            /* 2 And set the new value */ \
-    A("lds r16, %[timsk1]")            /* 2 Load into R0 the stepper timer Interrupt mask register [TIMSK1] */ \
-    A("andi r16,~%[msk1]")             /* 1 Disable the stepper ISR */ \
-    A("sts %[timsk1], r16")            /* 2 And set the new value */ \
-    A("push r16")                      /* 2 Save TIMSK1 into stack */ \
-    A("in r16, 0x3B")                  /* 1 Get RAMPZ register */ \
-    A("push r16")                      /* 2 Save RAMPZ into stack */ \
-    A("in r16, 0x3C")                  /* 1 Get EIND register */ \
-    A("push r0")                       /* C runtime can modify all the following registers without restoring them */ \
-    A("push r1")                       \
-    A("push r18")                      \
-    A("push r19")                      \
-    A("push r20")                      \
-    A("push r21")                      \
-    A("push r22")                      \
-    A("push r23")                      \
-    A("push r24")                      \
-    A("push r25")                      \
-    A("push r26")                      \
-    A("push r27")                      \
-    A("push r30")                      \
-    A("push r31")                      \
-    A("clr r1")                        /* C runtime expects this register to be 0 */ \
-    A("call TIMER1_COMPA_vect_bottom") /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
-    A("pop r31")                       \
-    A("pop r30")                       \
-    A("pop r27")                       \
-    A("pop r26")                       \
-    A("pop r25")                       \
-    A("pop r24")                       \
-    A("pop r23")                       \
-    A("pop r22")                       \
-    A("pop r21")                       \
-    A("pop r20")                       \
-    A("pop r19")                       \
-    A("pop r18")                       \
-    A("pop r1")                        \
-    A("pop r0")                        \
-    A("out 0x3C, r16")                 /* 1 Restore EIND register */ \
-    A("pop r16")                       /* 2 Get the original RAMPZ register value */ \
-    A("out 0x3B, r16")                 /* 1 Restore RAMPZ register to its original value */ \
-    A("pop r16")                       /* 2 Get the original TIMSK1 value but with stepper ISR disabled */ \
-    A("ori r16,%[msk1]")               /* 1 Reenable the stepper ISR */ \
-    A("cli")                           /* 1 Disable global interrupts - Reenabling Stepper ISR can reenter amd temperature can reenter, and we want that, if it happens, after this ISR has ended */ \
-    A("sts %[timsk1], r16")            /* 2 And restore the old value - This reenables the stepper ISR */ \
-    A("pop r16")                       /* 2 Get the temperature timer Interrupt mask register [TIMSK0] */ \
-    A("sts %[timsk0], r16")            /* 2 And restore the old value - This reenables the temperature ISR */ \
-    A("pop r16")                       /* 2 Get the old SREG value */ \
-    A("out __SREG__, r16")             /* 1 And restore the SREG value */ \
-    A("pop r16")                       /* 2 Restore R16 value */ \
-    A("reti")                          /* 4 Return from interrupt */ \
-    :                                   \
-    : [timsk0] "i" ((uint16_t)&TIMSK0), \
-      [timsk1] "i" ((uint16_t)&TIMSK1), \
-      [msk0] "M" ((uint8_t)(1<<OCIE0A)),\
-      [msk1] "M" ((uint8_t)(1<<OCIE1A)) \
-    : \
-  ); \
-} \
-void TIMER1_COMPA_vect_bottom()
-
-#endif // HAL_STEP_TIMER_ISR
-
-#ifndef HAL_TEMP_TIMER_ISR
-
-/* 14 cycles maximum latency */
-#define HAL_TEMP_TIMER_ISR() \
-extern "C" void TIMER0_COMPA_vect() __attribute__ ((signal, naked, used, externally_visible)); \
-extern "C" void TIMER0_COMPA_vect_bottom()  asm ("TIMER0_COMPA_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
-void TIMER0_COMPA_vect() { \
-  __asm__ __volatile__ ( \
-    A("push r16")                       /* 2 Save R16 */ \
-    A("in r16, __SREG__")               /* 1 Get SREG */ \
-    A("push r16")                       /* 2 Save SREG into stack */ \
-    A("lds r16, %[timsk0]")             /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
-    A("andi r16,~%[msk0]")              /* 1 Disable the temperature ISR */ \
-    A("sts %[timsk0], r16")             /* 2 And set the new value */ \
-    A("sei")                            /* 1 Enable global interrupts - It is safe, as the temperature ISR is disabled, so we cannot reenter it */    \
-    A("push r16")                       /* 2 Save TIMSK0 into stack */ \
-    A("in r16, 0x3B")                   /* 1 Get RAMPZ register */ \
-    A("push r16")                       /* 2 Save RAMPZ into stack */ \
-    A("in r16, 0x3C")                   /* 1 Get EIND register */ \
-    A("push r0")                        /* C runtime can modify all the following registers without restoring them */ \
-    A("push r1")                        \
-    A("push r18")                       \
-    A("push r19")                       \
-    A("push r20")                       \
-    A("push r21")                       \
-    A("push r22")                       \
-    A("push r23")                       \
-    A("push r24")                       \
-    A("push r25")                       \
-    A("push r26")                       \
-    A("push r27")                       \
-    A("push r30")                       \
-    A("push r31")                       \
-    A("clr r1")                         /* C runtime expects this register to be 0 */ \
-    A("call TIMER0_COMPA_vect_bottom")  /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
-    A("pop r31")                        \
-    A("pop r30")                        \
-    A("pop r27")                        \
-    A("pop r26")                        \
-    A("pop r25")                        \
-    A("pop r24")                        \
-    A("pop r23")                        \
-    A("pop r22")                        \
-    A("pop r21")                        \
-    A("pop r20")                        \
-    A("pop r19")                        \
-    A("pop r18")                        \
-    A("pop r1")                         \
-    A("pop r0")                         \
-    A("out 0x3C, r16")                  /* 1 Restore EIND register */ \
-    A("pop r16")                        /* 2 Get the original RAMPZ register value */ \
-    A("out 0x3B, r16")                  /* 1 Restore RAMPZ register to its original value */ \
-    A("pop r16")                        /* 2 Get the original TIMSK0 value but with temperature ISR disabled */ \
-    A("ori r16,%[msk0]")                /* 1 Enable temperature ISR */ \
-    A("cli")                            /* 1 Disable global interrupts - We must do this, as we will reenable the temperature ISR, and we don't want to reenter this handler until the current one is done */ \
-    A("sts %[timsk0], r16")             /* 2 And restore the old value */ \
-    A("pop r16")                        /* 2 Get the old SREG */ \
-    A("out __SREG__, r16")              /* 1 And restore the SREG value */ \
-    A("pop r16")                        /* 2 Restore R16 */ \
-    A("reti")                           /* 4 Return from interrupt */ \
-    :                                   \
-    : [timsk0] "i"((uint16_t)&TIMSK0),  \
-      [msk0] "M" ((uint8_t)(1<<OCIE0A)) \
-    : \
-  ); \
-} \
-void TIMER0_COMPA_vect_bottom()
-
-#endif // HAL_TEMP_TIMER_ISR
diff --git a/Marlin/src/HAL/AVR/u8g_com_HAL_AVR_sw_spi.cpp b/Marlin/src/HAL/AVR/u8g_com_HAL_AVR_sw_spi.cpp
deleted file mode 100644
index 45b5437..0000000
--- a/Marlin/src/HAL/AVR/u8g_com_HAL_AVR_sw_spi.cpp
+++ /dev/null
@@ -1,193 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_st7920_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if defined(ARDUINO) && !defined(ARDUINO_ARCH_STM32) && !defined(ARDUINO_ARCH_SAM)
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include "../shared/Marduino.h"
-#include "../shared/Delay.h"
-
-#include <U8glib-HAL.h>
-
-static uint8_t u8g_bitData, u8g_bitNotData, u8g_bitClock, u8g_bitNotClock;
-static volatile uint8_t *u8g_outData, *u8g_outClock;
-
-static void u8g_com_arduino_init_shift_out(uint8_t dataPin, uint8_t clockPin) {
-  u8g_outData = portOutputRegister(digitalPinToPort(dataPin));
-  u8g_outClock = portOutputRegister(digitalPinToPort(clockPin));
-  u8g_bitData = digitalPinToBitMask(dataPin);
-  u8g_bitClock = digitalPinToBitMask(clockPin);
-
-  u8g_bitNotClock = u8g_bitClock;
-  u8g_bitNotClock ^= 0xFF;
-
-  u8g_bitNotData = u8g_bitData;
-  u8g_bitNotData ^= 0xFF;
-}
-
-void u8g_spiSend_sw_AVR_mode_0(uint8_t val) {
-  uint8_t bitData = u8g_bitData,
-          bitNotData = u8g_bitNotData,
-          bitClock = u8g_bitClock,
-          bitNotClock = u8g_bitNotClock;
-  volatile uint8_t *outData = u8g_outData,
-                   *outClock = u8g_outClock;
-  U8G_ATOMIC_START();
-  LOOP_L_N(i, 8) {
-    if (val & 0x80)
-      *outData |= bitData;
-    else
-      *outData &= bitNotData;
-    *outClock |= bitClock;
-    val <<= 1;
-    *outClock &= bitNotClock;
-  }
-  U8G_ATOMIC_END();
-}
-
-void u8g_spiSend_sw_AVR_mode_3(uint8_t val) {
-  uint8_t bitData = u8g_bitData,
-          bitNotData = u8g_bitNotData,
-          bitClock = u8g_bitClock,
-          bitNotClock = u8g_bitNotClock;
-  volatile uint8_t *outData = u8g_outData,
-                   *outClock = u8g_outClock;
-  U8G_ATOMIC_START();
-  LOOP_L_N(i, 8) {
-    *outClock &= bitNotClock;
-    if (val & 0x80)
-      *outData |= bitData;
-    else
-      *outData &= bitNotData;
-    *outClock |= bitClock;
-    val <<= 1;
-  }
-  U8G_ATOMIC_END();
-}
-
-
-#if ENABLED(FYSETC_MINI_12864)
-  #define SPISEND_SW_AVR u8g_spiSend_sw_AVR_mode_3
-#else
-  #define SPISEND_SW_AVR u8g_spiSend_sw_AVR_mode_0
-#endif
-
-uint8_t u8g_com_HAL_AVR_sw_sp_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      u8g_com_arduino_init_shift_out(u8g->pin_list[U8G_PI_MOSI], u8g->pin_list[U8G_PI_SCK]);
-      u8g_com_arduino_assign_pin_output_high(u8g);
-      u8g_com_arduino_digital_write(u8g, U8G_PI_SCK, 0);
-      u8g_com_arduino_digital_write(u8g, U8G_PI_MOSI, 0);
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_com_arduino_digital_write(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      #if ENABLED(FYSETC_MINI_12864)           // LCD SPI is running mode 3 while SD card is running mode 0
-        if (arg_val) {                         //   SCK idle state needs to be set to the proper idle state before
-                                               //   the next chip select goes active
-          u8g_com_arduino_digital_write(u8g, U8G_PI_SCK, 1);  // Set SCK to mode 3 idle state before CS goes active
-          u8g_com_arduino_digital_write(u8g, U8G_PI_CS, LOW);
-        }
-        else {
-          u8g_com_arduino_digital_write(u8g, U8G_PI_CS, HIGH);
-          u8g_com_arduino_digital_write(u8g, U8G_PI_SCK, 0);  // Set SCK to mode 0 idle state after CS goes inactive
-        }
-      #else
-        u8g_com_arduino_digital_write(u8g, U8G_PI_CS, !arg_val);
-      #endif
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      SPISEND_SW_AVR(arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          SPISEND_SW_AVR(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          SPISEND_SW_AVR(u8g_pgm_read(ptr));
-          ptr++;
-          arg_val--;
-        }
-      }
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g_com_arduino_digital_write(u8g, U8G_PI_A0, arg_val);
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/HAL.cpp b/Marlin/src/HAL/DUE/HAL.cpp
deleted file mode 100644
index 4353f16..0000000
--- a/Marlin/src/HAL/DUE/HAL.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL for Arduino Due and compatible (SAM3X8E)
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-#include "../../MarlinCore.h"
-
-#include <Wire.h>
-#include "usb/usb_task.h"
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-uint16_t MarlinHAL::adc_result;
-
-// ------------------------
-// Public functions
-// ------------------------
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  extern void install_min_serial();
-#endif
-
-void MarlinHAL::init() {
-  #if ENABLED(SDSUPPORT)
-    OUT_WRITE(SDSS, HIGH);  // Try to set SDSS inactive before any other SPI users start up
-  #endif
-  usb_task_init();          // Initialize the USB stack
-  TERN_(POSTMORTEM_DEBUGGING, install_min_serial()); // Install the min serial handler
-}
-
-void MarlinHAL::init_board() {
-  #ifdef BOARD_INIT
-    BOARD_INIT();
-  #endif
-}
-
-void MarlinHAL::idletask() { usb_task_idle(); } // Perform USB stack housekeeping
-
-uint8_t MarlinHAL::get_reset_source() {
-  switch ((RSTC->RSTC_SR >> 8) & 0x07) {
-    case 0: return RST_POWER_ON;
-    case 1: return RST_BACKUP;
-    case 2: return RST_WATCHDOG;
-    case 3: return RST_SOFTWARE;
-    case 4: return RST_EXTERNAL;
-    default: return 0;
-  }
-}
-
-void MarlinHAL::reboot() { rstc_start_software_reset(RSTC); }
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  // Initialize watchdog - On SAM3X, Watchdog was already configured
-  //  and enabled or disabled at startup, so no need to reconfigure it
-  //  here.
-  void MarlinHAL::watchdog_init() { WDT_Restart(WDT); } // Reset watchdog to start clean
-
-  // Reset watchdog. MUST be called at least every 4 seconds after the
-  // first watchdog_init or AVR will go into emergency procedures.
-  void MarlinHAL::watchdog_refresh() { watchdogReset(); }
-
-#endif
-
-// Override Arduino runtime to either config or disable the watchdog
-//
-// We need to configure the watchdog as soon as possible in the boot
-// process, because watchdog initialization at hardware reset on SAM3X8E
-// is unreliable, and there is risk of unintended resets if we delay
-// that initialization to a later time.
-void watchdogSetup() {
-
-  #if ENABLED(USE_WATCHDOG)
-
-    // 4 seconds timeout
-    uint32_t timeout = TERN(WATCHDOG_DURATION_8S, 8000, 4000);
-
-    // Calculate timeout value in WDT counter ticks: This assumes
-    // the slow clock is running at 32.768 kHz watchdog
-    // frequency is therefore 32768 / 128 = 256 Hz
-    timeout = (timeout << 8) / 1000;
-    if (timeout == 0)
-      timeout = 1;
-    else if (timeout > 0xFFF)
-      timeout = 0xFFF;
-
-    // We want to enable the watchdog with the specified timeout
-    uint32_t value =
-      WDT_MR_WDV(timeout) |               // With the specified timeout
-      WDT_MR_WDD(timeout) |               // and no invalid write window
-    #if !(SAMV70 || SAMV71 || SAME70 || SAMS70)
-      WDT_MR_WDRPROC   |                  // WDT fault resets processor only - We want
-                                          // to keep PIO controller state
-    #endif
-      WDT_MR_WDDBGHLT  |                  // WDT stops in debug state.
-      WDT_MR_WDIDLEHLT;                   // WDT stops in idle state.
-
-    #if ENABLED(WATCHDOG_RESET_MANUAL)
-      // We enable the watchdog timer, but only for the interrupt.
-
-      // Configure WDT to only trigger an interrupt
-      value |= WDT_MR_WDFIEN;             // Enable WDT fault interrupt.
-
-      // Disable WDT interrupt (just in case, to avoid triggering it!)
-      NVIC_DisableIRQ(WDT_IRQn);
-
-      // We NEED memory barriers to ensure Interrupts are actually disabled!
-      // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-      __DSB();
-      __ISB();
-
-      // Initialize WDT with the given parameters
-      WDT_Enable(WDT, value);
-
-      // Configure and enable WDT interrupt.
-      NVIC_ClearPendingIRQ(WDT_IRQn);
-      NVIC_SetPriority(WDT_IRQn, 0); // Use highest priority, so we detect all kinds of lockups
-      NVIC_EnableIRQ(WDT_IRQn);
-
-    #else
-
-      // a WDT fault triggers a reset
-      value |= WDT_MR_WDRSTEN;
-
-      // Initialize WDT with the given parameters
-      WDT_Enable(WDT, value);
-
-    #endif
-
-    // Reset the watchdog
-    WDT_Restart(WDT);
-
-  #else
-
-    // Make sure to completely disable the Watchdog
-    WDT_Disable(WDT);
-
-  #endif
-}
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-extern "C" {
-  extern unsigned int _ebss; // end of bss section
-}
-
-// Return free memory between end of heap (or end bss) and whatever is current
-int freeMemory() {
-  int free_memory, heap_end = (int)_sbrk(0);
-  return (int)&free_memory - (heap_end ?: (int)&_ebss);
-}
-
-// ------------------------
-// Serial Ports
-// ------------------------
-
-// Forward the default serial ports
-#if USING_HW_SERIAL0
-  DefaultSerial1 MSerial0(false, Serial);
-#endif
-#if USING_HW_SERIAL1
-  DefaultSerial2 MSerial1(false, Serial1);
-#endif
-#if USING_HW_SERIAL2
-  DefaultSerial3 MSerial2(false, Serial2);
-#endif
-#if USING_HW_SERIAL3
-  DefaultSerial4 MSerial3(false, Serial3);
-#endif
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/HAL.h b/Marlin/src/HAL/DUE/HAL.h
deleted file mode 100644
index 4d3f482..0000000
--- a/Marlin/src/HAL/DUE/HAL.h
+++ /dev/null
@@ -1,233 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Arduino Due and compatible (SAM3X8E)
- */
-
-#define CPU_32_BIT
-
-#include "../shared/Marduino.h"
-#include "../shared/eeprom_if.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-#include "fastio.h"
-
-#include <stdint.h>
-
-#include "../../core/serial_hook.h"
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
-typedef ForwardSerial1Class< decltype(Serial1) > DefaultSerial2;
-typedef ForwardSerial1Class< decltype(Serial2) > DefaultSerial3;
-typedef ForwardSerial1Class< decltype(Serial3) > DefaultSerial4;
-extern DefaultSerial1 MSerial0;
-extern DefaultSerial2 MSerial1;
-extern DefaultSerial3 MSerial2;
-extern DefaultSerial4 MSerial3;
-
-#define _MSERIAL(X) MSerial##X
-#define MSERIAL(X) _MSERIAL(X)
-
-#if SERIAL_PORT == -1 || ENABLED(EMERGENCY_PARSER)
-  #define MYSERIAL1 customizedSerial1
-#elif WITHIN(SERIAL_PORT, 0, 3)
-  #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-#else
-  #error "The required SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
-#endif
-
-#ifdef SERIAL_PORT_2
-  #if SERIAL_PORT_2 == -1 || ENABLED(EMERGENCY_PARSER)
-    #define MYSERIAL2 customizedSerial2
-  #elif WITHIN(SERIAL_PORT_2, 0, 3)
-    #define MYSERIAL2 MSERIAL(SERIAL_PORT_2)
-  #else
-    #error "SERIAL_PORT_2 must be from 0 to 3, or -1 for USB Serial."
-  #endif
-#endif
-
-#ifdef SERIAL_PORT_3
-  #if SERIAL_PORT_3 == -1 || ENABLED(EMERGENCY_PARSER)
-    #define MYSERIAL3 customizedSerial3
-  #elif WITHIN(SERIAL_PORT_3, 0, 3)
-    #define MYSERIAL3 MSERIAL(SERIAL_PORT_3)
-  #else
-    #error "SERIAL_PORT_3 must be from 0 to 3, or -1 for USB Serial."
-  #endif
-#endif
-
-#ifdef MMU2_SERIAL_PORT
-  #if WITHIN(MMU2_SERIAL_PORT, 0, 3)
-    #define MMU2_SERIAL MSERIAL(MMU2_SERIAL_PORT)
-  #else
-    #error "MMU2_SERIAL_PORT must be from 0 to 3."
-  #endif
-#endif
-
-#ifdef LCD_SERIAL_PORT
-  #if WITHIN(LCD_SERIAL_PORT, 0, 3)
-    #define LCD_SERIAL MSERIAL(LCD_SERIAL_PORT)
-  #else
-    #error "LCD_SERIAL_PORT must be from 0 to 3."
-  #endif
-#endif
-
-#include "MarlinSerial.h"
-#include "MarlinSerialUSB.h"
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef int8_t pin_t;
-
-#define SHARED_SERVOS HAS_SERVOS  // Use shared/servos.cpp
-
-class Servo;
-typedef Servo hal_servo_t;
-
-//
-// Interrupts
-//
-#define sei() interrupts()
-#define cli() noInterrupts()
-
-#define CRITICAL_SECTION_START()  const bool _irqon = hal.isr_state(); hal.isr_off()
-#define CRITICAL_SECTION_END()    if (_irqon) hal.isr_on()
-
-//
-// ADC
-//
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10
-
-#ifndef analogInputToDigitalPin
-  #define analogInputToDigitalPin(p) ((p < 12U) ? (p) + 54U : -1)
-#endif
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-//
-// Tone
-//
-void tone(const pin_t _pin, const unsigned int frequency, const unsigned long duration=0);
-void noTone(const pin_t _pin);
-
-// ------------------------
-// Class Utilities
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-#pragma GCC diagnostic pop
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-char *dtostrf(double __val, signed char __width, unsigned char __prec, char *__s);
-#ifdef __cplusplus
-  }
-#endif
-
-// Return free RAM between end of heap (or end bss) and whatever is current
-int freeMemory();
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init();          // Called early in setup()
-  static void init_board();    // Called less early in setup()
-  static void reboot();        // Restart the firmware
-
-  // Interrupts
-  static bool isr_state() { return !__get_PRIMASK(); }
-  static void isr_on()  { __enable_irq(); }
-  static void isr_off() { __disable_irq(); }
-
-  static void delay_ms(const int ms) { delay(ms); }
-
-  // Tasks, called from idle()
-  static void idletask();
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  static uint16_t adc_result;
-
-  // Called by Temperature::init once at startup
-  static void adc_init() {}
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const uint8_t ch) {}
-
-  // Begin ADC sampling on the given channel. Called from Temperature::isr!
-  static void adc_start(const uint8_t ch) { adc_result = analogRead(ch); }
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value() { return adc_result; }
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No inverting the duty cycle in this HAL.
-   * No changing the maximum size of the provided value to enable finer PWM duty control in this HAL.
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-};
diff --git a/Marlin/src/HAL/DUE/HAL_SPI.cpp b/Marlin/src/HAL/DUE/HAL_SPI.cpp
deleted file mode 100644
index 7e3fe01..0000000
--- a/Marlin/src/HAL/DUE/HAL_SPI.cpp
+++ /dev/null
@@ -1,819 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Software SPI functions originally from Arduino Sd2Card Library
- * Copyright (c) 2009 by William Greiman
- *
- * Completely rewritten and tuned by Eduardo JosÃ© Tagle in 2017/2018
- * in ARM thumb2 inline assembler and tuned for maximum speed and performance
- * allowing SPI clocks of up to 12 Mhz to increase SD card read/write performance
- */
-
-/**
- * HAL for Arduino Due and compatible (SAM3X8E)
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-#include "../shared/Delay.h"
-
-// ------------------------
-// Public functions
-// ------------------------
-
-#if EITHER(DUE_SOFTWARE_SPI, FORCE_SOFT_SPI)
-
-  // ------------------------
-  // Software SPI
-  // ------------------------
-
-  // Make sure GCC optimizes this file.
-  // Note that this line triggers a bug in GCC which is fixed by casting.
-  // See the note below.
-  #pragma GCC optimize (3)
-
-  typedef uint8_t (*pfnSpiTransfer)(uint8_t b);
-  typedef void    (*pfnSpiRxBlock)(uint8_t *buf, uint32_t nbyte);
-  typedef void    (*pfnSpiTxBlock)(const uint8_t *buf, uint32_t nbyte);
-
-  /* ---------------- Macros to be able to access definitions from asm */
-  #define _PORT(IO) DIO ##  IO ## _WPORT
-  #define _PIN_MASK(IO) MASK(DIO ## IO ## _PIN)
-  #define _PIN_SHIFT(IO) DIO ## IO ## _PIN
-  #define PORT(IO) _PORT(IO)
-  #define PIN_MASK(IO) _PIN_MASK(IO)
-  #define PIN_SHIFT(IO) _PIN_SHIFT(IO)
-
-  // run at ~8 .. ~10Mhz - Tx version (Rx data discarded)
-  static uint8_t spiTransferTx0(uint8_t bout) { // using Mode 0
-    uint32_t MOSI_PORT_PLUS30 = ((uint32_t) PORT(SD_MOSI_PIN)) + 0x30;  /* SODR of port */
-    uint32_t MOSI_MASK = PIN_MASK(SD_MOSI_PIN);
-    uint32_t SCK_PORT_PLUS30 = ((uint32_t) PORT(SD_SCK_PIN)) + 0x30;    /* SODR of port */
-    uint32_t SCK_MASK = PIN_MASK(SD_SCK_PIN);
-    uint32_t idx = 0;
-
-    /* Negate bout, as the assembler requires a negated value */
-    bout = ~bout;
-
-    /* The software SPI routine */
-    __asm__ __volatile__(
-      A(".syntax unified") // is to prevent CM0,CM1 non-unified syntax
-
-      /* Bit 7 */
-      A("ubfx %[idx],%[txval],#7,#1")                      /* Place bit 7 in bit 0 of idx*/
-
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#6,#1")                      /* Place bit 6 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 6 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#5,#1")                      /* Place bit 5 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 5 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#4,#1")                      /* Place bit 4 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 4 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#3,#1")                      /* Place bit 3 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 3 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#2,#1")                      /* Place bit 2 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 2 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#1,#1")                      /* Place bit 1 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 1 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[idx],%[txval],#0,#1")                      /* Place bit 0 in bit 0 of idx*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 0 */
-      A("str %[mosi_mask],[%[mosi_port], %[idx],LSL #2]")  /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("nop")                                             /* Result will be 0 */
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      : [idx]"+r"( idx )
-      : [txval]"r"( bout ) ,
-        [mosi_mask]"r"( MOSI_MASK ),
-        [mosi_port]"r"( MOSI_PORT_PLUS30 ),
-        [sck_mask]"r"( SCK_MASK ),
-        [sck_port]"r"( SCK_PORT_PLUS30 )
-      : "cc"
-    );
-
-    return 0;
-  }
-
-   // Calculates the bit band alias address and returns a pointer address to word.
-   // addr: The byte address of bitbanding bit.
-   // bit:  The bit position of bitbanding bit.
-  #define BITBAND_ADDRESS(addr, bit) \
-    (((uint32_t)(addr) & 0xF0000000) + 0x02000000 + ((uint32_t)(addr)&0xFFFFF)*32 + (bit)*4)
-
-  // run at ~8 .. ~10Mhz - Rx version (Tx line not altered)
-  static uint8_t spiTransferRx0(uint8_t) { // using Mode 0
-    uint32_t bin = 0;
-    uint32_t work = 0;
-    uint32_t BITBAND_MISO_PORT = BITBAND_ADDRESS( ((uint32_t)PORT(SD_MISO_PIN))+0x3C, PIN_SHIFT(SD_MISO_PIN));  /* PDSR of port in bitband area */
-    uint32_t SCK_PORT_PLUS30 = ((uint32_t) PORT(SD_SCK_PIN)) + 0x30;    /* SODR of port */
-    uint32_t SCK_MASK = PIN_MASK(SD_SCK_PIN);
-
-    /* The software SPI routine */
-    __asm__ __volatile__(
-      A(".syntax unified") // is to prevent CM0,CM1 non-unified syntax
-
-      /* bit 7 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#7,#1")                /* Store read bit as the bit 7 */
-
-      /* bit 6 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#6,#1")                /* Store read bit as the bit 6 */
-
-      /* bit 5 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#5,#1")                /* Store read bit as the bit 5 */
-
-      /* bit 4 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#4,#1")                /* Store read bit as the bit 4 */
-
-      /* bit 3 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#3,#1")                /* Store read bit as the bit 3 */
-
-      /* bit 2 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#2,#1")                /* Store read bit as the bit 2 */
-
-      /* bit 1 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#1,#1")                /* Store read bit as the bit 1 */
-
-      /* bit 0 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#0,#1")                /* Store read bit as the bit 0 */
-
-      : [bin]"+r"(bin),
-        [work]"+r"(work)
-      : [bitband_miso_port]"r"( BITBAND_MISO_PORT ),
-        [sck_mask]"r"( SCK_MASK ),
-        [sck_port]"r"( SCK_PORT_PLUS30 )
-      : "cc"
-    );
-
-    return bin;
-  }
-
-  // run at ~4Mhz
-  static uint8_t spiTransfer1(uint8_t b) { // using Mode 0
-    int bits = 8;
-    do {
-      WRITE(SD_MOSI_PIN, b & 0x80);
-      b <<= 1;        // little setup time
-
-      WRITE(SD_SCK_PIN, HIGH);
-      DELAY_NS(125);  // 10 cycles @ 84mhz
-
-      b |= (READ(SD_MISO_PIN) != 0);
-
-      WRITE(SD_SCK_PIN, LOW);
-      DELAY_NS(125);  // 10 cycles @ 84mhz
-    } while (--bits);
-    return b;
-  }
-
-  // all the others
-  static uint16_t spiDelayNS = 4000; // 4000ns => 125khz
-
-  static uint8_t spiTransferX(uint8_t b) { // using Mode 0
-    int bits = 8;
-    do {
-      WRITE(SD_MOSI_PIN, b & 0x80);
-      b <<= 1; // little setup time
-
-      WRITE(SD_SCK_PIN, HIGH);
-      DELAY_NS(spiDelayNS);
-
-      b |= (READ(SD_MISO_PIN) != 0);
-
-      WRITE(SD_SCK_PIN, LOW);
-      DELAY_NS(spiDelayNS);
-    } while (--bits);
-    return b;
-  }
-
-  // Pointers to generic functions for byte transfers
-
-  /**
-   * Note: The cast is unnecessary, but without it, this file triggers a GCC 4.8.3-2014 bug.
-   * Later GCC versions do not have this problem, but at this time (May 2018) Arduino still
-   * uses that buggy and obsolete GCC version!!
-   */
-  static pfnSpiTransfer spiTransferRx = (pfnSpiTransfer)spiTransferX;
-  static pfnSpiTransfer spiTransferTx = (pfnSpiTransfer)spiTransferX;
-
-  // Block transfers run at ~8 .. ~10Mhz - Tx version (Rx data discarded)
-  static void spiTxBlock0(const uint8_t *ptr, uint32_t todo) {
-    uint32_t MOSI_PORT_PLUS30 = ((uint32_t) PORT(SD_MOSI_PIN)) + 0x30;  /* SODR of port */
-    uint32_t MOSI_MASK = PIN_MASK(SD_MOSI_PIN);
-    uint32_t SCK_PORT_PLUS30 = ((uint32_t) PORT(SD_SCK_PIN)) + 0x30;    /* SODR of port */
-    uint32_t SCK_MASK = PIN_MASK(SD_SCK_PIN);
-    uint32_t work = 0;
-    uint32_t txval = 0;
-
-    /* The software SPI routine */
-    __asm__ __volatile__(
-      A(".syntax unified") // is to prevent CM0,CM1 non-unified syntax
-
-      L("loop%=")
-      A("ldrb.w %[txval], [%[ptr]], #1")                   /* Load value to send, increment buffer */
-      A("mvn %[txval],%[txval]")                           /* Negate value */
-
-      /* Bit 7 */
-      A("ubfx %[work],%[txval],#7,#1")                     /* Place bit 7 in bit 0 of work*/
-
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#6,#1")                     /* Place bit 6 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 6 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#5,#1")                     /* Place bit 5 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 5 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#4,#1")                     /* Place bit 4 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 4 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#3,#1")                     /* Place bit 3 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 3 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#2,#1")                     /* Place bit 2 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 2 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#1,#1")                     /* Place bit 1 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 1 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("ubfx %[work],%[txval],#0,#1")                     /* Place bit 0 in bit 0 of work*/
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-
-      /* Bit 0 */
-      A("str %[mosi_mask],[%[mosi_port], %[work],LSL #2]") /* Access the proper SODR or CODR registers based on that bit */
-      A("str %[sck_mask],[%[sck_port]]")                   /* SODR */
-      A("subs %[todo],#1")                                 /* Decrement count of pending words to send, update status */
-      A("str %[sck_mask],[%[sck_port],#0x4]")              /* CODR */
-      A("bne.n loop%=")                                    /* Repeat until done */
-
-      : [ptr]"+r" ( ptr ) ,
-        [todo]"+r" ( todo ) ,
-        [work]"+r"( work ) ,
-        [txval]"+r"( txval )
-      : [mosi_mask]"r"( MOSI_MASK ),
-        [mosi_port]"r"( MOSI_PORT_PLUS30 ),
-        [sck_mask]"r"( SCK_MASK ),
-        [sck_port]"r"( SCK_PORT_PLUS30 )
-      : "cc"
-    );
-  }
-
-  static void spiRxBlock0(uint8_t *ptr, uint32_t todo) {
-    uint32_t bin = 0;
-    uint32_t work = 0;
-    uint32_t BITBAND_MISO_PORT = BITBAND_ADDRESS( ((uint32_t)PORT(SD_MISO_PIN))+0x3C, PIN_SHIFT(SD_MISO_PIN));  /* PDSR of port in bitband area */
-    uint32_t SCK_PORT_PLUS30 = ((uint32_t) PORT(SD_SCK_PIN)) + 0x30;    /* SODR of port */
-    uint32_t SCK_MASK = PIN_MASK(SD_SCK_PIN);
-
-    /* The software SPI routine */
-    __asm__ __volatile__(
-      A(".syntax unified")                  // is to prevent CM0,CM1 non-unified syntax
-
-      L("loop%=")
-
-      /* bit 7 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#7,#1")                /* Store read bit as the bit 7 */
-
-      /* bit 6 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#6,#1")                /* Store read bit as the bit 6 */
-
-      /* bit 5 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#5,#1")                /* Store read bit as the bit 5 */
-
-      /* bit 4 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#4,#1")                /* Store read bit as the bit 4 */
-
-      /* bit 3 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#3,#1")                /* Store read bit as the bit 3 */
-
-      /* bit 2 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#2,#1")                /* Store read bit as the bit 2 */
-
-      /* bit 1 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#1,#1")                /* Store read bit as the bit 1 */
-
-      /* bit 0 */
-      A("str %[sck_mask],[%[sck_port]]")           /* SODR */
-      A("ldr %[work],[%[bitband_miso_port]]")      /* PDSR on bitband area for required bit: work will be 1 or 0 based on port */
-      A("str %[sck_mask],[%[sck_port],#0x4]")      /* CODR */
-      A("bfi %[bin],%[work],#0,#1")                /* Store read bit as the bit 0 */
-
-      A("subs %[todo],#1")                         /* Decrement count of pending words to send, update status */
-      A("strb.w %[bin], [%[ptr]], #1")             /* Store read value into buffer, increment buffer pointer */
-      A("bne.n loop%=")                            /* Repeat until done */
-
-      : [ptr]"+r"(ptr),
-        [todo]"+r"(todo),
-        [bin]"+r"(bin),
-        [work]"+r"(work)
-      : [bitband_miso_port]"r"( BITBAND_MISO_PORT ),
-        [sck_mask]"r"( SCK_MASK ),
-        [sck_port]"r"( SCK_PORT_PLUS30 )
-      : "cc"
-    );
-  }
-
-  static void spiTxBlockX(const uint8_t *buf, uint32_t todo) {
-    do {
-      (void)spiTransferTx(*buf++);
-    } while (--todo);
-  }
-
-  static void spiRxBlockX(uint8_t *buf, uint32_t todo) {
-    do {
-      *buf++ = spiTransferRx(0xFF);
-    } while (--todo);
-  }
-
-  // Pointers to generic functions for block transfers
-  static pfnSpiTxBlock spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;
-  static pfnSpiRxBlock spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;
-
-  #if MB(ALLIGATOR)
-    #define _SS_WRITE(S) WRITE(SD_SS_PIN, S)
-  #else
-    #define _SS_WRITE(S) NOOP
-  #endif
-
-  void spiBegin() {
-    SET_OUTPUT(SD_SS_PIN);
-    _SS_WRITE(HIGH);
-    SET_OUTPUT(SD_SCK_PIN);
-    SET_INPUT(SD_MISO_PIN);
-    SET_OUTPUT(SD_MOSI_PIN);
-  }
-
-  uint8_t spiRec() {
-    _SS_WRITE(LOW);
-    WRITE(SD_MOSI_PIN, HIGH); // Output 1s 1
-    uint8_t b = spiTransferRx(0xFF);
-    _SS_WRITE(HIGH);
-    return b;
-  }
-
-  void spiRead(uint8_t *buf, uint16_t nbyte) {
-    if (nbyte) {
-      _SS_WRITE(LOW);
-      WRITE(SD_MOSI_PIN, HIGH); // Output 1s 1
-      spiRxBlock(buf, nbyte);
-      _SS_WRITE(HIGH);
-    }
-  }
-
-  void spiSend(uint8_t b) {
-    _SS_WRITE(LOW);
-    (void)spiTransferTx(b);
-    _SS_WRITE(HIGH);
-  }
-
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-    _SS_WRITE(LOW);
-    (void)spiTransferTx(token);
-    spiTxBlock(buf, 512);
-    _SS_WRITE(HIGH);
-  }
-
-  /**
-   * spiRate should be
-   *  0 :  8 - 10 MHz
-   *  1 :  4 - 5 MHz
-   *  2 :  2 - 2.5 MHz
-   *  3 :  1 - 1.25 MHz
-   *  4 :  500 - 625 kHz
-   *  5 :  250 - 312 kHz
-   *  6 :  125 - 156 kHz
-   */
-  void spiInit(uint8_t spiRate) {
-    switch (spiRate) {
-      case 0:
-        spiTransferTx = (pfnSpiTransfer)spiTransferTx0;
-        spiTransferRx = (pfnSpiTransfer)spiTransferRx0;
-        spiTxBlock = (pfnSpiTxBlock)spiTxBlock0;
-        spiRxBlock = (pfnSpiRxBlock)spiRxBlock0;
-        break;
-      case 1:
-        spiTransferTx = (pfnSpiTransfer)spiTransfer1;
-        spiTransferRx = (pfnSpiTransfer)spiTransfer1;
-        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;
-        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;
-        break;
-      default:
-        spiDelayNS = 4000 >> (6 - spiRate); // spiRate of 2 gives the maximum error with current CPU
-        spiTransferTx = (pfnSpiTransfer)spiTransferX;
-        spiTransferRx = (pfnSpiTransfer)spiTransferX;
-        spiTxBlock = (pfnSpiTxBlock)spiTxBlockX;
-        spiRxBlock = (pfnSpiRxBlock)spiRxBlockX;
-        break;
-    }
-
-    _SS_WRITE(HIGH);
-    WRITE(SD_MOSI_PIN, HIGH);
-    WRITE(SD_SCK_PIN, LOW);
-  }
-
-  /** Begin SPI transaction, set clock, bit order, data mode */
-  void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-    // TODO: to be implemented
-  }
-
-  #pragma GCC reset_options
-
-#else // !SOFTWARE_SPI
-
-  #define WHILE_TX(N) while ((SPI0->SPI_SR & SPI_SR_TDRE) == (N))
-  #define WHILE_RX(N) while ((SPI0->SPI_SR & SPI_SR_RDRF) == (N))
-  #define FLUSH_TX() do{ WHILE_RX(1) SPI0->SPI_RDR; }while(0)
-
-  #if MB(ALLIGATOR)
-
-    // slave selects controlled by SPI controller
-    // doesn't support changing SPI speeds for SD card
-
-    // ------------------------
-    // hardware SPI
-    // ------------------------
-    static bool spiInitialized = false;
-
-    void spiInit(uint8_t spiRate) {
-      if (spiInitialized) return;
-
-      // 8.4 MHz, 4 MHz, 2 MHz, 1 MHz, 0.5 MHz, 0.329 MHz, 0.329 MHz
-      constexpr int spiDivider[] = { 10, 21, 42, 84, 168, 255, 255 };
-      if (spiRate > 6) spiRate = 1;
-
-      // Set SPI mode 1, clock, select not active after transfer, with delay between transfers
-      SPI_ConfigureNPCS(SPI0, SPI_CHAN_DAC,
-                        SPI_CSR_CSAAT | SPI_CSR_SCBR(spiDivider[spiRate]) |
-                        SPI_CSR_DLYBCT(1));
-      // Set SPI mode 0, clock, select not active after transfer, with delay between transfers
-      SPI_ConfigureNPCS(SPI0, SPI_CHAN_EEPROM1, SPI_CSR_NCPHA |
-                        SPI_CSR_CSAAT | SPI_CSR_SCBR(spiDivider[spiRate]) |
-                        SPI_CSR_DLYBCT(1));
-
-      // Set SPI mode 0, clock, select not active after transfer, with delay between transfers
-      SPI_ConfigureNPCS(SPI0, SPI_CHAN, SPI_CSR_NCPHA |
-                        SPI_CSR_CSAAT | SPI_CSR_SCBR(spiDivider[spiRate]) |
-                        SPI_CSR_DLYBCT(1));
-      SPI_Enable(SPI0);
-      spiInitialized = true;
-    }
-
-    void spiBegin() {
-      if (spiInitialized) return;
-
-      // Configure SPI pins
-      PIO_Configure(
-         g_APinDescription[SD_SCK_PIN].pPort,
-         g_APinDescription[SD_SCK_PIN].ulPinType,
-         g_APinDescription[SD_SCK_PIN].ulPin,
-         g_APinDescription[SD_SCK_PIN].ulPinConfiguration);
-      PIO_Configure(
-         g_APinDescription[SD_MOSI_PIN].pPort,
-         g_APinDescription[SD_MOSI_PIN].ulPinType,
-         g_APinDescription[SD_MOSI_PIN].ulPin,
-         g_APinDescription[SD_MOSI_PIN].ulPinConfiguration);
-      PIO_Configure(
-         g_APinDescription[SD_MISO_PIN].pPort,
-         g_APinDescription[SD_MISO_PIN].ulPinType,
-         g_APinDescription[SD_MISO_PIN].ulPin,
-         g_APinDescription[SD_MISO_PIN].ulPinConfiguration);
-
-      // set master mode, peripheral select, fault detection
-      SPI_Configure(SPI0, ID_SPI0, SPI_MR_MSTR | SPI_MR_MODFDIS | SPI_MR_PS);
-      SPI_Enable(SPI0);
-
-      SET_OUTPUT(DAC0_SYNC_PIN);
-      #if HAS_MULTI_EXTRUDER
-        OUT_WRITE(DAC1_SYNC_PIN, HIGH);
-      #endif
-      WRITE(DAC0_SYNC_PIN, HIGH);
-      OUT_WRITE(SPI_EEPROM1_CS_PIN, HIGH);
-      OUT_WRITE(SPI_EEPROM2_CS_PIN, HIGH);
-      OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
-      WRITE(SD_SS_PIN, HIGH);
-
-      OUT_WRITE(SDSS, LOW);
-
-      PIO_Configure(
-        g_APinDescription[SPI_PIN].pPort,
-        g_APinDescription[SPI_PIN].ulPinType,
-        g_APinDescription[SPI_PIN].ulPin,
-        g_APinDescription[SPI_PIN].ulPinConfiguration
-      );
-
-      spiInit(1);
-    }
-
-    // Read single byte from SPI
-    uint8_t spiRec() {
-      // write dummy byte with address and end transmission flag
-      SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;
-
-      WHILE_TX(0);
-      WHILE_RX(0);
-
-      //DELAY_US(1U);
-      return SPI0->SPI_RDR;
-    }
-
-    uint8_t spiRec(uint32_t chan) {
-
-      WHILE_TX(0);
-      FLUSH_RX();
-
-      // write dummy byte with address and end transmission flag
-      SPI0->SPI_TDR = 0x000000FF | SPI_PCS(chan) | SPI_TDR_LASTXFER;
-      WHILE_RX(0);
-
-      return SPI0->SPI_RDR;
-    }
-
-    // Read from SPI into buffer
-    void spiRead(uint8_t *buf, uint16_t nbyte) {
-      if (!nbyte) return;
-      --nbyte;
-      for (int i = 0; i < nbyte; i++) {
-        //WHILE_TX(0);
-        SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN);
-        WHILE_RX(0);
-        buf[i] = SPI0->SPI_RDR;
-        //DELAY_US(1U);
-      }
-      buf[nbyte] = spiRec();
-    }
-
-    // Write single byte to SPI
-    void spiSend(const byte b) {
-      // write byte with address and end transmission flag
-      SPI0->SPI_TDR = (uint32_t)b | SPI_PCS(SPI_CHAN) | SPI_TDR_LASTXFER;
-      WHILE_TX(0);
-      WHILE_RX(0);
-      SPI0->SPI_RDR;
-      //DELAY_US(1U);
-    }
-
-    void spiSend(const uint8_t *buf, size_t nbyte) {
-      if (!nbyte) return;
-      --nbyte;
-      for (size_t i = 0; i < nbyte; i++) {
-        SPI0->SPI_TDR = (uint32_t)buf[i] | SPI_PCS(SPI_CHAN);
-        WHILE_TX(0);
-        WHILE_RX(0);
-        SPI0->SPI_RDR;
-        //DELAY_US(1U);
-      }
-      spiSend(buf[nbyte]);
-    }
-
-    void spiSend(uint32_t chan, byte b) {
-      WHILE_TX(0);
-      // write byte with address and end transmission flag
-      SPI0->SPI_TDR = (uint32_t)b | SPI_PCS(chan) | SPI_TDR_LASTXFER;
-      WHILE_RX(0);
-      FLUSH_RX();
-    }
-
-    void spiSend(uint32_t chan, const uint8_t *buf, size_t nbyte) {
-      if (!nbyte) return;
-      --nbyte;
-      for (size_t i = 0; i < nbyte; i++) {
-        WHILE_TX(0);
-        SPI0->SPI_TDR = (uint32_t)buf[i] | SPI_PCS(chan);
-        WHILE_RX(0);
-        FLUSH_RX();
-      }
-      spiSend(chan, buf[nbyte]);
-    }
-
-    // Write from buffer to SPI
-    void spiSendBlock(uint8_t token, const uint8_t *buf) {
-      SPI0->SPI_TDR = (uint32_t)token | SPI_PCS(SPI_CHAN);
-      WHILE_TX(0);
-      //WHILE_RX(0);
-      //SPI0->SPI_RDR;
-      for (int i = 0; i < 511; i++) {
-        SPI0->SPI_TDR = (uint32_t)buf[i] | SPI_PCS(SPI_CHAN);
-        WHILE_TX(0);
-        WHILE_RX(0);
-        SPI0->SPI_RDR;
-        //DELAY_US(1U);
-      }
-      spiSend(buf[511]);
-    }
-
-    /** Begin SPI transaction, set clock, bit order, data mode */
-    void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-      // TODO: to be implemented
-    }
-
-  #else // U8G compatible hardware SPI
-
-    #define SPI_MODE_0_DUE_HW 2  // DUE CPHA control bit is inverted
-    #define SPI_MODE_1_DUE_HW 3
-    #define SPI_MODE_2_DUE_HW 0
-    #define SPI_MODE_3_DUE_HW 1
-
-    /**
-     *  The DUE SPI controller is set up so the upper word of the longword
-     *  written to the transmit data register selects which SPI Chip Select
-     *  Register is used. This allows different streams to have different SPI
-     *  settings.
-     *
-     *  In practice it's spooky. Some combinations hang the system, while others
-     *  upset the peripheral device.
-     *
-     *  SPI mode should be the same for all streams. The FYSETC_MINI_12864 gets
-     *  upset if the clock phase changes after chip select goes active.
-     *
-     *  SPI_CSR_CSAAT should be set for all streams. If not the WHILE_TX(0)
-     *  macro returns immediately which can result in the SPI chip select going
-     *  inactive before all the data has been sent.
-     *
-     *  The TMC2130 library uses SPI0->SPI_CSR[3].
-     *
-     *  The U8G hardware SPI uses SPI0->SPI_CSR[0]. The system hangs and/or the
-     *  FYSETC_MINI_12864 gets upset if lower baud rates are used and the SD card
-     *  is inserted or removed.
-     *
-     *  The SD card uses SPI0->SPI_CSR[3]. Efforts were made to use [1] and [2]
-     *  but they all resulted in hangs or garbage on the LCD.
-     *
-     *  The SPI controlled chip selects are NOT enabled in the GPIO controller.
-     *  The application must control the chip select.
-     *
-     *  All of the above can be avoided by defining FORCE_SOFT_SPI to force the
-     *  display to use software SPI.
-     */
-
-    void spiInit(uint8_t spiRate=6) {  // Default to slowest rate if not specified)
-                                       // Also sets U8G SPI rate to 4MHz and the SPI mode to 3
-
-      // 8.4 MHz, 4 MHz, 2 MHz, 1 MHz, 0.5 MHz, 0.329 MHz, 0.329 MHz
-      constexpr int spiDivider[] = { 10, 21, 42, 84, 168, 255, 255 };
-      if (spiRate > 6) spiRate = 1;
-
-      // Enable PIOA and SPI0
-      REG_PMC_PCER0 = (1UL << ID_PIOA) | (1UL << ID_SPI0);
-
-      // Disable PIO on A26 and A27
-      REG_PIOA_PDR = 0x0C000000;
-      OUT_WRITE(SDSS, HIGH);
-
-      // Reset SPI0 (from sam lib)
-      SPI0->SPI_CR = SPI_CR_SPIDIS;
-      SPI0->SPI_CR = SPI_CR_SWRST;
-      SPI0->SPI_CR = SPI_CR_SWRST;
-      SPI0->SPI_CR = SPI_CR_SPIEN;
-
-      // TMC2103 compatible setup
-      // Master mode, no fault detection, PCS bits in data written to TDR select CSR register
-      SPI0->SPI_MR = SPI_MR_MSTR | SPI_MR_PS | SPI_MR_MODFDIS;
-      // SPI mode 3, 8 Bit data transfer, baud rate
-      SPI0->SPI_CSR[3] = SPI_CSR_SCBR(spiDivider[spiRate]) | SPI_CSR_CSAAT | SPI_MODE_3_DUE_HW;  // use same CSR as TMC2130
-      SPI0->SPI_CSR[0] = SPI_CSR_SCBR(spiDivider[1]) | SPI_CSR_CSAAT | SPI_MODE_3_DUE_HW;  // U8G default to 4MHz
-    }
-
-    void spiBegin() { spiInit(); }
-
-    static uint8_t spiTransfer(uint8_t data) {
-      WHILE_TX(0);
-      SPI0->SPI_TDR = (uint32_t)data | 0x00070000UL;  // Add TMC2130 PCS bits to every byte (use SPI0->SPI_CSR[3])
-      WHILE_TX(0);
-      WHILE_RX(0);
-      return SPI0->SPI_RDR;
-    }
-
-    uint8_t spiRec() { return (uint8_t)spiTransfer(0xFF); }
-
-    void spiRead(uint8_t *buf, uint16_t nbyte) {
-      for (int i = 0; i < nbyte; i++)
-        buf[i] = spiTransfer(0xFF);
-    }
-
-    void spiSend(uint8_t data) { spiTransfer(data); }
-
-    void spiSend(const uint8_t *buf, size_t nbyte) {
-      for (uint16_t i = 0; i < nbyte; i++)
-        spiTransfer(buf[i]);
-    }
-
-    void spiSendBlock(uint8_t token, const uint8_t *buf) {
-      spiTransfer(token);
-      for (uint16_t i = 0; i < 512; i++)
-        spiTransfer(buf[i]);
-    }
-
-  #endif // !ALLIGATOR
-#endif // !SOFTWARE_SPI
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/InterruptVectors.cpp b/Marlin/src/HAL/DUE/InterruptVectors.cpp
deleted file mode 100644
index e4e0ce9..0000000
--- a/Marlin/src/HAL/DUE/InterruptVectors.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * InterruptVectors_Due.cpp - This module relocates the Interrupt vector table to SRAM,
- *  allowing to register new interrupt handlers at runtime. Specially valuable and needed
- * because Arduino runtime allocates some interrupt handlers that we NEED to override to
- * properly support extended functionality, as for example, USB host or USB device (MSD, MTP)
- * and custom serial port handlers, and we don't actually want to modify and/or recompile the
- * Arduino runtime. We just want to run as much as possible on Stock Arduino
- *
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- */
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-#include "InterruptVectors.h"
-
-/* The relocated Exception/Interrupt Table - According to the ARM
-   reference manual, alignment to 128 bytes should suffice, but in
-   practice, we need alignment to 256 bytes to make this work in all
-   cases */
-__attribute__ ((aligned(256)))
-static DeviceVectors ram_tab = { nullptr };
-
-/**
- * This function checks if the exception/interrupt table is already in SRAM or not.
- * If it is not, then it copies the ROM table to the SRAM and relocates the table
- * by reprogramming the NVIC registers
- */
-static pfnISR_Handler* get_relocated_table_addr() {
-  // Get the address of the interrupt/exception table
-  uint32_t isrtab = SCB->VTOR;
-
-  // If already relocated, we are done!
-  if (isrtab >= IRAM0_ADDR)
-    return (pfnISR_Handler*)isrtab;
-
-  // Get the address of the table stored in FLASH
-  const pfnISR_Handler* romtab = (const pfnISR_Handler*)isrtab;
-
-  // Copy it to SRAM
-  memcpy(&ram_tab, romtab, sizeof(ram_tab));
-
-  // Disable global interrupts
-  CRITICAL_SECTION_START();
-
-  // Set the vector table base address to the SRAM copy
-  SCB->VTOR = (uint32_t)(&ram_tab);
-
-  // Reenable interrupts
-  CRITICAL_SECTION_END();
-
-  // Return the address of the table
-  return (pfnISR_Handler*)(&ram_tab);
-}
-
-pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler) {
-  // Get the address of the relocated table
-  pfnISR_Handler *isrtab = get_relocated_table_addr();
-
-  // Disable global interrupts
-  CRITICAL_SECTION_START();
-
-  // Get the original handler
-  pfnISR_Handler oldHandler = isrtab[irq + 16];
-
-  // Install the new one
-  isrtab[irq + 16] = newHandler;
-
-  // Reenable interrupts
-  CRITICAL_SECTION_END();
-
-  // Return the original one
-  return oldHandler;
-}
-
-#endif
diff --git a/Marlin/src/HAL/DUE/InterruptVectors.h b/Marlin/src/HAL/DUE/InterruptVectors.h
deleted file mode 100644
index 6faeb34..0000000
--- a/Marlin/src/HAL/DUE/InterruptVectors.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * InterruptVectors_Due.h
- *
- * This module relocates the Interrupt vector table to SRAM, allowing new
- * interrupt handlers to be added at runtime. This is required because the
- * Arduino runtime steals interrupt handlers that Marlin MUST use to support
- * extended functionality such as USB hosts and USB devices (MSD, MTP) and
- * custom serial port handlers. Rather than modifying and/or recompiling the
- * Arduino runtime, We just want to run as much as possible on Stock Arduino.
- *
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-// ISR handler type
-typedef void (*pfnISR_Handler)();
-
-// Install a new interrupt vector handler for the given irq, returning the old one
-pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler);
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/MarlinSPI.h b/Marlin/src/HAL/DUE/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/DUE/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/DUE/MarlinSerial.cpp b/Marlin/src/HAL/DUE/MarlinSerial.cpp
deleted file mode 100644
index 638f7a1..0000000
--- a/Marlin/src/HAL/DUE/MarlinSerial.cpp
+++ /dev/null
@@ -1,494 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * MarlinSerial_Due.cpp - Hardware serial library for Arduino DUE
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- * Based on MarlinSerial for AVR, copyright (c) 2006 Nicholas Zambetti.  All right reserved.
- */
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-
-#include "MarlinSerial.h"
-#include "InterruptVectors.h"
-#include "../../MarlinCore.h"
-
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_r MarlinSerial<Cfg>::rx_buffer = { 0, 0, { 0 } };
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_t MarlinSerial<Cfg>::tx_buffer = { 0 };
-template<typename Cfg> bool     MarlinSerial<Cfg>::_written = false;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::xon_xoff_state = MarlinSerial<Cfg>::XON_XOFF_CHAR_SENT | MarlinSerial<Cfg>::XON_CHAR;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_dropped_bytes = 0;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_buffer_overruns = 0;
-template<typename Cfg> uint8_t  MarlinSerial<Cfg>::rx_framing_errors = 0;
-template<typename Cfg> typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::rx_max_enqueued = 0;
-
-// A SW memory barrier, to ensure GCC does not overoptimize loops
-#define sw_barrier() asm volatile("": : :"memory");
-
-#include "../../feature/e_parser.h"
-
-// (called with RX interrupts disabled)
-template<typename Cfg>
-FORCE_INLINE void MarlinSerial<Cfg>::store_rxd_char() {
-
-  static EmergencyParser::State emergency_state; // = EP_RESET
-
-  // Get the tail - Nothing can alter its value while we are at this ISR
-  const ring_buffer_pos_t t = rx_buffer.tail;
-
-  // Get the head pointer
-  ring_buffer_pos_t h = rx_buffer.head;
-
-  // Get the next element
-  ring_buffer_pos_t i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-  // Read the character from the USART
-  uint8_t c = HWUART->UART_RHR;
-
-  if (Cfg::EMERGENCYPARSER) emergency_parser.update(emergency_state, c);
-
-  // If the character is to be stored at the index just before the tail
-  // (such that the head would advance to the current tail), the RX FIFO is
-  // full, so don't write the character or advance the head.
-  if (i != t) {
-    rx_buffer.buffer[h] = c;
-    h = i;
-  }
-  else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-    --rx_dropped_bytes;
-
-  const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-  // Calculate count of bytes stored into the RX buffer
-
-  // Keep track of the maximum count of enqueued bytes
-  if (Cfg::MAX_RX_QUEUED) NOLESS(rx_max_enqueued, rx_count);
-
-  if (Cfg::XONOFF) {
-    // If the last char that was sent was an XON
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XON_CHAR) {
-
-      // Bytes stored into the RX buffer
-      const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-      // If over 12.5% of RX buffer capacity, send XOFF before running out of
-      // RX buffer space .. 325 bytes @ 250kbits/s needed to let the host react
-      // and stop sending bytes. This translates to 13mS propagation time.
-      if (rx_count >= (Cfg::RX_SIZE) / 8) {
-
-        // At this point, definitely no TX interrupt was executing, since the TX isr can't be preempted.
-        // Don't enable the TX interrupt here as a means to trigger the XOFF char, because if it happens
-        // to be in the middle of trying to disable the RX interrupt in the main program, eventually the
-        // enabling of the TX interrupt could be undone. The ONLY reliable thing this can do to ensure
-        // the sending of the XOFF char is to send it HERE AND NOW.
-
-        // About to send the XOFF char
-        xon_xoff_state = XOFF_CHAR | XON_XOFF_CHAR_SENT;
-
-        // Wait until the TX register becomes empty and send it - Here there could be a problem
-        // - While waiting for the TX register to empty, the RX register could receive a new
-        //   character. This must also handle that situation!
-        uint32_t status;
-        while (!((status = HWUART->UART_SR) & UART_SR_TXRDY)) {
-
-          if (status & UART_SR_RXRDY) {
-            // We received a char while waiting for the TX buffer to be empty - Receive and process it!
-
-            i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-            // Read the character from the USART
-            c = HWUART->UART_RHR;
-
-            if (Cfg::EMERGENCYPARSER) emergency_parser.update(emergency_state, c);
-
-            // If the character is to be stored at the index just before the tail
-            // (such that the head would advance to the current tail), the FIFO is
-            // full, so don't write the character or advance the head.
-            if (i != t) {
-              rx_buffer.buffer[h] = c;
-              h = i;
-            }
-            else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-              --rx_dropped_bytes;
-          }
-          sw_barrier();
-        }
-
-        HWUART->UART_THR = XOFF_CHAR;
-
-        // At this point there could be a race condition between the write() function
-        // and this sending of the XOFF char. This interrupt could happen between the
-        // wait to be empty TX buffer loop and the actual write of the character. Since
-        // the TX buffer is full because it's sending the XOFF char, the only way to be
-        // sure the write() function will succeed is to wait for the XOFF char to be
-        // completely sent. Since an extra character could be received during the wait
-        // it must also be handled!
-        while (!((status = HWUART->UART_SR) & UART_SR_TXRDY)) {
-
-          if (status & UART_SR_RXRDY) {
-            // A char arrived while waiting for the TX buffer to be empty - Receive and process it!
-
-            i = (ring_buffer_pos_t)(h + 1) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-
-            // Read the character from the USART
-            c = HWUART->UART_RHR;
-
-            if (Cfg::EMERGENCYPARSER) emergency_parser.update(emergency_state, c);
-
-            // If the character is to be stored at the index just before the tail
-            // (such that the head would advance to the current tail), the FIFO is
-            // full, so don't write the character or advance the head.
-            if (i != t) {
-              rx_buffer.buffer[h] = c;
-              h = i;
-            }
-            else if (Cfg::DROPPED_RX && !++rx_dropped_bytes)
-              --rx_dropped_bytes;
-          }
-          sw_barrier();
-        }
-
-        // At this point everything is ready. The write() function won't
-        // have any issues writing to the UART TX register if it needs to!
-      }
-    }
-  }
-
-  // Store the new head value
-  rx_buffer.head = h;
-}
-
-template<typename Cfg>
-FORCE_INLINE void MarlinSerial<Cfg>::_tx_thr_empty_irq() {
-  if (Cfg::TX_SIZE > 0) {
-    // Read positions
-    uint8_t t = tx_buffer.tail;
-    const uint8_t h = tx_buffer.head;
-
-    if (Cfg::XONOFF) {
-      // If an XON char is pending to be sent, do it now
-      if (xon_xoff_state == XON_CHAR) {
-
-        // Send the character
-        HWUART->UART_THR = XON_CHAR;
-
-        // Remember we sent it.
-        xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-
-        // If nothing else to transmit, just disable TX interrupts.
-        if (h == t) HWUART->UART_IDR = UART_IDR_TXRDY;
-
-        return;
-      }
-    }
-
-    // If nothing to transmit, just disable TX interrupts. This could
-    // happen as the result of the non atomicity of the disabling of RX
-    // interrupts that could end reenabling TX interrupts as a side effect.
-    if (h == t) {
-      HWUART->UART_IDR = UART_IDR_TXRDY;
-      return;
-    }
-
-    // There is something to TX, Send the next byte
-    const uint8_t c = tx_buffer.buffer[t];
-    t = (t + 1) & (Cfg::TX_SIZE - 1);
-    HWUART->UART_THR = c;
-    tx_buffer.tail = t;
-
-    // Disable interrupts if there is nothing to transmit following this byte
-    if (h == t) HWUART->UART_IDR = UART_IDR_TXRDY;
-  }
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::UART_ISR() {
-  const uint32_t status = HWUART->UART_SR;
-
-  // Data received?
-  if (status & UART_SR_RXRDY) store_rxd_char();
-
-  if (Cfg::TX_SIZE > 0) {
-    // Something to send, and TX interrupts are enabled (meaning something to send)?
-    if ((status & UART_SR_TXRDY) && (HWUART->UART_IMR & UART_IMR_TXRDY)) _tx_thr_empty_irq();
-  }
-
-  // Acknowledge errors
-  if ((status & UART_SR_OVRE) || (status & UART_SR_FRAME)) {
-    if (Cfg::DROPPED_RX && (status & UART_SR_OVRE) && !++rx_dropped_bytes) --rx_dropped_bytes;
-    if (Cfg::RX_OVERRUNS && (status & UART_SR_OVRE) && !++rx_buffer_overruns) --rx_buffer_overruns;
-    if (Cfg::RX_FRAMING_ERRORS && (status & UART_SR_FRAME) && !++rx_framing_errors) --rx_framing_errors;
-
-    // TODO: error reporting outside ISR
-    HWUART->UART_CR = UART_CR_RSTSTA;
-  }
-}
-
-// Public Methods
-template<typename Cfg>
-void MarlinSerial<Cfg>::begin(const long baud_setting) {
-
-  // Disable UART interrupt in NVIC
-  NVIC_DisableIRQ( HWUART_IRQ );
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-
-  // Disable clock
-  pmc_disable_periph_clk( HWUART_IRQ_ID );
-
-  // Configure PMC
-  pmc_enable_periph_clk( HWUART_IRQ_ID );
-
-  // Disable PDC channel
-  HWUART->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
-
-  // Reset and disable receiver and transmitter
-  HWUART->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX | UART_CR_RXDIS | UART_CR_TXDIS;
-
-  // Configure mode: 8bit, No parity, 1 bit stop
-  HWUART->UART_MR = UART_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT | US_MR_NBSTOP_1_BIT | UART_MR_PAR_NO;
-
-  // Configure baudrate (asynchronous, no oversampling)
-  HWUART->UART_BRGR = (SystemCoreClock / (baud_setting << 4));
-
-  // Configure interrupts
-  HWUART->UART_IDR = 0xFFFFFFFF;
-  HWUART->UART_IER = UART_IER_RXRDY | UART_IER_OVRE | UART_IER_FRAME;
-
-  // Install interrupt handler
-  install_isr(HWUART_IRQ, UART_ISR);
-
-  // Configure priority. We need a very high priority to avoid losing characters
-  // and we need to be able to preempt the Stepper ISR and everything else!
-  // (this could probably be fixed by using DMA with the Serial port)
-  NVIC_SetPriority(HWUART_IRQ, 1);
-
-  // Enable UART interrupt in NVIC
-  NVIC_EnableIRQ(HWUART_IRQ);
-
-  // Enable receiver and transmitter
-  HWUART->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
-
-  if (Cfg::TX_SIZE > 0) _written = false;
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::end() {
-  // Disable UART interrupt in NVIC
-  NVIC_DisableIRQ( HWUART_IRQ );
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-
-  pmc_disable_periph_clk( HWUART_IRQ_ID );
-}
-
-template<typename Cfg>
-int MarlinSerial<Cfg>::peek() {
-  const int v = rx_buffer.head == rx_buffer.tail ? -1 : rx_buffer.buffer[rx_buffer.tail];
-  return v;
-}
-
-template<typename Cfg>
-int MarlinSerial<Cfg>::read() {
-
-  const ring_buffer_pos_t h = rx_buffer.head;
-  ring_buffer_pos_t t = rx_buffer.tail;
-
-  if (h == t) return -1;
-
-  int v = rx_buffer.buffer[t];
-  t = (ring_buffer_pos_t)(t + 1) & (Cfg::RX_SIZE - 1);
-
-  // Advance tail
-  rx_buffer.tail = t;
-
-  if (Cfg::XONOFF) {
-    // If the XOFF char was sent, or about to be sent...
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XOFF_CHAR) {
-      // Get count of bytes in the RX buffer
-      const ring_buffer_pos_t rx_count = (ring_buffer_pos_t)(h - t) & (ring_buffer_pos_t)(Cfg::RX_SIZE - 1);
-      // When below 10% of RX buffer capacity, send XON before running out of RX buffer bytes
-      if (rx_count < (Cfg::RX_SIZE) / 10) {
-        if (Cfg::TX_SIZE > 0) {
-          // Signal we want an XON character to be sent.
-          xon_xoff_state = XON_CHAR;
-          // Enable TX isr.
-          HWUART->UART_IER = UART_IER_TXRDY;
-        }
-        else {
-          // If not using TX interrupts, we must send the XON char now
-          xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-          while (!(HWUART->UART_SR & UART_SR_TXRDY)) sw_barrier();
-          HWUART->UART_THR = XON_CHAR;
-        }
-      }
-    }
-  }
-
-  return v;
-}
-
-template<typename Cfg>
-typename MarlinSerial<Cfg>::ring_buffer_pos_t MarlinSerial<Cfg>::available() {
-  const ring_buffer_pos_t h = rx_buffer.head, t = rx_buffer.tail;
-  return (ring_buffer_pos_t)(Cfg::RX_SIZE + h - t) & (Cfg::RX_SIZE - 1);
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::flush() {
-  rx_buffer.tail = rx_buffer.head;
-
-  if (Cfg::XONOFF) {
-    if ((xon_xoff_state & XON_XOFF_CHAR_MASK) == XOFF_CHAR) {
-      if (Cfg::TX_SIZE > 0) {
-        // Signal we want an XON character to be sent.
-        xon_xoff_state = XON_CHAR;
-        // Enable TX isr.
-        HWUART->UART_IER = UART_IER_TXRDY;
-      }
-      else {
-        // If not using TX interrupts, we must send the XON char now
-        xon_xoff_state = XON_CHAR | XON_XOFF_CHAR_SENT;
-        while (!(HWUART->UART_SR & UART_SR_TXRDY)) sw_barrier();
-        HWUART->UART_THR = XON_CHAR;
-      }
-    }
-  }
-}
-
-template<typename Cfg>
-size_t MarlinSerial<Cfg>::write(const uint8_t c) {
-  _written = true;
-
-  if (Cfg::TX_SIZE == 0) {
-    while (!(HWUART->UART_SR & UART_SR_TXRDY)) sw_barrier();
-    HWUART->UART_THR = c;
-  }
-  else {
-
-    // If the TX interrupts are disabled and the data register
-    // is empty, just write the byte to the data register and
-    // be done. This shortcut helps significantly improve the
-    // effective datarate at high (>500kbit/s) bitrates, where
-    // interrupt overhead becomes a slowdown.
-    // Yes, there is a race condition between the sending of the
-    // XOFF char at the RX isr, but it is properly handled there
-    if (!(HWUART->UART_IMR & UART_IMR_TXRDY) && (HWUART->UART_SR & UART_SR_TXRDY)) {
-      HWUART->UART_THR = c;
-      return 1;
-    }
-
-    const uint8_t i = (tx_buffer.head + 1) & (Cfg::TX_SIZE - 1);
-
-    // If global interrupts are disabled (as the result of being called from an ISR)...
-    if (!hal.isr_state()) {
-
-      // Make room by polling if it is possible to transmit, and do so!
-      while (i == tx_buffer.tail) {
-        // If we can transmit another byte, do it.
-        if (HWUART->UART_SR & UART_SR_TXRDY) _tx_thr_empty_irq();
-        // Make sure compiler rereads tx_buffer.tail
-        sw_barrier();
-      }
-    }
-    else {
-      // Interrupts are enabled, just wait until there is space
-      while (i == tx_buffer.tail) sw_barrier();
-    }
-
-    // Store new char. head is always safe to move
-    tx_buffer.buffer[tx_buffer.head] = c;
-    tx_buffer.head = i;
-
-    // Enable TX isr - Non atomic, but it will eventually enable TX isr
-    HWUART->UART_IER = UART_IER_TXRDY;
-  }
-  return 1;
-}
-
-template<typename Cfg>
-void MarlinSerial<Cfg>::flushTX() {
-  // TX
-
-  if (Cfg::TX_SIZE == 0) {
-    // No bytes written, no need to flush. This special case is needed since there's
-    // no way to force the TXC (transmit complete) bit to 1 during initialization.
-    if (!_written) return;
-
-    // Wait until everything was transmitted
-    while (!(HWUART->UART_SR & UART_SR_TXEMPTY)) sw_barrier();
-
-    // At this point nothing is queued anymore (DRIE is disabled) and
-    // the hardware finished transmission (TXC is set).
-
-  }
-  else {
-    // If we have never written a byte, no need to flush. This special
-    // case is needed since there is no way to force the TXC (transmit
-    // complete) bit to 1 during initialization
-    if (!_written) return;
-
-    // If global interrupts are disabled (as the result of being called from an ISR)...
-    if (!hal.isr_state()) {
-
-      // Wait until everything was transmitted - We must do polling, as interrupts are disabled
-      while (tx_buffer.head != tx_buffer.tail || !(HWUART->UART_SR & UART_SR_TXEMPTY)) {
-        // If there is more space, send an extra character
-        if (HWUART->UART_SR & UART_SR_TXRDY) _tx_thr_empty_irq();
-        sw_barrier();
-      }
-
-    }
-    else {
-      // Wait until everything was transmitted
-      while (tx_buffer.head != tx_buffer.tail || !(HWUART->UART_SR & UART_SR_TXEMPTY)) sw_barrier();
-    }
-
-    // At this point nothing is queued anymore (DRIE is disabled) and
-    // the hardware finished transmission (TXC is set).
-  }
-}
-
-
-// If not using the USB port as serial port
-#if defined(SERIAL_PORT) && SERIAL_PORT >= 0
-  template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT> >;
-  MSerialT1 customizedSerial1(MarlinSerialCfg<SERIAL_PORT>::EMERGENCYPARSER);
-#endif
-
-#if defined(SERIAL_PORT_2) && SERIAL_PORT_2 >= 0
-  template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT_2> >;
-  MSerialT2 customizedSerial2(MarlinSerialCfg<SERIAL_PORT_2>::EMERGENCYPARSER);
-#endif
-
-#if defined(SERIAL_PORT_3) && SERIAL_PORT_3 >= 0
-  template class MarlinSerial< MarlinSerialCfg<SERIAL_PORT_3> >;
-  MSerialT3 customizedSerial3(MarlinSerialCfg<SERIAL_PORT_3>::EMERGENCYPARSER);
-#endif
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/MarlinSerial.h b/Marlin/src/HAL/DUE/MarlinSerial.h
deleted file mode 100644
index 5a61bff..0000000
--- a/Marlin/src/HAL/DUE/MarlinSerial.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * MarlinSerial_Due.h - Hardware serial library for Arduino DUE
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- * Based on MarlinSerial for AVR, copyright (c) 2006 Nicholas Zambetti.  All right reserved.
- */
-
-#include <WString.h>
-
-#include "../../inc/MarlinConfigPre.h"
-#include "../../core/serial_hook.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-// 256 is the max limit due to uint8_t head and tail. Use only powers of 2. (...,16,32,64,128,256)
-#ifndef RX_BUFFER_SIZE
-  #define RX_BUFFER_SIZE 128
-#endif
-#ifndef TX_BUFFER_SIZE
-  #define TX_BUFFER_SIZE 32
-#endif
-
-//#if ENABLED(SERIAL_XON_XOFF) && RX_BUFFER_SIZE < 1024
-//  #error "SERIAL_XON_XOFF requires RX_BUFFER_SIZE >= 1024 for reliable transfers without drops."
-//#elif RX_BUFFER_SIZE && (RX_BUFFER_SIZE < 2 || !IS_POWER_OF_2(RX_BUFFER_SIZE))
-//  #error "RX_BUFFER_SIZE must be a power of 2 greater than 1."
-//#elif TX_BUFFER_SIZE && (TX_BUFFER_SIZE < 2 || TX_BUFFER_SIZE > 256 || !IS_POWER_OF_2(TX_BUFFER_SIZE))
-//  #error "TX_BUFFER_SIZE must be 0, a power of 2 greater than 1, and no greater than 256."
-//#endif
-
-// Templated type selector
-template<bool b, typename T, typename F> struct TypeSelector { typedef T type;} ;
-template<typename T, typename F> struct TypeSelector<false, T, F> { typedef F type; };
-
-// Templated structure wrapper
-template<typename S, unsigned int addr> struct StructWrapper {
-  constexpr StructWrapper(int) {}
-  FORCE_INLINE S* operator->() const { return (S*)addr; }
-};
-
-template<typename Cfg>
-class MarlinSerial {
-protected:
-  // Information for all supported UARTs
-  static constexpr uint32_t BASES[] = {0x400E0800U, 0x40098000U, 0x4009C000U, 0x400A0000U, 0x400A4000U};
-  static constexpr IRQn_Type IRQS[] = {  UART_IRQn, USART0_IRQn, USART1_IRQn, USART2_IRQn, USART3_IRQn};
-  static constexpr int    IRQ_IDS[] = {    ID_UART,   ID_USART0,   ID_USART1,   ID_USART2,   ID_USART3};
-
-  // Alias for shorter code
-  static constexpr StructWrapper<Uart,BASES[Cfg::PORT]> HWUART = 0;
-  static constexpr IRQn_Type HWUART_IRQ = IRQS[Cfg::PORT];
-  static constexpr int HWUART_IRQ_ID = IRQ_IDS[Cfg::PORT];
-
-  // Base size of type on buffer size
-  typedef typename TypeSelector<(Cfg::RX_SIZE>256), uint16_t, uint8_t>::type ring_buffer_pos_t;
-
-  struct ring_buffer_r {
-    volatile ring_buffer_pos_t head, tail;
-    unsigned char buffer[Cfg::RX_SIZE];
-  };
-
-  struct ring_buffer_t {
-    volatile uint8_t head, tail;
-    unsigned char buffer[Cfg::TX_SIZE];
-  };
-
-  static ring_buffer_r rx_buffer;
-  static ring_buffer_t tx_buffer;
-  static bool _written;
-
-  static constexpr uint8_t XON_XOFF_CHAR_SENT = 0x80,  // XON / XOFF Character was sent
-                           XON_XOFF_CHAR_MASK = 0x1F;  // XON / XOFF character to send
-
-  // XON / XOFF character definitions
-  static constexpr uint8_t XON_CHAR  = 17, XOFF_CHAR = 19;
-  static uint8_t xon_xoff_state,
-                 rx_dropped_bytes,
-                 rx_buffer_overruns,
-                 rx_framing_errors;
-  static ring_buffer_pos_t rx_max_enqueued;
-
-  FORCE_INLINE static void store_rxd_char();
-  FORCE_INLINE static void _tx_thr_empty_irq();
-  static void UART_ISR();
-
-public:
-  MarlinSerial() {};
-  static void begin(const long);
-  static void end();
-  static int peek();
-  static int read();
-  static void flush();
-  static ring_buffer_pos_t available();
-  static size_t write(const uint8_t c);
-  static void flushTX();
-
-  static bool emergency_parser_enabled() { return Cfg::EMERGENCYPARSER; }
-
-  FORCE_INLINE static uint8_t dropped() { return Cfg::DROPPED_RX ? rx_dropped_bytes : 0; }
-  FORCE_INLINE static uint8_t buffer_overruns() { return Cfg::RX_OVERRUNS ? rx_buffer_overruns : 0; }
-  FORCE_INLINE static uint8_t framing_errors() { return Cfg::RX_FRAMING_ERRORS ? rx_framing_errors : 0; }
-  FORCE_INLINE static ring_buffer_pos_t rxMaxEnqueued() { return Cfg::MAX_RX_QUEUED ? rx_max_enqueued : 0; }
-};
-
-// Serial port configuration
-template <uint8_t serial>
-struct MarlinSerialCfg {
-  static constexpr int PORT               = serial;
-  static constexpr unsigned int RX_SIZE   = RX_BUFFER_SIZE;
-  static constexpr unsigned int TX_SIZE   = TX_BUFFER_SIZE;
-  static constexpr bool XONOFF            = ENABLED(SERIAL_XON_XOFF);
-  static constexpr bool EMERGENCYPARSER   = ENABLED(EMERGENCY_PARSER);
-  static constexpr bool DROPPED_RX        = ENABLED(SERIAL_STATS_DROPPED_RX);
-  static constexpr bool RX_OVERRUNS       = ENABLED(SERIAL_STATS_RX_BUFFER_OVERRUNS);
-  static constexpr bool RX_FRAMING_ERRORS = ENABLED(SERIAL_STATS_RX_FRAMING_ERRORS);
-  static constexpr bool MAX_RX_QUEUED     = ENABLED(SERIAL_STATS_MAX_RX_QUEUED);
-};
-
-#if defined(SERIAL_PORT) && SERIAL_PORT >= 0
-  typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT> > > MSerialT1;
-  extern MSerialT1 customizedSerial1;
-#endif
-
-#if defined(SERIAL_PORT_2) && SERIAL_PORT_2 >= 0
-  typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT_2> > > MSerialT2;
-  extern MSerialT2 customizedSerial2;
-#endif
-
-#if defined(SERIAL_PORT_3) && SERIAL_PORT_3 >= 0
-  typedef Serial1Class< MarlinSerial< MarlinSerialCfg<SERIAL_PORT_3> > > MSerialT3;
-  extern MSerialT3 customizedSerial3;
-#endif
diff --git a/Marlin/src/HAL/DUE/MarlinSerialUSB.cpp b/Marlin/src/HAL/DUE/MarlinSerialUSB.cpp
deleted file mode 100644
index 8de2dc7..0000000
--- a/Marlin/src/HAL/DUE/MarlinSerialUSB.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_SAM
-
-/**
- * MarlinSerial_Due.cpp - Hardware serial library for Arduino DUE
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- * Based on MarlinSerial for AVR, copyright (c) 2006 Nicholas Zambetti.  All right reserved.
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_USB_SERIAL
-
-#include "MarlinSerialUSB.h"
-
-// Imports from Atmel USB Stack/CDC implementation
-extern "C" {
-  bool usb_task_cdc_isenabled();
-  bool usb_task_cdc_dtr_active();
-  bool udi_cdc_is_rx_ready();
-  int udi_cdc_getc();
-  bool udi_cdc_is_tx_ready();
-  int udi_cdc_putc(int value);
-}
-
-// Pending character
-static int pending_char = -1;
-
-// Public Methods
-void MarlinSerialUSB::begin(const long) {}
-
-void MarlinSerialUSB::end() {}
-
-int MarlinSerialUSB::peek() {
-  if (pending_char >= 0)
-    return pending_char;
-
-  // If USB CDC not enumerated or not configured on the PC side
-  if (!usb_task_cdc_isenabled())
-    return -1;
-
-  // If no bytes sent from the PC
-  if (!udi_cdc_is_rx_ready())
-    return -1;
-
-  pending_char = udi_cdc_getc();
-
-  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));
-
-  return pending_char;
-}
-
-int MarlinSerialUSB::read() {
-  if (pending_char >= 0) {
-    int ret = pending_char;
-    pending_char = -1;
-    return ret;
-  }
-
-  // If USB CDC not enumerated or not configured on the PC side
-  if (!usb_task_cdc_isenabled())
-    return -1;
-
-  // If no bytes sent from the PC
-  if (!udi_cdc_is_rx_ready())
-    return -1;
-
-  int c = udi_cdc_getc();
-
-  TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));
-
-  return c;
-}
-
-int MarlinSerialUSB::available() {
-  if (pending_char > 0) return pending_char;
-  return pending_char == 0 ||
-    // or USB CDC enumerated and configured on the PC side and some bytes where sent to us */
-    (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready());
-}
-
-void MarlinSerialUSB::flush() { }
-
-size_t MarlinSerialUSB::write(const uint8_t c) {
-
-  /* Do not even bother sending anything if USB CDC is not enumerated
-     or not configured on the PC side or there is no program on the PC
-     listening to our messages */
-  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active())
-    return 0;
-
-  /* Wait until the PC has read the pending to be sent data */
-  while (usb_task_cdc_isenabled() &&
-         usb_task_cdc_dtr_active() &&
-        !udi_cdc_is_tx_ready()) {
-  };
-
-  /* Do not even bother sending anything if USB CDC is not enumerated
-     or not configured on the PC side or there is no program on the PC
-     listening to our messages at this point */
-  if (!usb_task_cdc_isenabled() || !usb_task_cdc_dtr_active())
-    return 0;
-
-  // Fifo full
-  //  udi_cdc_signal_overrun();
-  udi_cdc_putc(c);
-  return 1;
-}
-
-// Preinstantiate
-#if SERIAL_PORT == -1
-  MSerialT1 customizedSerial1(TERN0(EMERGENCY_PARSER, true));
-#endif
-#if SERIAL_PORT_2 == -1
-  MSerialT2 customizedSerial2(TERN0(EMERGENCY_PARSER, true));
-#endif
-#if SERIAL_PORT_3 == -1
-  MSerialT3 customizedSerial3(TERN0(EMERGENCY_PARSER, true));
-#endif
-
-#endif // HAS_USB_SERIAL
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/MarlinSerialUSB.h b/Marlin/src/HAL/DUE/MarlinSerialUSB.h
deleted file mode 100644
index 6da1ef8..0000000
--- a/Marlin/src/HAL/DUE/MarlinSerialUSB.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * MarlinSerialUSB_Due.h - Hardware Serial over USB (CDC) library for Arduino DUE
- * Copyright (c) 2017 Eduardo JosÃ© Tagle. All right reserved
- */
-
-#include "../../inc/MarlinConfig.h"
-#include "../../core/serial_hook.h"
-
-#include <WString.h>
-
-struct MarlinSerialUSB {
-  void begin(const long);
-  void end();
-  int peek();
-  int read();
-  void flush();
-  int available();
-  size_t write(const uint8_t c);
-
-  #if ENABLED(SERIAL_STATS_DROPPED_RX)
-    FORCE_INLINE uint32_t dropped() { return 0; }
-  #endif
-
-  #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-    FORCE_INLINE int rxMaxEnqueued() { return 0; }
-  #endif
-};
-
-#if SERIAL_PORT == -1
-  typedef Serial1Class<MarlinSerialUSB> MSerialT1;
-  extern MSerialT1 customizedSerial1;
-#endif
-
-#if SERIAL_PORT_2 == -1
-  typedef Serial1Class<MarlinSerialUSB> MSerialT2;
-  extern MSerialT2 customizedSerial2;
-#endif
-
-#if SERIAL_PORT_3 == -1
-  typedef Serial1Class<MarlinSerialUSB> MSerialT3;
-  extern MSerialT3 customizedSerial3;
-#endif
diff --git a/Marlin/src/HAL/DUE/MinSerial.cpp b/Marlin/src/HAL/DUE/MinSerial.cpp
deleted file mode 100644
index e5b3dbf..0000000
--- a/Marlin/src/HAL/DUE/MinSerial.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-
-#include "../shared/MinSerial.h"
-
-#include <stdarg.h>
-
-static void TXBegin() {
-  // Disable UART interrupt in NVIC
-  NVIC_DisableIRQ( UART_IRQn );
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-
-  // Disable clock
-  pmc_disable_periph_clk( ID_UART );
-
-  // Configure PMC
-  pmc_enable_periph_clk( ID_UART );
-
-  // Disable PDC channel
-  UART->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
-
-  // Reset and disable receiver and transmitter
-  UART->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX | UART_CR_RXDIS | UART_CR_TXDIS;
-
-  // Configure mode: 8bit, No parity, 1 bit stop
-  UART->UART_MR = UART_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT | US_MR_NBSTOP_1_BIT | UART_MR_PAR_NO;
-
-  // Configure baudrate (asynchronous, no oversampling) to BAUDRATE bauds
-  UART->UART_BRGR = (SystemCoreClock / (BAUDRATE << 4));
-
-  // Enable receiver and transmitter
-  UART->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
-}
-
-// A SW memory barrier, to ensure GCC does not overoptimize loops
-#define sw_barrier() __asm__ volatile("": : :"memory");
-static void TX(char c) {
-  while (!(UART->UART_SR & UART_SR_TXRDY)) { WDT_Restart(WDT); sw_barrier(); };
-  UART->UART_THR = c;
-}
-
-void install_min_serial() {
-  HAL_min_serial_init = &TXBegin;
-  HAL_min_serial_out = &TX;
-}
-
-#if DISABLED(DYNAMIC_VECTORTABLE)
-extern "C" {
-  __attribute__((naked)) void JumpHandler_ASM() {
-    __asm__ __volatile__ (
-      "b CommonHandler_ASM\n"
-    );
-  }
-  void __attribute__((naked, alias("JumpHandler_ASM"))) HardFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) BusFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) UsageFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) MemManage_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) NMI_Handler();
-}
-#endif
-
-#endif // POSTMORTEM_DEBUGGING
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/Servo.cpp b/Marlin/src/HAL/DUE/Servo.cpp
deleted file mode 100644
index 2dab882..0000000
--- a/Marlin/src/HAL/DUE/Servo.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/*
-  Copyright (c) 2013 Arduino LLC. All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "../shared/servo.h"
-#include "../shared/servo_private.h"
-
-static Flags<_Nbr_16timers> DisablePending; // ISR should disable the timer at the next timer reset
-
-// ------------------------
-/// Interrupt handler for the TC0 channel 1.
-// ------------------------
-void Servo_Handler(const timer16_Sequence_t, Tc*, const uint8_t);
-
-#ifdef _useTimer1
-  void HANDLER_FOR_TIMER1() { Servo_Handler(_timer1, TC_FOR_TIMER1, CHANNEL_FOR_TIMER1); }
-#endif
-#ifdef _useTimer2
-  void HANDLER_FOR_TIMER2() { Servo_Handler(_timer2, TC_FOR_TIMER2, CHANNEL_FOR_TIMER2); }
-#endif
-#ifdef _useTimer3
-  void HANDLER_FOR_TIMER3() { Servo_Handler(_timer3, TC_FOR_TIMER3, CHANNEL_FOR_TIMER3); }
-#endif
-#ifdef _useTimer4
-  void HANDLER_FOR_TIMER4() { Servo_Handler(_timer4, TC_FOR_TIMER4, CHANNEL_FOR_TIMER4); }
-#endif
-#ifdef _useTimer5
-  void HANDLER_FOR_TIMER5() { Servo_Handler(_timer5, TC_FOR_TIMER5, CHANNEL_FOR_TIMER5); }
-#endif
-
-void Servo_Handler(const timer16_Sequence_t timer, Tc *tc, const uint8_t channel) {
-  static int8_t Channel[_Nbr_16timers];                               // Servo counters to pulse (or -1 for refresh interval)
-  int8_t cho = Channel[timer];                                        // Handle the prior Channel[timer] first
-  if (cho < 0) {                                                      // Channel -1 indicates the refresh interval completed...
-    tc->TC_CHANNEL[channel].TC_CCR |= TC_CCR_SWTRG;                   // ...so reset the timer
-    if (DisablePending[timer]) {
-      // Disabling only after the full servo period expires prevents
-      // pulses being too close together if immediately re-enabled.
-      DisablePending.clear(timer);
-      TC_Stop(tc, channel);
-      tc->TC_CHANNEL[channel].TC_SR;                                  // clear interrupt
-      return;
-    }
-  }
-  else if (SERVO_INDEX(timer, cho) < ServoCount)                      // prior channel handled?
-    extDigitalWrite(SERVO(timer, cho).Pin.nbr, LOW);                  // pulse the prior channel LOW
-
-  Channel[timer] = ++cho;                                             // go to the next channel (or 0)
-  if (cho < SERVOS_PER_TIMER && SERVO_INDEX(timer, cho) < ServoCount) {
-    tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + SERVO(timer, cho).ticks;
-    if (SERVO(timer, cho).Pin.isActive)                               // activated?
-      extDigitalWrite(SERVO(timer, cho).Pin.nbr, HIGH);               // yes: pulse HIGH
-  }
-  else {
-    // finished all channels so wait for the refresh period to expire before starting over
-    const unsigned int cval = tc->TC_CHANNEL[channel].TC_CV + 128 / (SERVO_TIMER_PRESCALER), // allow 128 cycles to ensure the next CV not missed
-                       ival = (unsigned int)usToTicks(REFRESH_INTERVAL); // at least REFRESH_INTERVAL has elapsed
-    tc->TC_CHANNEL[channel].TC_RA = max(cval, ival);
-
-    Channel[timer] = -1;                                              // reset the timer CCR on the next call
-  }
-
-  tc->TC_CHANNEL[channel].TC_SR;                                      // clear interrupt
-}
-
-static void _initISR(Tc *tc, uint32_t channel, uint32_t id, IRQn_Type irqn) {
-  pmc_enable_periph_clk(id);
-  TC_Configure(tc, channel,
-      TC_CMR_WAVE                   // Waveform mode
-    | TC_CMR_WAVSEL_UP_RC           // Counter running up and reset when equal to RC
-    | (SERVO_TIMER_PRESCALER ==   2 ? TC_CMR_TCCLKS_TIMER_CLOCK1 : 0) // MCK/2
-    | (SERVO_TIMER_PRESCALER ==   8 ? TC_CMR_TCCLKS_TIMER_CLOCK2 : 0) // MCK/8
-    | (SERVO_TIMER_PRESCALER ==  32 ? TC_CMR_TCCLKS_TIMER_CLOCK3 : 0) // MCK/32
-    | (SERVO_TIMER_PRESCALER == 128 ? TC_CMR_TCCLKS_TIMER_CLOCK4 : 0) // MCK/128
-  );
-
-  // Wait 1ms before the first ISR
-  TC_SetRA(tc, channel, (F_CPU) / (SERVO_TIMER_PRESCALER) / 1000UL); // 1ms
-
-  // Configure and enable interrupt
-  NVIC_EnableIRQ(irqn);
-  tc->TC_CHANNEL[channel].TC_IER = TC_IER_CPAS; // TC_IER_CPAS: RA Compare
-
-  // Enables the timer clock and performs a software reset to start the counting
-  TC_Start(tc, channel);
-}
-
-void initISR(const timer16_Sequence_t timer_index) {
-  CRITICAL_SECTION_START();
-  const bool disable_soon = DisablePending[timer_index];
-  DisablePending.clear(timer_index);
-  CRITICAL_SECTION_END();
-
-  if (!disable_soon) switch (timer_index) {
-    default: break;
-    #ifdef _useTimer1
-      case _timer1: return _initISR(TC_FOR_TIMER1, CHANNEL_FOR_TIMER1, ID_TC_FOR_TIMER1, IRQn_FOR_TIMER1);
-    #endif
-    #ifdef _useTimer2
-      case _timer2: return _initISR(TC_FOR_TIMER2, CHANNEL_FOR_TIMER2, ID_TC_FOR_TIMER2, IRQn_FOR_TIMER2);
-    #endif
-    #ifdef _useTimer3
-      case _timer3: return _initISR(TC_FOR_TIMER3, CHANNEL_FOR_TIMER3, ID_TC_FOR_TIMER3, IRQn_FOR_TIMER3);
-    #endif
-    #ifdef _useTimer4
-      case _timer4: return _initISR(TC_FOR_TIMER4, CHANNEL_FOR_TIMER4, ID_TC_FOR_TIMER4, IRQn_FOR_TIMER4);
-    #endif
-    #ifdef _useTimer5
-      case _timer5: return _initISR(TC_FOR_TIMER5, CHANNEL_FOR_TIMER5, ID_TC_FOR_TIMER5, IRQn_FOR_TIMER5);
-    #endif
-  }
-}
-
-void finISR(const timer16_Sequence_t timer_index) {
-  // Timer is disabled from the ISR, to ensure proper final pulse length.
-  DisablePending.set(timer_index);
-}
-
-#endif // HAS_SERVOS
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/ServoTimers.h b/Marlin/src/HAL/DUE/ServoTimers.h
deleted file mode 100644
index 95bd404..0000000
--- a/Marlin/src/HAL/DUE/ServoTimers.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Copyright (c) 2013 Arduino LLC. All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * Defines for 16 bit timers used with  Servo library
- *
- * If _useTimerX is defined then TimerX is a 32 bit timer on the current board
- * timer16_Sequence_t enumerates the sequence that the timers should be allocated
- * _Nbr_16timers indicates how many timers are available.
- */
-
-/**
- * SAM Only definitions
- * --------------------
- */
-
-// For SAM3X:
-//!#define _useTimer1
-//!#define _useTimer2
-#define _useTimer3
-//!#define _useTimer4
-#define _useTimer5
-
-#define TRIM_DURATION             2   // compensation ticks to trim adjust for digitalWrite delays
-#define SERVO_TIMER_PRESCALER     2   // timer prescaler
-
-/*
-  TC0, chan 0 => TC0_Handler
-  TC0, chan 1 => TC1_Handler
-  TC0, chan 2 => TC2_Handler
-  TC1, chan 0 => TC3_Handler
-  TC1, chan 1 => TC4_Handler
-  TC1, chan 2 => TC5_Handler
-  TC2, chan 0 => TC6_Handler
-  TC2, chan 1 => TC7_Handler
-  TC2, chan 2 => TC8_Handler
- */
-
-#ifdef _useTimer1
-  #define TC_FOR_TIMER1       TC1
-  #define CHANNEL_FOR_TIMER1  0
-  #define ID_TC_FOR_TIMER1    ID_TC3
-  #define IRQn_FOR_TIMER1     TC3_IRQn
-  #define HANDLER_FOR_TIMER1  TC3_Handler
-#endif
-#ifdef _useTimer2
-  #define TC_FOR_TIMER2       TC1
-  #define CHANNEL_FOR_TIMER2  1
-  #define ID_TC_FOR_TIMER2    ID_TC4
-  #define IRQn_FOR_TIMER2     TC4_IRQn
-  #define HANDLER_FOR_TIMER2  TC4_Handler
-#endif
-#ifdef _useTimer3
-  #define TC_FOR_TIMER3       TC1
-  #define CHANNEL_FOR_TIMER3  2
-  #define ID_TC_FOR_TIMER3    ID_TC5
-  #define IRQn_FOR_TIMER3     TC5_IRQn
-  #define HANDLER_FOR_TIMER3  TC5_Handler
-#endif
-#ifdef _useTimer4
-  #define TC_FOR_TIMER4       TC0
-  #define CHANNEL_FOR_TIMER4  2
-  #define ID_TC_FOR_TIMER4    ID_TC2
-  #define IRQn_FOR_TIMER4     TC2_IRQn
-  #define HANDLER_FOR_TIMER4  TC2_Handler
-#endif
-#ifdef _useTimer5
-  #define TC_FOR_TIMER5       TC0
-  #define CHANNEL_FOR_TIMER5  0
-  #define ID_TC_FOR_TIMER5    ID_TC0
-  #define IRQn_FOR_TIMER5     TC0_IRQn
-  #define HANDLER_FOR_TIMER5  TC0_Handler
-#endif
-
-typedef enum : unsigned char {
-  #ifdef _useTimer1
-    _timer1,
-  #endif
-  #ifdef _useTimer2
-    _timer2,
-  #endif
-  #ifdef _useTimer3
-    _timer3,
-  #endif
-  #ifdef _useTimer4
-    _timer4,
-  #endif
-  #ifdef _useTimer5
-    _timer5,
-  #endif
-  _Nbr_16timers
-} timer16_Sequence_t;
diff --git a/Marlin/src/HAL/DUE/Tone.cpp b/Marlin/src/HAL/DUE/Tone.cpp
deleted file mode 100644
index 4bc8142..0000000
--- a/Marlin/src/HAL/DUE/Tone.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Description: Tone function for Arduino Due and compatible (SAM3X8E)
- * Derived from https://forum.arduino.cc/index.php?topic=136500.msg2903012#msg2903012
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-static pin_t tone_pin;
-volatile static int32_t toggles;
-
-void tone(const pin_t _pin, const unsigned int frequency, const unsigned long duration/*=0*/) {
-  tone_pin = _pin;
-  toggles = 2 * frequency * duration / 1000;
-  HAL_timer_start(MF_TIMER_TONE, 2 * frequency);
-}
-
-void noTone(const pin_t _pin) {
-  HAL_timer_disable_interrupt(MF_TIMER_TONE);
-  extDigitalWrite(_pin, LOW);
-}
-
-HAL_TONE_TIMER_ISR() {
-  static uint8_t pin_state = 0;
-  HAL_timer_isr_prologue(MF_TIMER_TONE);
-
-  if (toggles) {
-    toggles--;
-    extDigitalWrite(tone_pin, (pin_state ^= 1));
-  }
-  else noTone(tone_pin);                         // turn off interrupt
-}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_shared_hw_spi.cpp b/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_shared_hw_spi.cpp
deleted file mode 100644
index 68f6a5c..0000000
--- a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_shared_hw_spi.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_msp430_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2012, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * * Redistributions of source code must retain the above copyright notice, this list
- * of conditions and the following disclaimer.
- *
- * * Redistributions in binary form must reproduce the above copyright notice, this
- * list of conditions and the following disclaimer in the documentation and/or other
- * materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef __SAM3X8E__
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include <U8glib-HAL.h>
-
-#include "../../../MarlinCore.h"
-
-#ifndef LCD_SPI_SPEED
-  #define LCD_SPI_SPEED SPI_QUARTER_SPEED
-#endif
-
-#include "../../shared/HAL_SPI.h"
-#include "../fastio.h"
-
-void u8g_SetPIOutput_DUE_hw_spi(u8g_t *u8g, uint8_t pin_index) {
-   PIO_Configure(g_APinDescription[u8g->pin_list[pin_index]].pPort, PIO_OUTPUT_1,
-     g_APinDescription[u8g->pin_list[pin_index]].ulPin, g_APinDescription[u8g->pin_list[pin_index]].ulPinConfiguration);  // OUTPUT
-}
-
-void u8g_SetPILevel_DUE_hw_spi(u8g_t *u8g, uint8_t pin_index, uint8_t level) {
-  volatile Pio* port = g_APinDescription[u8g->pin_list[pin_index]].pPort;
-  uint32_t mask = g_APinDescription[u8g->pin_list[pin_index]].ulPin;
-  if (level) port->PIO_SODR = mask;
-  else port->PIO_CODR = mask;
-}
-
-uint8_t u8g_com_HAL_DUE_shared_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_INIT:
-      u8g_SetPILevel_DUE_hw_spi(u8g, U8G_PI_CS, 1);
-      u8g_SetPILevel_DUE_hw_spi(u8g, U8G_PI_A0, 1);
-
-      u8g_SetPIOutput_DUE_hw_spi(u8g, U8G_PI_CS);
-      u8g_SetPIOutput_DUE_hw_spi(u8g, U8G_PI_A0);
-
-      u8g_Delay(5);
-
-      spiBegin();
-
-      spiInit(LCD_SPI_SPEED);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g_SetPILevel_DUE_hw_spi(u8g, U8G_PI_A0, arg_val);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      u8g_SetPILevel_DUE_hw_spi(u8g, U8G_PI_CS, (arg_val ? 0 : 1));
-      break;
-
-    case U8G_COM_MSG_RESET:
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-
-      spiSend((uint8_t)arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          spiSend(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          spiSend(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-
-#endif // __SAM3X8E__
diff --git a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_st7920_sw_spi.cpp b/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_st7920_sw_spi.cpp
deleted file mode 100644
index 8268cf3..0000000
--- a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_st7920_sw_spi.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_st7920_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if IS_U8GLIB_ST7920
-
-#include "../../../inc/MarlinConfig.h"
-#include "../../shared/Delay.h"
-
-#include <U8glib-HAL.h>
-
-#include "u8g_com_HAL_DUE_sw_spi_shared.h"
-
-#define SPISEND_SW_DUE u8g_spiSend_sw_DUE_mode_0
-
-static uint8_t rs_last_state = 255;
-
-static void u8g_com_DUE_st7920_write_byte_sw_spi(uint8_t rs, uint8_t val) {
-  if (rs != rs_last_state) {  // time to send a command/data byte
-    rs_last_state = rs;
-    SPISEND_SW_DUE(rs ? 0x0FA : 0x0F8); // Command or Data
-    DELAY_US(40); // give the controller some time to process the data: 20 is bad, 30 is OK, 40 is safe
-  }
-  SPISEND_SW_DUE(val & 0xF0);
-  SPISEND_SW_DUE(val << 4);
-}
-
-uint8_t u8g_com_HAL_DUE_ST7920_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      SCK_pPio = g_APinDescription[u8g->pin_list[U8G_PI_SCK]].pPort;
-      SCK_dwMask = g_APinDescription[u8g->pin_list[U8G_PI_SCK]].ulPin;
-      MOSI_pPio = g_APinDescription[u8g->pin_list[U8G_PI_MOSI]].pPort;
-      MOSI_dwMask = g_APinDescription[u8g->pin_list[U8G_PI_MOSI]].ulPin;
-
-      u8g_SetPILevel_DUE(u8g, U8G_PI_CS, 0);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_CS);
-      u8g_SetPILevel_DUE(u8g, U8G_PI_SCK, 0);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_SCK);
-      u8g_SetPILevel_DUE(u8g, U8G_PI_MOSI, 0);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_MOSI);
-
-      SCK_pPio->PIO_CODR = SCK_dwMask;   //SCK low - needed at power up but not after reset
-      MOSI_pPio->PIO_CODR = MOSI_dwMask; //MOSI low - needed at power up but not after reset
-
-      u8g_Delay(5);
-
-      u8g->pin_list[U8G_PI_A0_STATE] = 0;       /* initial RS state: command mode */
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-       if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPILevel_DUE(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g->pin_list[U8G_PI_A0_STATE] = arg_val;
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_CS])
-        u8g_SetPILevel_DUE(u8g, U8G_PI_CS, arg_val);  //note: the st7920 has an active high chip select
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-
-      u8g_com_DUE_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_DUE_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_DUE_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-  }
-  return 1;
-}
-
-#if ENABLED(LIGHTWEIGHT_UI)
-  #include "../../../lcd/marlinui.h"
-  #include "../../shared/HAL_ST7920.h"
-
-  #define ST7920_CS_PIN LCD_PINS_RS
-
-  #if DOGM_SPI_DELAY_US > 0
-    #define U8G_DELAY() DELAY_US(DOGM_SPI_DELAY_US)
-  #else
-    #define U8G_DELAY() DELAY_US(10)
-  #endif
-
-  void ST7920_cs() {
-    WRITE(ST7920_CS_PIN, HIGH);
-    U8G_DELAY();
-  }
-
-  void ST7920_ncs() {
-    WRITE(ST7920_CS_PIN, LOW);
-  }
-
-  void ST7920_set_cmd() {
-    SPISEND_SW_DUE(0xF8);
-    DELAY_US(40);
-  }
-
-  void ST7920_set_dat() {
-    SPISEND_SW_DUE(0xFA);
-    DELAY_US(40);
-  }
-
-  void ST7920_write_byte(const uint8_t val) {
-    SPISEND_SW_DUE(val & 0xF0);
-    SPISEND_SW_DUE(val << 4);
-  }
-#endif // LIGHTWEIGHT_UI
-
-#endif // IS_U8GLIB_ST7920
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi.cpp b/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi.cpp
deleted file mode 100644
index 68e3e74..0000000
--- a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_std_sw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2015, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB && !IS_U8GLIB_ST7920
-
-#include "u8g_com_HAL_DUE_sw_spi_shared.h"
-
-#include "../../shared/Marduino.h"
-#include "../../shared/Delay.h"
-
-#include <U8glib-HAL.h>
-
-#if ENABLED(FYSETC_MINI_12864)
-  #define SPISEND_SW_DUE u8g_spiSend_sw_DUE_mode_3
-#else
-  #define SPISEND_SW_DUE u8g_spiSend_sw_DUE_mode_0
-#endif
-
-uint8_t u8g_com_HAL_DUE_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      SCK_pPio = g_APinDescription[u8g->pin_list[U8G_PI_SCK]].pPort;
-      SCK_dwMask = g_APinDescription[u8g->pin_list[U8G_PI_SCK]].ulPin;
-      MOSI_pPio = g_APinDescription[u8g->pin_list[U8G_PI_MOSI]].pPort;
-      MOSI_dwMask = g_APinDescription[u8g->pin_list[U8G_PI_MOSI]].ulPin;
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_SCK);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_MOSI);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_CS);
-      u8g_SetPIOutput_DUE(u8g, U8G_PI_A0);
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPIOutput_DUE(u8g, U8G_PI_RESET);
-      u8g_SetPILevel_DUE(u8g, U8G_PI_SCK, 0);
-      u8g_SetPILevel_DUE(u8g, U8G_PI_MOSI, 0);
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPILevel_DUE(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      #if ENABLED(FYSETC_MINI_12864)           // LCD SPI is running mode 3 while SD card is running mode 0
-        if (arg_val) {                        //   SCK idle state needs to be set to the proper idle state before
-                                               //   the next chip select goes active
-          u8g_SetPILevel_DUE(u8g, U8G_PI_SCK, 1);  //set SCK to mode 3 idle state before CS goes active
-          u8g_SetPILevel_DUE(u8g, U8G_PI_CS, LOW);
-        }
-        else {
-          u8g_SetPILevel_DUE(u8g, U8G_PI_CS, HIGH);
-          u8g_SetPILevel_DUE(u8g, U8G_PI_SCK, 0); //set SCK to mode 0 idle state after CS goes inactive
-        }
-      #else
-        u8g_SetPILevel_DUE(u8g, U8G_PI_CS, !arg_val);
-      #endif
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      SPISEND_SW_DUE(arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          SPISEND_SW_DUE(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          SPISEND_SW_DUE(u8g_pgm_read(ptr));
-          ptr++;
-          arg_val--;
-        }
-      }
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g_SetPILevel_DUE(u8g, U8G_PI_A0, arg_val);
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB && !IS_U8GLIB_ST7920
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.cpp b/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.cpp
deleted file mode 100644
index 9049247..0000000
--- a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_st7920_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include "../../../inc/MarlinConfig.h"
-#include "../../shared/Delay.h"
-
-#include <U8glib-HAL.h>
-
-#include "u8g_com_HAL_DUE_sw_spi_shared.h"
-
-void u8g_SetPIOutput_DUE(u8g_t *u8g, uint8_t pin_index) {
-  PIO_Configure(g_APinDescription[u8g->pin_list[pin_index]].pPort, PIO_OUTPUT_1,
-    g_APinDescription[u8g->pin_list[pin_index]].ulPin, g_APinDescription[u8g->pin_list[pin_index]].ulPinConfiguration);  // OUTPUT
-}
-
-void u8g_SetPILevel_DUE(u8g_t *u8g, uint8_t pin_index, uint8_t level) {
-  volatile Pio* port = g_APinDescription[u8g->pin_list[pin_index]].pPort;
-  uint32_t mask = g_APinDescription[u8g->pin_list[pin_index]].ulPin;
-  if (level) port->PIO_SODR = mask; else port->PIO_CODR = mask;
-}
-
-Pio *SCK_pPio, *MOSI_pPio;
-uint32_t SCK_dwMask, MOSI_dwMask;
-
-void u8g_spiSend_sw_DUE_mode_0(uint8_t val) { // 3MHz
-  LOOP_L_N(i, 8) {
-    if (val & 0x80)
-      MOSI_pPio->PIO_SODR = MOSI_dwMask;
-    else
-      MOSI_pPio->PIO_CODR = MOSI_dwMask;
-    DELAY_NS(48);
-    SCK_pPio->PIO_SODR = SCK_dwMask;
-    DELAY_NS(905);
-    val <<= 1;
-    SCK_pPio->PIO_CODR = SCK_dwMask;
-  }
-}
-
-void u8g_spiSend_sw_DUE_mode_3(uint8_t val) { // 3.5MHz
-  LOOP_L_N(i, 8) {
-    SCK_pPio->PIO_CODR = SCK_dwMask;
-    DELAY_NS(50);
-    if (val & 0x80)
-      MOSI_pPio->PIO_SODR = MOSI_dwMask;
-    else
-      MOSI_pPio->PIO_CODR = MOSI_dwMask;
-    val <<= 1;
-    DELAY_NS(10);
-    SCK_pPio->PIO_SODR = SCK_dwMask;
-    DELAY_NS(70);
-  }
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.h b/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.h
deleted file mode 100644
index 45231fd..0000000
--- a/Marlin/src/HAL/DUE/dogm/u8g_com_HAL_DUE_sw_spi_shared.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../../inc/MarlinConfigPre.h"
-#include "../../shared/Marduino.h"
-#include <U8glib-HAL.h>
-
-void u8g_SetPIOutput_DUE(u8g_t *u8g, uint8_t pin_index);
-void u8g_SetPILevel_DUE(u8g_t *u8g, uint8_t pin_index, uint8_t level);
-
-void u8g_spiSend_sw_DUE_mode_0(uint8_t val);
-void u8g_spiSend_sw_DUE_mode_3(uint8_t val);
-
-extern Pio *SCK_pPio, *MOSI_pPio;
-extern uint32_t SCK_dwMask, MOSI_dwMask;
diff --git a/Marlin/src/HAL/DUE/eeprom_flash.cpp b/Marlin/src/HAL/DUE/eeprom_flash.cpp
deleted file mode 100644
index 6077641..0000000
--- a/Marlin/src/HAL/DUE/eeprom_flash.cpp
+++ /dev/null
@@ -1,998 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- * Copyright (c) 2016 Victor Perez victor_pv@hotmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(FLASH_EEPROM_EMULATION)
-
-/* EEPROM emulation over flash with reduced wear
- *
- * We will use 2 contiguous groups of pages as main and alternate.
- * We want an structure that allows to read as fast as possible,
- * without the need of scanning the whole FLASH memory.
- *
- * FLASH bits default erased state is 1, and can be set to 0
- * on a per bit basis. To reset them to 1, a full page erase
- * is needed.
- *
- * Values are stored as differences that should be applied to a
- * completely erased EEPROM (filled with 0xFFs). We just encode
- * the starting address of the values to change, the length of
- * the block of new values, and the values themselves. All diffs
- * are accumulated into a RAM buffer, compacted into the least
- * amount of non overlapping diffs possible and sorted by starting
- * address before being saved into the next available page of FLASH
- * of the current group.
- * Once the current group is completely full, we compact it and save
- * it into the other group, then erase the current group and switch
- * to that new group and set it as current.
- *
- * The FLASH endurance is about 1/10 ... 1/100 of an EEPROM
- * endurance, but EEPROM endurance is specified per byte, not
- * per page. We can't emulate EE endurance with FLASH for all
- * bytes, but we can emulate endurance for a given percent of
- * bytes.
- */
-
-//#define EE_EMU_DEBUG
-
-#define EEPROMSize     4096
-#define PagesPerGroup   128
-#define GroupCount        2
-#define PageSize        256U
-
- /* Flash storage */
-typedef struct FLASH_SECTOR {
-  uint8_t page[PageSize];
-} FLASH_SECTOR_T;
-
-#define PAGE_FILL \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, \
-  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
-
-#define FLASH_INIT_FILL \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL, \
-  PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL,PAGE_FILL
-
-/* This is the FLASH area used to emulate a 2Kbyte EEPROM  -- We need this buffer aligned
-   to a 256 byte boundary. */
-static const uint8_t flashStorage[PagesPerGroup * GroupCount * PageSize] __attribute__ ((aligned (PageSize))) = { FLASH_INIT_FILL };
-
-/* Get the address of an specific page */
-static const FLASH_SECTOR_T* getFlashStorage(int page) {
-  return (const FLASH_SECTOR_T*)&flashStorage[page*PageSize];
-}
-
-static uint8_t buffer[256] = {0},   // The RAM buffer to accumulate writes
-               curPage = 0,         // Current FLASH page inside the group
-               curGroup = 0xFF;     // Current FLASH group
-
-#define DEBUG_OUT ENABLED(EE_EMU_DEBUG)
-#include "../../core/debug_out.h"
-
-static void ee_Dump(const int page, const void *data) {
-
-  #ifdef EE_EMU_DEBUG
-
-    const uint8_t *c = (const uint8_t*) data;
-    char buffer[80];
-
-    sprintf_P(buffer, PSTR("Page: %d (0x%04x)\n"), page, page);
-    DEBUG_ECHO(buffer);
-
-    char* p = &buffer[0];
-    for (int i = 0; i< PageSize; ++i) {
-      if ((i & 0xF) == 0) p += sprintf_P(p, PSTR("%04x] "), i);
-
-      p += sprintf_P(p, PSTR(" %02x"), c[i]);
-      if ((i & 0xF) == 0xF) {
-        *p++ = '\n';
-        *p = 0;
-        DEBUG_ECHO(buffer);
-        p = &buffer[0];
-      }
-    }
-
-  #else
-    UNUSED(page);
-    UNUSED(data);
-  #endif
-}
-
-/* Flash Writing Protection Key */
-#define FWP_KEY    0x5Au
-
-#if SAM4S_SERIES
-  #define EEFC_FCR_FCMD(value) \
-  ((EEFC_FCR_FCMD_Msk & ((value) << EEFC_FCR_FCMD_Pos)))
-  #define EEFC_ERROR_FLAGS  (EEFC_FSR_FLOCKE | EEFC_FSR_FCMDE | EEFC_FSR_FLERR)
-#else
-  #define EEFC_ERROR_FLAGS  (EEFC_FSR_FLOCKE | EEFC_FSR_FCMDE)
-#endif
-
-/**
- * Writes the contents of the specified page (no previous erase)
- * @param page    (page #)
- * @param data    (pointer to the data buffer)
- */
-__attribute__ ((long_call, section (".ramfunc")))
-static bool ee_PageWrite(uint16_t page, const void *data) {
-
-  uint16_t i;
-  uint32_t addrflash = uint32_t(getFlashStorage(page));
-
-  // Read the flash contents
-  uint32_t pageContents[PageSize>>2];
-  memcpy(pageContents, (void*)addrflash, PageSize);
-
-  // We ONLY want to toggle bits that have changed, and that have changed to 0.
-  // SAM3X8E tends to destroy contiguous bits if reprogrammed without erasing, so
-  // we try by all means to avoid this. That is why it says: "The Partial
-  // Programming mode works only with 128-bit (or higher) boundaries. It cannot
-  // be used with boundaries lower than 128 bits (8, 16 or 32-bit for example)."
-  // All bits that did not change, set them to 1.
-  for (i = 0; i <PageSize >> 2; i++)
-    pageContents[i] = (((uint32_t*)data)[i]) | (~(pageContents[i] ^ ((uint32_t*)data)[i]));
-
-  DEBUG_ECHO_MSG("EEPROM PageWrite   ", page);
-  DEBUG_ECHOLNPGM(" in FLASH address ", (uint32_t)addrflash);
-  DEBUG_ECHOLNPGM(" base address     ", (uint32_t)getFlashStorage(0));
-  DEBUG_FLUSH();
-
-  // Get the page relative to the start of the EFC controller, and the EFC controller to use
-  Efc *efc;
-  uint16_t fpage;
-  if (addrflash >= IFLASH1_ADDR) {
-    efc = EFC1;
-    fpage = (addrflash - IFLASH1_ADDR) / IFLASH1_PAGE_SIZE;
-  }
-  else {
-    efc = EFC0;
-    fpage = (addrflash - IFLASH0_ADDR) / IFLASH0_PAGE_SIZE;
-  }
-
-  // Get the page that must be unlocked, then locked
-  uint16_t lpage = fpage & (~((IFLASH0_LOCK_REGION_SIZE / IFLASH0_PAGE_SIZE) - 1));
-
-  // Disable all interrupts
-  __disable_irq();
-
-  // Get the FLASH wait states
-  uint32_t orgWS = (efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos;
-
-  // Set wait states to 6 (SAM errata)
-  efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(6);
-
-  // Unlock the flash page
-  uint32_t status;
-  efc->EEFC_FCR = EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(lpage) | EEFC_FCR_FCMD(EFC_FCMD_CLB);
-  while (((status = efc->EEFC_FSR) & EEFC_FSR_FRDY) != EEFC_FSR_FRDY) {
-    // force compiler to not optimize this -- NOPs don't work!
-    __asm__ __volatile__("");
-  };
-
-  if ((status & EEFC_ERROR_FLAGS) != 0) {
-
-    // Restore original wait states
-    efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-    // Reenable interrupts
-    __enable_irq();
-
-    DEBUG_ECHO_MSG("EEPROM Unlock failure for page ", page);
-    return false;
-  }
-
-  // Write page and lock:  Writing 8-bit and 16-bit data is not allowed and may lead to unpredictable data corruption.
-  const uint32_t * aligned_src = (const uint32_t *) &pageContents[0]; /*data;*/
-  uint32_t * p_aligned_dest = (uint32_t *) addrflash;
-  for (i = 0; i < (IFLASH0_PAGE_SIZE / sizeof(uint32_t)); ++i) {
-    *p_aligned_dest++ = *aligned_src++;
-  }
-  efc->EEFC_FCR = EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(fpage) | EEFC_FCR_FCMD(EFC_FCMD_WPL);
-  while (((status = efc->EEFC_FSR) & EEFC_FSR_FRDY) != EEFC_FSR_FRDY) {
-    // force compiler to not optimize this -- NOPs don't work!
-    __asm__ __volatile__("");
-  };
-
-  if ((status & EEFC_ERROR_FLAGS) != 0) {
-
-    // Restore original wait states
-    efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-    // Reenable interrupts
-    __enable_irq();
-
-    DEBUG_ECHO_MSG("EEPROM Write failure for page ", page);
-
-    return false;
-  }
-
-  // Restore original wait states
-  efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-  // Reenable interrupts
-  __enable_irq();
-
-  // Compare contents
-  if (memcmp(getFlashStorage(page),data,PageSize)) {
-
-    #ifdef EE_EMU_DEBUG
-      DEBUG_ECHO_MSG("EEPROM Verify Write failure for page ", page);
-
-      ee_Dump( page, (uint32_t *)addrflash);
-      ee_Dump(-page, data);
-
-      // Calculate count of changed bits
-      uint32_t *p1 = (uint32_t*)addrflash;
-      uint32_t *p2 = (uint32_t*)data;
-      int count = 0;
-      for (i =0; i<PageSize >> 2; i++) {
-        if (p1[i] != p2[i]) {
-          uint32_t delta = p1[i] ^ p2[i];
-          while (delta) {
-            if ((delta&1) != 0)
-              count++;
-            delta >>= 1;
-          }
-        }
-      }
-      DEBUG_ECHOLNPGM("--> Differing bits: ", count);
-    #endif
-
-    return false;
-  }
-
-  return true;
-}
-
-/**
- * Erases the contents of the specified page
- * @param page    (page #)
-  */
-__attribute__ ((long_call, section (".ramfunc")))
-static bool ee_PageErase(uint16_t page) {
-
-  uint16_t i;
-  uint32_t addrflash = uint32_t(getFlashStorage(page));
-
-  DEBUG_ECHO_MSG("EEPROM PageErase  ", page);
-  DEBUG_ECHOLNPGM(" in FLASH address ", (uint32_t)addrflash);
-  DEBUG_ECHOLNPGM(" base address     ", (uint32_t)getFlashStorage(0));
-  DEBUG_FLUSH();
-
-  // Get the page relative to the start of the EFC controller, and the EFC controller to use
-  Efc *efc;
-  uint16_t fpage;
-  if (addrflash >= IFLASH1_ADDR) {
-    efc = EFC1;
-    fpage = (addrflash - IFLASH1_ADDR) / IFLASH1_PAGE_SIZE;
-  }
-  else {
-    efc = EFC0;
-    fpage = (addrflash - IFLASH0_ADDR) / IFLASH0_PAGE_SIZE;
-  }
-
-  // Get the page that must be unlocked, then locked
-  uint16_t lpage = fpage & (~((IFLASH0_LOCK_REGION_SIZE / IFLASH0_PAGE_SIZE) - 1));
-
-  // Disable all interrupts
-  __disable_irq();
-
-  // Get the FLASH wait states
-  uint32_t orgWS = (efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos;
-
-  // Set wait states to 6 (SAM errata)
-  efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(6);
-
-  // Unlock the flash page
-  uint32_t status;
-  efc->EEFC_FCR = EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(lpage) | EEFC_FCR_FCMD(EFC_FCMD_CLB);
-  while (((status = efc->EEFC_FSR) & EEFC_FSR_FRDY) != EEFC_FSR_FRDY) {
-    // force compiler to not optimize this -- NOPs don't work!
-    __asm__ __volatile__("");
-  };
-  if ((status & EEFC_ERROR_FLAGS) != 0) {
-
-    // Restore original wait states
-    efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-    // Reenable interrupts
-    __enable_irq();
-
-    DEBUG_ECHO_MSG("EEPROM Unlock failure for page ",page);
-
-    return false;
-  }
-
-  // Erase Write page and lock: Writing 8-bit and 16-bit data is not allowed and may lead to unpredictable data corruption.
-  uint32_t * p_aligned_dest = (uint32_t *) addrflash;
-  for (i = 0; i < (IFLASH0_PAGE_SIZE / sizeof(uint32_t)); ++i) {
-    *p_aligned_dest++ = 0xFFFFFFFF;
-  }
-  efc->EEFC_FCR = EEFC_FCR_FKEY(FWP_KEY) | EEFC_FCR_FARG(fpage) | EEFC_FCR_FCMD(EFC_FCMD_EWPL);
-  while (((status = efc->EEFC_FSR) & EEFC_FSR_FRDY) != EEFC_FSR_FRDY) {
-    // force compiler to not optimize this -- NOPs don't work!
-    __asm__ __volatile__("");
-  };
-  if ((status & EEFC_ERROR_FLAGS) != 0) {
-
-    // Restore original wait states
-    efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-    // Reenable interrupts
-    __enable_irq();
-
-    DEBUG_ECHO_MSG("EEPROM Erase failure for page ",page);
-
-    return false;
-  }
-
-  // Restore original wait states
-  efc->EEFC_FMR = (efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(orgWS);
-
-  // Reenable interrupts
-  __enable_irq();
-
-  // Check erase
-  uint32_t * aligned_src = (uint32_t *) addrflash;
-  for (i = 0; i < PageSize >> 2; i++) {
-    if (*aligned_src++ != 0xFFFFFFFF) {
-      DEBUG_ECHO_MSG("EEPROM Verify Erase failure for page ",page);
-      ee_Dump(page, (uint32_t *)addrflash);
-      return false;
-    }
-  }
-
-  return true;
-}
-
-static uint8_t ee_Read(uint32_t address, bool excludeRAMBuffer=false) {
-
-  uint32_t baddr;
-  uint32_t blen;
-
-  // If we were requested an address outside of the emulated range, fail now
-  if (address >= EEPROMSize)
-    return false;
-
-  // Check that the value is not contained in the RAM buffer
-  if (!excludeRAMBuffer) {
-    uint16_t i = 0;
-    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-      // Get the address of the block
-      baddr = buffer[i] | (buffer[i + 1] << 8);
-
-      // Get the length of the block
-      blen = buffer[i + 2];
-
-      // If we reach the end of the list, break loop
-      if (blen == 0xFF)
-        break;
-
-      // Check if data is contained in this block
-      if (address >= baddr &&
-        address < (baddr + blen)) {
-
-        // Yes, it is contained. Return it!
-        return buffer[i + 3 + address - baddr];
-      }
-
-      // As blocks are always sorted, if the starting address of this block is higher
-      // than the address we are looking for, break loop now - We wont find the value
-      // associated to the address
-      if (baddr > address)
-        break;
-
-      // Jump to the next block
-      i += 3 + blen;
-    }
-  }
-
-  // It is NOT on the RAM buffer. It could be stored in FLASH. We are
-  //  ensured on a given FLASH page, address contents are never repeated
-  //  but on different pages, there is no such warranty, so we must go
-  //  backwards from the last written FLASH page to the first one.
-  for (int page = curPage - 1; page >= 0; --page) {
-
-    // Get a pointer to the flash page
-    uint8_t *pflash = (uint8_t*)getFlashStorage(page + curGroup * PagesPerGroup);
-
-    uint16_t i = 0;
-    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-      // Get the address of the block
-      baddr = pflash[i] | (pflash[i + 1] << 8);
-
-      // Get the length of the block
-      blen = pflash[i + 2];
-
-      // If we reach the end of the list, break loop
-      if (blen == 0xFF)
-        break;
-
-      // Check if data is contained in this block
-      if (address >= baddr && address < (baddr + blen))
-        return pflash[i + 3 + address - baddr]; // Yes, it is contained. Return it!
-
-      // As blocks are always sorted, if the starting address of this block is higher
-      // than the address we are looking for, break loop now - We wont find the value
-      // associated to the address
-      if (baddr > address) break;
-
-      // Jump to the next block
-      i += 3 + blen;
-    }
-  }
-
-  // If reached here, value is not stored, so return its default value
-  return 0xFF;
-}
-
-static uint32_t ee_GetAddrRange(uint32_t address, bool excludeRAMBuffer=false) {
-  uint32_t baddr,
-           blen,
-           nextAddr = 0xFFFF,
-           nextRange = 0;
-
-  // Check that the value is not contained in the RAM buffer
-  if (!excludeRAMBuffer) {
-    uint16_t i = 0;
-    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-      // Get the address of the block
-      baddr = buffer[i] | (buffer[i + 1] << 8);
-
-      // Get the length of the block
-      blen = buffer[i + 2];
-
-      // If we reach the end of the list, break loop
-      if (blen == 0xFF) break;
-
-      // Check if address and address + 1 is contained in this block
-      if (address >= baddr && address < (baddr + blen))
-        return address | ((blen - address + baddr) << 16); // Yes, it is contained. Return it!
-
-      // Otherwise, check if we can use it as a limit
-      if (baddr > address && baddr < nextAddr) {
-        nextAddr = baddr;
-        nextRange = blen;
-      }
-
-      // As blocks are always sorted, if the starting address of this block is higher
-      // than the address we are looking for, break loop now - We wont find the value
-      // associated to the address
-      if (baddr > address) break;
-
-      // Jump to the next block
-      i += 3 + blen;
-    }
-  }
-
-  // It is NOT on the RAM buffer. It could be stored in FLASH. We are
-  //  ensured on a given FLASH page, address contents are never repeated
-  //  but on different pages, there is no such warranty, so we must go
-  //  backwards from the last written FLASH page to the first one.
-  for (int page = curPage - 1; page >= 0; --page) {
-
-    // Get a pointer to the flash page
-    uint8_t *pflash = (uint8_t*)getFlashStorage(page + curGroup * PagesPerGroup);
-
-    uint16_t i = 0;
-    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-      // Get the address of the block
-      baddr = pflash[i] | (pflash[i + 1] << 8);
-
-      // Get the length of the block
-      blen = pflash[i + 2];
-
-      // If we reach the end of the list, break loop
-      if (blen == 0xFF) break;
-
-      // Check if data is contained in this block
-      if (address >= baddr && address < (baddr + blen))
-        return address | ((blen - address + baddr) << 16); // Yes, it is contained. Return it!
-
-      // Otherwise, check if we can use it as a limit
-      if (baddr > address && baddr < nextAddr) {
-        nextAddr = baddr;
-        nextRange = blen;
-      }
-
-      // As blocks are always sorted, if the starting address of this block is higher
-      // than the address we are looking for, break loop now - We wont find the value
-      // associated to the address
-      if (baddr > address) break;
-
-      // Jump to the next block
-      i += 3 + blen;
-    }
-  }
-
-  // If reached here, we will return the next valid address
-  return nextAddr | (nextRange << 16);
-}
-
-static bool ee_IsPageClean(int page) {
-  uint32_t *pflash = (uint32_t*) getFlashStorage(page);
-  for (uint16_t i = 0; i < (PageSize >> 2); ++i)
-    if (*pflash++ != 0xFFFFFFFF) return false;
-  return true;
-}
-
-static bool ee_Flush(uint32_t overrideAddress = 0xFFFFFFFF, uint8_t overrideData=0xFF) {
-
-  // Check if RAM buffer has something to be written
-  bool isEmpty = true;
-  uint32_t *p = (uint32_t*) &buffer[0];
-  for (uint16_t j = 0; j < (PageSize >> 2); j++) {
-    if (*p++ != 0xFFFFFFFF) {
-      isEmpty = false;
-      break;
-    }
-  }
-
-  // If something has to be written, do so!
-  if (!isEmpty) {
-
-    // Write the current ram buffer into FLASH
-    ee_PageWrite(curPage + curGroup * PagesPerGroup, buffer);
-
-    // Clear the RAM buffer
-    memset(buffer, 0xFF, sizeof(buffer));
-
-    // Increment the page to use the next time
-    ++curPage;
-  }
-
-  // Did we reach the maximum count of available pages per group for storage ?
-  if (curPage < PagesPerGroup) {
-
-    // Do we have an override address ?
-    if (overrideAddress < EEPROMSize) {
-
-      // Yes, just store the value into the RAM buffer
-      buffer[0] = overrideAddress & 0xFF;
-      buffer[0 + 1] = (overrideAddress >> 8) & 0xFF;
-      buffer[0 + 2] = 1;
-      buffer[0 + 3] = overrideData;
-    }
-
-    // Done!
-    return true;
-  }
-
-  // We have no space left on the current group - We must compact the values
-  uint16_t i = 0;
-
-  // Compute the next group to use
-  int curwPage = 0, curwGroup = curGroup + 1;
-  if (curwGroup >= GroupCount) curwGroup = 0;
-
-  uint32_t rdAddr = 0;
-  do {
-
-    // Get the next valid range
-    uint32_t addrRange = ee_GetAddrRange(rdAddr, true);
-
-    // Make sure not to skip the override address, if specified
-    int rdRange;
-    if (overrideAddress < EEPROMSize &&
-      rdAddr <= overrideAddress &&
-      (addrRange & 0xFFFF) > overrideAddress) {
-
-      rdAddr = overrideAddress;
-      rdRange = 1;
-    }
-    else {
-      rdAddr = addrRange & 0xFFFF;
-      rdRange = addrRange >> 16;
-    }
-
-    // If no range, break loop
-    if (rdRange == 0)
-      break;
-
-    do {
-
-      // Get the value
-      uint8_t rdValue = overrideAddress == rdAddr ? overrideData : ee_Read(rdAddr, true);
-
-      // Do not bother storing default values
-      if (rdValue != 0xFF) {
-
-        // If we have room, add it to the buffer
-        if (buffer[i + 2] == 0xFF) {
-
-          // Uninitialized buffer, just add it!
-          buffer[i] = rdAddr & 0xFF;
-          buffer[i + 1] = (rdAddr >> 8) & 0xFF;
-          buffer[i + 2] = 1;
-          buffer[i + 3] = rdValue;
-
-        }
-        else {
-          // Buffer already has contents. Check if we can extend it
-
-          // Get the address of the block
-          uint32_t baddr = buffer[i] | (buffer[i + 1] << 8);
-
-          // Get the length of the block
-          uint32_t blen = buffer[i + 2];
-
-          // Can we expand it ?
-          if (rdAddr == (baddr + blen) &&
-            i < (PageSize - 4) && /* This block has a chance to contain data AND */
-            buffer[i + 2] < (PageSize - i - 3)) {/* There is room for this block to be expanded */
-
-            // Yes, do it
-            ++buffer[i + 2];
-
-            // And store the value
-            buffer[i + 3 + rdAddr - baddr] = rdValue;
-
-          }
-          else {
-
-            // No, we can't expand it - Skip the existing block
-            i += 3 + blen;
-
-            // Can we create a new slot ?
-            if (i > (PageSize - 4)) {
-
-              // Not enough space - Write the current buffer to FLASH
-              ee_PageWrite(curwPage + curwGroup * PagesPerGroup, buffer);
-
-              // Advance write page (as we are compacting, should never overflow!)
-              ++curwPage;
-
-              // Clear RAM buffer
-              memset(buffer, 0xFF, sizeof(buffer));
-
-              // Start fresh */
-              i = 0;
-            }
-
-            // Enough space, add the new block
-            buffer[i] = rdAddr & 0xFF;
-            buffer[i + 1] = (rdAddr >> 8) & 0xFF;
-            buffer[i + 2] = 1;
-            buffer[i + 3] = rdValue;
-          }
-        }
-      }
-
-      // Go to the next address
-      ++rdAddr;
-
-      // Repeat for bytes of this range
-    } while (--rdRange);
-
-    // Repeat until we run out of ranges
-  } while (rdAddr < EEPROMSize);
-
-  // We must erase the previous group, in preparation for the next swap
-  for (int page = 0; page < curPage; page++) {
-    ee_PageErase(page + curGroup * PagesPerGroup);
-  }
-
-  // Finally, Now the active group is the created new group
-  curGroup = curwGroup;
-  curPage = curwPage;
-
-  // Done!
-  return true;
-}
-
-static bool ee_Write(uint32_t address, uint8_t data) {
-
-  // If we were requested an address outside of the emulated range, fail now
-  if (address >= EEPROMSize) return false;
-
-  // Lets check if we have a block with that data previously defined. Block
-  //  start addresses are always sorted in ascending order
-  uint16_t i = 0;
-  while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-    // Get the address of the block
-    uint32_t baddr = buffer[i] | (buffer[i + 1] << 8);
-
-    // Get the length of the block
-    uint32_t blen = buffer[i + 2];
-
-    // If we reach the end of the list, break loop
-    if (blen == 0xFF)
-      break;
-
-    // Check if data is contained in this block
-    if (address >= baddr &&
-      address < (baddr + blen)) {
-
-      // Yes, it is contained. Just modify it
-      buffer[i + 3 + address - baddr] = data;
-
-      // Done!
-      return true;
-    }
-
-    // Maybe we could add it to the front or to the back
-    // of this block ?
-    if ((address + 1) == baddr || address == (baddr + blen)) {
-
-      // Potentially, it could be done. But we must ensure there is room
-      // so we can expand the block. Lets find how much free space remains
-      uint32_t iend = i;
-      do {
-        uint32_t ln = buffer[iend + 2];
-        if (ln == 0xFF) break;
-        iend += 3 + ln;
-      } while (iend <= (PageSize - 4)); /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-
-      // Here, inxt points to the first free address in the buffer. Do we have room ?
-      if (iend < PageSize) {
-        // Yes, at least a byte is free - We can expand the block
-
-        // Do we have to insert at the beginning ?
-        if ((address + 1) == baddr) {
-
-          // Insert at the beginning
-
-          // Make room at the beginning for our byte
-          memmove(&buffer[i + 3 + 1], &buffer[i + 3], iend - i - 3);
-
-          // Adjust the header and store the data
-          buffer[i] = address & 0xFF;
-          buffer[i + 1] = (address >> 8) & 0xFF;
-          buffer[i + 2]++;
-          buffer[i + 3] = data;
-
-        }
-        else {
-
-          // Insert at the end - There is a very interesting thing that could happen here:
-          //  Maybe we could coalesce the next block with this block. Let's try to do it!
-          uint16_t inext = i + 3 + blen;
-          if (inext <= (PageSize - 4) &&
-            (buffer[inext] | uint16_t(buffer[inext + 1] << 8)) == (baddr + blen + 1)) {
-            // YES! ... we can coalesce blocks! . Do it!
-
-            // Adjust this block header to include the next one
-            buffer[i + 2] += buffer[inext + 2] + 1;
-
-            // Store data at the right place
-            buffer[i + 3 + blen] = data;
-
-            // Remove the next block header and append its data
-            memmove(&buffer[inext + 1], &buffer[inext + 3], iend - inext - 3);
-
-            // Finally, as we have saved 2 bytes at the end, make sure to clean them
-            buffer[iend - 2] = 0xFF;
-            buffer[iend - 1] = 0xFF;
-
-          }
-          else {
-            // NO ... No coalescing possible yet
-
-            // Make room at the end for our byte
-            memmove(&buffer[i + 3 + blen + 1], &buffer[i + 3 + blen], iend - i - 3 - blen);
-
-            // And add the data to the block
-            buffer[i + 2]++;
-            buffer[i + 3 + blen] = data;
-          }
-        }
-
-        // Done!
-        return true;
-      }
-    }
-
-    // As blocks are always sorted, if the starting address of this block is higher
-    // than the address we are looking for, break loop now - We wont find the value
-    // associated to the address
-    if (baddr > address) break;
-
-    // Jump to the next block
-    i += 3 + blen;
-  }
-
-  // Value is not stored AND we can't expand previous block to contain it. We must create a new block
-
-  // First, lets find how much free space remains
-  uint32_t iend = i;
-  while (iend <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */
-    uint32_t ln = buffer[iend + 2];
-    if (ln == 0xFF) break;
-    iend += 3 + ln;
-  }
-
-  // If there is room for a new block, insert it at the proper place
-  if (iend <= (PageSize - 4)) {
-
-    // We have room to create a new block. Do so --- But add
-    // the block at the proper position, sorted by starting
-    // address, so it will be possible to compact it with other blocks.
-
-    // Make space
-    memmove(&buffer[i + 4], &buffer[i], iend - i);
-
-    // And add the block
-    buffer[i] = address & 0xFF;
-    buffer[i + 1] = (address >> 8) & 0xFF;
-    buffer[i + 2] = 1;
-    buffer[i + 3] = data;
-
-    // Done!
-    return true;
-  }
-
-  // Not enough room to store this information on this FLASH page -  Perform a
-  // flush and override the address with the specified contents
-  return ee_Flush(address, data);
-}
-
-static void ee_Init() {
-
-  // Just init once!
-  if (curGroup != 0xFF) return;
-
-  // Clean up the SRAM buffer
-  memset(buffer, 0xFF, sizeof(buffer));
-
-  // Now, we must find out the group where settings are stored
-  for (curGroup = 0; curGroup < GroupCount; curGroup++)
-    if (!ee_IsPageClean(curGroup * PagesPerGroup)) break;
-
-  // If all groups seem to be used, default to first group
-  if (curGroup >= GroupCount) curGroup = 0;
-
-  DEBUG_ECHO_MSG("EEPROM Current Group: ",curGroup);
-  DEBUG_FLUSH();
-
-  // Now, validate that all the other group pages are empty
-  for (int grp = 0; grp < GroupCount; grp++) {
-    if (grp == curGroup) continue;
-
-    for (int page = 0; page < PagesPerGroup; page++) {
-      if (!ee_IsPageClean(grp * PagesPerGroup + page)) {
-        DEBUG_ECHO_MSG("EEPROM Page ", page, " not clean on group ", grp);
-        DEBUG_FLUSH();
-        ee_PageErase(grp * PagesPerGroup + page);
-      }
-    }
-  }
-
-  // Finally, for the active group, determine the first unused page
-  // and also validate that all the other ones are clean
-  for (curPage = 0; curPage < PagesPerGroup; curPage++) {
-    if (ee_IsPageClean(curGroup * PagesPerGroup + curPage)) {
-      ee_Dump(curGroup * PagesPerGroup + curPage, getFlashStorage(curGroup * PagesPerGroup + curPage));
-      break;
-    }
-  }
-
-  DEBUG_ECHO_MSG("EEPROM Active page: ", curPage);
-  DEBUG_FLUSH();
-
-  // Make sure the pages following the first clean one are also clean
-  for (int page = curPage + 1; page < PagesPerGroup; page++) {
-    if (!ee_IsPageClean(curGroup * PagesPerGroup + page)) {
-      DEBUG_ECHO_MSG("EEPROM Page ", page, " not clean on active group ", curGroup);
-      DEBUG_FLUSH();
-      ee_Dump(curGroup * PagesPerGroup + page, getFlashStorage(curGroup * PagesPerGroup + page));
-      ee_PageErase(curGroup * PagesPerGroup + page);
-    }
-  }
-}
-
-/* PersistentStore -----------------------------------------------------------*/
-
-#include "../shared/eeprom_api.h"
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE 0x1000 // 4KB
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-bool PersistentStore::access_start()  { ee_Init();  return true; }
-bool PersistentStore::access_finish() { ee_Flush(); return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != ee_Read(uint32_t(p))) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      ee_Write(uint32_t(p), v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (ee_Read(uint32_t(p)) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = ee_Read(uint32_t(pos));
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // FLASH_EEPROM_EMULATION
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/eeprom_wired.cpp b/Marlin/src/HAL/DUE/eeprom_wired.cpp
deleted file mode 100644
index 557a2f2..0000000
--- a/Marlin/src/HAL/DUE/eeprom_wired.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- * Copyright (c) 2016 Victor Perez victor_pv@hotmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-/**
- * PersistentStore for Arduino-style EEPROM interface
- * with simple implementations supplied by Marlin.
- */
-
-#include "../shared/eeprom_if.h"
-#include "../shared/eeprom_api.h"
-
-#ifndef MARLIN_EEPROM_SIZE
-  #error "MARLIN_EEPROM_SIZE is required for I2C / SPI EEPROM."
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-bool PersistentStore::access_start()  { eeprom_init(); return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/endstop_interrupts.h b/Marlin/src/HAL/DUE/endstop_interrupts.h
deleted file mode 100644
index c1bbcb1..0000000
--- a/Marlin/src/HAL/DUE/endstop_interrupts.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-/**
- *  Endstop interrupts for Due based targets.
- *  On Due, all pins support external interrupt capability.
- */
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  TERN_(HAS_X_MAX, _ATTACH(X_MAX_PIN));
-  TERN_(HAS_X_MIN, _ATTACH(X_MIN_PIN));
-  TERN_(HAS_Y_MAX, _ATTACH(Y_MAX_PIN));
-  TERN_(HAS_Y_MIN, _ATTACH(Y_MIN_PIN));
-  TERN_(HAS_Z_MAX, _ATTACH(Z_MAX_PIN));
-  TERN_(HAS_Z_MIN, _ATTACH(Z_MIN_PIN));
-  TERN_(HAS_X2_MAX, _ATTACH(X2_MAX_PIN));
-  TERN_(HAS_X2_MIN, _ATTACH(X2_MIN_PIN));
-  TERN_(HAS_Y2_MAX, _ATTACH(Y2_MAX_PIN));
-  TERN_(HAS_Y2_MIN, _ATTACH(Y2_MIN_PIN));
-  TERN_(HAS_Z2_MAX, _ATTACH(Z2_MAX_PIN));
-  TERN_(HAS_Z2_MIN, _ATTACH(Z2_MIN_PIN));
-  TERN_(HAS_Z3_MAX, _ATTACH(Z3_MAX_PIN));
-  TERN_(HAS_Z3_MIN, _ATTACH(Z3_MIN_PIN));
-  TERN_(HAS_Z4_MAX, _ATTACH(Z4_MAX_PIN));
-  TERN_(HAS_Z4_MIN, _ATTACH(Z4_MIN_PIN));
-  TERN_(HAS_Z_MIN_PROBE_PIN, _ATTACH(Z_MIN_PROBE_PIN));
-  TERN_(HAS_I_MAX, _ATTACH(I_MAX_PIN));
-  TERN_(HAS_I_MIN, _ATTACH(I_MIN_PIN));
-  TERN_(HAS_J_MAX, _ATTACH(J_MAX_PIN));
-  TERN_(HAS_J_MIN, _ATTACH(J_MIN_PIN));
-  TERN_(HAS_K_MAX, _ATTACH(K_MAX_PIN));
-  TERN_(HAS_K_MIN, _ATTACH(K_MIN_PIN));
-  TERN_(HAS_U_MAX, _ATTACH(U_MAX_PIN));
-  TERN_(HAS_U_MIN, _ATTACH(U_MIN_PIN));
-  TERN_(HAS_V_MAX, _ATTACH(V_MAX_PIN));
-  TERN_(HAS_V_MIN, _ATTACH(V_MIN_PIN));
-  TERN_(HAS_W_MAX, _ATTACH(W_MAX_PIN));
-  TERN_(HAS_W_MIN, _ATTACH(W_MIN_PIN));
-}
diff --git a/Marlin/src/HAL/DUE/fastio.h b/Marlin/src/HAL/DUE/fastio.h
deleted file mode 100644
index a609210..0000000
--- a/Marlin/src/HAL/DUE/fastio.h
+++ /dev/null
@@ -1,565 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for SAM3X8E
- * Use direct port manipulation to save scads of processor time.
- * Contributed by Triffid_Hunter and modified by Kliment, thinkyhead, Bob-the-Kuhn, et.al.
- */
-
-/**
- * Description: Fast IO functions for Arduino Due and compatible (SAM3X8E)
- *
- * For ARDUINO_ARCH_SAM
- * Note the code here was specifically crafted by disassembling what GCC produces
- * out of it, so GCC is able to optimize it out as much as possible to the least
- * amount of instructions. Be very careful if you modify them, as "clean code"
- * leads to less efficient compiled code!!
- */
-
-#include <pins_arduino.h>
-
-#include "../../inc/MarlinConfigPre.h"
-
-/**
- * Utility functions
- */
-
-// Due has 12 PWMs assigned to logical pins 2-13.
-// 6, 7, 8 & 9 come from the PWM controller. The others come from the timers.
-#define PWM_PIN(P)              WITHIN(P, 2, 13)
-
-#ifndef MASK
-  #define MASK(PIN) _BV(PIN)
-#endif
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(STEP); WRITE(STEP, HIGH); WRITE(STEP, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/cpp/Stringification.html
- */
-
-// Read a pin
-#define _READ(IO) bool(DIO ## IO ## _WPORT -> PIO_PDSR & MASK(DIO ## IO ## _PIN))
-
-// Write to a pin
-#define _WRITE(IO,V) do { \
-  volatile Pio* port = (DIO ##  IO ## _WPORT); \
-  const uint32_t mask = MASK(DIO ## IO ## _PIN); \
-  if (V) port->PIO_SODR = mask; \
-  else port->PIO_CODR = mask; \
-}while(0)
-
-// Toggle a pin
-#define _TOGGLE(IO) _WRITE(IO, !READ(IO))
-
-#if MB(PRINTRBOARD_G2)
-
-  #include "fastio/G2_pins.h"
-
-  // Set pin as input
-  #define _SET_INPUT(IO) do{ \
-    pmc_enable_periph_clk(G2_g_APinDescription[IO].ulPeripheralId); \
-    PIO_Configure((DIO ## IO ## _WPORT), PIO_INPUT, MASK(DIO ## IO ## _PIN), 0); \
-  }while(0)
-
-  // Set pin as output
-  #define _SET_OUTPUT(IO) do{ \
-    uint32_t mask = MASK(G2_g_APinDescription[IO].ulPeripheralId); \
-    if ((PMC->PMC_PCSR0 & mask) != (mask)) PMC->PMC_PCER0 = mask; \
-    volatile Pio* port = (DIO ## IO ## _WPORT); \
-    mask = MASK(DIO ## IO ## _PIN); \
-    if (_READ(IO)) port->PIO_SODR = mask; \
-    else port->PIO_CODR = mask; \
-    port->PIO_IDR = mask; \
-    const uint32_t pin_config = G2_g_APinDescription[IO].ulPinConfiguration; \
-    if (pin_config & PIO_PULLUP) port->PIO_PUER = mask; \
-    else port->PIO_PUDR = mask; \
-    if (pin_config & PIO_OPENDRAIN) port->PIO_MDER = mask; \
-    else port->PIO_MDDR = mask; \
-    port->PIO_PER = mask; \
-    port->PIO_OER = mask; \
-    g_pinStatus[IO] = (g_pinStatus[IO] & 0xF0) | PIN_STATUS_DIGITAL_OUTPUT; \
-  }while(0)
-
- /**
-  *  Set pin as output with comments
-  *  #define _SET_OUTPUT(IO) do{ \
-  *    uint32_t mask = MASK(G2_g_APinDescription[IO].ulPeripheralId); \
-  *    if ((PMC->PMC_PCSR0 & mask ) != (mask))  PMC->PMC_PCER0 = mask; \  // enable PIO clock if not already enabled
-  *
-  *    volatile Pio* port = (DIO ##  IO ## _WPORT); \
-  *    const uint32_t mask = MASK(DIO ## IO ## _PIN); \
-  *    if (_READ(IO)) port->PIO_SODR = mask; \ // set output to match input BEFORE setting direction or will glitch the output
-  *    else port->PIO_CODR = mask; \
-  *
-  *    port->PIO_IDR = mask; \ // disable interrupt
-  *
-  *    uint32_t pin_config = G2_g_APinDescription[IO].ulPinConfiguration; \
-  *    if (pin_config & PIO_PULLUP) pPio->PIO_PUER = mask; \  // enable pullup if necessary
-  *    else  pPio->PIO_PUDR = mask; \
-  *
-  *    if (pin_config & PIO_OPENDRAIN) port->PIO_MDER = mask; \ // Enable multi-drive if necessary
-  *    else  port->PIO_MDDR = mask; \
-  *
-  *    port->PIO_PER = mask; \
-  *    port->PIO_OER = mask; \  // set to output
-  *
-  *    g_pinStatus[IO] = (g_pinStatus[IO] & 0xF0) | PIN_STATUS_DIGITAL_OUTPUT; \
-  *  }while(0)
-  */
-
-#else
-
-    // Set pin as input
-  #define _SET_INPUT(IO) do{ \
-    pmc_enable_periph_clk(g_APinDescription[IO].ulPeripheralId); \
-    PIO_Configure(digitalPinToPort(IO), PIO_INPUT, digitalPinToBitMask(IO), 0); \
-  }while(0)
-
-  // Set pin as output
-  #define _SET_OUTPUT(IO) do{ \
-    pmc_enable_periph_clk(g_APinDescription[IO].ulPeripheralId); \
-    PIO_Configure(digitalPinToPort(IO), _READ(IO) ? PIO_OUTPUT_1 : PIO_OUTPUT_0, digitalPinToBitMask(IO), g_APinDescription[IO].ulPinConfiguration); \
-    g_pinStatus[IO] = (g_pinStatus[IO] & 0xF0) | PIN_STATUS_DIGITAL_OUTPUT; \
-  }while(0)
-#endif
-
-// Set pin as input with pullup mode
-#define _PULLUP(IO,V)        pinMode(IO, (V) ? INPUT_PULLUP : INPUT)
-
-// Read a pin (wrapper)
-#define READ(IO)             _READ(IO)
-
-// Write to a pin (wrapper)
-#define WRITE(IO,V)          _WRITE(IO,V)
-
-// Toggle a pin (wrapper)
-#define TOGGLE(IO)           _TOGGLE(IO)
-
-// Set pin as input (wrapper)
-#define SET_INPUT(IO)        _SET_INPUT(IO)
-// Set pin as input with pullup (wrapper)
-#define SET_INPUT_PULLUP(IO) do{ _SET_INPUT(IO); _PULLUP(IO, HIGH); }while(0)
-// Set pin as input with pulldown (substitution)
-#define SET_INPUT_PULLDOWN   SET_INPUT
-
-// Set pin as output (wrapper) -  reads the pin and sets the output to that value
-#define SET_OUTPUT(IO)       _SET_OUTPUT(IO)
-// Set pin as PWM
-#define SET_PWM               SET_OUTPUT
-
-// Check if pin is an input
-#define IS_INPUT(IO)         ((digitalPinToPort(IO)->PIO_OSR & digitalPinToBitMask(IO)) == 0)
-// Check if pin is an output
-#define IS_OUTPUT(IO)        ((digitalPinToPort(IO)->PIO_OSR & digitalPinToBitMask(IO)) != 0)
-
-// Shorthand
-#define OUT_WRITE(IO,V)      do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
-
-/**
- * Ports and functions
- * Added as necessary or if I feel like it- not a comprehensive list!
- */
-
-// UART
-#define RXD        DIO0
-#define TXD        DIO1
-
-// TWI (I2C)
-#define SCL        DIO21
-#define SDA        DIO20
-
-/**
- * pins
- */
-
-#define DIO0_PIN 8
-#define DIO0_WPORT PIOA
-
-#define DIO1_PIN 9
-#define DIO1_WPORT PIOA
-
-#define DIO2_PIN 25
-#define DIO2_WPORT PIOB
-
-#define DIO3_PIN 28
-#define DIO3_WPORT PIOC
-
-#define DIO4_PIN 26
-#define DIO4_WPORT PIOC
-
-#define DIO5_PIN 25
-#define DIO5_WPORT PIOC
-
-#define DIO6_PIN 24
-#define DIO6_WPORT PIOC
-
-#define DIO7_PIN 23
-#define DIO7_WPORT PIOC
-
-#define DIO8_PIN 22
-#define DIO8_WPORT PIOC
-
-#define DIO9_PIN 21
-#define DIO9_WPORT PIOC
-
-#define DIO10_PIN 29
-#define DIO10_WPORT PIOC
-
-#define DIO11_PIN 7
-#define DIO11_WPORT PIOD
-
-#define DIO12_PIN 8
-#define DIO12_WPORT PIOD
-
-#define DIO13_PIN 27
-#define DIO13_WPORT PIOB
-
-#define DIO14_PIN 4
-#define DIO14_WPORT PIOD
-
-#define DIO15_PIN 5
-#define DIO15_WPORT PIOD
-
-#define DIO16_PIN 13
-#define DIO16_WPORT PIOA
-
-#define DIO17_PIN 12
-#define DIO17_WPORT PIOA
-
-#define DIO18_PIN 11
-#define DIO18_WPORT PIOA
-
-#define DIO19_PIN 10
-#define DIO19_WPORT PIOA
-
-#define DIO20_PIN 12
-#define DIO20_WPORT PIOB
-
-#define DIO21_PIN 13
-#define DIO21_WPORT PIOB
-
-#define DIO22_PIN 26
-#define DIO22_WPORT PIOB
-
-#define DIO23_PIN 14
-#define DIO23_WPORT PIOA
-
-#define DIO24_PIN 15
-#define DIO24_WPORT PIOA
-
-#define DIO25_PIN 0
-#define DIO25_WPORT PIOD
-
-#define DIO26_PIN 1
-#define DIO26_WPORT PIOD
-
-#define DIO27_PIN 2
-#define DIO27_WPORT PIOD
-
-#define DIO28_PIN 3
-#define DIO28_WPORT PIOD
-
-#define DIO29_PIN 6
-#define DIO29_WPORT PIOD
-
-#define DIO30_PIN 9
-#define DIO30_WPORT PIOD
-
-#define DIO31_PIN 7
-#define DIO31_WPORT PIOA
-
-#define DIO32_PIN 10
-#define DIO32_WPORT PIOD
-
-#define DIO33_PIN 1
-#define DIO33_WPORT PIOC
-
-#if !MB(PRINTRBOARD_G2)    // normal DUE pin mapping
-
-  #define DIO34_PIN 2
-  #define DIO34_WPORT PIOC
-
-  #define DIO35_PIN 3
-  #define DIO35_WPORT PIOC
-
-  #define DIO36_PIN 4
-  #define DIO36_WPORT PIOC
-
-  #define DIO37_PIN 5
-  #define DIO37_WPORT PIOC
-
-  #define DIO38_PIN 6
-  #define DIO38_WPORT PIOC
-
-  #define DIO39_PIN 7
-  #define DIO39_WPORT PIOC
-
-  #define DIO40_PIN 8
-  #define DIO40_WPORT PIOC
-
-  #define DIO41_PIN 9
-  #define DIO41_WPORT PIOC
-
-#endif // !PRINTRBOARD_G2
-
-#define DIO42_PIN 19
-#define DIO42_WPORT PIOA
-
-#define DIO43_PIN 20
-#define DIO43_WPORT PIOA
-
-#define DIO44_PIN 19
-#define DIO44_WPORT PIOC
-
-#define DIO45_PIN 18
-#define DIO45_WPORT PIOC
-
-#define DIO46_PIN 17
-#define DIO46_WPORT PIOC
-
-#define DIO47_PIN 16
-#define DIO47_WPORT PIOC
-
-#define DIO48_PIN 15
-#define DIO48_WPORT PIOC
-
-#define DIO49_PIN 14
-#define DIO49_WPORT PIOC
-
-#define DIO50_PIN 13
-#define DIO50_WPORT PIOC
-
-#define DIO51_PIN 12
-#define DIO51_WPORT PIOC
-
-#define DIO52_PIN 21
-#define DIO52_WPORT PIOB
-
-#define DIO53_PIN 14
-#define DIO53_WPORT PIOB
-
-#define DIO54_PIN 16
-#define DIO54_WPORT PIOA
-
-#define DIO55_PIN 24
-#define DIO55_WPORT PIOA
-
-#define DIO56_PIN 23
-#define DIO56_WPORT PIOA
-
-#define DIO57_PIN 22
-#define DIO57_WPORT PIOA
-
-#define DIO58_PIN 6
-#define DIO58_WPORT PIOA
-
-#define DIO59_PIN 4
-#define DIO59_WPORT PIOA
-
-#define DIO60_PIN 3
-#define DIO60_WPORT PIOA
-
-#define DIO61_PIN 2
-#define DIO61_WPORT PIOA
-
-#define DIO62_PIN 17
-#define DIO62_WPORT PIOB
-
-#define DIO63_PIN 18
-#define DIO63_WPORT PIOB
-
-#define DIO64_PIN 19
-#define DIO64_WPORT PIOB
-
-#define DIO65_PIN 20
-#define DIO65_WPORT PIOB
-
-#define DIO66_PIN 15
-#define DIO66_WPORT PIOB
-
-#define DIO67_PIN 16
-#define DIO67_WPORT PIOB
-
-#define DIO68_PIN 1
-#define DIO68_WPORT PIOA
-
-#define DIO69_PIN 0
-#define DIO69_WPORT PIOA
-
-#define DIO70_PIN 17
-#define DIO70_WPORT PIOA
-
-#define DIO71_PIN 18
-#define DIO71_WPORT PIOA
-
-#define DIO72_PIN 30
-#define DIO72_WPORT PIOC
-
-#define DIO73_PIN 21
-#define DIO73_WPORT PIOA
-
-#define DIO74_PIN 25
-#define DIO74_WPORT PIOA
-
-#define DIO75_PIN 26
-#define DIO75_WPORT PIOA
-
-#define DIO76_PIN 27
-#define DIO76_WPORT PIOA
-
-#define DIO77_PIN 28
-#define DIO77_WPORT PIOA
-
-#define DIO78_PIN 23
-#define DIO78_WPORT PIOB
-
-#define DIO79_PIN 17
-#define DIO79_WPORT PIOA
-
-#define DIO80_PIN 12
-#define DIO80_WPORT PIOB
-
-#define DIO81_PIN 8
-#define DIO81_WPORT PIOA
-
-#define DIO82_PIN 11
-#define DIO82_WPORT PIOA
-
-#define DIO83_PIN 13
-#define DIO83_WPORT PIOA
-
-#define DIO84_PIN 4
-#define DIO84_WPORT PIOD
-
-#define DIO85_PIN 11
-#define DIO85_WPORT PIOB
-
-#define DIO86_PIN 21
-#define DIO86_WPORT PIOB
-
-#define DIO87_PIN 29
-#define DIO87_WPORT PIOA
-
-#define DIO88_PIN 15
-#define DIO88_WPORT PIOB
-
-#define DIO89_PIN 14
-#define DIO89_WPORT PIOB
-
-#define DIO90_PIN 1
-#define DIO90_WPORT PIOA
-
-#define DIO91_PIN 15
-#define DIO91_WPORT PIOB
-
-#ifdef ARDUINO_SAM_ARCHIM
-
-  #define DIO92_PIN 11
-  #define DIO92_WPORT PIOC
-
-  #define DIO93_PIN 2
-  #define DIO93_WPORT PIOB
-
-  #define DIO94_PIN 1
-  #define DIO94_WPORT PIOB
-
-  #define DIO95_PIN 0
-  #define DIO95_WPORT PIOB
-
-  #define DIO96_PIN 10
-  #define DIO96_WPORT PIOC
-
-  #define DIO97_PIN 24
-  #define DIO97_WPORT PIOB
-
-  #define DIO98_PIN 7
-  #define DIO98_WPORT PIOB
-
-  #define DIO99_PIN 6
-  #define DIO99_WPORT PIOB
-
-  #define DIO100_PIN 8
-  #define DIO100_WPORT PIOB
-
-  #define DIO101_PIN 5
-  #define DIO101_WPORT PIOB
-
-  #define DIO102_PIN 4
-  #define DIO102_WPORT PIOB
-
-  #define DIO103_PIN 3
-  #define DIO103_WPORT PIOB
-
-  #define DIO104_PIN 20
-  #define DIO104_WPORT PIOC
-
-  #define DIO105_PIN 22
-  #define DIO105_WPORT PIOB
-
-  #define DIO106_PIN 27
-  #define DIO106_WPORT PIOC
-
-  #define DIO107_PIN 10
-  #define DIO107_WPORT PIOB
-
-  #define DIO108_PIN 9
-  #define DIO108_WPORT PIOB
-
-#else // !ARDUINO_SAM_ARCHIM
-
-  #define DIO92_PIN 5
-  #define DIO92_WPORT PIOA
-
-  #define DIO93_PIN 12
-  #define DIO93_WPORT PIOB
-
-  #define DIO94_PIN 22
-  #define DIO94_WPORT PIOB
-
-  #define DIO95_PIN 23
-  #define DIO95_WPORT PIOB
-
-  #define DIO96_PIN 24
-  #define DIO96_WPORT PIOB
-
-  #define DIO97_PIN 20
-  #define DIO97_WPORT PIOC
-
-  #define DIO98_PIN 27
-  #define DIO98_WPORT PIOC
-
-  #define DIO99_PIN 10
-  #define DIO99_WPORT PIOC
-
-  #define DIO100_PIN 11
-  #define DIO100_WPORT PIOC
-
-#endif // !ARDUINO_SAM_ARCHIM
diff --git a/Marlin/src/HAL/DUE/fastio/G2_PWM.cpp b/Marlin/src/HAL/DUE/fastio/G2_PWM.cpp
deleted file mode 100644
index 800915f..0000000
--- a/Marlin/src/HAL/DUE/fastio/G2_PWM.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * The PWM module is only used to generate interrupts at specified times. It
- * is NOT used to directly toggle pins. The ISR writes to the pin assigned to
- * that interrupt.
- *
- * All PWMs use the same repetition rate.  The G2 needs about 10kHz min in order to
- * not have obvious ripple on the Vref signals.
- *
- * The data structures are setup to minimize the computation done by the ISR which
- * minimizes ISR execution time.  Execution times are 0.8 to 1.1 microseconds.
- *
- * FIve PWM interrupt sources are used.  Channel 0 sets the base period.  All Vref
- * signals are set active when this counter overflows and resets to zero.  The compare
- * values in channels 1-4 are set to give the desired duty cycle for that Vref pin.
- * When counter 0 matches the compare value then that channel generates an interrupt.
- * The ISR checks the source of the interrupt and sets the corresponding pin inactive.
- *
- * Some jitter in the Vref signal is OK so the interrupt priority is left at its default value.
- */
-
-#include "../../../inc/MarlinConfig.h"
-
-#if MB(PRINTRBOARD_G2)
-
-#include "G2_PWM.h"
-
-#if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-  #define G2_PWM_X 1
-#else
-  #define G2_PWM_X 0
-#endif
-#if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-  #define G2_PWM_Y 1
-#else
-  #define G2_PWM_Y 0
-#endif
-#if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-  #define G2_PWM_Z 1
-#else
-  #define G2_PWM_Z 0
-#endif
-#if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-  #define G2_PWM_E 1
-#else
-  #define G2_PWM_E 0
-#endif
-#define G2_MASK_X(V) (G2_PWM_X * (V))
-#define G2_MASK_Y(V) (G2_PWM_Y * (V))
-#define G2_MASK_Z(V) (G2_PWM_Z * (V))
-#define G2_MASK_E(V) (G2_PWM_E * (V))
-
-volatile uint32_t *SODR_A = &PIOA->PIO_SODR,
-                  *SODR_B = &PIOB->PIO_SODR,
-                  *CODR_A = &PIOA->PIO_CODR,
-                  *CODR_B = &PIOB->PIO_CODR;
-
-PWM_map ISR_table[NUM_PWMS] = PWM_MAP_INIT;
-
-void Stepper::digipot_init() {
-
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-    OUT_WRITE(MOTOR_CURRENT_PWM_X_PIN, 0);  // init pins
-  #endif
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-    OUT_WRITE(MOTOR_CURRENT_PWM_Y_PIN, 0);
-  #endif
-  #if G2_PWM_Z
-    OUT_WRITE(MOTOR_CURRENT_PWM_Z_PIN, 0);
-  #endif
-  #if G2_PWM_E
-    OUT_WRITE(MOTOR_CURRENT_PWM_E_PIN, 0);
-  #endif
-
-  #define WPKEY          (0x50574D << 8) // â€œPWMâ€ in ASCII
-  #define WPCMD_DIS_SW   0  // command to disable Write Protect SW
-  #define WPRG_ALL       (PWM_WPCR_WPRG0 | PWM_WPCR_WPRG1 | PWM_WPCR_WPRG2 | PWM_WPCR_WPRG3 | PWM_WPCR_WPRG4 | PWM_WPCR_WPRG5)  // all Write Protect Groups
-
-  #define PWM_CLOCK_F    F_CPU / 1000000UL   // set clock to 1MHz
-
-  PMC->PMC_PCER1 = PMC_PCER1_PID36;                       // enable PWM controller clock (disabled on power up)
-
-  PWM->PWM_WPCR = WPKEY | WPRG_ALL | WPCMD_DIS_SW;        // enable setting of all PWM registers
-  PWM->PWM_CLK = PWM_CLOCK_F;                             // enable CLK_A and set it to 1MHz, leave CLK_B disabled
-  PWM->PWM_CH_NUM[0].PWM_CMR = 0b1011;                    // set channel 0 to Clock A input & to left aligned
-  if (G2_PWM_X) PWM->PWM_CH_NUM[1].PWM_CMR = 0b1011;      // set channel 1 to Clock A input & to left aligned
-  if (G2_PWM_Y) PWM->PWM_CH_NUM[2].PWM_CMR = 0b1011;      // set channel 2 to Clock A input & to left aligned
-  if (G2_PWM_Z) PWM->PWM_CH_NUM[3].PWM_CMR = 0b1011;      // set channel 3 to Clock A input & to left aligned
-  if (G2_PWM_E) PWM->PWM_CH_NUM[4].PWM_CMR = 0b1011;      // set channel 4 to Clock A input & to left aligned
-
-  PWM->PWM_CH_NUM[0].PWM_CPRD = PWM_PERIOD_US;            // set channel 0 Period
-
-  PWM->PWM_IER2 = PWM_IER1_CHID0;                         // generate interrupt when counter0 overflows
-  PWM->PWM_IER2 = PWM_IER2_CMPM0
-    | G2_MASK_X(PWM_IER2_CMPM1)
-    | G2_MASK_Y(PWM_IER2_CMPM2)
-    | G2_MASK_Z(PWM_IER2_CMPM3)
-    | G2_MASK_E(PWM_IER2_CMPM4)
-  ; // generate interrupt on compare event
-
-  if (G2_PWM_X) PWM->PWM_CMP[1].PWM_CMPV = 0x010000000LL | G2_VREF_COUNT(G2_VREF(motor_current_setting[0])); // interrupt when counter0 == CMPV - used to set Motor 1 PWM inactive
-  if (G2_PWM_Y) PWM->PWM_CMP[2].PWM_CMPV = 0x010000000LL | G2_VREF_COUNT(G2_VREF(motor_current_setting[0])); // interrupt when counter0 == CMPV - used to set Motor 2 PWM inactive
-  if (G2_PWM_Z) PWM->PWM_CMP[3].PWM_CMPV = 0x010000000LL | G2_VREF_COUNT(G2_VREF(motor_current_setting[1])); // interrupt when counter0 == CMPV - used to set Motor 3 PWM inactive
-  if (G2_PWM_E) PWM->PWM_CMP[4].PWM_CMPV = 0x010000000LL | G2_VREF_COUNT(G2_VREF(motor_current_setting[2])); // interrupt when counter0 == CMPV - used to set Motor 4 PWM inactive
-
-  if (G2_PWM_X) PWM->PWM_CMP[1].PWM_CMPM = 0x0001;  // enable compare event
-  if (G2_PWM_Y) PWM->PWM_CMP[2].PWM_CMPM = 0x0001;  // enable compare event
-  if (G2_PWM_Z) PWM->PWM_CMP[3].PWM_CMPM = 0x0001;  // enable compare event
-  if (G2_PWM_E) PWM->PWM_CMP[4].PWM_CMPM = 0x0001;  // enable compare event
-
-  PWM->PWM_SCM = PWM_SCM_UPDM_MODE0 | PWM_SCM_SYNC0
-    | G2_MASK_X(PWM_SCM_SYNC1)
-    | G2_MASK_Y(PWM_SCM_SYNC2)
-    | G2_MASK_Z(PWM_SCM_SYNC3)
-    | G2_MASK_E(PWM_SCM_SYNC4)
-  ; // sync 1-4 with 0, use mode 0 for updates
-
-  PWM->PWM_ENA = PWM_ENA_CHID0
-    | G2_MASK_X(PWM_ENA_CHID1)
-    | G2_MASK_Y(PWM_ENA_CHID2)
-    | G2_MASK_Z(PWM_ENA_CHID3)
-    | G2_MASK_E(PWM_ENA_CHID4)
-  ; // enable channels used by G2
-
-  PWM->PWM_IER1 = PWM_IER1_CHID0
-    | G2_MASK_X(PWM_IER1_CHID1)
-    | G2_MASK_Y(PWM_IER1_CHID2)
-    | G2_MASK_Z(PWM_IER1_CHID3)
-    | G2_MASK_E(PWM_IER1_CHID4)
-  ; // enable interrupts for channels used by G2
-
-  NVIC_EnableIRQ(PWM_IRQn);     // Enable interrupt handler
-  NVIC_SetPriority(PWM_IRQn, NVIC_EncodePriority(0, 10, 0));  // normal priority for PWM module (can stand some jitter on the Vref signals)
-}
-
-void Stepper::set_digipot_current(const uint8_t driver, const int16_t current) {
-
-  if (!(PWM->PWM_CH_NUM[0].PWM_CPRD == PWM_PERIOD_US)) digipot_init();  // Init PWM system if needed
-
-  switch (driver) {
-    case 0:
-      if (G2_PWM_X) PWM->PWM_CMP[1].PWM_CMPVUPD = 0x010000000LL | G2_VREF_COUNT(G2_VREF(current));    // update X & Y
-      if (G2_PWM_Y) PWM->PWM_CMP[2].PWM_CMPVUPD = 0x010000000LL | G2_VREF_COUNT(G2_VREF(current));
-      if (G2_PWM_X) PWM->PWM_CMP[1].PWM_CMPMUPD = 0x0001;  // enable compare event
-      if (G2_PWM_Y) PWM->PWM_CMP[2].PWM_CMPMUPD = 0x0001;  // enable compare event
-      if (G2_PWM_X || G2_PWM_Y) PWM->PWM_SCUC = PWM_SCUC_UPDULOCK; // tell the PWM controller to update the values on the next cycle
-      break;
-    case 1:
-      if (G2_PWM_Z) {
-        PWM->PWM_CMP[3].PWM_CMPVUPD = 0x010000000LL | G2_VREF_COUNT(G2_VREF(current));    // update Z
-        PWM->PWM_CMP[3].PWM_CMPMUPD = 0x0001;  // enable compare event
-        PWM->PWM_SCUC = PWM_SCUC_UPDULOCK; // tell the PWM controller to update the values on the next cycle
-      }
-      break;
-    default:
-      if (G2_PWM_E) {
-        PWM->PWM_CMP[4].PWM_CMPVUPD = 0x010000000LL | G2_VREF_COUNT(G2_VREF(current));    // update E
-        PWM->PWM_CMP[4].PWM_CMPMUPD = 0x0001;  // enable compare event
-        PWM->PWM_SCUC = PWM_SCUC_UPDULOCK; // tell the PWM controller to update the values on the next cycle
-      }
-      break;
-  }
-}
-
-volatile uint32_t PWM_ISR1_STATUS, PWM_ISR2_STATUS;
-
-void PWM_Handler() {
-  PWM_ISR1_STATUS = PWM->PWM_ISR1;
-  PWM_ISR2_STATUS = PWM->PWM_ISR2;
-  if (PWM_ISR1_STATUS & PWM_IER1_CHID0) {                                                         // CHAN_0 interrupt
-    if (G2_PWM_X) *ISR_table[0].set_register = ISR_table[0].write_mask;                           // set X to active
-    if (G2_PWM_Y) *ISR_table[1].set_register = ISR_table[1].write_mask;                           // set Y to active
-    if (G2_PWM_Z) *ISR_table[2].set_register = ISR_table[2].write_mask;                           // set Z to active
-    if (G2_PWM_E) *ISR_table[3].set_register = ISR_table[3].write_mask;                           // set E to active
-  }
-  else {
-    if (G2_PWM_X && (PWM_ISR2_STATUS & PWM_IER2_CMPM1)) *ISR_table[0].clr_register = ISR_table[0].write_mask; // set X to inactive
-    if (G2_PWM_Y && (PWM_ISR2_STATUS & PWM_IER2_CMPM2)) *ISR_table[1].clr_register = ISR_table[1].write_mask; // set Y to inactive
-    if (G2_PWM_Z && (PWM_ISR2_STATUS & PWM_IER2_CMPM3)) *ISR_table[2].clr_register = ISR_table[2].write_mask; // set Z to inactive
-    if (G2_PWM_E && (PWM_ISR2_STATUS & PWM_IER2_CMPM4)) *ISR_table[3].clr_register = ISR_table[3].write_mask; // set E to inactive
-  }
-  return;
-}
-
-#endif // PRINTRBOARD_G2
diff --git a/Marlin/src/HAL/DUE/fastio/G2_PWM.h b/Marlin/src/HAL/DUE/fastio/G2_PWM.h
deleted file mode 100644
index dc4edff..0000000
--- a/Marlin/src/HAL/DUE/fastio/G2_PWM.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * This module is stripped down version of the LPC1768_PWM.h file from
- * PR #7500. It is hardwired for the PRINTRBOARD_G2 Motor Current needs.
- */
-
-#include "../../../inc/MarlinConfigPre.h"
-#include "../../../module/stepper.h"
-//C:\Users\bobku\Documents\GitHub\Marlin-Bob-2\Marlin\src\module\stepper.h
-//C:\Users\bobku\Documents\GitHub\Marlin-Bob-2\Marlin\src\HAL\HAL_DUE\G2_PWM.h
-
-#define PWM_PERIOD_US  100  // base repetition rate in micro seconds
-
-typedef struct {       // holds the data needed by the ISR to control the Vref pin
-  volatile uint32_t* set_register;
-  volatile uint32_t* clr_register;
-  uint32_t write_mask;
-} PWM_map;
-
-#define G2_VREF(I) (uint32_t)(I * 5 * 0.15)   // desired Vref * 1000 (scaled so don't loose accuracy in next step)
-
-#define G2_VREF_COUNT(Q) (uint32_t)map(constrain(Q, 500, 3.3 * 1000), 0, 3.3 * 1000, 0, PWM_PERIOD_US)  // under 500  the results are very non-linear
-
-extern volatile uint32_t *SODR_A, *SODR_B, *CODR_A, *CODR_B;
-
-#define _PIN(IO) (DIO ## IO ## _PIN)
-
-#define PWM_MAP_INIT_ROW(IO,ZZ) { ZZ == 'A' ? SODR_A : SODR_B,  ZZ == 'A' ? CODR_A : CODR_B, 1 << _PIN(IO) }
-
-
-#define PWM_MAP_INIT {  PWM_MAP_INIT_ROW(MOTOR_CURRENT_PWM_X_PIN, 'B'), \
-                        PWM_MAP_INIT_ROW(MOTOR_CURRENT_PWM_Y_PIN, 'B'), \
-                        PWM_MAP_INIT_ROW(MOTOR_CURRENT_PWM_Z_PIN, 'B'), \
-                        PWM_MAP_INIT_ROW(MOTOR_CURRENT_PWM_E_PIN, 'A'), \
-                     };
-
-#define NUM_PWMS 4
-
-extern PWM_map ISR_table[NUM_PWMS];
-
-extern uint32_t motor_current_setting[3];
-
-#define IR_BIT(p) (WITHIN(p, 0, 3) ? (p) : (p) + 4)
-#define COPY_ACTIVE_TABLE() do{ LOOP_L_N(i, 6) work_table[i] = active_table[i]; }while(0)
-
-#define PWM_MR0 19999         // base repetition rate minus one count - 20mS
-#define PWM_PR 24             // prescaler value - prescaler divide by 24 + 1  -  1 MHz output
-#define PWM_PCLKSEL0 0x00     // select clock source for prescaler - defaults to 25MHz on power up
-                              // 0: 25MHz, 1: 100MHz, 2: 50MHz, 3: 12.5MHZ to PWM1 prescaler
-#define MR0_MARGIN 200        // if channel value too close to MR0 the system locks up
-
-extern bool PWM_table_swap;   // flag to tell the ISR that the tables have been swapped
-
-#define HAL_G2_PWM_ISR  void PWM_Handler()
-
-extern volatile uint32_t PWM_ISR1_STATUS, PWM_ISR2_STATUS;
diff --git a/Marlin/src/HAL/DUE/fastio/G2_pins.h b/Marlin/src/HAL/DUE/fastio/G2_pins.h
deleted file mode 100644
index 80c87bd..0000000
--- a/Marlin/src/HAL/DUE/fastio/G2_pins.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-
-/**
- * This file contains the custom port/pin definitions for the PRINTRBOARD_G2
- * motherboard. This motherboard uses the SAM3X8C which is a subset of the
- * SAM3X8E used in the DUE board.  It uses port/pin pairs that are not
- * available using the DUE definitions.
- *
- * The first part is a copy of the pin descriptions in the
- * "variants\arduino_due_x\variant.cpp" file but with pins 34-41 replaced by
- * the G2 pins.
- *
- * The second part is the FASTIO port/pin definitions.
- *
- * THESE PINS CAN ONLY BE ACCESSED VIA FASTIO COMMANDS.
- */
-
-/*
-  Copyright (c) 2011 Arduino.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-  See the GNU Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-typedef struct _G2_PinDescription {
-  Pio* pPort;
-  uint32_t ulPin;
-  uint32_t ulPeripheralId;
-  EPioType ulPinType;
-  uint32_t ulPinConfiguration;
-  uint32_t ulPinAttribute;
-  EAnalogChannel ulAnalogChannel; /* Analog pin in the Arduino context (label on the board) */
-  EAnalogChannel ulADCChannelNumber; /* ADC Channel number in the SAM device */
-  EPWMChannel ulPWMChannel;
-  ETCChannel ulTCChannel;
-} G2_PinDescription;
-
-/**
- * This section is a copy of the pin descriptions in the "variants\arduino_due_x\variant.cpp" file
- * with pins 34-41 replaced by the G2 pins.
- */
-
-/**
- * Pins descriptions
- */
-const G2_PinDescription G2_g_APinDescription[] = {
-  // 0 .. 53 - Digital pins
-  // ----------------------
-  // 0/1 - UART (Serial)
-  { PIOA, PIO_PA8A_URXD,     ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT,  PIN_ATTR_DIGITAL,                 NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // URXD
-  { PIOA, PIO_PA9A_UTXD,     ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT,  PIN_ATTR_DIGITAL,                 NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // UTXD
-
-  // 2
-  { PIOB, PIO_PB25B_TIOA0,   ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC0_CHA0     }, // TIOA0
-  { PIOC, PIO_PC28B_TIOA7,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHA7     }, // TIOA7
-  { PIOC, PIO_PC26B_TIOB6,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHB6     }, // TIOB6
-
-  // 5
-  { PIOC, PIO_PC25B_TIOA6,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHA6     }, // TIOA6
-  { PIOC, PIO_PC24B_PWML7,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM),   NO_ADC, NO_ADC, PWM_CH7,     NOT_ON_TIMER }, // PWML7
-  { PIOC, PIO_PC23B_PWML6,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM),   NO_ADC, NO_ADC, PWM_CH6,     NOT_ON_TIMER }, // PWML6
-  { PIOC, PIO_PC22B_PWML5,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM),   NO_ADC, NO_ADC, PWM_CH5,     NOT_ON_TIMER }, // PWML5
-  { PIOC, PIO_PC21B_PWML4,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_PWM),   NO_ADC, NO_ADC, PWM_CH4,     NOT_ON_TIMER }, // PWML4
-  // 10
-  { PIOC, PIO_PC29B_TIOB7,   ID_PIOC, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHB7     }, // TIOB7
-  { PIOD, PIO_PD7B_TIOA8,    ID_PIOD, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHA8     }, // TIOA8
-  { PIOD, PIO_PD8B_TIOB8,    ID_PIOD, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC2_CHB8     }, // TIOB8
-
-  // 13 - AMBER LED
-  { PIOB, PIO_PB27B_TIOB0,   ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_TIMER), NO_ADC, NO_ADC, NOT_ON_PWM,  TC0_CHB0     }, // TIOB0
-
-  // 14/15 - USART3 (Serial3)
-  { PIOD, PIO_PD4B_TXD3,     ID_PIOD, PIO_PERIPH_B, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TXD3
-  { PIOD, PIO_PD5B_RXD3,     ID_PIOD, PIO_PERIPH_B, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // RXD3
-
-  // 16/17 - USART1 (Serial2)
-  { PIOA, PIO_PA13A_TXD1,    ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TXD1
-  { PIOA, PIO_PA12A_RXD1,    ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // RXD1
-
-  // 18/19 - USART0 (Serial1)
-  { PIOA, PIO_PA11A_TXD0,    ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TXD0
-  { PIOA, PIO_PA10A_RXD0,    ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // RXD0
-
-  // 20/21 - TWI1
-  { PIOB, PIO_PB12A_TWD1,    ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TWD1 - SDA0
-  { PIOB, PIO_PB13A_TWCK1,   ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TWCK1 - SCL0
-
-  // 22
-  { PIOB, PIO_PB26,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 22
-  { PIOA, PIO_PA14,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 23
-  { PIOA, PIO_PA15,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 24
-  { PIOD, PIO_PD0,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 25
-
-  // 26
-  { PIOD, PIO_PD1,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 26
-  { PIOD, PIO_PD2,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 27
-  { PIOD, PIO_PD3,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 28
-  { PIOD, PIO_PD6,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 29
-
-  // 30
-  { PIOD, PIO_PD9,           ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 30
-  { PIOA, PIO_PA7,           ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 31
-  { PIOD, PIO_PD10,          ID_PIOD, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 32
-  { PIOC, PIO_PC1,           ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 33
-
-  // 34
-
-  // start of custom pins
-  { PIOA, PIO_PA29,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 34  Y_STEP_PIN
-  { PIOB, PIO_PB1,           ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 35  Y_DIR_PIN
-  { PIOB, PIO_PB0,           ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 36  Y_ENABLE_PIN
-  { PIOB, PIO_PB22,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 37  E0_ENABLE_PIN
-  { PIOB, PIO_PB11,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 38  E0_MS1_PIN
-  { PIOB, PIO_PB10,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 39  E0_MS3_PIN
-  { PIOA, PIO_PA5,           ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 40  HEATER_0_PIN
-  { PIOB, PIO_PB24,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 41  HEATER_BED_PIN
-  // end of custom pins
-
-  // 42
-  { PIOA, PIO_PA19,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 42
-  { PIOA, PIO_PA20,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 43
-  { PIOC, PIO_PC19,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 44
-  { PIOC, PIO_PC18,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 45
-
-  // 46
-  { PIOC, PIO_PC17,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 46
-  { PIOC, PIO_PC16,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 47
-  { PIOC, PIO_PC15,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 48
-  { PIOC, PIO_PC14,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 49
-
-  // 50
-  { PIOC, PIO_PC13,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 50
-  { PIOC, PIO_PC12,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 51
-  { PIOB, PIO_PB21,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 52
-  { PIOB, PIO_PB14,          ID_PIOB, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // PIN 53
-
-
-  // 54 .. 65 - Analog pins
-  // ----------------------
-  { PIOA, PIO_PA16X1_AD7,    ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC0,   ADC7,   NOT_ON_PWM,  NOT_ON_TIMER }, // AD0
-  { PIOA, PIO_PA24X1_AD6,    ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC1,   ADC6,   NOT_ON_PWM,  NOT_ON_TIMER }, // AD1
-  { PIOA, PIO_PA23X1_AD5,    ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC2,   ADC5,   NOT_ON_PWM,  NOT_ON_TIMER }, // AD2
-  { PIOA, PIO_PA22X1_AD4,    ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC3,   ADC4,   NOT_ON_PWM,  NOT_ON_TIMER }, // AD3
-  // 58
-  { PIOA, PIO_PA6X1_AD3,     ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC4,   ADC3,   NOT_ON_PWM,  TC0_CHB2     }, // AD4
-  { PIOA, PIO_PA4X1_AD2,     ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC5,   ADC2,   NOT_ON_PWM,  NOT_ON_TIMER }, // AD5
-  { PIOA, PIO_PA3X1_AD1,     ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC6,   ADC1,   NOT_ON_PWM,  TC0_CHB1     }, // AD6
-  { PIOA, PIO_PA2X1_AD0,     ID_PIOA, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC7,   ADC0,   NOT_ON_PWM,  TC0_CHA1     }, // AD7
-  // 62
-  { PIOB, PIO_PB17X1_AD10,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC8,   ADC10,  NOT_ON_PWM,  NOT_ON_TIMER }, // AD8
-  { PIOB, PIO_PB18X1_AD11,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC9,   ADC11,  NOT_ON_PWM,  NOT_ON_TIMER }, // AD9
-  { PIOB, PIO_PB19X1_AD12,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC10,  ADC12,  NOT_ON_PWM,  NOT_ON_TIMER }, // AD10
-  { PIOB, PIO_PB20X1_AD13,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC11,  ADC13,  NOT_ON_PWM,  NOT_ON_TIMER }, // AD11
-
-  // 66/67 - DAC0/DAC1
-  { PIOB, PIO_PB15X1_DAC0,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC12,  DA0,    NOT_ON_PWM,  NOT_ON_TIMER }, // DAC0
-  { PIOB, PIO_PB16X1_DAC1,   ID_PIOB, PIO_INPUT,    PIO_DEFAULT, PIN_ATTR_ANALOG,                   ADC13,  DA1,    NOT_ON_PWM,  NOT_ON_TIMER }, // DAC1
-
-  // 68/69 - CANRX0/CANTX0
-  { PIOA, PIO_PA1A_CANRX0,   ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  ADC14,  NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // CANRX
-  { PIOA, PIO_PA0A_CANTX0,   ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  ADC15,  NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // CANTX
-
-  // 70/71 - TWI0
-  { PIOA, PIO_PA17A_TWD0,    ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TWD0 - SDA1
-  { PIOA, PIO_PA18A_TWCK0,   ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // TWCK0 - SCL1
-
-  // 72/73 - LEDs
-  { PIOC, PIO_PC30,          ID_PIOC, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // LED AMBER RXL
-  { PIOA, PIO_PA21,          ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // LED AMBER TXL
-
-  // 74/75/76 - SPI
-  { PIOA, PIO_PA25A_SPI0_MISO,ID_PIOA,PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // MISO
-  { PIOA, PIO_PA26A_SPI0_MOSI,ID_PIOA,PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // MOSI
-  { PIOA, PIO_PA27A_SPI0_SPCK,ID_PIOA,PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // SPCK
-
-  // 77 - SPI CS0
-  { PIOA, PIO_PA28A_SPI0_NPCS0,ID_PIOA,PIO_PERIPH_A,PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // NPCS0
-
-  // 78 - SPI CS3 (unconnected)
-  { PIOB, PIO_PB23B_SPI0_NPCS3,ID_PIOB,PIO_PERIPH_B,PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // NPCS3
-
-  // 79 .. 84 - "All pins" masks
-
-  // 79 - TWI0 all pins
-  { PIOA, PIO_PA17A_TWD0|PIO_PA18A_TWCK0, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-  // 80 - TWI1 all pins
-  { PIOB, PIO_PB12A_TWD1|PIO_PB13A_TWCK1, ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-  // 81 - UART (Serial) all pins
-  { PIOA, PIO_PA8A_URXD|PIO_PA9A_UTXD, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-  // 82 - USART0 (Serial1) all pins
-  { PIOA, PIO_PA11A_TXD0|PIO_PA10A_RXD0, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-  // 83 - USART1 (Serial2) all pins
-  { PIOA, PIO_PA13A_TXD1|PIO_PA12A_RXD1, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-  // 84 - USART3 (Serial3) all pins
-  { PIOD, PIO_PD4B_TXD3|PIO_PD5B_RXD3, ID_PIOD, PIO_PERIPH_B, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER },
-
-  // 85 - USB
-  { PIOB, PIO_PB11A_UOTGID|PIO_PB10A_UOTGVBOF, ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // ID - VBOF
-
-  // 86 - SPI CS2
-  { PIOB, PIO_PB21B_SPI0_NPCS2, ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // NPCS2
-
-  // 87 - SPI CS1
-  { PIOA, PIO_PA29A_SPI0_NPCS1, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // NPCS1
-
-  // 88/89 - CANRX1/CANTX1 (same physical pin for 66/53)
-  { PIOB, PIO_PB15A_CANRX1,     ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // CANRX1
-  { PIOB, PIO_PB14A_CANTX1,     ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, PIN_ATTR_DIGITAL,                  NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER }, // CANTX1
-
-  // 90 .. 91 - "All CAN pins" masks
-  // 90 - CAN0 all pins
-  { PIOA, PIO_PA1A_CANRX0|PIO_PA0A_CANTX0, ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC,  NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER },
-  // 91 - CAN1 all pins
-  { PIOB, PIO_PB15A_CANRX1|PIO_PB14A_CANTX1, ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT, (PIN_ATTR_DIGITAL|PIN_ATTR_COMBO), NO_ADC, NO_ADC, NOT_ON_PWM,  NOT_ON_TIMER },
-
-  // END
-  { nullptr, 0, 0, PIO_NOT_A_PIN, PIO_DEFAULT, 0, NO_ADC, NO_ADC, NOT_ON_PWM, NOT_ON_TIMER }
-};
-
-// This section replaces the FASTIO definitions of pins 34-41
-
-#define DIO34_PIN 29
-#define DIO34_WPORT PIOA  // only available via FASTIO      //       34 PA29 - Y_STEP_PIN
-
-#define DIO35_PIN 1
-#define DIO35_WPORT PIOB  // only available via FASTIO      //       35 PAB1 - Y_DIR_PIN
-
-#define DIO36_PIN 0
-#define DIO36_WPORT PIOB  // only available via FASTIO      //       36 PB0 - Y_ENABLE_PIN
-
-#define DIO37_PIN 22
-#define DIO37_WPORT PIOB  // only available via FASTIO      //       37 PB22 - E0_ENABLE_PIN
-
-#define DIO38_PIN 11
-#define DIO38_WPORT PIOB  // only available via FASTIO      //       38 PB11 - E0_MS1_PIN
-
-#define DIO39_PIN 10
-#define DIO39_WPORT PIOB  // only available via FASTIO      //       39 PB10 - E0_MS3_PIN
-
-#define DIO40_PIN 5
-#define DIO40_WPORT PIOA  // only available via FASTIO      //       40 PA5  - HEATER_0_PIN
-
-#define DIO41_PIN 24
-#define DIO41_WPORT PIOB  // only available via FASTIO      //       41 PB24 - HEATER_BED_PIN
diff --git a/Marlin/src/HAL/DUE/inc/Conditionals_LCD.h b/Marlin/src/HAL/DUE/inc/Conditionals_LCD.h
deleted file mode 100644
index 5867414..0000000
--- a/Marlin/src/HAL/DUE/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/DUE."
-#endif
diff --git a/Marlin/src/HAL/DUE/inc/Conditionals_adv.h b/Marlin/src/HAL/DUE/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/DUE/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/DUE/inc/Conditionals_post.h b/Marlin/src/HAL/DUE/inc/Conditionals_post.h
deleted file mode 100644
index ce6d3fd..0000000
--- a/Marlin/src/HAL/DUE/inc/Conditionals_post.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define FLASH_EEPROM_EMULATION
-#elif EITHER(I2C_EEPROM, SPI_EEPROM)
-  #define USE_SHARED_EEPROM 1
-#endif
diff --git a/Marlin/src/HAL/DUE/inc/SanityCheck.h b/Marlin/src/HAL/DUE/inc/SanityCheck.h
deleted file mode 100644
index 13484f7..0000000
--- a/Marlin/src/HAL/DUE/inc/SanityCheck.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test Arduino Due specific configuration values for errors at compile-time.
- */
-
-/**
- * Check for common serial pin conflicts
- */
-#define CHECK_SERIAL_PIN(N) ( \
-     X_STOP_PIN == N || Y_STOP_PIN == N || Z_STOP_PIN == N \
-  || X_MIN_PIN  == N || Y_MIN_PIN  == N || Z_MIN_PIN  == N \
-  || X_MAX_PIN  == N || Y_MAX_PIN  == N || Z_MAX_PIN  == N \
-  || X_STEP_PIN == N || Y_STEP_PIN == N || Z_STEP_PIN == N \
-  || X_DIR_PIN  == N || Y_DIR_PIN  == N || Z_DIR_PIN  == N \
-  || X_ENA_PIN  == N || Y_ENA_PIN  == N || Z_ENA_PIN  == N \
-)
-#if CONF_SERIAL_IS(0) // D0-D1. No known conflicts.
-#endif
-#if CONF_SERIAL_IS(1) && (CHECK_SERIAL_PIN(18) || CHECK_SERIAL_PIN(19))
-  #error "Serial Port 1 pin D18 and/or D19 conflicts with another pin on the board."
-#endif
-#if CONF_SERIAL_IS(2) && (CHECK_SERIAL_PIN(16) || CHECK_SERIAL_PIN(17))
-  #error "Serial Port 2 pin D16 and/or D17 conflicts with another pin on the board."
-#endif
-#if CONF_SERIAL_IS(3) && (CHECK_SERIAL_PIN(14) || CHECK_SERIAL_PIN(15))
-  #error "Serial Port 3 pin D14 and/or D15 conflicts with another pin on the board."
-#endif
-#undef CHECK_SERIAL_PIN
-
-/**
- * HARDWARE VS. SOFTWARE SPI COMPATIBILITY
- *
- * DUE selects hardware vs. software SPI depending on whether one of the hardware-controllable SDSS pins is in use.
- *
- * The hardware SPI controller doesn't allow software SPIs to control any shared pins.
- *
- * When DUE software SPI is used then Trinamic drivers must use the TMC softSPI.
- *
- * When DUE hardware SPI is used then a Trinamic driver can use either its hardware SPI or, if there are no shared
- * pins, its software SPI.
- *
- * Usually the hardware SPI pins are only available to the LCD. This makes the DUE hard SPI used at the same time
- * as the TMC2130 soft SPI the most common setup.
- */
-#define _IS_HW_SPI(P) (defined(TMC_SW_##P) && (TMC_SW_##P == SD_MOSI_PIN || TMC_SW_##P == SD_MISO_PIN || TMC_SW_##P == SD_SCK_PIN))
-
-#if ENABLED(SDSUPPORT) && HAS_DRIVER(TMC2130)
-  #if ENABLED(TMC_USE_SW_SPI)
-    #if DISABLED(DUE_SOFTWARE_SPI) && (_IS_HW_SPI(MOSI) || _IS_HW_SPI(MISO) || _IS_HW_SPI(SCK))
-      #error "DUE hardware SPI is required but is incompatible with TMC2130 software SPI. Either disable TMC_USE_SW_SPI or use separate pins for the two SPIs."
-    #endif
-  #elif ENABLED(DUE_SOFTWARE_SPI)
-    #error "DUE software SPI is required but is incompatible with TMC2130 hardware SPI. Enable TMC_USE_SW_SPI to fix."
-  #endif
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on DUE."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on the DUE platform."
-#endif
-
-#if USING_PULLDOWNS
-  #error "PULLDOWN pin mode is not available on DUE boards."
-#endif
diff --git a/Marlin/src/HAL/DUE/pinsDebug.h b/Marlin/src/HAL/DUE/pinsDebug.h
deleted file mode 100644
index df1ba41..0000000
--- a/Marlin/src/HAL/DUE/pinsDebug.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Support routines for Due
- */
-
-/**
- * Translation of routines & variables used by pinsDebug.h
- */
-
-#include "../shared/Marduino.h"
-
-/**
- * Due/Marlin quirks
- *
- * a) determining the state of a pin
- *     The Due/Arduino status definitions for the g_pinStatus[pin] array are:
- *       #define PIN_STATUS_DIGITAL_INPUT_PULLUP  (0x01)
- *       #define PIN_STATUS_DIGITAL_INPUT         (0x02)
- *       #define PIN_STATUS_DIGITAL_OUTPUT        (0x03)
- *       #define PIN_STATUS_ANALOG                (0x04)
- *       #define PIN_STATUS_PWM                   (0x05)
- *       #define PIN_STATUS_TIMER                 (0x06)
- *
- *     These are only valid if the following Due/Arduino provided functions are used:
- *       analogRead
- *       analogWrite
- *       digitalWrite
- *       pinMode
- *
- *     The FASTIO routines do not touch the g_pinStatus[pin] array.
- *
- *     The net result is that both the g_pinStatus[pin] array and the PIO_OSR register
- *     needs to be looked at when determining if a pin is an input or an output.
- *
- * b) Due has only pins 6, 7, 8 & 9 enabled for PWMs.  FYI - they run at 1kHz
- *
- * c) NUM_DIGITAL_PINS does not include the analog pins
- *
- * d) Pins 0-78 are defined for Due but 78 has a comment of "unconnected!".  78 is
- *    included just in case.
- */
-
-#define NUMBER_PINS_TOTAL PINS_COUNT
-
-#define digitalRead_mod(p) extDigitalRead(p)  // AVR digitalRead disabled PWM before it read the pin
-#define PRINT_PORT(p)
-#define PRINT_ARRAY_NAME(x) do{ sprintf_P(buffer, PSTR("%-" STRINGIFY(MAX_NAME_LENGTH) "s"), pin_array[x].name); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN(p) do{ sprintf_P(buffer, PSTR("%02d"), p); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR(" (A%2d)  "), DIGITAL_PIN_TO_ANALOG_PIN(pin)); SERIAL_ECHO(buffer); }while(0)
-#define GET_ARRAY_PIN(p) pin_array[p].pin
-#define GET_ARRAY_IS_DIGITAL(p) pin_array[p].is_digital
-#define VALID_PIN(pin) (pin >= 0 && pin < (int8_t)NUMBER_PINS_TOTAL ? 1 : 0)
-#define DIGITAL_PIN_TO_ANALOG_PIN(p) int(p - analogInputToDigitalPin(0))
-#define IS_ANALOG(P) WITHIN(P, char(analogInputToDigitalPin(0)), char(analogInputToDigitalPin(NUM_ANALOG_INPUTS - 1)))
-#define pwm_status(pin) (((g_pinStatus[pin] & 0xF) == PIN_STATUS_PWM) && \
-                        ((g_APinDescription[pin].ulPinAttribute & PIN_ATTR_PWM) == PIN_ATTR_PWM))
-#define MULTI_NAME_PAD 14 // space needed to be pretty if not first name assigned to a pin
-
-bool GET_PINMODE(int8_t pin) {  // 1: output, 0: input
-  volatile Pio* port = g_APinDescription[pin].pPort;
-  uint32_t mask = g_APinDescription[pin].ulPin;
-  uint8_t pin_status = g_pinStatus[pin] & 0xF;
-  return (  (pin_status == 0 && (port->PIO_OSR & mask))
-          || pin_status == PIN_STATUS_DIGITAL_OUTPUT
-          || pwm_status(pin));
-}
-
-void pwm_details(int32_t pin) {
-  if (pwm_status(pin)) {
-    uint32_t chan = g_APinDescription[pin].ulPWMChannel;
-    SERIAL_ECHOPGM("PWM = ", PWM_INTERFACE->PWM_CH_NUM[chan].PWM_CDTY);
-  }
-}
-
-/**
- * DUE Board pin   |  PORT  | Label
- * ----------------+--------+-------
- *   0             |  PA8   | "RX0"
- *   1             |  PA9   | "TX0"
- *   2       TIOA0 |  PB25  |
- *   3       TIOA7 |  PC28  |
- *   4       NPCS1 |  PA29  |
- *           TIOB6 |  PC26  |
- *   5       TIOA6 |  PC25  |
- *   6       PWML7 |  PC24  |
- *   7       PWML6 |  PC23  |
- *   8       PWML5 |  PC22  |
- *   9       PWML4 |  PC21  |
- *  10       NPCS0 |  PA28  |
- *           TIOB7 |  PC29  |
- *  11       TIOA8 |  PD7   |
- *  12       TIOB8 |  PD8   |
- *  13       TIOB0 |  PB27  | LED AMBER "L"
- *  14       TXD3  |  PD4   | "TX3"
- *  15       RXD3  |  PD5   | "RX3"
- *  16       TXD1  |  PA13  | "TX2"
- *  17       RXD1  |  PA12  | "RX2"
- *  18       TXD0  |  PA11  | "TX1"
- *  19       RXD0  |  PA10  | "RX1"
- *  20             |  PB12  | "SDA"
- *  21             |  PB13  | "SCL"
- *  22             |  PB26  |
- *  23             |  PA14  |
- *  24             |  PA15  |
- *  25             |  PD0   |
- *  26             |  PD1   |
- *  27             |  PD2   |
- *  28             |  PD3   |
- *  29             |  PD6   |
- *  30             |  PD9   |
- *  31             |  PA7   |
- *  32             |  PD10  |
- *  33             |  PC1   |
- *  34             |  PC2   |
- *  35             |  PC3   |
- *  36             |  PC4   |
- *  37             |  PC5   |
- *  38             |  PC6   |
- *  39             |  PC7   |
- *  40             |  PC8   |
- *  41             |  PC9   |
- *  42             |  PA19  |
- *  43             |  PA20  |
- *  44             |  PC19  |
- *  45             |  PC18  |
- *  46             |  PC17  |
- *  47             |  PC16  |
- *  48             |  PC15  |
- *  49             |  PC14  |
- *  50             |  PC13  |
- *  51             |  PC12  |
- *  52       NPCS2 |  PB21  |
- *  53             |  PB14  |
- *  54             |  PA16  | "A0"
- *  55             |  PA24  | "A1"
- *  56             |  PA23  | "A2"
- *  57             |  PA22  | "A3"
- *  58       TIOB2 |  PA6   | "A4"
- *  69             |  PA4   | "A5"
- *  60       TIOB1 |  PA3   | "A6"
- *  61       TIOA1 |  PA2   | "A7"
- *  62             |  PB17  | "A8"
- *  63             |  PB18  | "A9"
- *  64             |  PB19  | "A10"
- *  65             |  PB20  | "A11"
- *  66             |  PB15  | "DAC0"
- *  67             |  PB16  | "DAC1"
- *  68             |  PA1   | "CANRX"
- *  69             |  PA0   | "CANTX"
- *  70             |  PA17  | "SDA1"
- *  71             |  PA18  | "SCL1"
- *  72             |  PC30  | LED AMBER "RX"
- *  73             |  PA21  | LED AMBER "TX"
- *  74       MISO  |  PA25  |
- *  75       MOSI  |  PA26  |
- *  76       SCLK  |  PA27  |
- *  77       NPCS0 |  PA28  |
- *  78       NPCS3 |  PB23  | unconnected!
- *
- * USB pin         |  PORT
- * ----------------+--------
- *  ID             |  PB11
- *  VBOF           |  PB10
- */
diff --git a/Marlin/src/HAL/DUE/spi_pins.h b/Marlin/src/HAL/DUE/spi_pins.h
deleted file mode 100644
index cec22c2..0000000
--- a/Marlin/src/HAL/DUE/spi_pins.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Define SPI Pins: SCK, MISO, MOSI, SS
- *
- * Available chip select pins for HW SPI are 4 10 52 77
- */
-#if SDSS == 4 || SDSS == 10 || SDSS == 52 || SDSS == 77 || SDSS == 87
-  #if SDSS == 4
-    #define SPI_PIN         87
-    #define SPI_CHAN         1
-  #elif SDSS == 10
-    #define SPI_PIN         77
-    #define SPI_CHAN         0
-  #elif SDSS == 52
-    #define SPI_PIN         86
-    #define SPI_CHAN         2
-  #elif SDSS == 77
-    #define SPI_PIN         77
-    #define SPI_CHAN         0
-  #else
-    #define SPI_PIN         87
-    #define SPI_CHAN         1
-  #endif
-  #define SD_SCK_PIN        76
-  #define SD_MISO_PIN       74
-  #define SD_MOSI_PIN       75
-#else
-  // defaults
-  #define DUE_SOFTWARE_SPI
-  #ifndef SD_SCK_PIN
-    #define SD_SCK_PIN      52
-  #endif
-  #ifndef SD_MISO_PIN
-    #define SD_MISO_PIN     50
-  #endif
-  #ifndef SD_MOSI_PIN
-    #define SD_MOSI_PIN     51
-  #endif
-#endif
-
-/* A.28, A.29, B.21, C.26, C.29 */
-#define SD_SS_PIN         SDSS
diff --git a/Marlin/src/HAL/DUE/timers.cpp b/Marlin/src/HAL/DUE/timers.cpp
deleted file mode 100644
index e564781..0000000
--- a/Marlin/src/HAL/DUE/timers.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Timers for Arduino Due and compatible (SAM3X8E)
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-// ------------------------
-// Includes
-// ------------------------
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-// ------------------------
-// Local defines
-// ------------------------
-
-#define NUM_HARDWARE_TIMERS 9
-
-// ------------------------
-// Private Variables
-// ------------------------
-
-const tTimerConfig timer_config[NUM_HARDWARE_TIMERS] = {
-  { TC0, 0, TC0_IRQn,  3}, // 0 - [servo timer5]
-  { TC0, 1, TC1_IRQn,  0}, // 1
-  { TC0, 2, TC2_IRQn,  2}, // 2 - stepper
-  { TC1, 0, TC3_IRQn,  0}, // 3 - stepper for BOARD_ARCHIM1
-  { TC1, 1, TC4_IRQn, 15}, // 4 - temperature
-  { TC1, 2, TC5_IRQn,  3}, // 5 - [servo timer3]
-  { TC2, 0, TC6_IRQn, 14}, // 6 - tone
-  { TC2, 1, TC7_IRQn,  0}, // 7
-  { TC2, 2, TC8_IRQn,  0}, // 8
-};
-
-// ------------------------
-// Public functions
-// ------------------------
-
-/*
-  Timer_clock1: Prescaler 2 -> 42MHz
-  Timer_clock2: Prescaler 8 -> 10.5MHz
-  Timer_clock3: Prescaler 32 -> 2.625MHz
-  Timer_clock4: Prescaler 128 -> 656.25kHz
-*/
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  Tc *tc = timer_config[timer_num].pTimerRegs;
-  IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  uint32_t channel = timer_config[timer_num].channel;
-
-  // Disable interrupt, just in case it was already enabled
-  NVIC_DisableIRQ(irq);
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-
-  // Disable timer interrupt
-  tc->TC_CHANNEL[channel].TC_IDR = TC_IDR_CPCS;
-
-  // Stop timer, just in case, to be able to reconfigure it
-  TC_Stop(tc, channel);
-
-  pmc_set_writeprotect(false);
-  pmc_enable_periph_clk((uint32_t)irq);
-  NVIC_SetPriority(irq, timer_config[timer_num].priority);
-
-  // wave mode, reset counter on match with RC,
-  TC_Configure(tc, channel,
-      TC_CMR_WAVE
-    | TC_CMR_WAVSEL_UP_RC
-    | (HAL_TIMER_PRESCALER ==   2 ? TC_CMR_TCCLKS_TIMER_CLOCK1 : 0)
-    | (HAL_TIMER_PRESCALER ==   8 ? TC_CMR_TCCLKS_TIMER_CLOCK2 : 0)
-    | (HAL_TIMER_PRESCALER ==  32 ? TC_CMR_TCCLKS_TIMER_CLOCK3 : 0)
-    | (HAL_TIMER_PRESCALER == 128 ? TC_CMR_TCCLKS_TIMER_CLOCK4 : 0)
-  );
-
-  // Set compare value
-  TC_SetRC(tc, channel, VARIANT_MCK / (HAL_TIMER_PRESCALER) / frequency);
-
-  // And start timer
-  TC_Start(tc, channel);
-
-  // enable interrupt on RC compare
-  tc->TC_CHANNEL[channel].TC_IER = TC_IER_CPCS;
-
-  // Finally, enable IRQ
-  NVIC_EnableIRQ(irq);
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  NVIC_EnableIRQ(irq);
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  NVIC_DisableIRQ(irq);
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-}
-
-// missing from CMSIS: Check if interrupt is enabled or not
-static bool NVIC_GetEnabledIRQ(IRQn_Type IRQn) {
-  return TEST(NVIC->ISER[uint32_t(IRQn) >> 5], uint32_t(IRQn) & 0x1F);
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  return NVIC_GetEnabledIRQ(irq);
-}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/timers.h b/Marlin/src/HAL/DUE/timers.h
deleted file mode 100644
index dc35c77..0000000
--- a/Marlin/src/HAL/DUE/timers.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Timers for Arduino Due and compatible (SAM3X8E)
- */
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define HAL_TIMER_PRESCALER    2
-#define HAL_TIMER_RATE         ((F_CPU) / (HAL_TIMER_PRESCALER))  // frequency of timers peripherals
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         2  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         4  // Timer Index for Temperature
-#endif
-#ifndef MF_TIMER_TONE
-  #define MF_TIMER_TONE         6  // index of timer to use for beeper tones
-#endif
-
-#define TEMP_TIMER_FREQUENCY   1000 // temperature interrupt frequency
-
-#define STEPPER_TIMER_RATE          HAL_TIMER_RATE                                        // frequency of stepper timer (HAL_TIMER_RATE / STEPPER_TIMER_PRESCALE)
-#define STEPPER_TIMER_TICKS_PER_US  ((STEPPER_TIMER_RATE) / 1000000)                      // stepper timer ticks per Âµs
-#define STEPPER_TIMER_PRESCALE      (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE            STEPPER_TIMER_RATE                                    // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE        STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US    STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT()  HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT()  HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() void TC2_Handler()
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() void TC4_Handler()
-#endif
-#ifndef HAL_TONE_TIMER_ISR
-  #define HAL_TONE_TIMER_ISR() void TC6_Handler()
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef struct {
-  Tc          *pTimerRegs;
-  uint16_t    channel;
-  IRQn_Type   IRQ_Id;
-  uint8_t     priority;
-} tTimerConfig;
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-extern const tTimerConfig timer_config[];
-
-// ------------------------
-// Public functions
-// ------------------------
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  const tTimerConfig * const pConfig = &timer_config[timer_num];
-  pConfig->pTimerRegs->TC_CHANNEL[pConfig->channel].TC_RC = compare;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  const tTimerConfig * const pConfig = &timer_config[timer_num];
-  return pConfig->pTimerRegs->TC_CHANNEL[pConfig->channel].TC_RC;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  const tTimerConfig * const pConfig = &timer_config[timer_num];
-  return pConfig->pTimerRegs->TC_CHANNEL[pConfig->channel].TC_CV;
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-FORCE_INLINE static void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  const tTimerConfig * const pConfig = &timer_config[timer_num];
-  // Reading the status register clears the interrupt flag
-  pConfig->pTimerRegs->TC_CHANNEL[pConfig->channel].TC_SR;
-}
-
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/DUE/upload_extra_script.py b/Marlin/src/HAL/DUE/upload_extra_script.py
deleted file mode 100644
index 4f7a494..0000000
--- a/Marlin/src/HAL/DUE/upload_extra_script.py
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-# Set upload_command
-#
-#  Windows: bossac.exe
-#  Other: leave unchanged
-#
-import pioutil
-if pioutil.is_pio_build():
-	import platform
-	current_OS = platform.system()
-
-	if current_OS == 'Windows':
-
-		Import("env")
-
-		# Use bossac.exe on Windows
-		env.Replace(
-			UPLOADCMD="bossac --info --unlock --write --verify --reset --erase -U false --boot $SOURCE"
-		)
diff --git a/Marlin/src/HAL/DUE/usb/arduino_due_x.h b/Marlin/src/HAL/DUE/usb/arduino_due_x.h
deleted file mode 100644
index e7b6f3d..0000000
--- a/Marlin/src/HAL/DUE/usb/arduino_due_x.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * \file
- *
- * \brief Arduino Due/X Board Definition.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-#pragma once
-
-/**
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-/**
- *  \page arduino_due_x_opfreq "Arduino Due/X - Operating frequencies"
- *  This page lists several definition related to the board operating frequency
- *
- *  \section Definitions
- *  - \ref BOARD_FREQ_*
- *  - \ref BOARD_MCK
- */
-
-/*! Board oscillator settings */
-#define BOARD_FREQ_SLCK_XTAL            (32768U)
-#define BOARD_FREQ_SLCK_BYPASS          (32768U)
-#define BOARD_FREQ_MAINCK_XTAL          (12000000U)
-#define BOARD_FREQ_MAINCK_BYPASS        (12000000U)
-
-/*! Master clock frequency */
-#define BOARD_MCK                       CHIP_FREQ_CPU_MAX
-#define BOARD_NO_32K_XTAL
-
-/** board main clock xtal startup time */
-#define BOARD_OSC_STARTUP_US   15625
-
-/* ------------------------------------------------------------------------ */
-
-/**
- * \page arduino_due_x_board_info "Arduino Due/X - Board information"
- * This page lists several definition related to the board description.
- *
- */
-
-/* ------------------------------------------------------------------------ */
-/* USB                                                                      */
-/* ------------------------------------------------------------------------ */
-/*! USB OTG VBus On/Off: Bus Power Control Port. */
-#define PIN_UOTGHS_VBOF  { PIO_PB10, PIOB, ID_PIOB, PIO_PERIPH_A, PIO_PULLUP }
-/*! USB OTG Identification: Mini Connector Identification Port. */
-#define PIN_UOTGHS_ID    { PIO_PB11, PIOB, ID_PIOB, PIO_PERIPH_A, PIO_PULLUP }
-
-/*! Multiplexed pin used for USB_ID: */
-#define USB_ID                      PIO_PB11_IDX
-#define USB_ID_GPIO                 (PIO_PB11_IDX)
-#define USB_ID_FLAGS                (PIO_PERIPH_A | PIO_DEFAULT)
-/*! Multiplexed pin used for USB_VBOF: */
-#define USB_VBOF                    PIO_PB10_IDX
-#define USB_VBOF_GPIO               (PIO_PB10_IDX)
-#define USB_VBOF_FLAGS              (PIO_PERIPH_A | PIO_DEFAULT)
-/*! Active level of the USB_VBOF output pin. */
-#define USB_VBOF_ACTIVE_STATE       LOW
-/* ------------------------------------------------------------------------ */
diff --git a/Marlin/src/HAL/DUE/usb/compiler.h b/Marlin/src/HAL/DUE/usb/compiler.h
deleted file mode 100644
index 6331979..0000000
--- a/Marlin/src/HAL/DUE/usb/compiler.h
+++ /dev/null
@@ -1,1150 +0,0 @@
-/**
- * \file
- *
- * \brief Commonly used includes, types and macros.
- *
- * Copyright (c) 2010-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef UTILS_COMPILER_H
-#define UTILS_COMPILER_H
-
-#include <sam.h>
-#include <chip.h>
-#include "arduino_due_x.h"
-#include "conf_clock.h"
-#ifdef SAM3XA_SERIES
-#define SAM3XA 1
-#endif
-#define UDD_NO_SLEEP_MGR 1
-#define pmc_is_wakeup_clocks_restored() true
-
-#undef udd_get_endpoint_size_max
-#define UDD_USB_INT_FUN USBD_ISR
-
-/**
- * \defgroup group_sam_utils Compiler abstraction layer and code utilities
- *
- * Compiler abstraction layer and code utilities for AT91SAM.
- * This module provides various abstraction layers and utilities to make code compatible between different compilers.
- *
- * \{
- */
-#include <stddef.h>
-
-#if (defined __ICCARM__)
-#  include <intrinsics.h>
-#endif
-
-#include <sam.h>
-#include "preprocessor.h"
-
-//_____ D E C L A R A T I O N S ____________________________________________
-
-#ifndef __ASSEMBLY__ // Not defined for assembling.
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdlib.h>
-
-#ifdef __ICCARM__
-/*! \name Compiler Keywords
- *
- * Port of some keywords from GCC to IAR Embedded Workbench.
- */
-//! @{
-#define __asm__             asm
-#define __inline__          inline
-#define __volatile__
-//! @}
-
-#endif
-
-#define FUNC_PTR                            void *
-/**
- * \def UNUSED
- * \brief Marking \a v as a unused parameter or value.
- */
-#ifndef UNUSED
-  #define UNUSED(x) ((void)(x))
-#endif
-
-/**
- * \def unused
- * \brief Marking \a v as a unused parameter or value.
- */
-#define unused(v)          do { (void)(v); }while(0)
-
-/**
- * \def barrier
- * \brief Memory barrier
- */
-#define barrier()          __DMB()
-
-/**
- * \brief Emit the compiler pragma \a arg.
- *
- * \param arg The pragma directive as it would appear after \e \#pragma
- * (i.e. not stringified).
- */
-#define COMPILER_PRAGMA(arg)            _Pragma(#arg)
-
-/**
- * \def COMPILER_PACK_SET(alignment)
- * \brief Set maximum alignment for subsequent struct and union
- * definitions to \a alignment.
- */
-#define COMPILER_PACK_SET(alignment)   COMPILER_PRAGMA(pack(alignment))
-
-/**
- * \def COMPILER_PACK_RESET()
- * \brief Set default alignment for subsequent struct and union
- * definitions.
- */
-#define COMPILER_PACK_RESET()          COMPILER_PRAGMA(pack())
-
-
-/**
- * \brief Set aligned boundary.
- */
-#if (defined __GNUC__) || (defined __CC_ARM)
-#   define COMPILER_ALIGNED(a)    __attribute__((__aligned__(a)))
-#elif (defined __ICCARM__)
-#   define COMPILER_ALIGNED(a)    COMPILER_PRAGMA(data_alignment = a)
-#endif
-
-/**
- * \brief Set word-aligned boundary.
- */
-#if (defined __GNUC__) || defined(__CC_ARM)
-#define COMPILER_WORD_ALIGNED    __attribute__((__aligned__(4)))
-#elif (defined __ICCARM__)
-#define COMPILER_WORD_ALIGNED    COMPILER_PRAGMA(data_alignment = 4)
-#endif
-
-/**
- * \def __always_inline
- * \brief The function should always be inlined.
- *
- * This annotation instructs the compiler to ignore its inlining
- * heuristics and inline the function no matter how big it thinks it
- * becomes.
- */
-#ifdef __CC_ARM
-#   define __always_inline   __forceinline
-#elif (defined __GNUC__)
-#ifdef __always_inline
-# undef __always_inline
-#endif
-# define __always_inline   inline __attribute__((__always_inline__))
-#elif (defined __ICCARM__)
-# define __always_inline   _Pragma("inline=forced")
-#endif
-
-/**
- * \def __no_inline
- * \brief The function should not be inlined.
- *
- * This annotation instructs the compiler to ignore its inlining
- * heuristics and not inline the function.
- */
-#ifdef __CC_ARM
-# define __no_inline   __attribute__((noinline))
-#elif (defined __GNUC__)
-# define __no_inline   __attribute__((__noinline__))
-#elif (defined __ICCARM__)
-# define __no_inline   _Pragma("inline=never")
-#endif
-
-/*! \brief This macro is used to test fatal errors.
- *
- * The macro tests if the expression is false. If it is, a fatal error is
- * detected and the application hangs up. If TEST_SUITE_DEFINE_ASSERT_MACRO
- * is defined, a unit test version of the macro is used, to allow execution
- * of further tests after a false expression.
- *
- * \param expr  Expression to evaluate and supposed to be nonzero.
- */
-#ifdef _ASSERT_ENABLE_
-#  if defined(TEST_SUITE_DEFINE_ASSERT_MACRO)
-     // Assert() is defined in unit_test/suite.h
-#    include "unit_test/suite.h"
-#  else
-#undef TEST_SUITE_DEFINE_ASSERT_MACRO
-#    define Assert(expr) \
-  {\
-    if (!(expr)) while (true);\
-  }
-#  endif
-#else
-#  define Assert(expr) ((void) 0)
-#endif
-
-/* Define WEAK attribute */
-#if defined   ( __CC_ARM   ) /* Keil ÂµVision 4 */
-#   define WEAK __attribute__ ((weak))
-#elif defined ( __ICCARM__ ) /* IAR Ewarm 5.41+ */
-#   define WEAK __weak
-#elif defined (  __GNUC__  ) /* GCC CS3 2009q3-68 */
-#   define WEAK __attribute__ ((weak))
-#endif
-
-/* Define NO_INIT attribute */
-#if 0 //ndef NO_INIT
-#ifdef __CC_ARM
-#   define NO_INIT __attribute__((zero_init))
-#elif defined ( __ICCARM__ )
-#   define NO_INIT __no_init
-#elif defined (  __GNUC__  )
-#   define NO_INIT __attribute__((section(".no_init")))
-#endif
-#endif
-
-/* Define RAMFUNC attribute */
-#if defined   ( __CC_ARM   ) /* Keil ÂµVision 4 */
-#   define RAMFUNC __attribute__ ((section(".ramfunc")))
-#elif defined ( __ICCARM__ ) /* IAR Ewarm 5.41+ */
-#   define RAMFUNC __ramfunc
-#elif defined (  __GNUC__  ) /* GCC CS3 2009q3-68 */
-#   define RAMFUNC __attribute__ ((section(".ramfunc")))
-#endif
-
-/* Define OPTIMIZE_HIGH attribute */
-#if defined   ( __CC_ARM   ) /* Keil ÂµVision 4 */
-#   define OPTIMIZE_HIGH _Pragma("O3")
-#elif defined ( __ICCARM__ ) /* IAR Ewarm 5.41+ */
-#   define OPTIMIZE_HIGH _Pragma("optimize=high")
-#elif defined (  __GNUC__  ) /* GCC CS3 2009q3-68 */
-#   define OPTIMIZE_HIGH __attribute__((optimize("s")))
-#endif
-
-/*! \name Usual Types
- */
-//! @{
-typedef unsigned char           Bool; //!< Boolean.
-#ifndef __cplusplus
-#ifndef __bool_true_false_are_defined
-typedef unsigned char           bool; //!< Boolean.
-#endif
-#endif
-typedef int8_t                  S8 ;  //!< 8-bit signed integer.
-typedef uint8_t                 U8 ;  //!< 8-bit unsigned integer.
-typedef int16_t                 S16;  //!< 16-bit signed integer.
-typedef uint16_t                U16;  //!< 16-bit unsigned integer.
-typedef uint16_t                le16_t;
-typedef uint16_t                be16_t;
-typedef int32_t                 S32;  //!< 32-bit signed integer.
-typedef uint32_t                U32;  //!< 32-bit unsigned integer.
-typedef uint32_t                le32_t;
-typedef uint32_t                be32_t;
-typedef int64_t                 S64;  //!< 64-bit signed integer.
-typedef uint64_t                U64;  //!< 64-bit unsigned integer.
-typedef float                   F32;  //!< 32-bit floating-point number.
-typedef double                  F64;  //!< 64-bit floating-point number.
-typedef uint32_t                iram_size_t;
-//! @}
-
-
-/*! \name Status Types
- */
-//! @{
-typedef bool                Status_bool_t;  //!< Boolean status.
-typedef U8                  Status_t;       //!< 8-bit-coded status.
-//! @}
-
-
-/*! \name Aliasing Aggregate Types
- */
-//! @{
-
-//! 16-bit union.
-typedef union
-{
-  S16 s16   ;
-  U16 u16   ;
-  S8  s8 [2];
-  U8  u8 [2];
-} Union16;
-
-//! 32-bit union.
-typedef union
-{
-  S32 s32   ;
-  U32 u32   ;
-  S16 s16[2];
-  U16 u16[2];
-  S8  s8 [4];
-  U8  u8 [4];
-} Union32;
-
-//! 64-bit union.
-typedef union
-{
-  S64 s64   ;
-  U64 u64   ;
-  S32 s32[2];
-  U32 u32[2];
-  S16 s16[4];
-  U16 u16[4];
-  S8  s8 [8];
-  U8  u8 [8];
-} Union64;
-
-//! Union of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  S64 *s64ptr;
-  U64 *u64ptr;
-  S32 *s32ptr;
-  U32 *u32ptr;
-  S16 *s16ptr;
-  U16 *u16ptr;
-  S8  *s8ptr ;
-  U8  *u8ptr ;
-} UnionPtr;
-
-//! Union of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  volatile S64 *s64ptr;
-  volatile U64 *u64ptr;
-  volatile S32 *s32ptr;
-  volatile U32 *u32ptr;
-  volatile S16 *s16ptr;
-  volatile U16 *u16ptr;
-  volatile S8  *s8ptr ;
-  volatile U8  *u8ptr ;
-} UnionVPtr;
-
-//! Union of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  const S64 *s64ptr;
-  const U64 *u64ptr;
-  const S32 *s32ptr;
-  const U32 *u32ptr;
-  const S16 *s16ptr;
-  const U16 *u16ptr;
-  const S8  *s8ptr ;
-  const U8  *u8ptr ;
-} UnionCPtr;
-
-//! Union of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  const volatile S64 *s64ptr;
-  const volatile U64 *u64ptr;
-  const volatile S32 *s32ptr;
-  const volatile U32 *u32ptr;
-  const volatile S16 *s16ptr;
-  const volatile U16 *u16ptr;
-  const volatile S8  *s8ptr ;
-  const volatile U8  *u8ptr ;
-} UnionCVPtr;
-
-//! Structure of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  S64 *s64ptr;
-  U64 *u64ptr;
-  S32 *s32ptr;
-  U32 *u32ptr;
-  S16 *s16ptr;
-  U16 *u16ptr;
-  S8  *s8ptr ;
-  U8  *u8ptr ;
-} StructPtr;
-
-//! Structure of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  volatile S64 *s64ptr;
-  volatile U64 *u64ptr;
-  volatile S32 *s32ptr;
-  volatile U32 *u32ptr;
-  volatile S16 *s16ptr;
-  volatile U16 *u16ptr;
-  volatile S8  *s8ptr ;
-  volatile U8  *u8ptr ;
-} StructVPtr;
-
-//! Structure of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  const S64 *s64ptr;
-  const U64 *u64ptr;
-  const S32 *s32ptr;
-  const U32 *u32ptr;
-  const S16 *s16ptr;
-  const U16 *u16ptr;
-  const S8  *s8ptr ;
-  const U8  *u8ptr ;
-} StructCPtr;
-
-//! Structure of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  const volatile S64 *s64ptr;
-  const volatile U64 *u64ptr;
-  const volatile S32 *s32ptr;
-  const volatile U32 *u32ptr;
-  const volatile S16 *s16ptr;
-  const volatile U16 *u16ptr;
-  const volatile S8  *s8ptr ;
-  const volatile U8  *u8ptr ;
-} StructCVPtr;
-
-//! @}
-
-#endif  // #ifndef __ASSEMBLY__
-
-/*! \name Usual Constants
- */
-//! @{
-#define DISABLE   0
-#define ENABLE    1
-#ifndef __cplusplus
-#ifndef __bool_true_false_are_defined
-#define false (1==0)
-#define true (1==1)
-#endif
-#endif
-#ifndef PASS
-#define PASS      0
-#endif
-#ifndef FAIL
-#define FAIL      1
-#endif
-#ifndef LOW
-#define LOW  0x0
-#endif
-#ifndef HIGH
-#define HIGH 0x1
-#endif
-//! @}
-
-
-#ifndef __ASSEMBLY__ // not for assembling.
-
-//! \name Optimization Control
-//@{
-
-/**
- * \def likely(exp)
- * \brief The expression \a exp is likely to be true
- */
-#ifndef likely
-#   define likely(exp)    (exp)
-#endif
-
-/**
- * \def unlikely(exp)
- * \brief The expression \a exp is unlikely to be true
- */
-#ifndef unlikely
-#   define unlikely(exp)  (exp)
-#endif
-
-/**
- * \def is_constant(exp)
- * \brief Determine if an expression evaluates to a constant value.
- *
- * \param exp Any expression
- *
- * \return true if \a exp is constant, false otherwise.
- */
-#if (defined __GNUC__) || (defined __CC_ARM)
-#   define is_constant(exp)       __builtin_constant_p(exp)
-#else
-#   define is_constant(exp)       (0)
-#endif
-
-//! @}
-
-/*! \name Bit-Field Handling
- */
-//! @{
-
-/*! \brief Reads the bits of a value specified by a given bit-mask.
- *
- * \param value Value to read bits from.
- * \param mask  Bit-mask indicating bits to read.
- *
- * \return Read bits.
- */
-#define Rd_bits( value, mask)        ((value) & (mask))
-
-/*! \brief Writes the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue to write bits to.
- * \param mask    Bit-mask indicating bits to write.
- * \param bits    Bits to write.
- *
- * \return Resulting value with written bits.
- */
-#define Wr_bits(lvalue, mask, bits)  ((lvalue) = ((lvalue) & ~(mask)) |\
-                                                 ((bits  ) &  (mask)))
-
-/*! \brief Tests the bits of a value specified by a given bit-mask.
- *
- * \param value Value of which to test bits.
- * \param mask  Bit-mask indicating bits to test.
- *
- * \return \c 1 if at least one of the tested bits is set, else \c 0.
- */
-#define Tst_bits( value, mask)  (Rd_bits(value, mask) != 0)
-
-/*! \brief Clears the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to clear bits.
- * \param mask    Bit-mask indicating bits to clear.
- *
- * \return Resulting value with cleared bits.
- */
-#define Clr_bits(lvalue, mask)  ((lvalue) &= ~(mask))
-
-/*! \brief Sets the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to set bits.
- * \param mask    Bit-mask indicating bits to set.
- *
- * \return Resulting value with set bits.
- */
-#define Set_bits(lvalue, mask)  ((lvalue) |=  (mask))
-
-/*! \brief Toggles the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to toggle bits.
- * \param mask    Bit-mask indicating bits to toggle.
- *
- * \return Resulting value with toggled bits.
- */
-#define Tgl_bits(lvalue, mask)  ((lvalue) ^=  (mask))
-
-/*! \brief Reads the bit-field of a value specified by a given bit-mask.
- *
- * \param value Value to read a bit-field from.
- * \param mask  Bit-mask indicating the bit-field to read.
- *
- * \return Read bit-field.
- */
-#define Rd_bitfield( value, mask)           (Rd_bits( value, mask) >> ctz(mask))
-
-/*! \brief Writes the bit-field of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue    C lvalue to write a bit-field to.
- * \param mask      Bit-mask indicating the bit-field to write.
- * \param bitfield  Bit-field to write.
- *
- * \return Resulting value with written bit-field.
- */
-#define Wr_bitfield(lvalue, mask, bitfield) (Wr_bits(lvalue, mask, (U32)(bitfield) << ctz(mask)))
-
-//! @}
-
-
-/*! \name Zero-Bit Counting
- *
- * Under GCC, __builtin_clz and __builtin_ctz behave like macros when
- * applied to constant expressions (values known at compile time), so they are
- * more optimized than the use of the corresponding assembly instructions and
- * they can be used as constant expressions e.g. to initialize objects having
- * static storage duration, and like the corresponding assembly instructions
- * when applied to non-constant expressions (values unknown at compile time), so
- * they are more optimized than an assembly periphrasis. Hence, clz and ctz
- * ensure a possible and optimized behavior for both constant and non-constant
- * expressions.
- */
-//! @{
-
-/*! \brief Counts the leading zero bits of the given value considered as a 32-bit integer.
- *
- * \param u Value of which to count the leading zero bits.
- *
- * \return The count of leading zero bits in \a u.
- */
-#ifndef clz
-#if (defined __GNUC__) || (defined __CC_ARM)
-#   define clz(u)              ((u) ? __builtin_clz(u) : 32)
-#elif (defined __ICCARM__)
-#   define clz(u)              ((u) ? __CLZ(u) : 32)
-#else
-#   define clz(u)              (((u) == 0)          ? 32 : \
-                                ((u) & (1UL << 31)) ?  0 : \
-                                ((u) & (1UL << 30)) ?  1 : \
-                                ((u) & (1UL << 29)) ?  2 : \
-                                ((u) & (1UL << 28)) ?  3 : \
-                                ((u) & (1UL << 27)) ?  4 : \
-                                ((u) & (1UL << 26)) ?  5 : \
-                                ((u) & (1UL << 25)) ?  6 : \
-                                ((u) & (1UL << 24)) ?  7 : \
-                                ((u) & (1UL << 23)) ?  8 : \
-                                ((u) & (1UL << 22)) ?  9 : \
-                                ((u) & (1UL << 21)) ? 10 : \
-                                ((u) & (1UL << 20)) ? 11 : \
-                                ((u) & (1UL << 19)) ? 12 : \
-                                ((u) & (1UL << 18)) ? 13 : \
-                                ((u) & (1UL << 17)) ? 14 : \
-                                ((u) & (1UL << 16)) ? 15 : \
-                                ((u) & (1UL << 15)) ? 16 : \
-                                ((u) & (1UL << 14)) ? 17 : \
-                                ((u) & (1UL << 13)) ? 18 : \
-                                ((u) & (1UL << 12)) ? 19 : \
-                                ((u) & (1UL << 11)) ? 20 : \
-                                ((u) & (1UL << 10)) ? 21 : \
-                                ((u) & (1UL <<  9)) ? 22 : \
-                                ((u) & (1UL <<  8)) ? 23 : \
-                                ((u) & (1UL <<  7)) ? 24 : \
-                                ((u) & (1UL <<  6)) ? 25 : \
-                                ((u) & (1UL <<  5)) ? 26 : \
-                                ((u) & (1UL <<  4)) ? 27 : \
-                                ((u) & (1UL <<  3)) ? 28 : \
-                                ((u) & (1UL <<  2)) ? 29 : \
-                                ((u) & (1UL <<  1)) ? 30 : \
-                                31)
-#endif
-#endif
-
-/*! \brief Counts the trailing zero bits of the given value considered as a 32-bit integer.
- *
- * \param u Value of which to count the trailing zero bits.
- *
- * \return The count of trailing zero bits in \a u.
- */
-#ifndef ctz
-#if (defined __GNUC__) || (defined __CC_ARM)
-#   define ctz(u)              ((u) ? __builtin_ctz(u) : 32)
-#else
-#   define ctz(u)              ((u) & (1UL <<  0) ?  0 : \
-                                (u) & (1UL <<  1) ?  1 : \
-                                (u) & (1UL <<  2) ?  2 : \
-                                (u) & (1UL <<  3) ?  3 : \
-                                (u) & (1UL <<  4) ?  4 : \
-                                (u) & (1UL <<  5) ?  5 : \
-                                (u) & (1UL <<  6) ?  6 : \
-                                (u) & (1UL <<  7) ?  7 : \
-                                (u) & (1UL <<  8) ?  8 : \
-                                (u) & (1UL <<  9) ?  9 : \
-                                (u) & (1UL << 10) ? 10 : \
-                                (u) & (1UL << 11) ? 11 : \
-                                (u) & (1UL << 12) ? 12 : \
-                                (u) & (1UL << 13) ? 13 : \
-                                (u) & (1UL << 14) ? 14 : \
-                                (u) & (1UL << 15) ? 15 : \
-                                (u) & (1UL << 16) ? 16 : \
-                                (u) & (1UL << 17) ? 17 : \
-                                (u) & (1UL << 18) ? 18 : \
-                                (u) & (1UL << 19) ? 19 : \
-                                (u) & (1UL << 20) ? 20 : \
-                                (u) & (1UL << 21) ? 21 : \
-                                (u) & (1UL << 22) ? 22 : \
-                                (u) & (1UL << 23) ? 23 : \
-                                (u) & (1UL << 24) ? 24 : \
-                                (u) & (1UL << 25) ? 25 : \
-                                (u) & (1UL << 26) ? 26 : \
-                                (u) & (1UL << 27) ? 27 : \
-                                (u) & (1UL << 28) ? 28 : \
-                                (u) & (1UL << 29) ? 29 : \
-                                (u) & (1UL << 30) ? 30 : \
-                                (u) & (1UL << 31) ? 31 : \
-                                32)
-#endif
-#endif
-
-//! @}
-
-
-/*! \name Bit Reversing
- */
-//! @{
-
-/*! \brief Reverses the bits of \a u8.
- *
- * \param u8  U8 of which to reverse the bits.
- *
- * \return Value resulting from \a u8 with reversed bits.
- */
-#define bit_reverse8(u8)    ((U8)(bit_reverse32((U8)(u8)) >> 24))
-
-/*! \brief Reverses the bits of \a u16.
- *
- * \param u16 U16 of which to reverse the bits.
- *
- * \return Value resulting from \a u16 with reversed bits.
- */
-#define bit_reverse16(u16)  ((U16)(bit_reverse32((U16)(u16)) >> 16))
-
-/*! \brief Reverses the bits of \a u32.
- *
- * \param u32 U32 of which to reverse the bits.
- *
- * \return Value resulting from \a u32 with reversed bits.
- */
-#define bit_reverse32(u32)   __RBIT(u32)
-
-/*! \brief Reverses the bits of \a u64.
- *
- * \param u64 U64 of which to reverse the bits.
- *
- * \return Value resulting from \a u64 with reversed bits.
- */
-#define bit_reverse64(u64)  ((U64)(((U64)bit_reverse32((U64)(u64) >> 32)) |\
-                                   ((U64)bit_reverse32((U64)(u64)) << 32)))
-
-//! @}
-
-
-/*! \name Alignment
- */
-//! @{
-
-/*! \brief Tests alignment of the number \a val with the \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return \c 1 if the number \a val is aligned with the \a n boundary, else \c 0.
- */
-#define Test_align(val, n     ) (!Tst_bits( val, (n) - 1     )   )
-
-/*! \brief Gets alignment of the number \a val with respect to the \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Alignment of the number \a val with respect to the \a n boundary.
- */
-#define Get_align( val, n     ) (  Rd_bits( val, (n) - 1     )   )
-
-/*! \brief Sets alignment of the lvalue number \a lval to \a alg with respect to the \a n boundary.
- *
- * \param lval  Input/output lvalue.
- * \param n     Boundary.
- * \param alg   Alignment.
- *
- * \return New value of \a lval resulting from its alignment set to \a alg with respect to the \a n boundary.
- */
-#define Set_align(lval, n, alg) (  Wr_bits(lval, (n) - 1, alg)   )
-
-/*! \brief Aligns the number \a val with the upper \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Value resulting from the number \a val aligned with the upper \a n boundary.
- */
-#define Align_up(  val, n     ) (((val) + ((n) - 1)) & ~((n) - 1))
-
-/*! \brief Aligns the number \a val with the lower \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Value resulting from the number \a val aligned with the lower \a n boundary.
- */
-#define Align_down(val, n     ) ( (val)              & ~((n) - 1))
-
-//! @}
-
-/*! \brief Calls the routine at address \a addr.
- *
- * It generates a long call opcode.
- *
- * For example, `Long_call(0x80000000)' generates a software reset on a UC3 if
- * it is invoked from the CPU supervisor mode.
- *
- * \param addr  Address of the routine to call.
- *
- * \note It may be used as a long jump opcode in some special cases.
- */
-#define Long_call(addr)                   ((*(void (*)(void))(addr))())
-
-
-/*! \name MCU Endianism Handling
- * ARM is MCU little endianism.
- */
-//! @{
-#define  MSB(u16)       (((U8  *)&(u16))[1]) //!< Most significant byte of \a u16.
-#define  LSB(u16)       (((U8  *)&(u16))[0]) //!< Least significant byte of \a u16.
-
-#define  MSH(u32)       (((U16 *)&(u32))[1]) //!< Most significant half-word of \a u32.
-#define  LSH(u32)       (((U16 *)&(u32))[0]) //!< Least significant half-word of \a u32.
-#define  MSB0W(u32)     (((U8  *)&(u32))[3]) //!< Most significant byte of 1st rank of \a u32.
-#define  MSB1W(u32)     (((U8  *)&(u32))[2]) //!< Most significant byte of 2nd rank of \a u32.
-#define  MSB2W(u32)     (((U8  *)&(u32))[1]) //!< Most significant byte of 3rd rank of \a u32.
-#define  MSB3W(u32)     (((U8  *)&(u32))[0]) //!< Most significant byte of 4th rank of \a u32.
-#define  LSB3W(u32)     MSB0W(u32)           //!< Least significant byte of 4th rank of \a u32.
-#define  LSB2W(u32)     MSB1W(u32)           //!< Least significant byte of 3rd rank of \a u32.
-#define  LSB1W(u32)     MSB2W(u32)           //!< Least significant byte of 2nd rank of \a u32.
-#define  LSB0W(u32)     MSB3W(u32)           //!< Least significant byte of 1st rank of \a u32.
-
-#define  MSW(u64)       (((U32 *)&(u64))[1]) //!< Most significant word of \a u64.
-#define  LSW(u64)       (((U32 *)&(u64))[0]) //!< Least significant word of \a u64.
-#define  MSH0(u64)      (((U16 *)&(u64))[3]) //!< Most significant half-word of 1st rank of \a u64.
-#define  MSH1(u64)      (((U16 *)&(u64))[2]) //!< Most significant half-word of 2nd rank of \a u64.
-#define  MSH2(u64)      (((U16 *)&(u64))[1]) //!< Most significant half-word of 3rd rank of \a u64.
-#define  MSH3(u64)      (((U16 *)&(u64))[0]) //!< Most significant half-word of 4th rank of \a u64.
-#define  LSH3(u64)      MSH0(u64)            //!< Least significant half-word of 4th rank of \a u64.
-#define  LSH2(u64)      MSH1(u64)            //!< Least significant half-word of 3rd rank of \a u64.
-#define  LSH1(u64)      MSH2(u64)            //!< Least significant half-word of 2nd rank of \a u64.
-#define  LSH0(u64)      MSH3(u64)            //!< Least significant half-word of 1st rank of \a u64.
-#define  MSB0D(u64)     (((U8  *)&(u64))[7]) //!< Most significant byte of 1st rank of \a u64.
-#define  MSB1D(u64)     (((U8  *)&(u64))[6]) //!< Most significant byte of 2nd rank of \a u64.
-#define  MSB2D(u64)     (((U8  *)&(u64))[5]) //!< Most significant byte of 3rd rank of \a u64.
-#define  MSB3D(u64)     (((U8  *)&(u64))[4]) //!< Most significant byte of 4th rank of \a u64.
-#define  MSB4D(u64)     (((U8  *)&(u64))[3]) //!< Most significant byte of 5th rank of \a u64.
-#define  MSB5D(u64)     (((U8  *)&(u64))[2]) //!< Most significant byte of 6th rank of \a u64.
-#define  MSB6D(u64)     (((U8  *)&(u64))[1]) //!< Most significant byte of 7th rank of \a u64.
-#define  MSB7D(u64)     (((U8  *)&(u64))[0]) //!< Most significant byte of 8th rank of \a u64.
-#define  LSB7D(u64)     MSB0D(u64)           //!< Least significant byte of 8th rank of \a u64.
-#define  LSB6D(u64)     MSB1D(u64)           //!< Least significant byte of 7th rank of \a u64.
-#define  LSB5D(u64)     MSB2D(u64)           //!< Least significant byte of 6th rank of \a u64.
-#define  LSB4D(u64)     MSB3D(u64)           //!< Least significant byte of 5th rank of \a u64.
-#define  LSB3D(u64)     MSB4D(u64)           //!< Least significant byte of 4th rank of \a u64.
-#define  LSB2D(u64)     MSB5D(u64)           //!< Least significant byte of 3rd rank of \a u64.
-#define  LSB1D(u64)     MSB6D(u64)           //!< Least significant byte of 2nd rank of \a u64.
-#define  LSB0D(u64)     MSB7D(u64)           //!< Least significant byte of 1st rank of \a u64.
-
-#define  BE16(x)        swap16(x)
-#define  LE16(x)        (x)
-
-#define  le16_to_cpu(x) (x)
-#define  cpu_to_le16(x) (x)
-#define  LE16_TO_CPU(x) (x)
-#define  CPU_TO_LE16(x) (x)
-
-#define  be16_to_cpu(x) swap16(x)
-#define  cpu_to_be16(x) swap16(x)
-#define  BE16_TO_CPU(x) swap16(x)
-#define  CPU_TO_BE16(x) swap16(x)
-
-#define  le32_to_cpu(x) (x)
-#define  cpu_to_le32(x) (x)
-#define  LE32_TO_CPU(x) (x)
-#define  CPU_TO_LE32(x) (x)
-
-#define  be32_to_cpu(x) swap32(x)
-#define  cpu_to_be32(x) swap32(x)
-#define  BE32_TO_CPU(x) swap32(x)
-#define  CPU_TO_BE32(x) swap32(x)
-//! @}
-
-
-/*! \name Endianism Conversion
- *
- * The same considerations as for clz and ctz apply here but GCC's
- * __builtin_bswap_32 and __builtin_bswap_64 do not behave like macros when
- * applied to constant expressions, so two sets of macros are defined here:
- *   - Swap16, Swap32 and Swap64 to apply to constant expressions (values known
- *     at compile time);
- *   - swap16, swap32 and swap64 to apply to non-constant expressions (values
- *     unknown at compile time).
- */
-//! @{
-
-/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
- *
- * \param u16 U16 of which to toggle the endianism.
- *
- * \return Value resulting from \a u16 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap16(u16) ((U16)(((U16)(u16) >> 8) |\
-                           ((U16)(u16) << 8)))
-
-/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
- *
- * \param u32 U32 of which to toggle the endianism.
- *
- * \return Value resulting from \a u32 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap32(u32) ((U32)(((U32)Swap16((U32)(u32) >> 16)) |\
-                           ((U32)Swap16((U32)(u32)) << 16)))
-
-/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
- *
- * \param u64 U64 of which to toggle the endianism.
- *
- * \return Value resulting from \a u64 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap64(u64) ((U64)(((U64)Swap32((U64)(u64) >> 32)) |\
-                           ((U64)Swap32((U64)(u64)) << 32)))
-
-/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
- *
- * \param u16 U16 of which to toggle the endianism.
- *
- * \return Value resulting from \a u16 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#define swap16(u16) Swap16(u16)
-
-/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
- *
- * \param u32 U32 of which to toggle the endianism.
- *
- * \return Value resulting from \a u32 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if (defined __GNUC__)
-#   define swap32(u32) ((U32)__builtin_bswap32((U32)(u32)))
-#else
-#   define swap32(u32) Swap32(u32)
-#endif
-
-/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
- *
- * \param u64 U64 of which to toggle the endianism.
- *
- * \return Value resulting from \a u64 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if (defined __GNUC__)
-#   define swap64(u64) ((U64)__builtin_bswap64((U64)(u64)))
-#else
-#   define swap64(u64) ((U64)(((U64)swap32((U64)(u64) >> 32)) |\
-                           ((U64)swap32((U64)(u64)) << 32)))
-#endif
-
-//! @}
-
-
-/*! \name Target Abstraction
- */
-//! @{
-
-#define _GLOBEXT_           extern      //!< extern storage-class specifier.
-#define _CONST_TYPE_        const       //!< const type qualifier.
-#define _MEM_TYPE_SLOW_                 //!< Slow memory type.
-#define _MEM_TYPE_MEDFAST_              //!< Fairly fast memory type.
-#define _MEM_TYPE_FAST_                 //!< Fast memory type.
-
-typedef U8                  Byte;       //!< 8-bit unsigned integer.
-
-#define memcmp_ram2ram      memcmp      //!< Target-specific memcmp of RAM to RAM.
-#define memcmp_code2ram     memcmp      //!< Target-specific memcmp of RAM to NVRAM.
-#define memcpy_ram2ram      memcpy      //!< Target-specific memcpy from RAM to RAM.
-#define memcpy_code2ram     memcpy      //!< Target-specific memcpy from NVRAM to RAM.
-
-#define LSB0(u32)           LSB0W(u32)  //!< Least significant byte of 1st rank of \a u32.
-#define LSB1(u32)           LSB1W(u32)  //!< Least significant byte of 2nd rank of \a u32.
-#define LSB2(u32)           LSB2W(u32)  //!< Least significant byte of 3rd rank of \a u32.
-#define LSB3(u32)           LSB3W(u32)  //!< Least significant byte of 4th rank of \a u32.
-#define MSB3(u32)           MSB3W(u32)  //!< Most significant byte of 4th rank of \a u32.
-#define MSB2(u32)           MSB2W(u32)  //!< Most significant byte of 3rd rank of \a u32.
-#define MSB1(u32)           MSB1W(u32)  //!< Most significant byte of 2nd rank of \a u32.
-#define MSB0(u32)           MSB0W(u32)  //!< Most significant byte of 1st rank of \a u32.
-
-//! @}
-
-/**
- * \brief Calculate \f$ \left\lceil \frac{a}{b} \right\rceil \f$ using
- * integer arithmetic.
- *
- * \param a An integer
- * \param b Another integer
- *
- * \return (\a a / \a b) rounded up to the nearest integer.
- */
-#define div_ceil(a, b)      (((a) + (b) - 1) / (b))
-
-#endif  // #ifndef __ASSEMBLY__
-
-
-#ifdef __ICCARM__
-#define SHORTENUM           __packed
-#elif defined(__GNUC__)
-#define SHORTENUM           __attribute__((packed))
-#endif
-
-/* No operation */
-#ifdef __ICCARM__
-#define nop()               __no_operation()
-#elif defined(__GNUC__)
-#define nop()               (__NOP())
-#endif
-
-#define FLASH_DECLARE(x)  const x
-#define FLASH_EXTERN(x) extern const x
-#define PGM_READ_BYTE(x) *(x)
-#define PGM_READ_WORD(x) *(x)
-#define PGM_READ_DWORD(x) *(x)
-#define MEMCPY_ENDIAN memcpy
-#define PGM_READ_BLOCK(dst, src, len) memcpy((dst), (src), (len))
-
-/*Defines the Flash Storage for the request and response of MAC*/
-#define CMD_ID_OCTET    (0)
-
-/* Converting of values from CPU endian to little endian. */
-#define CPU_ENDIAN_TO_LE16(x)   (x)
-#define CPU_ENDIAN_TO_LE32(x)   (x)
-#define CPU_ENDIAN_TO_LE64(x)   (x)
-
-/* Converting of values from little endian to CPU endian. */
-#define LE16_TO_CPU_ENDIAN(x)   (x)
-#define LE32_TO_CPU_ENDIAN(x)   (x)
-#define LE64_TO_CPU_ENDIAN(x)   (x)
-
-/* Converting of constants from little endian to CPU endian. */
-#define CLE16_TO_CPU_ENDIAN(x)  (x)
-#define CLE32_TO_CPU_ENDIAN(x)  (x)
-#define CLE64_TO_CPU_ENDIAN(x)  (x)
-
-/* Converting of constants from CPU endian to little endian. */
-#define CCPU_ENDIAN_TO_LE16(x)  (x)
-#define CCPU_ENDIAN_TO_LE32(x)  (x)
-#define CCPU_ENDIAN_TO_LE64(x)  (x)
-
-#define ADDR_COPY_DST_SRC_16(dst, src)  ((dst) = (src))
-#define ADDR_COPY_DST_SRC_64(dst, src)  ((dst) = (src))
-
-/**
- * @brief Converts a 64-Bit value into  a 8 Byte array
- *
- * @param[in] value 64-Bit value
- * @param[out] data Pointer to the 8 Byte array to be updated with 64-Bit value
- * @ingroup apiPalApi
- */
-static inline void convert_64_bit_to_byte_array(uint64_t value, uint8_t *data)
-{
-    uint8_t val_index = 0;
-
-    while (val_index < 8)
-    {
-        data[val_index++] = value & 0xFF;
-        value >>= 8;
-    }
-}
-
-/**
- * @brief Converts a 16-Bit value into  a 2 Byte array
- *
- * @param[in] value 16-Bit value
- * @param[out] data Pointer to the 2 Byte array to be updated with 16-Bit value
- * @ingroup apiPalApi
- */
-static inline void convert_16_bit_to_byte_array(uint16_t value, uint8_t *data)
-{
-    data[0] = value & 0xFF;
-    data[1] = (value >> 8) & 0xFF;
-}
-
-/* Converts a 16-Bit value into a 2 Byte array */
-static inline void convert_spec_16_bit_to_byte_array(uint16_t value, uint8_t *data)
-{
-    data[0] = value & 0xFF;
-    data[1] = (value >> 8) & 0xFF;
-}
-
-/* Converts a 16-Bit value into a 2 Byte array */
-static inline void convert_16_bit_to_byte_address(uint16_t value, uint8_t *data)
-{
-    data[0] = value & 0xFF;
-    data[1] = (value >> 8) & 0xFF;
-}
-
-/*
- * @brief Converts a 2 Byte array into a 16-Bit value
- *
- * @param data Specifies the pointer to the 2 Byte array
- *
- * @return 16-Bit value
- * @ingroup apiPalApi
- */
-static inline uint16_t convert_byte_array_to_16_bit(uint8_t *data)
-{
-    return (data[0] | ((uint16_t)data[1] << 8));
-}
-
-/* Converts a 8 Byte array into a 32-Bit value */
-static inline uint32_t convert_byte_array_to_32_bit(uint8_t *data)
-{
-  union
-  {
-    uint32_t u32;
-    uint8_t u8[8];
-  }long_addr;
-  uint8_t index;
-  for (index = 0; index < 4; index++) {
-    long_addr.u8[index] = *data++;
-  }
-  return long_addr.u32;
-}
-
-/**
- * @brief Converts a 8 Byte array into a 64-Bit value
- *
- * @param data Specifies the pointer to the 8 Byte array
- *
- * @return 64-Bit value
- * @ingroup apiPalApi
- */
-static inline uint64_t convert_byte_array_to_64_bit(uint8_t *data)
-{
-    union
-    {
-        uint64_t u64;
-        uint8_t u8[8];
-    } long_addr;
-
-    uint8_t val_index;
-
-    for (val_index = 0; val_index < 8; val_index++)
-    {
-        long_addr.u8[val_index] = *data++;
-    }
-
-    return long_addr.u64;
-}
-/**
- * \}
- */
-
-#endif /* UTILS_COMPILER_H */
diff --git a/Marlin/src/HAL/DUE/usb/conf_access.h b/Marlin/src/HAL/DUE/usb/conf_access.h
deleted file mode 100644
index f401685..0000000
--- a/Marlin/src/HAL/DUE/usb/conf_access.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * \file
- *
- * \brief Memory access control configuration file.
- *
- * Copyright (c) 2012-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _CONF_ACCESS_H_
-#define _CONF_ACCESS_H_
-
-#include "compiler.h"
-#include "../../../inc/MarlinConfigPre.h"
-
-/*! \name Activation of Logical Unit Numbers
- */
-//! @{
-
-#define LUN_0                ENABLE    //!< SD/MMC Card over MCI Slot 0.
-#define LUN_1                DISABLE
-#define LUN_2                DISABLE
-#define LUN_3                DISABLE
-#define LUN_4                DISABLE
-#define LUN_5                DISABLE
-#define LUN_6                DISABLE
-#define LUN_7                DISABLE
-#define LUN_USB              DISABLE
-//! @}
-
-/*! \name LUN 0 Definitions
- */
-//! @{
-#define SD_MMC_SPI_MEM                          LUN_0
-#define LUN_ID_SD_MMC_SPI_MEM                   LUN_ID_0
-#define LUN_0_INCLUDE                           "sd_mmc_spi_mem.h"
-#define Lun_0_test_unit_ready                   sd_mmc_spi_test_unit_ready
-#define Lun_0_read_capacity                     sd_mmc_spi_read_capacity
-#define Lun_0_unload                            sd_mmc_spi_unload
-#define Lun_0_wr_protect                        sd_mmc_spi_wr_protect
-#define Lun_0_removal                           sd_mmc_spi_removal
-#define Lun_0_usb_read_10                       sd_mmc_spi_usb_read_10
-#define Lun_0_usb_write_10                      sd_mmc_spi_usb_write_10
-#define LUN_0_NAME                              "\"SD/MMC Card\""
-//! @}
-
-
-/*! \name Actions Associated with Memory Accesses
- *
- * Write here the action to associate with each memory access.
- *
- * \warning Be careful not to waste time in order not to disturb the functions.
- */
-//! @{
-#define memory_start_read_action(nb_sectors)
-#define memory_stop_read_action()
-#define memory_start_write_action(nb_sectors)
-#define memory_stop_write_action()
-//! @}
-
-/*! \name Activation of Interface Features
- */
-//! @{
-#define ACCESS_USB           true    //!< MEM <-> USB interface.
-#define ACCESS_MEM_TO_RAM    false   //!< MEM <-> RAM interface.
-#define ACCESS_STREAM        false   //!< Streaming MEM <-> MEM interface.
-#define ACCESS_STREAM_RECORD false   //!< Streaming MEM <-> MEM interface in record mode.
-#define ACCESS_MEM_TO_MEM    false   //!< MEM <-> MEM interface.
-#define ACCESS_CODEC         false   //!< Codec interface.
-//! @}
-
-/*! \name Specific Options for Access Control
- */
-//! @{
-#define GLOBAL_WR_PROTECT    false   //!< Management of a global write protection.
-//! @}
-
-
-#endif // _CONF_ACCESS_H_
diff --git a/Marlin/src/HAL/DUE/usb/conf_clock.h b/Marlin/src/HAL/DUE/usb/conf_clock.h
deleted file mode 100644
index 97e70e9..0000000
--- a/Marlin/src/HAL/DUE/usb/conf_clock.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * \file
- *
- * \brief SAM3X clock configuration.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef CONF_CLOCK_H_INCLUDED
-#define CONF_CLOCK_H_INCLUDED
-
-// ===== System Clock (MCK) Source Options
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_SLCK_RC
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_SLCK_XTAL
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_SLCK_BYPASS
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_MAINCK_4M_RC
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_MAINCK_8M_RC
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_MAINCK_12M_RC
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_MAINCK_XTAL
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_MAINCK_BYPASS
-#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_PLLACK
-//#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_UPLLCK
-
-// ===== System Clock (MCK) Prescaler Options   (Fmck = Fsys / (SYSCLK_PRES))
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_1
-#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_2
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_4
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_8
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_16
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_32
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_64
-//#define CONFIG_SYSCLK_PRES          SYSCLK_PRES_3
-
-// ===== PLL0 (A) Options   (Fpll = (Fclk * PLL_mul) / PLL_div)
-// Use mul and div effective values here.
-#define CONFIG_PLL0_SOURCE          PLL_SRC_MAINCK_XTAL
-#define CONFIG_PLL0_MUL             14
-#define CONFIG_PLL0_DIV             1
-
-// ===== UPLL (UTMI) Hardware fixed at 480MHz.
-
-// ===== USB Clock Source Options   (Fusb = FpllX / USB_div)
-// Use div effective value here.
-//#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_PLL0
-#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_UPLL
-#define CONFIG_USBCLK_DIV           1
-
-// ===== Target frequency (System clock)
-// - XTAL frequency: 12MHz
-// - System clock source: PLLA
-// - System clock prescaler: 2 (divided by 2)
-// - PLLA source: XTAL
-// - PLLA output: XTAL * 14 / 1
-// - System clock is: 12 * 14 / 1 /2 = 84MHz
-// ===== Target frequency (USB Clock)
-// - USB clock source: UPLL
-// - USB clock divider: 1 (not divided)
-// - UPLL frequency: 480MHz
-// - USB clock: 480 / 1 = 480MHz
-
-
-#endif /* CONF_CLOCK_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/conf_usb.h b/Marlin/src/HAL/DUE/usb/conf_usb.h
deleted file mode 100644
index 4de9e34..0000000
--- a/Marlin/src/HAL/DUE/usb/conf_usb.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/**
- * \file
- *
- * \brief USB configuration file
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _CONF_USB_H_
-#define _CONF_USB_H_
-
-#undef UNUSED                           /* To avoid a macro clash as macros.h already defines it */
-#include "../../../inc/MarlinConfigPre.h"
-#include "compiler.h"
-
-/**
- * USB Device Configuration
- * @{
- */
-
-//! Device definition (mandatory)
-#define  USB_DEVICE_MAJOR_VERSION         1
-#define  USB_DEVICE_MINOR_VERSION         0
-#define  USB_DEVICE_POWER                 100 // Consumption on Vbus line (mA)
-#define  USB_DEVICE_ATTR                  \
-  (USB_CONFIG_ATTR_SELF_POWERED)
-// (USB_CONFIG_ATTR_BUS_POWERED)
-//  (USB_CONFIG_ATTR_REMOTE_WAKEUP|USB_CONFIG_ATTR_SELF_POWERED)
-//  (USB_CONFIG_ATTR_REMOTE_WAKEUP|USB_CONFIG_ATTR_BUS_POWERED)
-
-/**
- * Device speeds support
- * Low speed not supported by CDC and MSC
- * @{
- */
-
-//! To define a Low speed device
-//#define  USB_DEVICE_LOW_SPEED
-
-//! To define a Full speed device
-//#define USB_DEVICE_FULL_SPEED
-
-//! To authorize the High speed
-#ifndef USB_DEVICE_FULL_SPEED
-  #if (UC3A3||UC3A4)
-    #define  USB_DEVICE_HS_SUPPORT
-  #elif (SAM3XA||SAM3U)
-    #define  USB_DEVICE_HS_SUPPORT
-  #endif
-#endif
-//@}
-
-
-/**
- * USB Device Callbacks definitions (Optional)
- * @{
- */
-#define  UDC_VBUS_EVENT(b_vbus_high)
-#define  UDC_SOF_EVENT()
-#define  UDC_SUSPEND_EVENT()
-#define  UDC_RESUME_EVENT()
-#define  UDC_GET_EXTRA_STRING()         usb_task_extra_string()
-#define  USB_DEVICE_SPECIFIC_REQUEST()  usb_task_other_requests()
-//@}
-
-#if ENABLED(SDSUPPORT)
-  /**
-   * USB Device low level configuration
-   * When only one interface is used, these configurations are defined by the class module.
-   * For composite device, these configuration must be defined here
-   * @{
-   */
-  //! Control endpoint size
-  #define  USB_DEVICE_EP_CTRL_SIZE       64
-
-  //! Two interfaces for this device (CDC COM + CDC DATA + MSC)
-  #define  USB_DEVICE_NB_INTERFACE       3
-
-  //! 5 endpoints used by CDC and MSC interfaces
-  #if SAM3U
-  // (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
-  // (6 | USB_EP_DIR_IN)  // CDC TX
-  // (5 | USB_EP_DIR_OUT) // CDC RX
-  // (1 | USB_EP_DIR_IN)  // MSC IN
-  // (2 | USB_EP_DIR_OUT) // MSC OUT
-  #  define  USB_DEVICE_MAX_EP           6
-  #  if defined(USB_DEVICE_HS_SUPPORT)
-  // In HS mode, size of bulk endpoints are 512
-  // If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
-  // endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
-  // endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
-  #     define  UDD_BULK_NB_BANK(ep) ((ep == 5 || ep== 6) ? 1 : 2)
-  #endif
-  #else
-  // (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
-  // (4 | USB_EP_DIR_IN)  // CDC TX
-  // (5 | USB_EP_DIR_OUT) // CDC RX
-  // (1 | USB_EP_DIR_IN)  // MSC IN
-  // (2 | USB_EP_DIR_OUT) // MSC OUT
-  #  define  USB_DEVICE_MAX_EP           5
-  #  if SAM3XA && defined(USB_DEVICE_HS_SUPPORT)
-  // In HS mode, size of bulk endpoints are 512
-  // If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
-  // endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
-  // endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
-  #     define  UDD_BULK_NB_BANK(ep) ((ep == 4 || ep== 5) ? 1 : 2)
-  #  endif
-  #endif
-#endif
-
-//@}
-
-//@}
-
-
-/**
- * USB Interface Configuration
- * @{
- */
-/**
- * Configuration of CDC interface
- * @{
- */
-
-//! Define one USB communication ports
-#define  UDI_CDC_PORT_NB 1
-
-//! Interface callback definition
-#define  UDI_CDC_ENABLE_EXT(port)         usb_task_cdc_enable(port)
-#define  UDI_CDC_DISABLE_EXT(port)        usb_task_cdc_disable(port)
-#define  UDI_CDC_RX_NOTIFY(port)          usb_task_cdc_rx_notify(port)
-#define  UDI_CDC_TX_EMPTY_NOTIFY(port)
-#define  UDI_CDC_SET_CODING_EXT(port,cfg) usb_task_cdc_config(port,cfg)
-#define  UDI_CDC_SET_DTR_EXT(port,set)    usb_task_cdc_set_dtr(port,set)
-#define  UDI_CDC_SET_RTS_EXT(port,set)
-
-//! Define it when the transfer CDC Device to Host is a low rate (<512000 bauds)
-//! to reduce CDC buffers size
-//#define  UDI_CDC_LOW_RATE
-
-//! Default configuration of communication port
-#define  UDI_CDC_DEFAULT_RATE             115200
-#define  UDI_CDC_DEFAULT_STOPBITS         CDC_STOP_BITS_1
-#define  UDI_CDC_DEFAULT_PARITY           CDC_PAR_NONE
-#define  UDI_CDC_DEFAULT_DATABITS         8
-
-//! Enable id string of interface to add an extra USB string
-#define  UDI_CDC_IAD_STRING_ID            4
-
-#if ENABLED(SDSUPPORT)
-  /**
-   * USB CDC low level configuration
-   * In standalone these configurations are defined by the CDC module.
-   * For composite device, these configuration must be defined here
-   * @{
-   */
-  //! Endpoint numbers definition
-  #if SAM3U
-  #  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
-  #  define  UDI_CDC_DATA_EP_IN_0          (6 | USB_EP_DIR_IN) // TX
-  #  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
-  #else
-  #  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
-  #  define  UDI_CDC_DATA_EP_IN_0          (4 | USB_EP_DIR_IN) // TX
-  #  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
-  #endif
-
-  //! Interface numbers
-  #define  UDI_CDC_COMM_IFACE_NUMBER_0   0
-  #define  UDI_CDC_DATA_IFACE_NUMBER_0   1
-
-  //@}
-  //@}
-
-
-  /**
-   * Configuration of MSC interface
-   * @{
-   */
-  //! Vendor name and Product version of MSC interface
-  #define UDI_MSC_GLOBAL_VENDOR_ID            \
-     'M', 'A', 'R', 'L', 'I', 'N', '3', 'D'
-  #define UDI_MSC_GLOBAL_PRODUCT_VERSION            \
-     '1', '.', '0', '0'
-
-  //! Interface callback definition
-  #define  UDI_MSC_ENABLE_EXT()          usb_task_msc_enable()
-  #define  UDI_MSC_DISABLE_EXT()         usb_task_msc_disable()
-
-  //! Enable id string of interface to add an extra USB string
-  #define  UDI_MSC_STRING_ID             5
-
-  /**
-   * USB MSC low level configuration
-   * In standalone these configurations are defined by the MSC module.
-   * For composite device, these configuration must be defined here
-   * @{
-   */
-  //! Endpoint numbers definition
-  #define  UDI_MSC_EP_IN                 (1 | USB_EP_DIR_IN)
-  #define  UDI_MSC_EP_OUT                (2 | USB_EP_DIR_OUT)
-
-  //! Interface number
-  #define  UDI_MSC_IFACE_NUMBER          2
-  //@}
-  //@}
-
-  //@}
-
-
-  /**
-   * Description of Composite Device
-   * @{
-   */
-  //! USB Interfaces descriptor structure
-  #define UDI_COMPOSITE_DESC_T \
-    usb_iad_desc_t       udi_cdc_iad; \
-    udi_cdc_comm_desc_t  udi_cdc_comm; \
-    udi_cdc_data_desc_t  udi_cdc_data; \
-    udi_msc_desc_t       udi_msc
-
-  //! USB Interfaces descriptor value for Full Speed
-  #define UDI_COMPOSITE_DESC_FS \
-    .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
-    .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
-    .udi_cdc_data  = UDI_CDC_DATA_DESC_0_FS, \
-    .udi_msc       = UDI_MSC_DESC_FS
-
-  //! USB Interfaces descriptor value for High Speed
-  #define UDI_COMPOSITE_DESC_HS \
-    .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
-    .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
-    .udi_cdc_data  = UDI_CDC_DATA_DESC_0_HS, \
-    .udi_msc       = UDI_MSC_DESC_HS
-
-  //! USB Interface APIs
-  #define UDI_COMPOSITE_API \
-    &udi_api_cdc_comm, \
-    &udi_api_cdc_data, \
-    &udi_api_msc
-  //@}
-
-  /**
-   * USB Device Driver Configuration
-   * @{
-   */
-  //@}
-
-  //! The includes of classes and other headers must be done at the end of this file to avoid compile error
-  #include "udi_cdc.h"
-  #include "udi_msc.h"
-#else
-  #include "udi_cdc_conf.h"
-#endif
-
-#include "usb_task.h"
-
-#endif // _CONF_USB_H_
diff --git a/Marlin/src/HAL/DUE/usb/ctrl_access.c b/Marlin/src/HAL/DUE/usb/ctrl_access.c
deleted file mode 100644
index 99f97f6..0000000
--- a/Marlin/src/HAL/DUE/usb/ctrl_access.c
+++ /dev/null
@@ -1,647 +0,0 @@
-/*****************************************************************************
- *
- * \file
- *
- * \brief Abstraction layer for memory interfaces.
- *
- * This module contains the interfaces:
- *   - MEM <-> USB;
- *   - MEM <-> RAM;
- *   - MEM <-> MEM.
- *
- * This module may be configured and expanded to support the following features:
- *   - write-protected globals;
- *   - password-protected data;
- *   - specific features;
- *   - etc.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- ******************************************************************************/
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-//_____ I N C L U D E S ____________________________________________________
-
-#include "compiler.h"
-#include "preprocessor.h"
-#ifdef FREERTOS_USED
-#include "FreeRTOS.h"
-#include "semphr.h"
-#endif
-#include "ctrl_access.h"
-
-
-//_____ D E F I N I T I O N S ______________________________________________
-
-#ifdef FREERTOS_USED
-
-/*! \name LUN Access Protection Macros
- */
-//! @{
-
-/*! \brief Locks accesses to LUNs.
- *
- * \return \c true if the access was successfully locked, else \c false.
- */
-#define Ctrl_access_lock()    ctrl_access_lock()
-
-/*! \brief Unlocks accesses to LUNs.
- */
-#define Ctrl_access_unlock()  xSemaphoreGive(ctrl_access_semphr)
-
-//! @}
-
-//! Handle to the semaphore protecting accesses to LUNs.
-static xSemaphoreHandle ctrl_access_semphr = NULL;
-
-#else
-
-/*! \name LUN Access Protection Macros
- */
-//! @{
-
-/*! \brief Locks accesses to LUNs.
- *
- * \return \c true if the access was successfully locked, else \c false.
- */
-#define Ctrl_access_lock()    true
-
-/*! \brief Unlocks accesses to LUNs.
- */
-#define Ctrl_access_unlock()
-
-//! @}
-
-#endif  // FREERTOS_USED
-
-
-#if MAX_LUN
-
-/*! \brief Initializes an entry of the LUN descriptor table.
- *
- * \param lun Logical Unit Number.
- *
- * \return LUN descriptor table entry initializer.
- */
-#if ACCESS_USB == true && ACCESS_MEM_TO_RAM == true
-#define Lun_desc_entry(lun) \
-  {\
-    TPASTE3(Lun_, lun, _test_unit_ready),\
-    TPASTE3(Lun_, lun, _read_capacity),\
-    TPASTE3(Lun_, lun, _unload),\
-    TPASTE3(Lun_, lun, _wr_protect),\
-    TPASTE3(Lun_, lun, _removal),\
-    TPASTE3(Lun_, lun, _usb_read_10),\
-    TPASTE3(Lun_, lun, _usb_write_10),\
-    TPASTE3(Lun_, lun, _mem_2_ram),\
-    TPASTE3(Lun_, lun, _ram_2_mem),\
-    TPASTE3(LUN_, lun, _NAME)\
-  }
-#elif ACCESS_USB == true
-#define Lun_desc_entry(lun) \
-  {\
-    TPASTE3(Lun_, lun, _test_unit_ready),\
-    TPASTE3(Lun_, lun, _read_capacity),\
-    TPASTE3(Lun_, lun, _unload),\
-    TPASTE3(Lun_, lun, _wr_protect),\
-    TPASTE3(Lun_, lun, _removal),\
-    TPASTE3(Lun_, lun, _usb_read_10),\
-    TPASTE3(Lun_, lun, _usb_write_10),\
-    TPASTE3(LUN_, lun, _NAME)\
-  }
-#elif ACCESS_MEM_TO_RAM == true
-#define Lun_desc_entry(lun) \
-  {\
-    TPASTE3(Lun_, lun, _test_unit_ready),\
-    TPASTE3(Lun_, lun, _read_capacity),\
-    TPASTE3(Lun_, lun, _unload),\
-    TPASTE3(Lun_, lun, _wr_protect),\
-    TPASTE3(Lun_, lun, _removal),\
-    TPASTE3(Lun_, lun, _mem_2_ram),\
-    TPASTE3(Lun_, lun, _ram_2_mem),\
-    TPASTE3(LUN_, lun, _NAME)\
-  }
-#else
-#define Lun_desc_entry(lun) \
-  {\
-    TPASTE3(Lun_, lun, _test_unit_ready),\
-    TPASTE3(Lun_, lun, _read_capacity),\
-    TPASTE3(Lun_, lun, _unload),\
-    TPASTE3(Lun_, lun, _wr_protect),\
-    TPASTE3(Lun_, lun, _removal),\
-    TPASTE3(LUN_, lun, _NAME)\
-  }
-#endif
-
-//! LUN descriptor table.
-static const struct
-{
-  Ctrl_status (*test_unit_ready)(void);
-  Ctrl_status (*read_capacity)(U32 *);
-  bool (*unload)(bool);
-  bool (*wr_protect)(void);
-  bool (*removal)(void);
-#if ACCESS_USB == true
-  Ctrl_status (*usb_read_10)(U32, U16);
-  Ctrl_status (*usb_write_10)(U32, U16);
-#endif
-#if ACCESS_MEM_TO_RAM == true
-  Ctrl_status (*mem_2_ram)(U32, void *);
-  Ctrl_status (*ram_2_mem)(U32, const void *);
-#endif
-  const char *name;
-} lun_desc[MAX_LUN] =
-{
-#if LUN_0 == ENABLE
-# ifndef Lun_0_unload
-#  define Lun_0_unload NULL
-# endif
-  Lun_desc_entry(0),
-#endif
-#if LUN_1 == ENABLE
-# ifndef Lun_1_unload
-#  define Lun_1_unload NULL
-# endif
-  Lun_desc_entry(1),
-#endif
-#if LUN_2 == ENABLE
-# ifndef Lun_2_unload
-#  define Lun_2_unload NULL
-# endif
-  Lun_desc_entry(2),
-#endif
-#if LUN_3 == ENABLE
-# ifndef Lun_3_unload
-#  define Lun_3_unload NULL
-# endif
-  Lun_desc_entry(3),
-#endif
-#if LUN_4 == ENABLE
-# ifndef Lun_4_unload
-#  define Lun_4_unload NULL
-# endif
-  Lun_desc_entry(4),
-#endif
-#if LUN_5 == ENABLE
-# ifndef Lun_5_unload
-#  define Lun_5_unload NULL
-# endif
-  Lun_desc_entry(5),
-#endif
-#if LUN_6 == ENABLE
-# ifndef Lun_6_unload
-#  define Lun_6_unload NULL
-# endif
-  Lun_desc_entry(6),
-#endif
-#if LUN_7 == ENABLE
-# ifndef Lun_7_unload
-#  define Lun_7_unload NULL
-# endif
-  Lun_desc_entry(7)
-#endif
-};
-
-#endif
-
-
-#if GLOBAL_WR_PROTECT == true
-bool g_wr_protect;
-#endif
-
-
-/*! \name Control Interface
- */
-//! @{
-
-
-#ifdef FREERTOS_USED
-
-bool ctrl_access_init(void)
-{
-  // If the handle to the protecting semaphore is not valid,
-  if (!ctrl_access_semphr)
-  {
-    // try to create the semaphore.
-    vSemaphoreCreateBinary(ctrl_access_semphr);
-
-    // If the semaphore could not be created, there is no backup solution.
-    if (!ctrl_access_semphr) return false;
-  }
-
-  return true;
-}
-
-
-/*! \brief Locks accesses to LUNs.
- *
- * \return \c true if the access was successfully locked, else \c false.
- */
-static bool ctrl_access_lock(void)
-{
-  // If the semaphore could not be created, there is no backup solution.
-  if (!ctrl_access_semphr) return false;
-
-  // Wait for the semaphore.
-  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
-
-  return true;
-}
-
-#endif  // FREERTOS_USED
-
-
-U8 get_nb_lun(void)
-{
-#if MEM_USB == ENABLE
-#  ifndef Lun_usb_get_lun
-#    define Lun_usb_get_lun()  host_get_lun()
-#  endif
-  U8 nb_lun;
-
-  if (!Ctrl_access_lock()) return MAX_LUN;
-
-  nb_lun = MAX_LUN + Lun_usb_get_lun();
-
-  Ctrl_access_unlock();
-
-  return nb_lun;
-#else
-  return MAX_LUN;
-#endif
-}
-
-
-U8 get_cur_lun(void)
-{
-  return LUN_ID_0;
-}
-
-
-Ctrl_status mem_test_unit_ready(U8 lun)
-{
-  Ctrl_status status;
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  status =
-#if MAX_LUN
-         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
-#endif
-#if LUN_USB == ENABLE
-                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
-#else
-                             CTRL_FAIL;
-#endif
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
-{
-  Ctrl_status status;
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  status =
-#if MAX_LUN
-         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
-#endif
-#if LUN_USB == ENABLE
-                             Lun_usb_read_capacity(lun - LUN_ID_USB, u32_nb_sector);
-#else
-                             CTRL_FAIL;
-#endif
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-U8 mem_sector_size(U8 lun)
-{
-  U8 sector_size;
-
-  if (!Ctrl_access_lock()) return 0;
-
-  sector_size =
-#if MAX_LUN
-              (lun < MAX_LUN) ? 1 :
-#endif
-#if LUN_USB == ENABLE
-                                  Lun_usb_read_sector_size(lun - LUN_ID_USB);
-#else
-                                  0;
-#endif
-
-  Ctrl_access_unlock();
-
-  return sector_size;
-}
-
-
-bool mem_unload(U8 lun, bool unload)
-{
-  bool unloaded;
-#if !MAX_LUN || !defined(Lun_usb_unload)
-  UNUSED(lun);
-#endif
-
-  if (!Ctrl_access_lock()) return false;
-
-  unloaded =
-#if MAX_LUN
-          (lun < MAX_LUN) ?
-              (lun_desc[lun].unload ?
-                  lun_desc[lun].unload(unload) : !unload) :
-#endif
-#if LUN_USB == ENABLE
-# if defined(Lun_usb_unload)
-              Lun_usb_unload(lun - LUN_ID_USB, unload);
-# else
-              !unload; /* Can not unload: load success, unload fail */
-# endif
-#else
-              false; /* No mem, unload/load fail */
-#endif
-
-  Ctrl_access_unlock();
-
-  return unloaded;
-}
-
-bool mem_wr_protect(U8 lun)
-{
-  bool wr_protect;
-
-  if (!Ctrl_access_lock()) return true;
-
-  wr_protect =
-#if MAX_LUN
-             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
-#endif
-#if LUN_USB == ENABLE
-                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
-#else
-                                 true;
-#endif
-
-  Ctrl_access_unlock();
-
-  return wr_protect;
-}
-
-
-bool mem_removal(U8 lun)
-{
-  bool removal;
-#if MAX_LUN==0
-  UNUSED(lun);
-#endif
-
-  if (!Ctrl_access_lock()) return true;
-
-  removal =
-#if MAX_LUN
-          (lun < MAX_LUN) ? lun_desc[lun].removal() :
-#endif
-#if LUN_USB == ENABLE
-                              Lun_usb_removal();
-#else
-                              true;
-#endif
-
-  Ctrl_access_unlock();
-
-  return removal;
-}
-
-
-const char *mem_name(U8 lun)
-{
-#if MAX_LUN==0
-  UNUSED(lun);
-#endif
-  return
-#if MAX_LUN
-       (lun < MAX_LUN) ? lun_desc[lun].name :
-#endif
-#if LUN_USB == ENABLE
-                           LUN_USB_NAME;
-#else
-                           NULL;
-#endif
-}
-
-
-//! @}
-
-
-#if ACCESS_USB == true
-
-/*! \name MEM <-> USB Interface
- */
-//! @{
-
-
-Ctrl_status memory_2_usb(U8 lun, U32 addr, U16 nb_sector)
-{
-  Ctrl_status status;
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  memory_start_read_action(nb_sector);
-  status =
-#if MAX_LUN
-           (lun < MAX_LUN) ? lun_desc[lun].usb_read_10(addr, nb_sector) :
-#endif
-                             CTRL_FAIL;
-  memory_stop_read_action();
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-Ctrl_status usb_2_memory(U8 lun, U32 addr, U16 nb_sector)
-{
-  Ctrl_status status;
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  memory_start_write_action(nb_sector);
-  status =
-#if MAX_LUN
-           (lun < MAX_LUN) ? lun_desc[lun].usb_write_10(addr, nb_sector) :
-#endif
-                             CTRL_FAIL;
-  memory_stop_write_action();
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-//! @}
-
-#endif  // ACCESS_USB == true
-
-
-#if ACCESS_MEM_TO_RAM == true
-
-/*! \name MEM <-> RAM Interface
- */
-//! @{
-
-
-Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
-{
-  Ctrl_status status;
-#if MAX_LUN==0
-  UNUSED(lun);
-#endif
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  memory_start_read_action(1);
-  status =
-#if MAX_LUN
-           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
-#endif
-#if LUN_USB == ENABLE
-                             Lun_usb_mem_2_ram(addr, ram);
-#else
-                             CTRL_FAIL;
-#endif
-  memory_stop_read_action();
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
-{
-  Ctrl_status status;
-#if MAX_LUN==0
-  UNUSED(lun);
-#endif
-
-  if (!Ctrl_access_lock()) return CTRL_FAIL;
-
-  memory_start_write_action(1);
-  status =
-#if MAX_LUN
-           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
-#endif
-#if LUN_USB == ENABLE
-                             Lun_usb_ram_2_mem(addr, ram);
-#else
-                             CTRL_FAIL;
-#endif
-  memory_stop_write_action();
-
-  Ctrl_access_unlock();
-
-  return status;
-}
-
-
-//! @}
-
-#endif  // ACCESS_MEM_TO_RAM == true
-
-
-#if ACCESS_STREAM == true
-
-/*! \name Streaming MEM <-> MEM Interface
- */
-//! @{
-
-
-  #if ACCESS_MEM_TO_MEM == true
-
-#include "fat.h"
-
-Ctrl_status stream_mem_to_mem(U8 src_lun, U32 src_addr, U8 dest_lun, U32 dest_addr, U16 nb_sector)
-{
-  COMPILER_ALIGNED(4)
-  static U8 sector_buf[FS_512B];
-  Ctrl_status status = CTRL_GOOD;
-
-  while (nb_sector--)
-  {
-    if ((status = memory_2_ram(src_lun, src_addr++, sector_buf)) != CTRL_GOOD) break;
-    if ((status = ram_2_memory(dest_lun, dest_addr++, sector_buf)) != CTRL_GOOD) break;
-  }
-
-  return status;
-}
-
-  #endif  // ACCESS_MEM_TO_MEM == true
-
-
-Ctrl_status stream_state(U8 id)
-{
-  UNUSED(id);
-  return CTRL_GOOD;
-}
-
-
-U16 stream_stop(U8 id)
-{
-  UNUSED(id);
-  return 0;
-}
-
-
-//! @}
-
-#endif // ACCESS_STREAM
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/ctrl_access.h b/Marlin/src/HAL/DUE/usb/ctrl_access.h
deleted file mode 100644
index b338390..0000000
--- a/Marlin/src/HAL/DUE/usb/ctrl_access.h
+++ /dev/null
@@ -1,402 +0,0 @@
-/*****************************************************************************
- *
- * \file
- *
- * \brief Abstraction layer for memory interfaces.
- *
- * This module contains the interfaces:
- *   - MEM <-> USB;
- *   - MEM <-> RAM;
- *   - MEM <-> MEM.
- *
- * This module may be configured and expanded to support the following features:
- *   - write-protected globals;
- *   - password-protected data;
- *   - specific features;
- *   - etc.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- ******************************************************************************/
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-
-#ifndef _CTRL_ACCESS_H_
-#define _CTRL_ACCESS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \defgroup group_common_services_storage_ctrl_access Memory Control Access
- *
- * Common abstraction layer for memory interfaces. It provides interfaces between:
- * Memory and USB, Memory and RAM, Memory and Memory. Common API for XMEGA and UC3.
- *
- * \{
- */
-
-#include "compiler.h"
-#include "conf_access.h"
-
-#ifndef SECTOR_SIZE
-#define SECTOR_SIZE  512
-#endif
-
-//! Status returned by CTRL_ACCESS interfaces.
-typedef enum
-{
-  CTRL_GOOD       = PASS,     //!< Success, memory ready.
-  CTRL_FAIL       = FAIL,     //!< An error occurred.
-  CTRL_NO_PRESENT = FAIL + 1, //!< Memory unplugged.
-  CTRL_BUSY       = FAIL + 2  //!< Memory not initialized or changed.
-} Ctrl_status;
-
-
-// FYI: Each Logical Unit Number (LUN) corresponds to a memory.
-
-// Check LUN defines.
-#ifndef LUN_0
-  #error LUN_0 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_1
-  #error LUN_1 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_2
-  #error LUN_2 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_3
-  #error LUN_3 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_4
-  #error LUN_4 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_5
-  #error LUN_5 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_6
-  #error LUN_6 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_7
-  #error LUN_7 must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-#ifndef LUN_USB
-  #error LUN_USB must be defined as ENABLE or DISABLE in conf_access.h
-#endif
-
-/*! \name LUN IDs
- */
-//! @{
-#define LUN_ID_0        (0)                 //!< First static LUN.
-#define LUN_ID_1        (LUN_ID_0 + LUN_0)
-#define LUN_ID_2        (LUN_ID_1 + LUN_1)
-#define LUN_ID_3        (LUN_ID_2 + LUN_2)
-#define LUN_ID_4        (LUN_ID_3 + LUN_3)
-#define LUN_ID_5        (LUN_ID_4 + LUN_4)
-#define LUN_ID_6        (LUN_ID_5 + LUN_5)
-#define LUN_ID_7        (LUN_ID_6 + LUN_6)
-#define MAX_LUN         (LUN_ID_7 + LUN_7)  //!< Number of static LUNs.
-#define LUN_ID_USB      (MAX_LUN)           //!< First dynamic LUN (USB host mass storage).
-//! @}
-
-
-// Include LUN header files.
-#if LUN_0 == ENABLE
-  #include LUN_0_INCLUDE
-#endif
-#if LUN_1 == ENABLE
-  #include LUN_1_INCLUDE
-#endif
-#if LUN_2 == ENABLE
-  #include LUN_2_INCLUDE
-#endif
-#if LUN_3 == ENABLE
-  #include LUN_3_INCLUDE
-#endif
-#if LUN_4 == ENABLE
-  #include LUN_4_INCLUDE
-#endif
-#if LUN_5 == ENABLE
-  #include LUN_5_INCLUDE
-#endif
-#if LUN_6 == ENABLE
-  #include LUN_6_INCLUDE
-#endif
-#if LUN_7 == ENABLE
-  #include LUN_7_INCLUDE
-#endif
-#if LUN_USB == ENABLE
-  #include LUN_USB_INCLUDE
-#endif
-
-
-// Check the configuration of write protection in conf_access.h.
-#ifndef GLOBAL_WR_PROTECT
-  #error GLOBAL_WR_PROTECT must be defined as true or false in conf_access.h
-#endif
-
-
-#if GLOBAL_WR_PROTECT == true
-
-//! Write protect.
-extern bool g_wr_protect;
-
-#endif
-
-
-/*! \name Control Interface
- */
-//! @{
-
-#ifdef FREERTOS_USED
-
-/*! \brief Initializes the LUN access locker.
- *
- * \return \c true if the locker was successfully initialized, else \c false.
- */
-extern bool ctrl_access_init(void);
-
-#endif  // FREERTOS_USED
-
-/*! \brief Returns the number of LUNs.
- *
- * \return Number of LUNs in the system.
- */
-extern U8 get_nb_lun(void);
-
-/*! \brief Returns the current LUN.
- *
- * \return Current LUN.
- *
- * \todo Implement.
- */
-extern U8 get_cur_lun(void);
-
-/*! \brief Tests the memory state and initializes the memory if required.
- *
- * The TEST UNIT READY SCSI primary command allows an application client to poll
- * a LUN until it is ready without having to allocate memory for returned data.
- *
- * This command may be used to check the media status of LUNs with removable
- * media.
- *
- * \param lun Logical Unit Number.
- *
- * \return Status.
- */
-extern Ctrl_status mem_test_unit_ready(U8 lun);
-
-/*! \brief Returns the address of the last valid sector (512 bytes) in the
- *         memory.
- *
- * \param lun           Logical Unit Number.
- * \param u32_nb_sector Pointer to the address of the last valid sector.
- *
- * \return Status.
- */
-extern Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector);
-
-/*! \brief Returns the size of the physical sector.
- *
- * \param lun Logical Unit Number.
- *
- * \return Sector size (unit: 512 bytes).
- */
-extern U8 mem_sector_size(U8 lun);
-
-/*! \brief Unload/load the medium.
- *
- * \param lun Logical Unit Number.
- * \param unload \c true to unload the medium, \c false to load the medium.
- *
- * \return \c true if unload/load success, else \c false.
- */
-extern bool mem_unload(U8 lun, bool unload);
-
-/*! \brief Returns the write-protection state of the memory.
- *
- * \param lun Logical Unit Number.
- *
- * \return \c true if the memory is write-protected, else \c false.
- *
- * \note Only used by removable memories with hardware-specific write
- *       protection.
- */
-extern bool mem_wr_protect(U8 lun);
-
-/*! \brief Tells whether the memory is removable.
- *
- * \param lun Logical Unit Number.
- *
- * \return \c true if the memory is removable, else \c false.
- */
-extern bool mem_removal(U8 lun);
-
-/*! \brief Returns a pointer to the LUN name.
- *
- * \param lun Logical Unit Number.
- *
- * \return Pointer to the LUN name string.
- */
-extern const char *mem_name(U8 lun);
-
-//! @}
-
-
-#if ACCESS_USB == true
-
-/*! \name MEM <-> USB Interface
- */
-//! @{
-
-/*! \brief Transfers data from the memory to USB.
- *
- * \param lun       Logical Unit Number.
- * \param addr      Address of first memory sector to read.
- * \param nb_sector Number of sectors to transfer.
- *
- * \return Status.
- */
-extern Ctrl_status memory_2_usb(U8 lun, U32 addr, U16 nb_sector);
-
-/*! \brief Transfers data from USB to the memory.
- *
- * \param lun       Logical Unit Number.
- * \param addr      Address of first memory sector to write.
- * \param nb_sector Number of sectors to transfer.
- *
- * \return Status.
- */
-extern Ctrl_status usb_2_memory(U8 lun, U32 addr, U16 nb_sector);
-
-//! @}
-
-#endif  // ACCESS_USB == true
-
-
-#if ACCESS_MEM_TO_RAM == true
-
-/*! \name MEM <-> RAM Interface
- */
-//! @{
-
-/*! \brief Copies 1 data sector from the memory to RAM.
- *
- * \param lun   Logical Unit Number.
- * \param addr  Address of first memory sector to read.
- * \param ram   Pointer to RAM buffer to write.
- *
- * \return Status.
- */
-extern Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram);
-
-/*! \brief Copies 1 data sector from RAM to the memory.
- *
- * \param lun   Logical Unit Number.
- * \param addr  Address of first memory sector to write.
- * \param ram   Pointer to RAM buffer to read.
- *
- * \return Status.
- */
-extern Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram);
-
-//! @}
-
-#endif  // ACCESS_MEM_TO_RAM == true
-
-
-#if ACCESS_STREAM == true
-
-/*! \name Streaming MEM <-> MEM Interface
- */
-//! @{
-
-//! Erroneous streaming data transfer ID.
-#define ID_STREAM_ERR         0xFF
-
-  #if ACCESS_MEM_TO_MEM == true
-
-/*! \brief Copies data from one memory to another.
- *
- * \param src_lun   Source Logical Unit Number.
- * \param src_addr  Source address of first memory sector to read.
- * \param dest_lun  Destination Logical Unit Number.
- * \param dest_addr Destination address of first memory sector to write.
- * \param nb_sector Number of sectors to copy.
- *
- * \return Status.
- */
-extern Ctrl_status stream_mem_to_mem(U8 src_lun, U32 src_addr, U8 dest_lun, U32 dest_addr, U16 nb_sector);
-
-  #endif  // ACCESS_MEM_TO_MEM == true
-
-/*! \brief Returns the state of a streaming data transfer.
- *
- * \param id  Transfer ID.
- *
- * \return Status.
- *
- * \todo Implement.
- */
-extern Ctrl_status stream_state(U8 id);
-
-/*! \brief Stops a streaming data transfer.
- *
- * \param id  Transfer ID.
- *
- * \return Number of remaining sectors.
- *
- * \todo Implement.
- */
-extern U16 stream_stop(U8 id);
-
-//! @}
-
-#endif  // ACCESS_STREAM == true
-
-/**
- * \}
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  // _CTRL_ACCESS_H_
diff --git a/Marlin/src/HAL/DUE/usb/genclk.h b/Marlin/src/HAL/DUE/usb/genclk.h
deleted file mode 100644
index cde03bc..0000000
--- a/Marlin/src/HAL/DUE/usb/genclk.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/**
- * \file
- *
- * \brief Chip-specific generic clock management.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef CHIP_GENCLK_H_INCLUDED
-#define CHIP_GENCLK_H_INCLUDED
-
-#include <osc.h>
-#include <pll.h>
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-/**
- * \weakgroup genclk_group
- * @{
- */
-
-//! \name Programmable Clock Identifiers (PCK)
-//@{
-#define GENCLK_PCK_0      0 //!< PCK0 ID
-#define GENCLK_PCK_1      1 //!< PCK1 ID
-#define GENCLK_PCK_2      2 //!< PCK2 ID
-//@}
-
-//! \name Programmable Clock Sources (PCK)
-//@{
-
-enum genclk_source {
-	GENCLK_PCK_SRC_SLCK_RC       = 0, //!< Internal 32kHz RC oscillator as PCK source clock
-	GENCLK_PCK_SRC_SLCK_XTAL     = 1, //!< External 32kHz crystal oscillator as PCK source clock
-	GENCLK_PCK_SRC_SLCK_BYPASS   = 2, //!< External 32kHz bypass oscillator as PCK source clock
-	GENCLK_PCK_SRC_MAINCK_4M_RC  = 3, //!< Internal 4MHz RC oscillator as PCK source clock
-	GENCLK_PCK_SRC_MAINCK_8M_RC  = 4, //!< Internal 8MHz RC oscillator as PCK source clock
-	GENCLK_PCK_SRC_MAINCK_12M_RC = 5, //!< Internal 12MHz RC oscillator as PCK source clock
-	GENCLK_PCK_SRC_MAINCK_XTAL   = 6, //!< External crystal oscillator as PCK source clock
-	GENCLK_PCK_SRC_MAINCK_BYPASS = 7, //!< External bypass oscillator as PCK source clock
-	GENCLK_PCK_SRC_PLLACK        = 8, //!< Use PLLACK as PCK source clock
-	GENCLK_PCK_SRC_PLLBCK        = 9, //!< Use PLLBCK as PCK source clock
-	GENCLK_PCK_SRC_MCK           = 10, //!< Use Master Clk as PCK source clock
-};
-
-//@}
-
-//! \name Programmable Clock Prescalers (PCK)
-//@{
-
-enum genclk_divider {
-	GENCLK_PCK_PRES_1  = PMC_PCK_PRES_CLK_1, //!< Set PCK clock prescaler to 1
-	GENCLK_PCK_PRES_2  = PMC_PCK_PRES_CLK_2, //!< Set PCK clock prescaler to 2
-	GENCLK_PCK_PRES_4  = PMC_PCK_PRES_CLK_4, //!< Set PCK clock prescaler to 4
-	GENCLK_PCK_PRES_8  = PMC_PCK_PRES_CLK_8, //!< Set PCK clock prescaler to 8
-	GENCLK_PCK_PRES_16 = PMC_PCK_PRES_CLK_16, //!< Set PCK clock prescaler to 16
-	GENCLK_PCK_PRES_32 = PMC_PCK_PRES_CLK_32, //!< Set PCK clock prescaler to 32
-	GENCLK_PCK_PRES_64 = PMC_PCK_PRES_CLK_64, //!< Set PCK clock prescaler to 64
-};
-
-//@}
-
-struct genclk_config {
-	uint32_t ctrl;
-};
-
-static inline void genclk_config_defaults(struct genclk_config *p_cfg,
-		uint32_t ul_id)
-{
-	ul_id = ul_id;
-	p_cfg->ctrl = 0;
-}
-
-static inline void genclk_config_read(struct genclk_config *p_cfg,
-		uint32_t ul_id)
-{
-	p_cfg->ctrl = PMC->PMC_PCK[ul_id];
-}
-
-static inline void genclk_config_write(const struct genclk_config *p_cfg,
-		uint32_t ul_id)
-{
-	PMC->PMC_PCK[ul_id] = p_cfg->ctrl;
-}
-
-//! \name Programmable Clock Source and Prescaler configuration
-//@{
-
-static inline void genclk_config_set_source(struct genclk_config *p_cfg,
-		enum genclk_source e_src)
-{
-	p_cfg->ctrl &= (~PMC_PCK_CSS_Msk);
-
-	switch (e_src) {
-	case GENCLK_PCK_SRC_SLCK_RC:
-	case GENCLK_PCK_SRC_SLCK_XTAL:
-	case GENCLK_PCK_SRC_SLCK_BYPASS:
-		p_cfg->ctrl |= (PMC_PCK_CSS_SLOW_CLK);
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_4M_RC:
-	case GENCLK_PCK_SRC_MAINCK_8M_RC:
-	case GENCLK_PCK_SRC_MAINCK_12M_RC:
-	case GENCLK_PCK_SRC_MAINCK_XTAL:
-	case GENCLK_PCK_SRC_MAINCK_BYPASS:
-		p_cfg->ctrl |= (PMC_PCK_CSS_MAIN_CLK);
-		break;
-
-	case GENCLK_PCK_SRC_PLLACK:
-		p_cfg->ctrl |= (PMC_PCK_CSS_PLLA_CLK);
-		break;
-
-	case GENCLK_PCK_SRC_PLLBCK:
-		p_cfg->ctrl |= (PMC_PCK_CSS_UPLL_CLK);
-		break;
-
-	case GENCLK_PCK_SRC_MCK:
-		p_cfg->ctrl |= (PMC_PCK_CSS_MCK);
-		break;
-	}
-}
-
-static inline void genclk_config_set_divider(struct genclk_config *p_cfg,
-		uint32_t e_divider)
-{
-	p_cfg->ctrl &= ~PMC_PCK_PRES_Msk;
-	p_cfg->ctrl |= e_divider;
-}
-
-//@}
-
-static inline void genclk_enable(const struct genclk_config *p_cfg,
-		uint32_t ul_id)
-{
-	PMC->PMC_PCK[ul_id] = p_cfg->ctrl;
-	pmc_enable_pck(ul_id);
-}
-
-static inline void genclk_disable(uint32_t ul_id)
-{
-	pmc_disable_pck(ul_id);
-}
-
-static inline void genclk_enable_source(enum genclk_source e_src)
-{
-	switch (e_src) {
-	case GENCLK_PCK_SRC_SLCK_RC:
-		if (!osc_is_ready(OSC_SLCK_32K_RC)) {
-			osc_enable(OSC_SLCK_32K_RC);
-			osc_wait_ready(OSC_SLCK_32K_RC);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_SLCK_XTAL:
-		if (!osc_is_ready(OSC_SLCK_32K_XTAL)) {
-			osc_enable(OSC_SLCK_32K_XTAL);
-			osc_wait_ready(OSC_SLCK_32K_XTAL);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_SLCK_BYPASS:
-		if (!osc_is_ready(OSC_SLCK_32K_BYPASS)) {
-			osc_enable(OSC_SLCK_32K_BYPASS);
-			osc_wait_ready(OSC_SLCK_32K_BYPASS);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_4M_RC:
-		if (!osc_is_ready(OSC_MAINCK_4M_RC)) {
-			osc_enable(OSC_MAINCK_4M_RC);
-			osc_wait_ready(OSC_MAINCK_4M_RC);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_8M_RC:
-		if (!osc_is_ready(OSC_MAINCK_8M_RC)) {
-			osc_enable(OSC_MAINCK_8M_RC);
-			osc_wait_ready(OSC_MAINCK_8M_RC);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_12M_RC:
-		if (!osc_is_ready(OSC_MAINCK_12M_RC)) {
-			osc_enable(OSC_MAINCK_12M_RC);
-			osc_wait_ready(OSC_MAINCK_12M_RC);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_XTAL:
-		if (!osc_is_ready(OSC_MAINCK_XTAL)) {
-			osc_enable(OSC_MAINCK_XTAL);
-			osc_wait_ready(OSC_MAINCK_XTAL);
-		}
-		break;
-
-	case GENCLK_PCK_SRC_MAINCK_BYPASS:
-		if (!osc_is_ready(OSC_MAINCK_BYPASS)) {
-			osc_enable(OSC_MAINCK_BYPASS);
-			osc_wait_ready(OSC_MAINCK_BYPASS);
-		}
-		break;
-
-#ifdef CONFIG_PLL0_SOURCE
-	case GENCLK_PCK_SRC_PLLACK:
-		pll_enable_config_defaults(0);
-		break;
-#endif
-
-#ifdef CONFIG_PLL1_SOURCE
-	case GENCLK_PCK_SRC_PLLBCK:
-		pll_enable_config_defaults(1);
-		break;
-#endif
-
-	case GENCLK_PCK_SRC_MCK:
-		break;
-
-	default:
-		Assert(false);
-		break;
-	}
-}
-
-//! @}
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif /* CHIP_GENCLK_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/mrepeat.h b/Marlin/src/HAL/DUE/usb/mrepeat.h
deleted file mode 100644
index 8363d9c..0000000
--- a/Marlin/src/HAL/DUE/usb/mrepeat.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/**
- * \file
- *
- * \brief Preprocessor macro repeating utils.
- *
- * Copyright (c) 2010-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _MREPEAT_H_
-#define _MREPEAT_H_
-
-/**
- * \defgroup group_sam_utils_mrepeat Preprocessor - Macro Repeat
- *
- * \ingroup group_sam_utils
- *
- * \{
- */
-
-#include "preprocessor.h"
-
-
-//! Maximal number of repetitions supported by MREPEAT.
-#define MREPEAT_LIMIT   256
-
-/*! \brief Macro repeat.
- *
- * This macro represents a horizontal repetition construct.
- *
- * \param count  The number of repetitious calls to macro. Valid values range from 0 to MREPEAT_LIMIT.
- * \param macro  A binary operation of the form macro(n, data). This macro is expanded by MREPEAT with
- *               the current repetition number and the auxiliary data argument.
- * \param data   Auxiliary data passed to macro.
- *
- * \return       <tt>macro(0, data) macro(1, data) ... macro(count - 1, data)</tt>
- */
-#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)
-
-#define MREPEAT0(  macro, data)
-#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)
-#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)
-#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)
-#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)
-#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)
-#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)
-#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)
-#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)
-#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)
-#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)
-#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)
-#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)
-#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)
-#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)
-#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)
-#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)
-#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)
-#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)
-#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)
-#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)
-#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)
-#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)
-#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)
-#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)
-#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)
-#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)
-#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)
-#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)
-#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)
-#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)
-#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)
-#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)
-#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)
-#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)
-#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)
-#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)
-#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)
-#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)
-#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)
-#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)
-#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)
-#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)
-#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)
-#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)
-#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)
-#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)
-#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)
-#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)
-#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)
-#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)
-#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)
-#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)
-#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)
-#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)
-#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)
-#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)
-#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)
-#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)
-#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)
-#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)
-#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)
-#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)
-#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)
-#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)
-#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)
-#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)
-#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)
-#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)
-#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)
-#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)
-#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)
-#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)
-#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)
-#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)
-#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)
-#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)
-#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)
-#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)
-#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)
-#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)
-#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)
-#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)
-#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)
-#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)
-#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)
-#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)
-#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)
-#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)
-#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)
-#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)
-#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)
-#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)
-#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)
-#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)
-#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)
-#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)
-#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)
-#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)
-#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)
-#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)
-#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)
-#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)
-#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)
-#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)
-#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)
-#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)
-#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)
-#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)
-#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)
-#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)
-#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)
-#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)
-#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)
-#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)
-#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)
-#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)
-#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)
-#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)
-#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)
-#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)
-#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)
-#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)
-#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)
-#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)
-#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)
-#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)
-#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)
-#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)
-#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)
-#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)
-#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)
-#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)
-#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)
-#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)
-#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)
-#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)
-#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)
-#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)
-#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)
-#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)
-#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)
-#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)
-#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)
-#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)
-#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)
-#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)
-#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)
-#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)
-#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)
-#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)
-#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)
-#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)
-#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)
-#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)
-#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)
-#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)
-#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)
-#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)
-#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)
-#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)
-#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)
-#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)
-#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)
-#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)
-#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)
-#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)
-#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)
-#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)
-#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)
-#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)
-#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)
-#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)
-#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)
-#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)
-#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)
-#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)
-#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)
-#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)
-#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)
-#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)
-#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)
-#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)
-#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)
-#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)
-#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)
-#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)
-#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)
-#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)
-#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)
-#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)
-#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)
-#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)
-#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)
-#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)
-#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)
-#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)
-#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)
-#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)
-#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)
-#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)
-#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)
-#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)
-#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)
-#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)
-#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)
-#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)
-#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)
-#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)
-#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)
-#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)
-#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)
-#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)
-#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)
-#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)
-#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)
-#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)
-#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)
-#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)
-#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)
-#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)
-#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)
-#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)
-#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)
-#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)
-#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)
-#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)
-#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)
-#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)
-#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)
-#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)
-#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)
-#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)
-#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)
-#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)
-#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)
-#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)
-#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)
-#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)
-#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)
-#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)
-#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)
-#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)
-#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)
-#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)
-#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)
-#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)
-#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)
-#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)
-#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)
-#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)
-#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)
-#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)
-#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)
-#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)
-#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)
-#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)
-
-/**
- * \}
- */
-
-#endif  // _MREPEAT_H_
diff --git a/Marlin/src/HAL/DUE/usb/osc.h b/Marlin/src/HAL/DUE/usb/osc.h
deleted file mode 100644
index 953bcbb..0000000
--- a/Marlin/src/HAL/DUE/usb/osc.h
+++ /dev/null
@@ -1,261 +0,0 @@
-/**
- * \file
- *
- * \brief Chip-specific oscillator management functions.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef CHIP_OSC_H_INCLUDED
-#define CHIP_OSC_H_INCLUDED
-
-#include "compiler.h"
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-/*
- * Below BOARD_XXX macros are related to the specific board, and
- * should be defined by the board code, otherwise default value are used.
- */
-#ifndef BOARD_FREQ_SLCK_XTAL
-#  warning The board slow clock xtal frequency has not been defined.
-#  define BOARD_FREQ_SLCK_XTAL      (32768UL)
-#endif
-
-#ifndef BOARD_FREQ_SLCK_BYPASS
-#  warning The board slow clock bypass frequency has not been defined.
-#  define BOARD_FREQ_SLCK_BYPASS    (32768UL)
-#endif
-
-#ifndef BOARD_FREQ_MAINCK_XTAL
-#  warning The board main clock xtal frequency has not been defined.
-#  define BOARD_FREQ_MAINCK_XTAL    (12000000UL)
-#endif
-
-#ifndef BOARD_FREQ_MAINCK_BYPASS
-#  warning The board main clock bypass frequency has not been defined.
-#  define BOARD_FREQ_MAINCK_BYPASS  (12000000UL)
-#endif
-
-#ifndef BOARD_OSC_STARTUP_US
-#  warning The board main clock xtal startup time has not been defined.
-#  define BOARD_OSC_STARTUP_US      (15625UL)
-#endif
-
-/**
- * \weakgroup osc_group
- * @{
- */
-
-//! \name Oscillator identifiers
-//@{
-#define OSC_SLCK_32K_RC             0    //!< Internal 32kHz RC oscillator.
-#define OSC_SLCK_32K_XTAL           1    //!< External 32kHz crystal oscillator.
-#define OSC_SLCK_32K_BYPASS         2    //!< External 32kHz bypass oscillator.
-#define OSC_MAINCK_4M_RC            3    //!< Internal 4MHz RC oscillator.
-#define OSC_MAINCK_8M_RC            4    //!< Internal 8MHz RC oscillator.
-#define OSC_MAINCK_12M_RC           5    //!< Internal 12MHz RC oscillator.
-#define OSC_MAINCK_XTAL             6    //!< External crystal oscillator.
-#define OSC_MAINCK_BYPASS           7    //!< External bypass oscillator.
-//@}
-
-//! \name Oscillator clock speed in hertz
-//@{
-#define OSC_SLCK_32K_RC_HZ          CHIP_FREQ_SLCK_RC               //!< Internal 32kHz RC oscillator.
-#define OSC_SLCK_32K_XTAL_HZ        BOARD_FREQ_SLCK_XTAL            //!< External 32kHz crystal oscillator.
-#define OSC_SLCK_32K_BYPASS_HZ      BOARD_FREQ_SLCK_BYPASS          //!< External 32kHz bypass oscillator.
-#define OSC_MAINCK_4M_RC_HZ         CHIP_FREQ_MAINCK_RC_4MHZ        //!< Internal 4MHz RC oscillator.
-#define OSC_MAINCK_8M_RC_HZ         CHIP_FREQ_MAINCK_RC_8MHZ        //!< Internal 8MHz RC oscillator.
-#define OSC_MAINCK_12M_RC_HZ        CHIP_FREQ_MAINCK_RC_12MHZ       //!< Internal 12MHz RC oscillator.
-#define OSC_MAINCK_XTAL_HZ          BOARD_FREQ_MAINCK_XTAL          //!< External crystal oscillator.
-#define OSC_MAINCK_BYPASS_HZ        BOARD_FREQ_MAINCK_BYPASS        //!< External bypass oscillator.
-//@}
-
-static inline void osc_enable(uint32_t ul_id)
-{
-	switch (ul_id) {
-	case OSC_SLCK_32K_RC:
-		break;
-
-	case OSC_SLCK_32K_XTAL:
-		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
-		break;
-
-	case OSC_SLCK_32K_BYPASS:
-		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
-		break;
-
-
-	case OSC_MAINCK_4M_RC:
-		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
-		break;
-
-	case OSC_MAINCK_8M_RC:
-		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
-		break;
-
-	case OSC_MAINCK_12M_RC:
-		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
-		break;
-
-
-	case OSC_MAINCK_XTAL:
-		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL/*,
-			pmc_us_to_moscxtst(BOARD_OSC_STARTUP_US,
-				OSC_SLCK_32K_RC_HZ)*/);
-		break;
-
-	case OSC_MAINCK_BYPASS:
-		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS/*,
-			pmc_us_to_moscxtst(BOARD_OSC_STARTUP_US,
-				OSC_SLCK_32K_RC_HZ)*/);
-		break;
-	}
-}
-
-static inline void osc_disable(uint32_t ul_id)
-{
-	switch (ul_id) {
-	case OSC_SLCK_32K_RC:
-	case OSC_SLCK_32K_XTAL:
-	case OSC_SLCK_32K_BYPASS:
-		break;
-
-	case OSC_MAINCK_4M_RC:
-	case OSC_MAINCK_8M_RC:
-	case OSC_MAINCK_12M_RC:
-		pmc_osc_disable_fastrc();
-		break;
-
-	case OSC_MAINCK_XTAL:
-		pmc_osc_disable_xtal(PMC_OSC_XTAL);
-		break;
-
-	case OSC_MAINCK_BYPASS:
-		pmc_osc_disable_xtal(PMC_OSC_BYPASS);
-		break;
-	}
-}
-
-static inline bool osc_is_ready(uint32_t ul_id)
-{
-	switch (ul_id) {
-	case OSC_SLCK_32K_RC:
-		return 1;
-
-	case OSC_SLCK_32K_XTAL:
-	case OSC_SLCK_32K_BYPASS:
-		return pmc_osc_is_ready_32kxtal();
-
-	case OSC_MAINCK_4M_RC:
-	case OSC_MAINCK_8M_RC:
-	case OSC_MAINCK_12M_RC:
-	case OSC_MAINCK_XTAL:
-	case OSC_MAINCK_BYPASS:
-		return pmc_osc_is_ready_mainck();
-	}
-
-	return 0;
-}
-
-static inline uint32_t osc_get_rate(uint32_t ul_id)
-{
-	switch (ul_id) {
-	case OSC_SLCK_32K_RC:
-		return OSC_SLCK_32K_RC_HZ;
-
-	case OSC_SLCK_32K_XTAL:
-		return BOARD_FREQ_SLCK_XTAL;
-
-	case OSC_SLCK_32K_BYPASS:
-		return BOARD_FREQ_SLCK_BYPASS;
-
-	case OSC_MAINCK_4M_RC:
-		return OSC_MAINCK_4M_RC_HZ;
-
-	case OSC_MAINCK_8M_RC:
-		return OSC_MAINCK_8M_RC_HZ;
-
-	case OSC_MAINCK_12M_RC:
-		return OSC_MAINCK_12M_RC_HZ;
-
-	case OSC_MAINCK_XTAL:
-		return BOARD_FREQ_MAINCK_XTAL;
-
-	case OSC_MAINCK_BYPASS:
-		return BOARD_FREQ_MAINCK_BYPASS;
-	}
-
-	return 0;
-}
-
-/**
- * \brief Wait until the oscillator identified by \a id is ready
- *
- * This function will busy-wait for the oscillator identified by \a id
- * to become stable and ready to use as a clock source.
- *
- * \param id A number identifying the oscillator to wait for.
- */
-static inline void osc_wait_ready(uint8_t id)
-{
-	while (!osc_is_ready(id)) {
-		/* Do nothing */
-	}
-}
-
-//! @}
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif /* CHIP_OSC_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/pll.h b/Marlin/src/HAL/DUE/usb/pll.h
deleted file mode 100644
index 8eaf276..0000000
--- a/Marlin/src/HAL/DUE/usb/pll.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/**
- * \file
- *
- * \brief Chip-specific PLL definitions.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef CHIP_PLL_H_INCLUDED
-#define CHIP_PLL_H_INCLUDED
-
-#include "osc.h"
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-/**
- * \weakgroup pll_group
- * @{
- */
-
-#define PLL_OUTPUT_MIN_HZ   84000000
-#define PLL_OUTPUT_MAX_HZ   192000000
-
-#define PLL_INPUT_MIN_HZ    8000000
-#define PLL_INPUT_MAX_HZ    16000000
-
-#define NR_PLLS             2
-#define PLLA_ID             0
-#define UPLL_ID             1   //!< USB UTMI PLL.
-
-#define PLL_UPLL_HZ     480000000
-
-#define PLL_COUNT           0x3FU
-
-enum pll_source {
-	PLL_SRC_MAINCK_4M_RC        = OSC_MAINCK_4M_RC,     //!< Internal 4MHz RC oscillator.
-	PLL_SRC_MAINCK_8M_RC        = OSC_MAINCK_8M_RC,     //!< Internal 8MHz RC oscillator.
-	PLL_SRC_MAINCK_12M_RC       = OSC_MAINCK_12M_RC,    //!< Internal 12MHz RC oscillator.
-	PLL_SRC_MAINCK_XTAL         = OSC_MAINCK_XTAL,      //!< External crystal oscillator.
-	PLL_SRC_MAINCK_BYPASS       = OSC_MAINCK_BYPASS,    //!< External bypass oscillator.
-	PLL_NR_SOURCES,                                     //!< Number of PLL sources.
-};
-
-struct pll_config {
-	uint32_t ctrl;
-};
-
-#define pll_get_default_rate(pll_id)                                       \
-	((osc_get_rate(CONFIG_PLL##pll_id##_SOURCE)                            \
-			* CONFIG_PLL##pll_id##_MUL)                                    \
-			/ CONFIG_PLL##pll_id##_DIV)
-
-/* Force UTMI PLL parameters (Hardware defined) */
-#ifdef CONFIG_PLL1_SOURCE
-# undef CONFIG_PLL1_SOURCE
-#endif
-#ifdef CONFIG_PLL1_MUL
-# undef CONFIG_PLL1_MUL
-#endif
-#ifdef CONFIG_PLL1_DIV
-# undef CONFIG_PLL1_DIV
-#endif
-#define CONFIG_PLL1_SOURCE  PLL_SRC_MAINCK_XTAL
-#define CONFIG_PLL1_MUL     0
-#define CONFIG_PLL1_DIV     0
-
-/**
- * \note The SAM3X PLL hardware interprets mul as mul+1. For readability the hardware mul+1
- * is hidden in this implementation. Use mul as mul effective value.
- */
-static inline void pll_config_init(struct pll_config *p_cfg,
-		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
-{
-	uint32_t vco_hz;
-
-	Assert(e_src < PLL_NR_SOURCES);
-
-	if (ul_div == 0 && ul_mul == 0) { /* Must only be true for UTMI PLL */
-		p_cfg->ctrl = CKGR_UCKR_UPLLCOUNT(PLL_COUNT);
-	} else { /* PLLA */
-		/* Calculate internal VCO frequency */
-		vco_hz = osc_get_rate(e_src) / ul_div;
-		Assert(vco_hz >= PLL_INPUT_MIN_HZ);
-		Assert(vco_hz <= PLL_INPUT_MAX_HZ);
-
-		vco_hz *= ul_mul;
-		Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
-		Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);
-
-		/* PMC hardware will automatically make it mul+1 */
-		p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
-	}
-}
-
-#define pll_config_defaults(cfg, pll_id)                                   \
-	pll_config_init(cfg,                                                   \
-			CONFIG_PLL##pll_id##_SOURCE,                                   \
-			CONFIG_PLL##pll_id##_DIV,                                      \
-			CONFIG_PLL##pll_id##_MUL)
-
-static inline void pll_config_read(struct pll_config *p_cfg, uint32_t ul_pll_id)
-{
-	Assert(ul_pll_id < NR_PLLS);
-
-	if (ul_pll_id == PLLA_ID) {
-		p_cfg->ctrl = PMC->CKGR_PLLAR;
-	} else {
-		p_cfg->ctrl = PMC->CKGR_UCKR;
-	}
-}
-
-static inline void pll_config_write(const struct pll_config *p_cfg, uint32_t ul_pll_id)
-{
-	Assert(ul_pll_id < NR_PLLS);
-
-	if (ul_pll_id == PLLA_ID) {
-		pmc_disable_pllack(); // Always stop PLL first!
-		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
-	} else {
-		PMC->CKGR_UCKR = p_cfg->ctrl;
-	}
-}
-
-static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
-{
-	Assert(ul_pll_id < NR_PLLS);
-
-	if (ul_pll_id == PLLA_ID) {
-		pmc_disable_pllack(); // Always stop PLL first!
-		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
-	} else {
-		PMC->CKGR_UCKR = p_cfg->ctrl | CKGR_UCKR_UPLLEN;
-	}
-}
-
-/**
- * \note This will only disable the selected PLL, not the underlying oscillator (mainck).
- */
-static inline void pll_disable(uint32_t ul_pll_id)
-{
-	Assert(ul_pll_id < NR_PLLS);
-
-	if (ul_pll_id == PLLA_ID) {
-		pmc_disable_pllack();
-	} else {
-		PMC->CKGR_UCKR &= ~CKGR_UCKR_UPLLEN;
-	}
-}
-
-static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
-{
-	Assert(ul_pll_id < NR_PLLS);
-
-	if (ul_pll_id == PLLA_ID) {
-		return pmc_is_locked_pllack();
-	} else {
-		return pmc_is_locked_upll();
-	}
-}
-
-static inline void pll_enable_source(enum pll_source e_src)
-{
-	switch (e_src) {
-	case PLL_SRC_MAINCK_4M_RC:
-	case PLL_SRC_MAINCK_8M_RC:
-	case PLL_SRC_MAINCK_12M_RC:
-	case PLL_SRC_MAINCK_XTAL:
-	case PLL_SRC_MAINCK_BYPASS:
-		osc_enable(e_src);
-		osc_wait_ready(e_src);
-		break;
-
-	default:
-		Assert(false);
-		break;
-	}
-}
-
-static inline void pll_enable_config_defaults(unsigned int ul_pll_id)
-{
-	struct pll_config pllcfg;
-
-	if (pll_is_locked(ul_pll_id)) {
-		return; // Pll already running
-	}
-	switch (ul_pll_id) {
-#ifdef CONFIG_PLL0_SOURCE
-	case 0:
-		pll_enable_source(CONFIG_PLL0_SOURCE);
-		pll_config_init(&pllcfg,
-				CONFIG_PLL0_SOURCE,
-				CONFIG_PLL0_DIV,
-				CONFIG_PLL0_MUL);
-		break;
-#endif
-#ifdef CONFIG_PLL1_SOURCE
-	case 1:
-		pll_enable_source(CONFIG_PLL1_SOURCE);
-		pll_config_init(&pllcfg,
-				CONFIG_PLL1_SOURCE,
-				CONFIG_PLL1_DIV,
-				CONFIG_PLL1_MUL);
-		break;
-#endif
-	default:
-		Assert(false);
-		break;
-	}
-	pll_enable(&pllcfg, ul_pll_id);
-	while (!pll_is_locked(ul_pll_id));
-}
-
-/**
- * \brief Wait for PLL \a pll_id to become locked
- *
- * \todo Use a timeout to avoid waiting forever and hanging the system
- *
- * \param pll_id The ID of the PLL to wait for.
- *
- * \retval STATUS_OK The PLL is now locked.
- * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
- */
-static inline int pll_wait_for_lock(unsigned int pll_id)
-{
-	Assert(pll_id < NR_PLLS);
-
-	while (!pll_is_locked(pll_id)) {
-		/* Do nothing */
-	}
-
-	return 0;
-}
-
-//! @}
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif /* CHIP_PLL_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/preprocessor.h b/Marlin/src/HAL/DUE/usb/preprocessor.h
deleted file mode 100644
index c12d01c..0000000
--- a/Marlin/src/HAL/DUE/usb/preprocessor.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * \file
- *
- * \brief Preprocessor utils.
- *
- * Copyright (c) 2010-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _PREPROCESSOR_H_
-#define _PREPROCESSOR_H_
-
-#include "tpaste.h"
-#include "stringz.h"
-#include "mrepeat.h"
-
-
-#endif  // _PREPROCESSOR_H_
diff --git a/Marlin/src/HAL/DUE/usb/sbc_protocol.h b/Marlin/src/HAL/DUE/usb/sbc_protocol.h
deleted file mode 100644
index ab84573..0000000
--- a/Marlin/src/HAL/DUE/usb/sbc_protocol.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/**
- * \file
- *
- * \brief SCSI Block Commands
- *
- * This file contains definitions of some of the commands found in the
- * SCSI SBC-2 standard.
- *
- * Note that the SBC specification depends on several commands defined
- * by the SCSI Primary Commands (SPC) standard. Each version of the SBC
- * standard is meant to be used in conjunction with a specific version
- * of the SPC standard, as follows:
- *   - SBC   depends on SPC
- *   - SBC-2 depends on SPC-3
- *   - SBC-3 depends on SPC-4
- *
- * Copyright (c) 2014-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-#ifndef _SBC_PROTOCOL_H_
-#define _SBC_PROTOCOL_H_
-
-
-/**
- * \ingroup usb_msc_protocol
- * \defgroup usb_sbc_protocol SCSI Block Commands protocol definitions
- *
- * @{
- */
-
-//! \name SCSI commands defined by SBC-2
-//@{
-#define  SBC_FORMAT_UNIT         0x04
-#define  SBC_READ6               0x08
-#define  SBC_WRITE6              0x0A
-#define  SBC_START_STOP_UNIT     0x1B
-#define  SBC_READ_CAPACITY10     0x25
-#define  SBC_READ10              0x28
-#define  SBC_WRITE10             0x2A
-#define  SBC_VERIFY10            0x2F
-//@}
-
-//! \name SBC-2 Mode page definitions
-//@{
-
-enum scsi_sbc_mode {
-	SCSI_MS_MODE_RW_ERR_RECOV = 0x01,	//!< Read-Write Error Recovery mode page
-	SCSI_MS_MODE_FORMAT_DEVICE = 0x03,	//!< Format Device mode page
-	SCSI_MS_MODE_FLEXIBLE_DISK = 0x05,	//!< Flexible Disk mode page
-	SCSI_MS_MODE_CACHING = 0x08,	//!< Caching mode page
-};
-
-
-//! \name SBC-2 Device-Specific Parameter
-//@{
-#define SCSI_MS_SBC_WP              0x80	//!< Write Protected
-#define SCSI_MS_SBC_DPOFUA          0x10	//!< DPO and FUA supported
-//@}
-
-/**
- * \brief SBC-2 Short LBA mode parameter block descriptor
- */
-struct sbc_slba_block_desc {
-	be32_t nr_blocks;	//!< Number of Blocks
-	be32_t block_len;	//!< Block Length
-#define SBC_SLBA_BLOCK_LEN_MASK   0x00FFFFFFU	//!< Mask reserved bits
-};
-
-/**
- * \brief SBC-2 Caching mode page
- */
-struct sbc_caching_mode_page {
-	uint8_t page_code;
-	uint8_t page_length;
-	uint8_t flags2;
-#define  SBC_MP_CACHE_IC      (1 << 7)	//!< Initiator Control
-#define  SBC_MP_CACHE_ABPF    (1 << 6)	//!< Abort Pre-Fetch
-#define  SBC_MP_CACHE_CAP     (1 << 5)	//!< Catching Analysis Permitted
-#define  SBC_MP_CACHE_DISC    (1 << 4)	//!< Discontinuity
-#define  SBC_MP_CACHE_SIZE    (1 << 3)	//!< Size enable
-#define  SBC_MP_CACHE_WCE     (1 << 2)	//!< Write back Cache Enable
-#define  SBC_MP_CACHE_MF      (1 << 1)	//!< Multiplication Factor
-#define  SBC_MP_CACHE_RCD     (1 << 0)	//!< Read Cache Disable
-	uint8_t retention;
-	be16_t dis_pf_transfer_len;
-	be16_t min_prefetch;
-	be16_t max_prefetch;
-	be16_t max_prefetch_ceil;
-	uint8_t flags12;
-#define  SBC_MP_CACHE_FSW     (1 << 7)	//!< Force Sequential Write
-#define  SBC_MP_CACHE_LBCSS   (1 << 6)	//!< Logical Blk Cache Seg Sz
-#define  SBC_MP_CACHE_DRA     (1 << 5)	//!< Disable Read-Ahead
-#define  SBC_MP_CACHE_NV_DIS  (1 << 0)	//!< Non-Volatile Cache Disable
-	uint8_t nr_cache_segments;
-	be16_t cache_segment_size;
-	uint8_t reserved[4];
-};
-
-/**
- * \brief SBC-2 Read-Write Error Recovery mode page
- */
-struct sbc_rdwr_error_recovery_mode_page {
-	uint8_t page_code;
-	uint8_t page_length;
-#define  SPC_MP_RW_ERR_RECOV_PAGE_LENGTH    0x0A
-	uint8_t flags1;
-#define  SBC_MP_RW_ERR_RECOV_AWRE   (1 << 7)
-#define  SBC_MP_RW_ERR_RECOV_ARRE   (1 << 6)
-#define  SBC_MP_RW_ERR_RECOV_TB     (1 << 5)
-#define  SBC_MP_RW_ERR_RECOV_RC     (1 << 4)
-#define  SBC_MP_RW_ERR_RECOV_ERR    (1 << 3)
-#define  SBC_MP_RW_ERR_RECOV_PER    (1 << 2)
-#define  SBC_MP_RW_ERR_RECOV_DTE    (1 << 1)
-#define  SBC_MP_RW_ERR_RECOV_DCR    (1 << 0)
-	uint8_t read_retry_count;
-	uint8_t correction_span;
-	uint8_t head_offset_count;
-	uint8_t data_strobe_offset_count;
-	uint8_t flags2;
-	uint8_t write_retry_count;
-	uint8_t flags3;
-	be16_t recovery_time_limit;
-};
-//@}
-
-/**
- * \brief SBC-2 READ CAPACITY (10) parameter data
- */
-struct sbc_read_capacity10_data {
-	be32_t max_lba;	//!< LBA of last logical block
-	be32_t block_len;	//!< Number of bytes in the last logical block
-};
-
-//@}
-
-#endif // _SBC_PROTOCOL_H_
diff --git a/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.cpp b/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.cpp
deleted file mode 100644
index 34cc256..0000000
--- a/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/**
- * Interface from Atmel USB MSD to Marlin SD card
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "../../../inc/MarlinConfig.h"
-
-#if ENABLED(SDSUPPORT)
-
-#include "../../../sd/cardreader.h"
-extern "C" {
-  #include "sd_mmc_spi_mem.h"
-}
-
-#define SD_MMC_BLOCK_SIZE 512
-
-void sd_mmc_spi_mem_init() {
-}
-
-Ctrl_status sd_mmc_spi_test_unit_ready() {
-  #ifdef DISABLE_DUE_SD_MMC
-    return CTRL_NO_PRESENT;
-  #endif
-  if (!IS_SD_INSERTED() || IS_SD_PRINTING() || IS_SD_FILE_OPEN() || !card.isMounted())
-    return CTRL_NO_PRESENT;
-  return CTRL_GOOD;
-}
-
-// NOTE: This function is defined as returning the address of the last block
-// in the card, which is cardSize() - 1
-Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector) {
-  if (!IS_SD_INSERTED() || IS_SD_PRINTING() || IS_SD_FILE_OPEN() || !card.isMounted())
-    return CTRL_NO_PRESENT;
-  *nb_sector = card.diskIODriver()->cardSize() - 1;
-  return CTRL_GOOD;
-}
-
-bool sd_mmc_spi_unload(bool) { return true; }
-
-bool sd_mmc_spi_wr_protect() { return false; }
-
-bool sd_mmc_spi_removal() {
-  return (!IS_SD_INSERTED() || IS_SD_PRINTING() || IS_SD_FILE_OPEN() || !card.isMounted());
-}
-
-#if ACCESS_USB == true
-/**
- * \name MEM <-> USB Interface
- * @{
- */
-
-#include "udi_msc.h"
-
-COMPILER_WORD_ALIGNED
-uint8_t sector_buf[SD_MMC_BLOCK_SIZE];
-
-// #define DEBUG_MMC
-
-Ctrl_status sd_mmc_spi_usb_read_10(uint32_t addr, uint16_t nb_sector) {
-  #ifdef DISABLE_DUE_SD_MMC
-    return CTRL_NO_PRESENT;
-  #endif
-  if (!IS_SD_INSERTED() || IS_SD_PRINTING() || IS_SD_FILE_OPEN() || !card.isMounted())
-    return CTRL_NO_PRESENT;
-
-  #ifdef DEBUG_MMC
-  {
-    char buffer[80];
-    sprintf_P(buffer, PSTR("SDRD: %d @ 0x%08x\n"), nb_sector, addr);
-    PORT_REDIRECT(SERIAL_PORTMASK(0));
-    SERIAL_ECHO(buffer);
-  }
-  #endif
-
-  // Start reading
-  if (!card.diskIODriver()->readStart(addr))
-    return CTRL_FAIL;
-
-  // For each specified sector
-  while (nb_sector--) {
-
-    // Read a sector
-    card.diskIODriver()->readData(sector_buf);
-
-    // RAM -> USB
-    if (!udi_msc_trans_block(true, sector_buf, SD_MMC_BLOCK_SIZE, nullptr)) {
-      card.diskIODriver()->readStop();
-      return CTRL_FAIL;
-    }
-  }
-
-  // Stop reading
-  card.diskIODriver()->readStop();
-
-  // Done
-  return CTRL_GOOD;
-}
-
-Ctrl_status sd_mmc_spi_usb_write_10(uint32_t addr, uint16_t nb_sector) {
-  #ifdef DISABLE_DUE_SD_MMC
-    return CTRL_NO_PRESENT;
-  #endif
-  if (!IS_SD_INSERTED() || IS_SD_PRINTING() || IS_SD_FILE_OPEN() || !card.isMounted())
-    return CTRL_NO_PRESENT;
-
-  #ifdef DEBUG_MMC
-  {
-    char buffer[80];
-    sprintf_P(buffer, PSTR("SDWR: %d @ 0x%08x\n"), nb_sector, addr);
-    PORT_REDIRECT(SERIAL_PORTMASK(0));
-    SERIAL_ECHO(buffer);
-  }
-  #endif
-
-  if (!card.diskIODriver()->writeStart(addr, nb_sector))
-    return CTRL_FAIL;
-
-  // For each specified sector
-  while (nb_sector--) {
-
-    // USB -> RAM
-    if (!udi_msc_trans_block(false, sector_buf, SD_MMC_BLOCK_SIZE, nullptr)) {
-      card.diskIODriver()->writeStop();
-      return CTRL_FAIL;
-    }
-
-    // Write a sector
-    card.diskIODriver()->writeData(sector_buf);
-  }
-
-  // Stop writing
-  card.diskIODriver()->writeStop();
-
-  // Done
-  return CTRL_GOOD;
-}
-
-#endif // ACCESS_USB == true
-
-#endif // SDSUPPORT
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.h b/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.h
deleted file mode 100644
index 553fd3c..0000000
--- a/Marlin/src/HAL/DUE/usb/sd_mmc_spi_mem.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/*****************************************************************************
- *
- * \file
- *
- * \brief CTRL_ACCESS interface for SD/MMC card.
- *
- * Copyright (c) 2014-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- ******************************************************************************/
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-
-#ifndef _SD_MMC_SPI_MEM_H_
-#define _SD_MMC_SPI_MEM_H_
-
-/**
- * \defgroup group_avr32_components_memory_sd_mmc_sd_mmc_spi_mem SD/MMC SPI Memory
- *
- * \ingroup group_avr32_components_memory_sd_mmc_sd_mmc_spi
- *
- * \{
- */
-
-#include "conf_access.h"
-
-#if SD_MMC_SPI_MEM == DISABLE
-  #error sd_mmc_spi_mem.h is #included although SD_MMC_SPI_MEM is disabled
-#endif
-
-
-#include "ctrl_access.h"
-
-
-//_____ D E F I N I T I O N S ______________________________________________
-
-#define   SD_MMC_REMOVED       0
-#define   SD_MMC_INSERTED      1
-#define   SD_MMC_REMOVING      2
-
-
-//---- CONTROL FUNCTIONS ----
-//!
-//! @brief This function initializes the hw/sw resources required to drive the SD_MMC_SPI.
-//!/
-extern void           sd_mmc_spi_mem_init(void);
-
-//!
-//! @brief This function tests the state of the SD_MMC memory and sends it to the Host.
-//!        For a PC, this device is seen as a removable media
-//!        Before indicating any modification of the status of the media (GOOD->NO_PRESENT or vice-versa),
-//!         the function must return the BUSY data to make the PC accepting the change
-//!
-//! @return                Ctrl_status
-//!   Media is ready       ->    CTRL_GOOD
-//!   Media not present    ->    CTRL_NO_PRESENT
-//!   Media has changed    ->    CTRL_BUSY
-//!/
-extern Ctrl_status    sd_mmc_spi_test_unit_ready(void);
-
-//!
-//! @brief This function gives the address of the last valid sector.
-//!
-//! @param *nb_sector  number of sector (sector = 512B). OUT
-//!
-//! @return                Ctrl_status
-//!   Media ready          ->  CTRL_GOOD
-//!   Media not present    ->  CTRL_NO_PRESENT
-//!/
-extern Ctrl_status    sd_mmc_spi_read_capacity(uint32_t *nb_sector);
-
-/*! \brief Unload/Load the SD/MMC card selected
- *
- * The START STOP UNIT SCSI optional command allows an application client to
- * eject the removable medium on a LUN.
- *
- * \param unload \c true to unload the medium, \c false to load the medium.
- *
- * \return \c true if unload/load done success.
- */
-extern bool sd_mmc_spi_unload(bool unload);
-
-//!
-//! @brief This function returns the write protected status of the memory.
-//!
-//! Only used by memory removal with a HARDWARE SPECIFIC write protected detection
-//! ! The user must unplug the memory to change this write protected status,
-//! which cannot be for a SD_MMC.
-//!
-//! @return false  -> the memory is not write-protected (always)
-//!/
-extern bool           sd_mmc_spi_wr_protect(void);
-
-//!
-//! @brief This function tells if the memory has been removed or not.
-//!
-//! @return false  -> The memory isn't removed
-//!
-extern bool           sd_mmc_spi_removal(void);
-
-
-//---- ACCESS DATA FUNCTIONS ----
-
-#if ACCESS_USB == true
-// Standard functions for open in read/write mode the device
-
-//!
-//! @brief This function performs a read operation of n sectors from a given address on.
-//! (sector = 512B)
-//!
-//!         DATA FLOW is: SD_MMC => USB
-//!
-//! @param addr         Sector address to start the read from
-//! @param nb_sector    Number of sectors to transfer
-//!
-//! @return                Ctrl_status
-//!   It is ready    ->    CTRL_GOOD
-//!   A error occur  ->    CTRL_FAIL
-//!
-extern Ctrl_status    sd_mmc_spi_usb_read_10(uint32_t addr, uint16_t nb_sector);
-
-//! This function initializes the SD/MMC memory for a write operation
-//!
-//!         DATA FLOW is: USB => SD_MMC
-//!
-//! (sector = 512B)
-//! @param addr         Sector address to start write
-//! @param nb_sector    Number of sectors to transfer
-//!
-//! @return                Ctrl_status
-//!   It is ready    ->    CTRL_GOOD
-//!   An error occurs  ->    CTRL_FAIL
-//!
-extern Ctrl_status    sd_mmc_spi_usb_write_10(uint32_t addr, uint16_t nb_sector);
-
-#endif // #if ACCESS_USB == true
-
-/**
- * \}
- */
-
-#endif  // _SD_MMC_SPI_MEM_H_
diff --git a/Marlin/src/HAL/DUE/usb/spc_protocol.h b/Marlin/src/HAL/DUE/usb/spc_protocol.h
deleted file mode 100644
index d67cc5c..0000000
--- a/Marlin/src/HAL/DUE/usb/spc_protocol.h
+++ /dev/null
@@ -1,337 +0,0 @@
-/**
- * \file
- *
- * \brief SCSI Primary Commands
- *
- * This file contains definitions of some of the commands found in the
- * SPC-2 standard.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-#ifndef _SPC_PROTOCOL_H_
-#define _SPC_PROTOCOL_H_
-
-/**
- * \ingroup usb_msc_protocol
- * \defgroup usb_spc_protocol SCSI Primary Commands protocol definitions
- *
- * @{
- */
-
-//! \name SCSI commands defined by SPC-2
-//@{
-#define  SPC_TEST_UNIT_READY              0x00
-#define  SPC_REQUEST_SENSE                0x03
-#define  SPC_INQUIRY                      0x12
-#define  SPC_MODE_SELECT6                 0x15
-#define  SPC_MODE_SENSE6                  0x1A
-#define  SPC_SEND_DIAGNOSTIC              0x1D
-#define  SPC_PREVENT_ALLOW_MEDIUM_REMOVAL 0x1E
-#define  SPC_MODE_SENSE10                 0x5A
-#define  SPC_REPORT_LUNS                  0xA0
-//@}
-
-//! \brief May be set in byte 0 of the INQUIRY CDB
-//@{
-//! Enable Vital Product Data
-#define  SCSI_INQ_REQ_EVPD    0x01
-//! Command Support Data specified by the PAGE OR OPERATION CODE field
-#define  SCSI_INQ_REQ_CMDT    0x02
-//@}
-
-COMPILER_PACK_SET(1)
-
-/**
- * \brief SCSI Standard Inquiry data structure
- */
-struct scsi_inquiry_data {
-	uint8_t pq_pdt; //!< Peripheral Qual / Peripheral Dev Type
-#define  SCSI_INQ_PQ_CONNECTED   0x00   //!< Peripheral connected
-#define  SCSI_INQ_PQ_NOT_CONN    0x20   //!< Peripheral not connected
-#define  SCSI_INQ_PQ_NOT_SUPP    0x60   //!< Peripheral not supported
-#define  SCSI_INQ_DT_DIR_ACCESS  0x00   //!< Direct Access (SBC)
-#define  SCSI_INQ_DT_SEQ_ACCESS  0x01   //!< Sequential Access
-#define  SCSI_INQ_DT_PRINTER     0x02   //!< Printer
-#define  SCSI_INQ_DT_PROCESSOR   0x03   //!< Processor device
-#define  SCSI_INQ_DT_WRITE_ONCE  0x04   //!< Write-once device
-#define  SCSI_INQ_DT_CD_DVD      0x05   //!< CD/DVD device
-#define  SCSI_INQ_DT_OPTICAL     0x07   //!< Optical Memory
-#define  SCSI_INQ_DT_MC          0x08   //!< Medium Changer
-#define  SCSI_INQ_DT_ARRAY       0x0C   //!< Storage Array Controller
-#define  SCSI_INQ_DT_ENCLOSURE   0x0D   //!< Enclosure Services
-#define  SCSI_INQ_DT_RBC         0x0E   //!< Simplified Direct Access
-#define  SCSI_INQ_DT_OCRW        0x0F   //!< Optical card reader/writer
-#define  SCSI_INQ_DT_BCC         0x10   //!< Bridge Controller Commands
-#define  SCSI_INQ_DT_OSD         0x11   //!< Object-based Storage
-#define  SCSI_INQ_DT_NONE        0x1F   //!< No Peripheral
-	uint8_t flags1; //!< Flags (byte 1)
-#define  SCSI_INQ_RMB            0x80   //!< Removable Medium
-	uint8_t version; //!< Version
-#define  SCSI_INQ_VER_NONE       0x00   //!< No standards conformance
-#define  SCSI_INQ_VER_SPC        0x03   //!< SCSI Primary Commands     (link to SBC)
-#define  SCSI_INQ_VER_SPC2       0x04   //!< SCSI Primary Commands - 2 (link to SBC-2)
-#define  SCSI_INQ_VER_SPC3       0x05   //!< SCSI Primary Commands - 3 (link to SBC-2)
-#define  SCSI_INQ_VER_SPC4       0x06   //!< SCSI Primary Commands - 4 (link to SBC-3)
-	uint8_t flags3; //!< Flags (byte 3)
-#define  SCSI_INQ_NORMACA        0x20   //!< Normal ACA Supported
-#define  SCSI_INQ_HISUP          0x10   //!< Hierarchal LUN addressing
-#define  SCSI_INQ_RSP_SPC2       0x02   //!< SPC-2 / SPC-3 response format
-	uint8_t addl_len; //!< Additional Length (n-4)
-#define  SCSI_INQ_ADDL_LEN(tot)  ((tot)-5) //!< Total length is \a tot
-	uint8_t flags5; //!< Flags (byte 5)
-#define  SCSI_INQ_SCCS           0x80
-	uint8_t flags6; //!< Flags (byte 6)
-#define  SCSI_INQ_BQUE           0x80
-#define  SCSI_INQ_ENCSERV        0x40
-#define  SCSI_INQ_MULTIP         0x10
-#define  SCSI_INQ_MCHGR          0x08
-#define  SCSI_INQ_ADDR16         0x01
-	uint8_t flags7; //!< Flags (byte 7)
-#define  SCSI_INQ_WBUS16         0x20
-#define  SCSI_INQ_SYNC           0x10
-#define  SCSI_INQ_LINKED         0x08
-#define  SCSI_INQ_CMDQUE         0x02
-	uint8_t vendor_id[8];   //!< T10 Vendor Identification
-	uint8_t product_id[16]; //!< Product Identification
-	uint8_t product_rev[4]; //!< Product Revision Level
-};
-
-/**
- * \brief SCSI Standard Request sense data structure
- */
-struct scsi_request_sense_data {
-	/* 1st byte: REQUEST SENSE response flags*/
-	uint8_t valid_reponse_code;
-#define  SCSI_SENSE_VALID              0x80 //!< Indicates the INFORMATION field contains valid information
-#define  SCSI_SENSE_RESPONSE_CODE_MASK 0x7F
-#define  SCSI_SENSE_CURRENT            0x70 //!< Response code 70h (current errors)
-#define  SCSI_SENSE_DEFERRED           0x71
-
-	/* 2nd byte */
-	uint8_t obsolete;
-
-	/* 3rd byte */
-	uint8_t sense_flag_key;
-#define  SCSI_SENSE_FILEMARK        0x80 //!< Indicates that the current command has read a filemark or setmark.
-#define  SCSI_SENSE_EOM             0x40 //!< Indicates that an end-of-medium condition exists.
-#define  SCSI_SENSE_ILI             0x20 //!< Indicates that the requested logical block length did not match the logical block length of the data on the medium.
-#define  SCSI_SENSE_RESERVED        0x10 //!< Reserved
-#define  SCSI_SENSE_KEY(x)          (x&0x0F) //!< Sense Key
-
-	/* 4th to 7th bytes - INFORMATION field */
-	uint8_t information[4];
-
-	/* 8th byte  - ADDITIONAL SENSE LENGTH field */
-	uint8_t AddSenseLen;
-#define  SCSI_SENSE_ADDL_LEN(total_len)   ((total_len) - 8)
-
-	/* 9th to 12th byte  - COMMAND-SPECIFIC INFORMATION field */
-	uint8_t CmdSpecINFO[4];
-
-	/* 13th byte  - ADDITIONAL SENSE CODE field */
-	uint8_t AddSenseCode;
-
-	/* 14th byte  - ADDITIONAL SENSE CODE QUALIFIER field */
-	uint8_t AddSnsCodeQlfr;
-
-	/* 15th byte  - FIELD REPLACEABLE UNIT CODE field */
-	uint8_t FldReplUnitCode;
-
-	/* 16th byte */
-	uint8_t SenseKeySpec[3];
-#define  SCSI_SENSE_SKSV            0x80 //!< Indicates the SENSE-KEY SPECIFIC field contains valid information
-};
-
-COMPILER_PACK_RESET()
-
-/* Vital Product Data page codes */
-enum scsi_vpd_page_code {
-	SCSI_VPD_SUPPORTED_PAGES = 0x00,
-	SCSI_VPD_UNIT_SERIAL_NUMBER = 0x80,
-	SCSI_VPD_DEVICE_IDENTIFICATION = 0x83,
-};
-#define  SCSI_VPD_HEADER_SIZE       4
-
-/* Constants associated with the Device Identification VPD page */
-#define  SCSI_VPD_ID_HEADER_SIZE    4
-
-#define  SCSI_VPD_CODE_SET_BINARY   1
-#define  SCSI_VPD_CODE_SET_ASCII    2
-#define  SCSI_VPD_CODE_SET_UTF8     3
-
-#define  SCSI_VPD_ID_TYPE_T10       1
-
-
-/* Sense keys */
-enum scsi_sense_key {
-	SCSI_SK_NO_SENSE = 0x0,
-	SCSI_SK_RECOVERED_ERROR = 0x1,
-	SCSI_SK_NOT_READY = 0x2,
-	SCSI_SK_MEDIUM_ERROR = 0x3,
-	SCSI_SK_HARDWARE_ERROR = 0x4,
-	SCSI_SK_ILLEGAL_REQUEST = 0x5,
-	SCSI_SK_UNIT_ATTENTION = 0x6,
-	SCSI_SK_DATA_PROTECT = 0x7,
-	SCSI_SK_BLANK_CHECK = 0x8,
-	SCSI_SK_VENDOR_SPECIFIC = 0x9,
-	SCSI_SK_COPY_ABORTED = 0xA,
-	SCSI_SK_ABORTED_COMMAND = 0xB,
-	SCSI_SK_VOLUME_OVERFLOW = 0xD,
-	SCSI_SK_MISCOMPARE = 0xE,
-};
-
-/* Additional Sense Code / Additional Sense Code Qualifier pairs */
-enum scsi_asc_ascq {
-	SCSI_ASC_NO_ADDITIONAL_SENSE_INFO = 0x0000,
-	SCSI_ASC_LU_NOT_READY_REBUILD_IN_PROGRESS = 0x0405,
-	SCSI_ASC_WRITE_ERROR = 0x0C00,
-	SCSI_ASC_UNRECOVERED_READ_ERROR = 0x1100,
-	SCSI_ASC_INVALID_COMMAND_OPERATION_CODE = 0x2000,
-	SCSI_ASC_INVALID_FIELD_IN_CDB = 0x2400,
-	SCSI_ASC_WRITE_PROTECTED = 0x2700,
-	SCSI_ASC_NOT_READY_TO_READY_CHANGE = 0x2800,
-	SCSI_ASC_MEDIUM_NOT_PRESENT = 0x3A00,
-	SCSI_ASC_INTERNAL_TARGET_FAILURE = 0x4400,
-};
-
-/**
- * \brief SPC-2 Mode parameter
- * This subclause describes the block descriptors and the pages
- * used with MODE SELECT and MODE SENSE commands
- * that are applicable to all SCSI devices.
- */
-enum scsi_spc_mode {
-	SCSI_MS_MODE_VENDOR_SPEC = 0x00,
-	SCSI_MS_MODE_INFEXP = 0x1C,    // Informational exceptions control page
-	SCSI_MS_MODE_ALL = 0x3F,
-};
-
-/**
- * \brief SPC-2 Informational exceptions control page
- * See chapter 8.3.8
- */
-struct spc_control_page_info_execpt {
-	uint8_t page_code;
-	uint8_t page_length;
-#define  SPC_MP_INFEXP_PAGE_LENGTH     0x0A
-	uint8_t flags1;
-#define  SPC_MP_INFEXP_PERF            (1<<7)   //!< Initiator Control
-#define  SPC_MP_INFEXP_EBF             (1<<5)   //!< Caching Analysis Permitted
-#define  SPC_MP_INFEXP_EWASC           (1<<4)   //!< Discontinuity
-#define  SPC_MP_INFEXP_DEXCPT          (1<<3)   //!< Size enable
-#define  SPC_MP_INFEXP_TEST            (1<<2)   //!< Writeback Cache Enable
-#define  SPC_MP_INFEXP_LOGERR          (1<<0)   //!< Log errors bit
-	uint8_t mrie;
-#define  SPC_MP_INFEXP_MRIE_NO_REPORT           0x00
-#define  SPC_MP_INFEXP_MRIE_ASYNC_EVENT         0x01
-#define  SPC_MP_INFEXP_MRIE_GEN_UNIT            0x02
-#define  SPC_MP_INFEXP_MRIE_COND_RECOV_ERROR    0x03
-#define  SPC_MP_INFEXP_MRIE_UNCOND_RECOV_ERROR  0x04
-#define  SPC_MP_INFEXP_MRIE_NO_SENSE            0x05
-#define  SPC_MP_INFEXP_MRIE_ONLY_REPORT         0x06
-	be32_t interval_timer;
-	be32_t report_count;
-};
-
-
-enum scsi_spc_mode_sense_pc {
-	SCSI_MS_SENSE_PC_CURRENT = 0,
-	SCSI_MS_SENSE_PC_CHANGEABLE = 1,
-	SCSI_MS_SENSE_PC_DEFAULT = 2,
-	SCSI_MS_SENSE_PC_SAVED = 3,
-};
-
-
-
-static inline bool scsi_mode_sense_dbd_is_set(const uint8_t * cdb)
-{
-	return (cdb[1] >> 3) & 1;
-}
-
-static inline uint8_t scsi_mode_sense_get_page_code(const uint8_t * cdb)
-{
-	return cdb[2] & 0x3F;
-}
-
-static inline uint8_t scsi_mode_sense_get_pc(const uint8_t * cdb)
-{
-	return cdb[2] >> 6;
-}
-
-/**
- * \brief SCSI Mode Parameter Header used by MODE SELECT(6) and MODE
- * SENSE(6)
- */
-struct scsi_mode_param_header6 {
-	uint8_t mode_data_length;	//!< Number of bytes after this
-	uint8_t medium_type;	//!< Medium Type
-	uint8_t device_specific_parameter;	//!< Defined by command set
-	uint8_t block_descriptor_length;	//!< Length of block descriptors
-};
-
-/**
- * \brief SCSI Mode Parameter Header used by MODE SELECT(10) and MODE
- * SENSE(10)
- */
-struct scsi_mode_param_header10 {
-	be16_t mode_data_length;	//!< Number of bytes after this
-	uint8_t medium_type;	//!< Medium Type
-	uint8_t device_specific_parameter;	//!< Defined by command set
-	uint8_t flags4;	//!< LONGLBA in bit 0
-	uint8_t reserved;
-	be16_t block_descriptor_length;	//!< Length of block descriptors
-};
-
-/**
- * \brief SCSI Page_0 Mode Page header (SPF not set)
- */
-struct scsi_mode_page_0_header {
-	uint8_t page_code;
-#define  SCSI_PAGE_CODE_PS          (1 << 7)	//!< Parameters Saveable
-#define  SCSI_PAGE_CODE_SPF         (1 << 6)	//!< SubPage Format
-	uint8_t page_length;	//!< Number of bytes after this
-#define  SCSI_MS_PAGE_LEN(total)   ((total) - 2)
-};
-
-//@}
-
-#endif // SPC_PROTOCOL_H_
diff --git a/Marlin/src/HAL/DUE/usb/stringz.h b/Marlin/src/HAL/DUE/usb/stringz.h
deleted file mode 100644
index fc9aaf3..0000000
--- a/Marlin/src/HAL/DUE/usb/stringz.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * \file
- *
- * \brief Preprocessor stringizing utils.
- *
- * Copyright (c) 2010-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _STRINGZ_H_
-#define _STRINGZ_H_
-
-/**
- * \defgroup group_sam_utils_stringz Preprocessor - Stringize
- *
- * \ingroup group_sam_utils
- *
- * \{
- */
-
-/*! \brief Stringize.
- *
- * Stringize a preprocessing token, this token being allowed to be \#defined.
- *
- * May be used only within macros with the token passed as an argument if the token is \#defined.
- *
- * For example, writing STRINGZ(PIN) within a macro \#defined by PIN_NAME(PIN)
- * and invoked as PIN_NAME(PIN0) with PIN0 \#defined as A0 is equivalent to
- * writing "A0".
- */
-#define STRINGZ(x)                                #x
-
-/*! \brief Absolute stringize.
- *
- * Stringize a preprocessing token, this token being allowed to be \#defined.
- *
- * No restriction of use if the token is \#defined.
- *
- * For example, writing ASTRINGZ(PIN0) anywhere with PIN0 \#defined as A0 is
- * equivalent to writing "A0".
- */
-#define ASTRINGZ(x)                               STRINGZ(x)
-
-/**
- * \}
- */
-
-#endif  // _STRINGZ_H_
diff --git a/Marlin/src/HAL/DUE/usb/sysclk.c b/Marlin/src/HAL/DUE/usb/sysclk.c
deleted file mode 100644
index cbb4e2c..0000000
--- a/Marlin/src/HAL/DUE/usb/sysclk.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/**
- * \file
- *
- * \brief Chip-specific system clock management functions.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "sysclk.h"
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-/**
- * \weakgroup sysclk_group
- * @{
- */
-
-#if defined(CONFIG_USBCLK_SOURCE) || defined(__DOXYGEN__)
-/**
- * \brief Enable full speed USB clock.
- *
- * \note The SAM3X PMC hardware interprets div as div+1. For readability the hardware div+1
- * is hidden in this implementation. Use div as div effective value.
- *
- * \param pll_id Source of the USB clock.
- * \param div Actual clock divisor. Must be superior to 0.
- */
-void sysclk_enable_usb(void)
-{
-	Assert(CONFIG_USBCLK_DIV > 0);
-
-#ifdef CONFIG_PLL0_SOURCE
-	if (CONFIG_USBCLK_SOURCE == USBCLK_SRC_PLL0) {
-		struct pll_config pllcfg;
-
-		pll_enable_source(CONFIG_PLL0_SOURCE);
-		pll_config_defaults(&pllcfg, 0);
-		pll_enable(&pllcfg, 0);
-		pll_wait_for_lock(0);
-		pmc_switch_udpck_to_pllack(CONFIG_USBCLK_DIV - 1);
-		pmc_enable_udpck();
-		return;
-	}
-#endif
-
-	if (CONFIG_USBCLK_SOURCE == USBCLK_SRC_UPLL) {
-
-		pmc_enable_upll_clock();
-		pmc_switch_udpck_to_upllck(CONFIG_USBCLK_DIV - 1);
-		pmc_enable_udpck();
-		return;
-	}
-}
-
-/**
- * \brief Disable full speed USB clock.
- *
- * \note This implementation does not switch off the PLL, it just turns off the USB clock.
- */
-void sysclk_disable_usb(void)
-{
-	pmc_disable_udpck();
-}
-#endif // CONFIG_USBCLK_SOURCE
-
-//! @}
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/sysclk.h b/Marlin/src/HAL/DUE/usb/sysclk.h
deleted file mode 100644
index 16db8c8..0000000
--- a/Marlin/src/HAL/DUE/usb/sysclk.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/**
- * \file
- *
- * \brief Chip-specific system clock management functions.
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef CHIP_SYSCLK_H_INCLUDED
-#define CHIP_SYSCLK_H_INCLUDED
-
-#include "osc.h"
-#include "pll.h"
-
-/**
- * \page sysclk_quickstart Quick Start Guide for the System Clock Management service (SAM3A)
- *
- * This is the quick start guide for the \ref sysclk_group "System Clock Management"
- * service, with step-by-step instructions on how to configure and use the service for
- * specific use cases.
- *
- * \section sysclk_quickstart_usecases System Clock Management use cases
- * - \ref sysclk_quickstart_basic
- *
- * \section sysclk_quickstart_basic Basic usage of the System Clock Management service
- * This section will present a basic use case for the System Clock Management service.
- * This use case will configure the main system clock to 84MHz, using an internal PLL
- * module to multiply the frequency of a crystal attached to the microcontroller.
- *
- * \subsection sysclk_quickstart_use_case_1_prereq Prerequisites
- *  - None
- *
- * \subsection sysclk_quickstart_use_case_1_setup_steps Initialization code
- * Add to the application initialization code:
- * \code
-	sysclk_init();
-\endcode
- *
- * \subsection sysclk_quickstart_use_case_1_setup_steps_workflow Workflow
- * -# Configure the system clocks according to the settings in conf_clock.h:
- *    \code sysclk_init(); \endcode
- *
- * \subsection sysclk_quickstart_use_case_1_example_code Example code
- *   Add or uncomment the following in your conf_clock.h header file, commenting out all other
- *   definitions of the same symbol(s):
- *   \code
-	   #define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_PLLACK
-
-	   // Fpll0 = (Fclk * PLL_mul) / PLL_div
-	   #define CONFIG_PLL0_SOURCE          PLL_SRC_MAINCK_XTAL
-	   #define CONFIG_PLL0_MUL             (84000000UL / BOARD_FREQ_MAINCK_XTAL)
-	   #define CONFIG_PLL0_DIV             1
-
-	   // Fbus = Fsys / BUS_div
-	   #define CONFIG_SYSCLK_PRES          SYSCLK_PRES_1
-\endcode
- *
- * \subsection sysclk_quickstart_use_case_1_example_workflow Workflow
- *  -# Configure the main system clock to use the output of the PLL module as its source:
- *   \code #define CONFIG_SYSCLK_SOURCE          SYSCLK_SRC_PLLACK \endcode
- *  -# Configure the PLL module to use the fast external fast crystal oscillator as its source:
- *   \code #define CONFIG_PLL0_SOURCE            PLL_SRC_MAINCK_XTAL \endcode
- *  -# Configure the PLL module to multiply the external fast crystal oscillator frequency up to 84MHz:
- *   \code
-	#define CONFIG_PLL0_MUL             (84000000UL / BOARD_FREQ_MAINCK_XTAL)
-	#define CONFIG_PLL0_DIV             1
-\endcode
- *   \note For user boards, \c BOARD_FREQ_MAINCK_XTAL should be defined in the board \c conf_board.h configuration
- *         file as the frequency of the fast crystal attached to the microcontroller.
- *  -# Configure the main clock to run at the full 84MHz, disable scaling of the main system clock speed:
- *    \code
-	#define CONFIG_SYSCLK_PRES         SYSCLK_PRES_1
-\endcode
- *    \note Some dividers are powers of two, while others are integer division factors. Refer to the
- *          formulas in the conf_clock.h template commented above each division define.
- */
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-/**
- * \weakgroup sysclk_group
- * @{
- */
-
-//! \name Configuration Symbols
-//@{
-/**
- * \def CONFIG_SYSCLK_SOURCE
- * \brief Initial/static main system clock source
- *
- * The main system clock will be configured to use this clock during
- * initialization.
- */
-#ifndef CONFIG_SYSCLK_SOURCE
-# define CONFIG_SYSCLK_SOURCE   SYSCLK_SRC_MAINCK_4M_RC
-#endif
-/**
- * \def CONFIG_SYSCLK_PRES
- * \brief Initial CPU clock divider (mck)
- *
- * The MCK will run at
- * \f[
- *   f_{MCK} = \frac{f_{sys}}{\mathrm{CONFIG\_SYSCLK\_PRES}}\,\mbox{Hz}
- * \f]
- * after initialization.
- */
-#ifndef CONFIG_SYSCLK_PRES
-# define CONFIG_SYSCLK_PRES  0
-#endif
-
-//@}
-
-//! \name Master Clock Sources (MCK)
-//@{
-#define SYSCLK_SRC_SLCK_RC              0       //!< Internal 32kHz RC oscillator as master source clock
-#define SYSCLK_SRC_SLCK_XTAL            1       //!< External 32kHz crystal oscillator as master source clock
-#define SYSCLK_SRC_SLCK_BYPASS          2       //!< External 32kHz bypass oscillator as master source clock
-#define SYSCLK_SRC_MAINCK_4M_RC         3       //!< Internal 4MHz RC oscillator as master source clock
-#define SYSCLK_SRC_MAINCK_8M_RC         4       //!< Internal 8MHz RC oscillator as master source clock
-#define SYSCLK_SRC_MAINCK_12M_RC        5       //!< Internal 12MHz RC oscillator as master source clock
-#define SYSCLK_SRC_MAINCK_XTAL          6       //!< External crystal oscillator as master source clock
-#define SYSCLK_SRC_MAINCK_BYPASS        7       //!< External bypass oscillator as master source clock
-#define SYSCLK_SRC_PLLACK               8       //!< Use PLLACK as master source clock
-#define SYSCLK_SRC_UPLLCK               9       //!< Use UPLLCK as master source clock
-//@}
-
-//! \name Master Clock Prescalers (MCK)
-//@{
-#define SYSCLK_PRES_1           PMC_MCKR_PRES_CLK_1     //!< Set master clock prescaler to 1
-#define SYSCLK_PRES_2           PMC_MCKR_PRES_CLK_2     //!< Set master clock prescaler to 2
-#define SYSCLK_PRES_4           PMC_MCKR_PRES_CLK_4     //!< Set master clock prescaler to 4
-#define SYSCLK_PRES_8           PMC_MCKR_PRES_CLK_8     //!< Set master clock prescaler to 8
-#define SYSCLK_PRES_16          PMC_MCKR_PRES_CLK_16    //!< Set master clock prescaler to 16
-#define SYSCLK_PRES_32          PMC_MCKR_PRES_CLK_32    //!< Set master clock prescaler to 32
-#define SYSCLK_PRES_64          PMC_MCKR_PRES_CLK_64    //!< Set master clock prescaler to 64
-#define SYSCLK_PRES_3           PMC_MCKR_PRES_CLK_3     //!< Set master clock prescaler to 3
-//@}
-
-//! \name USB Clock Sources
-//@{
-#define USBCLK_SRC_PLL0       0     //!< Use PLLA
-#define USBCLK_SRC_UPLL       1     //!< Use UPLL
-//@}
-
-/**
- * \def CONFIG_USBCLK_SOURCE
- * \brief Configuration symbol for the USB generic clock source
- *
- * Sets the clock source to use for the USB. The source must also be properly
- * configured.
- *
- * Define this to one of the \c USBCLK_SRC_xxx settings. Leave it undefined if
- * USB is not required.
- */
-#ifdef __DOXYGEN__
-# define CONFIG_USBCLK_SOURCE
-#endif
-
-/**
- * \def CONFIG_USBCLK_DIV
- * \brief Configuration symbol for the USB generic clock divider setting
- *
- * Sets the clock division for the USB generic clock. If a USB clock source is
- * selected with CONFIG_USBCLK_SOURCE, this configuration symbol must also be
- * defined.
- */
-#ifdef __DOXYGEN__
-# define CONFIG_USBCLK_DIV
-#endif
-
-
-extern void sysclk_enable_usb(void);
-extern void sysclk_disable_usb(void);
-
-//! @}
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif /* CHIP_SYSCLK_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/tpaste.h b/Marlin/src/HAL/DUE/usb/tpaste.h
deleted file mode 100644
index 2ad3f27..0000000
--- a/Marlin/src/HAL/DUE/usb/tpaste.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * \file
- *
- * \brief Preprocessor token pasting utils.
- *
- * Copyright (c) 2010-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _TPASTE_H_
-#define _TPASTE_H_
-
-/**
- * \defgroup group_sam_utils_tpaste Preprocessor - Token Paste
- *
- * \ingroup group_sam_utils
- *
- * \{
- */
-
-/*! \name Token Paste
- *
- * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
- *
- * May be used only within macros with the tokens passed as arguments if the tokens are \#defined.
- *
- * For example, writing TPASTE2(U, WIDTH) within a macro \#defined by
- * UTYPE(WIDTH) and invoked as UTYPE(UL_WIDTH) with UL_WIDTH \#defined as 32 is
- * equivalent to writing U32.
- */
-//! @{
-#define TPASTE2( a, b)                            a##b
-#define TPASTE3( a, b, c)                         a##b##c
-#define TPASTE4( a, b, c, d)                      a##b##c##d
-#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e
-#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f
-#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g
-#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h
-#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i
-#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j
-//! @}
-
-/*! \name Absolute Token Paste
- *
- * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
- *
- * No restriction of use if the tokens are \#defined.
- *
- * For example, writing ATPASTE2(U, UL_WIDTH) anywhere with UL_WIDTH \#defined
- * as 32 is equivalent to writing U32.
- */
-//! @{
-#define ATPASTE2( a, b)                           TPASTE2( a, b)
-#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)
-#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)
-#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)
-#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)
-#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)
-#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)
-#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)
-#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)
-//! @}
-
-/**
- * \}
- */
-
-#endif  // _TPASTE_H_
diff --git a/Marlin/src/HAL/DUE/usb/udc.c b/Marlin/src/HAL/DUE/usb/udc.c
deleted file mode 100644
index 60bf0cf..0000000
--- a/Marlin/src/HAL/DUE/usb/udc.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Controller (UDC)
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "udd.h"
-#include "udc_desc.h"
-#include "udi.h"
-#include "udc.h"
-
-/**
- * \ingroup udc_group
- * \defgroup udc_group_interne Implementation of UDC
- *
- * Internal implementation
- * @{
- */
-
-//! \name Internal variables to manage the USB device
-//! @{
-
-//! Device status state (see enum usb_device_status in usb_protocol.h)
-static le16_t udc_device_status;
-
-COMPILER_WORD_ALIGNED
-//! Device interface setting value
-static uint8_t udc_iface_setting = 0;
-
-//! Device Configuration number selected by the USB host
-COMPILER_WORD_ALIGNED
-static uint8_t udc_num_configuration = 0;
-
-//! Pointer on the selected speed device configuration
-static udc_config_speed_t UDC_DESC_STORAGE *udc_ptr_conf;
-
-//! Pointer on interface descriptor used by SETUP request.
-static usb_iface_desc_t UDC_DESC_STORAGE *udc_ptr_iface;
-
-//! @}
-
-
-//! \name Internal structure to store the USB device main strings
-//! @{
-
-/**
- * \brief Language ID of USB device (US ID by default)
- */
-COMPILER_WORD_ALIGNED
-static UDC_DESC_STORAGE usb_str_lgid_desc_t udc_string_desc_languageid = {
-	.desc.bLength = sizeof(usb_str_lgid_desc_t),
-	.desc.bDescriptorType = USB_DT_STRING,
-	.string = {LE16(USB_LANGID_EN_US)}
-};
-
-/**
- * \brief USB device manufacture name storage
- * String is allocated only if USB_DEVICE_MANUFACTURE_NAME is declared
- * by usb application configuration
- */
-#ifdef USB_DEVICE_MANUFACTURE_NAME
-static uint8_t udc_string_manufacturer_name[] = USB_DEVICE_MANUFACTURE_NAME;
-#  define USB_DEVICE_MANUFACTURE_NAME_SIZE  \
-	(sizeof(udc_string_manufacturer_name)-1)
-#else
-#  define USB_DEVICE_MANUFACTURE_NAME_SIZE  0
-#endif
-
-/**
- * \brief USB device product name storage
- * String is allocated only if USB_DEVICE_PRODUCT_NAME is declared
- * by usb application configuration
- */
-#ifdef USB_DEVICE_PRODUCT_NAME
-static uint8_t udc_string_product_name[] = USB_DEVICE_PRODUCT_NAME;
-#  define USB_DEVICE_PRODUCT_NAME_SIZE  (sizeof(udc_string_product_name)-1)
-#else
-#  define USB_DEVICE_PRODUCT_NAME_SIZE  0
-#endif
-
-/**
- * \brief Get USB device serial number
- *
- * Use the define USB_DEVICE_SERIAL_NAME to set static serial number.
- *
- * For dynamic serial number set the define USB_DEVICE_GET_SERIAL_NAME_POINTER
- * to a suitable pointer. This will also require the serial number length
- * define USB_DEVICE_GET_SERIAL_NAME_LENGTH.
- */
-#if defined USB_DEVICE_GET_SERIAL_NAME_POINTER
-	static const uint8_t *udc_get_string_serial_name(void)
-	{
-		return (const uint8_t *)USB_DEVICE_GET_SERIAL_NAME_POINTER;
-	}
-#  define USB_DEVICE_SERIAL_NAME_SIZE \
-	USB_DEVICE_GET_SERIAL_NAME_LENGTH
-#elif defined USB_DEVICE_SERIAL_NAME
-	static const uint8_t *udc_get_string_serial_name(void)
-	{
-		return (const uint8_t *)USB_DEVICE_SERIAL_NAME;
-	}
-#  define USB_DEVICE_SERIAL_NAME_SIZE \
-	(sizeof(USB_DEVICE_SERIAL_NAME)-1)
-#else
-#  define USB_DEVICE_SERIAL_NAME_SIZE  0
-#endif
-
-/**
- * \brief USB device string descriptor
- * Structure used to transfer ASCII strings to USB String descriptor structure.
- */
-struct udc_string_desc_t {
-	usb_str_desc_t header;
-	le16_t string[Max(Max(USB_DEVICE_MANUFACTURE_NAME_SIZE, \
-			USB_DEVICE_PRODUCT_NAME_SIZE), USB_DEVICE_SERIAL_NAME_SIZE)];
-};
-COMPILER_WORD_ALIGNED
-static UDC_DESC_STORAGE struct udc_string_desc_t udc_string_desc = {
-	.header.bDescriptorType = USB_DT_STRING
-};
-//! @}
-
-usb_iface_desc_t UDC_DESC_STORAGE *udc_get_interface_desc(void)
-{
-	return udc_ptr_iface;
-}
-
-/**
- * \brief Returns a value to check the end of USB Configuration descriptor
- *
- * \return address after the last byte of USB Configuration descriptor
- */
-static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
-{
-	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
-			udc_ptr_conf->desc +
-			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
-}
-
-#if (0!=USB_DEVICE_MAX_EP)
-/**
- * \brief Search specific descriptor in global interface descriptor
- *
- * \param desc       Address of interface descriptor
- *                   or previous specific descriptor found
- * \param desc_id    Descriptor ID to search
- *
- * \return address of specific descriptor found
- * \return NULL if it is the end of global interface descriptor
- */
-static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
-		UDC_DESC_STORAGE * desc, uint8_t desc_id)
-{
-	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;
-
-	ptr_eof_desc = udc_get_eof_conf();
-	// Go to next descriptor
-	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
-			desc->bLength);
-	// Check the end of configuration descriptor
-	while (ptr_eof_desc > desc) {
-		// If new interface descriptor is found,
-		// then it is the end of the current global interface descriptor
-		if (USB_DT_INTERFACE == desc->bDescriptorType) {
-			break; // End of global interface descriptor
-		}
-		if (desc_id == desc->bDescriptorType) {
-			return desc; // Specific descriptor found
-		}
-		// Go to next descriptor
-		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
-				desc->bLength);
-	}
-	return NULL; // No specific descriptor found
-}
-#endif
-
-/**
- * \brief Search an interface descriptor
- * This routine updates the internal pointer udc_ptr_iface.
- *
- * \param iface_num     Interface number to find in Configuration Descriptor
- * \param setting_num   Setting number of interface to find
- *
- * \return 1 if found or 0 if not found
- */
-static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
-{
-	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;
-
-	if (0 == udc_num_configuration) {
-		return false;
-	}
-
-	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
-		return false;
-	}
-
-	// Start at the beginning of configuration descriptor
-	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
-			udc_ptr_conf->desc;
-
-	// Check the end of configuration descriptor
-	ptr_end_desc = udc_get_eof_conf();
-	while (ptr_end_desc >
-			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
-		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
-			// A interface descriptor is found
-			// Check interface and alternate setting number
-			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
-					(setting_num ==
-					udc_ptr_iface->bAlternateSetting)) {
-				return true; // Interface found
-			}
-		}
-		// Go to next descriptor
-		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
-				(uint8_t *) udc_ptr_iface +
-				udc_ptr_iface->bLength);
-	}
-	return false; // Interface not found
-}
-
-/**
- * \brief Disables an usb device interface (UDI)
- * This routine call the UDI corresponding to interface number
- *
- * \param iface_num     Interface number to disable
- *
- * \return 1 if it is done or 0 if interface is not found
- */
-static bool udc_iface_disable(uint8_t iface_num)
-{
-	udi_api_t UDC_DESC_STORAGE *udi_api;
-
-	// Select first alternate setting of the interface
-	// to update udc_ptr_iface before call iface->getsetting()
-	if (!udc_update_iface_desc(iface_num, 0)) {
-		return false;
-	}
-
-	// Select the interface with the current alternate setting
-	udi_api = udc_ptr_conf->udi_apis[iface_num];
-
-#if (0!=USB_DEVICE_MAX_EP)
-	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
-		return false;
-	}
-
-	// Start at the beginning of interface descriptor
-	{
-		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
-		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
-		while (1) {
-			// Search Endpoint descriptor included in global interface descriptor
-			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
-					udc_next_desc_in_iface((UDC_DESC_STORAGE
-					usb_conf_desc_t *)
-					ep_desc, USB_DT_ENDPOINT);
-			if (NULL == ep_desc) {
-				break;
-			}
-			// Free the endpoint used by the interface
-			udd_ep_free(ep_desc->bEndpointAddress);
-		}
-	}
-#endif
-
-	// Disable interface
-	udi_api->disable();
-	return true;
-}
-
-/**
- * \brief Enables an usb device interface (UDI)
- * This routine calls the UDI corresponding
- * to the interface and setting number.
- *
- * \param iface_num     Interface number to enable
- * \param setting_num   Setting number to enable
- *
- * \return 1 if it is done or 0 if interface is not found
- */
-static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
-{
-	// Select the interface descriptor
-	if (!udc_update_iface_desc(iface_num, setting_num)) {
-		return false;
-	}
-
-#if (0!=USB_DEVICE_MAX_EP)
-	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
-
-	// Start at the beginning of the global interface descriptor
-	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
-	while (1) {
-		// Search Endpoint descriptor included in the global interface descriptor
-		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
-				udc_next_desc_in_iface((UDC_DESC_STORAGE
-						usb_conf_desc_t *) ep_desc,
-				USB_DT_ENDPOINT);
-		if (NULL == ep_desc)
-			break;
-		// Alloc the endpoint used by the interface
-		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
-				ep_desc->bmAttributes,
-				le16_to_cpu
-				(ep_desc->wMaxPacketSize))) {
-			return false;
-		}
-	}
-#endif
-	// Enable the interface
-	return udc_ptr_conf->udi_apis[iface_num]->enable();
-}
-
-/*! \brief Start the USB Device stack
- */
-void udc_start(void)
-{
-	udd_enable();
-}
-
-/*! \brief Stop the USB Device stack
- */
-void udc_stop(void)
-{
-	udd_disable();
-	udc_reset();
-}
-
-/**
- * \brief Reset the current configuration of the USB device,
- * This routines can be called by UDD when a RESET on the USB line occurs.
- */
-void udc_reset(void)
-{
-	uint8_t iface_num;
-
-	if (udc_num_configuration) {
-		for (iface_num = 0;
-				iface_num < udc_ptr_conf->desc->bNumInterfaces;
-				iface_num++) {
-			udc_iface_disable(iface_num);
-		}
-	}
-	udc_num_configuration = 0;
-#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
-	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
-	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
-		// Remote wakeup is enabled then disable it
-		UDC_REMOTEWAKEUP_DISABLE();
-	}
-#endif
-	udc_device_status =
-#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
-			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
-#else
-			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
-#endif
-}
-
-void udc_sof_notify(void)
-{
-	uint8_t iface_num;
-
-	if (udc_num_configuration) {
-		for (iface_num = 0;
-				iface_num < udc_ptr_conf->desc->bNumInterfaces;
-				iface_num++) {
-			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
-				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
-			}
-		}
-	}
-}
-
-/**
- * \brief Standard device request to get device status
- *
- * \return true if success
- */
-static bool udc_req_std_dev_get_status(void)
-{
-	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
-		return false;
-	}
-
-	udd_set_setup_payload( (uint8_t *) & udc_device_status,
-			sizeof(udc_device_status));
-	return true;
-}
-
-#if (0!=USB_DEVICE_MAX_EP)
-/**
- * \brief Standard endpoint request to get endpoint status
- *
- * \return true if success
- */
-static bool udc_req_std_ep_get_status(void)
-{
-	static le16_t udc_ep_status;
-
-	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
-		return false;
-	}
-
-	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
-			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;
-
-	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
-			sizeof(udc_ep_status));
-	return true;
-}
-#endif
-
-/**
- * \brief Standard device request to change device status
- *
- * \return true if success
- */
-static bool udc_req_std_dev_clear_feature(void)
-{
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-
-	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
-		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
-#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
-	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
-		UDC_REMOTEWAKEUP_DISABLE();
-#endif
-		return true;
-	}
-	return false;
-}
-
-#if (0!=USB_DEVICE_MAX_EP)
-/**
- * \brief Standard endpoint request to clear endpoint feature
- *
- * \return true if success
- */
-static bool udc_req_std_ep_clear_feature(void)
-{
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-
-	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
-		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
-	}
-	return false;
-}
-#endif
-
-/**
- * \brief Standard device request to set a feature
- *
- * \return true if success
- */
-static bool udc_req_std_dev_set_feature(void)
-{
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-
-	switch (udd_g_ctrlreq.req.wValue) {
-
-	case USB_DEV_FEATURE_REMOTE_WAKEUP:
-#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
-	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
-		udc_device_status |= CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP);
-		UDC_REMOTEWAKEUP_ENABLE();
-		return true;
-#else
-		return false;
-#endif
-
-#ifdef USB_DEVICE_HS_SUPPORT
-	case USB_DEV_FEATURE_TEST_MODE:
-		if (!udd_is_high_speed()) {
-			break;
-		}
-		if (udd_g_ctrlreq.req.wIndex & 0xFF) {
-			break;
-		}
-		// Unconfigure the device, terminating all ongoing requests
-		udc_reset();
-		switch ((udd_g_ctrlreq.req.wIndex >> 8) & 0xFF) {
-		case USB_DEV_TEST_MODE_J:
-			udd_g_ctrlreq.callback = udd_test_mode_j;
-			return true;
-
-		case USB_DEV_TEST_MODE_K:
-			udd_g_ctrlreq.callback = udd_test_mode_k;
-			return true;
-
-		case USB_DEV_TEST_MODE_SE0_NAK:
-			udd_g_ctrlreq.callback = udd_test_mode_se0_nak;
-			return true;
-
-		case USB_DEV_TEST_MODE_PACKET:
-			udd_g_ctrlreq.callback = udd_test_mode_packet;
-			return true;
-
-		case USB_DEV_TEST_MODE_FORCE_ENABLE: // Only for downstream facing hub ports
-		default:
-			break;
-		}
-		break;
-#endif
-	default:
-		break;
-	}
-	return false;
-}
-
-/**
- * \brief Standard endpoint request to halt an endpoint
- *
- * \return true if success
- */
-#if (0!=USB_DEVICE_MAX_EP)
-static bool udc_req_std_ep_set_feature(void)
-{
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
-		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
-		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
-	}
-	return false;
-}
-#endif
-
-/**
- * \brief Change the address of device
- * Callback called at the end of request set address
- */
-static void udc_valid_address(void)
-{
-	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
-}
-
-/**
- * \brief Standard device request to set device address
- *
- * \return true if success
- */
-static bool udc_req_std_dev_set_address(void)
-{
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-
-	// The address must be changed at the end of setup request after the handshake
-	// then we use a callback to change address
-	udd_g_ctrlreq.callback = udc_valid_address;
-	return true;
-}
-
-/**
- * \brief Standard device request to get device string descriptor
- *
- * \return true if success
- */
-static bool udc_req_std_dev_get_str_desc(void)
-{
-	uint8_t i;
-	const uint8_t *str;
-	uint8_t str_length = 0;
-
-	// Link payload pointer to the string corresponding at request
-	switch (udd_g_ctrlreq.req.wValue & 0xFF) {
-	case 0:
-		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
-				sizeof(udc_string_desc_languageid));
-		break;
-
-#ifdef USB_DEVICE_MANUFACTURE_NAME
-	case 1:
-		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
-		str = udc_string_manufacturer_name;
-		break;
-#endif
-#ifdef USB_DEVICE_PRODUCT_NAME
-	case 2:
-		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
-		str = udc_string_product_name;
-		break;
-#endif
-#if defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER
-	case 3:
-		str_length = USB_DEVICE_SERIAL_NAME_SIZE;
-		str = udc_get_string_serial_name();
-		break;
-#endif
-	default:
-#ifdef UDC_GET_EXTRA_STRING
-		if (UDC_GET_EXTRA_STRING()) {
-			break;
-		}
-#endif
-		return false;
-	}
-
-	if (str_length) {
-		for(i = 0; i < str_length; i++) {
-			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
-		}
-
-		udc_string_desc.header.bLength = 2 + (str_length) * 2;
-		udd_set_setup_payload(
-			(uint8_t *) &udc_string_desc,
-			udc_string_desc.header.bLength);
-	}
-
-	return true;
-}
-
-/**
- * \brief Standard device request to get descriptors about USB device
- *
- * \return true if success
- */
-static bool udc_req_std_dev_get_descriptor(void)
-{
-	uint8_t conf_num;
-
-	conf_num = udd_g_ctrlreq.req.wValue & 0xFF;
-
-	// Check descriptor ID
-	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
-	case USB_DT_DEVICE:
-		// Device descriptor requested
-#ifdef USB_DEVICE_HS_SUPPORT
-		if (!udd_is_high_speed()) {
-			udd_set_setup_payload(
-				(uint8_t *) udc_config.confdev_hs,
-				udc_config.confdev_hs->bLength);
-		} else
-#endif
-		{
-			udd_set_setup_payload(
-				(uint8_t *) udc_config.confdev_lsfs,
-				udc_config.confdev_lsfs->bLength);
-		}
-		break;
-
-	case USB_DT_CONFIGURATION:
-		// Configuration descriptor requested
-#ifdef USB_DEVICE_HS_SUPPORT
-		if (udd_is_high_speed()) {
-			// HS descriptor
-			if (conf_num >= udc_config.confdev_hs->
-					bNumConfigurations) {
-				return false;
-			}
-			udd_set_setup_payload(
-				(uint8_t *)udc_config.conf_hs[conf_num].desc,
-				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
-		} else
-#endif
-		{
-			// FS descriptor
-			if (conf_num >= udc_config.confdev_lsfs->
-					bNumConfigurations) {
-				return false;
-			}
-			udd_set_setup_payload(
-				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
-				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
-		}
-		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
-				USB_DT_CONFIGURATION;
-		break;
-
-#ifdef USB_DEVICE_HS_SUPPORT
-	case USB_DT_DEVICE_QUALIFIER:
-		// Device qualifier descriptor requested
-		udd_set_setup_payload( (uint8_t *) udc_config.qualifier,
-				udc_config.qualifier->bLength);
-		break;
-
-	case USB_DT_OTHER_SPEED_CONFIGURATION:
-		// Other configuration descriptor requested
-		if (!udd_is_high_speed()) {
-			// HS descriptor
-			if (conf_num >= udc_config.confdev_hs->
-					bNumConfigurations) {
-				return false;
-			}
-			udd_set_setup_payload(
-				(uint8_t *)udc_config.conf_hs[conf_num].desc,
-				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
-		} else {
-			// FS descriptor
-			if (conf_num >= udc_config.confdev_lsfs->
-					bNumConfigurations) {
-				return false;
-			}
-			udd_set_setup_payload(
-				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
-				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
-		}
-		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
-				USB_DT_OTHER_SPEED_CONFIGURATION;
-		break;
-#endif
-
-	case USB_DT_BOS:
-		// Device BOS descriptor requested
-		if (udc_config.conf_bos == NULL) {
-			return false;
-		}
-		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
-				udc_config.conf_bos->wTotalLength);
-		break;
-
-	case USB_DT_STRING:
-		// String descriptor requested
-		if (!udc_req_std_dev_get_str_desc()) {
-			return false;
-		}
-		break;
-
-	default:
-		// Unknown descriptor requested
-		return false;
-	}
-	// if the descriptor is larger than length requested, then reduce it
-	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
-		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
-	}
-	return true;
-}
-
-/**
- * \brief Standard device request to get configuration number
- *
- * \return true if success
- */
-static bool udc_req_std_dev_get_configuration(void)
-{
-	if (udd_g_ctrlreq.req.wLength != 1) {
-		return false;
-	}
-
-	udd_set_setup_payload(&udc_num_configuration,1);
-	return true;
-}
-
-/**
- * \brief Standard device request to enable a configuration
- *
- * \return true if success
- */
-static bool udc_req_std_dev_set_configuration(void)
-{
-	uint8_t iface_num;
-
-	// Check request length
-	if (udd_g_ctrlreq.req.wLength) {
-		return false;
-	}
-	// Authorize configuration only if the address is valid
-	if (!udd_getaddress()) {
-		return false;
-	}
-	// Check the configuration number requested
-#ifdef USB_DEVICE_HS_SUPPORT
-	if (udd_is_high_speed()) {
-		// HS descriptor
-		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
-				udc_config.confdev_hs->bNumConfigurations) {
-			return false;
-		}
-	} else
-#endif
-	{
-		// FS descriptor
-		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
-				udc_config.confdev_lsfs->bNumConfigurations) {
-			return false;
-		}
-	}
-
-	// Reset current configuration
-	udc_reset();
-
-	// Enable new configuration
-	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
-	if (udc_num_configuration == 0) {
-		return true; // Default empty configuration requested
-	}
-	// Update pointer of the configuration descriptor
-#ifdef USB_DEVICE_HS_SUPPORT
-	if (udd_is_high_speed()) {
-		// HS descriptor
-		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
-	} else
-#endif
-	{
-		// FS descriptor
-		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
-	}
-	// Enable all interfaces of the selected configuration
-	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
-			iface_num++) {
-		if (!udc_iface_enable(iface_num, 0)) {
-			return false;
-		}
-	}
-	return true;
-}
-
-/**
- * \brief Standard interface request
- * to get the alternate setting number of an interface
- *
- * \return true if success
- */
-static bool udc_req_std_iface_get_setting(void)
-{
-	uint8_t iface_num;
-	udi_api_t UDC_DESC_STORAGE *udi_api;
-
-	if (udd_g_ctrlreq.req.wLength != 1) {
-		return false; // Error in request
-	}
-	if (!udc_num_configuration) {
-		return false; // The device is not is configured state yet
-	}
-
-	// Check the interface number included in the request
-	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
-	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
-		return false;
-	}
-
-	// Select first alternate setting of the interface to update udc_ptr_iface
-	// before call iface->getsetting()
-	if (!udc_update_iface_desc(iface_num, 0)) {
-		return false;
-	}
-	// Get alternate setting from UDI
-	udi_api = udc_ptr_conf->udi_apis[iface_num];
-	udc_iface_setting = udi_api->getsetting();
-
-	// Link value to payload pointer of request
-	udd_set_setup_payload(&udc_iface_setting,1);
-	return true;
-}
-
-/**
- * \brief Standard interface request
- * to set an alternate setting of an interface
- *
- * \return true if success
- */
-static bool udc_req_std_iface_set_setting(void)
-{
-	uint8_t iface_num, setting_num;
-
-	if (udd_g_ctrlreq.req.wLength) {
-		return false; // Error in request
-	}
-	if (!udc_num_configuration) {
-		return false; // The device is not is configured state yet
-	}
-
-	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
-	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
-
-	// Disable current setting
-	if (!udc_iface_disable(iface_num)) {
-		return false;
-	}
-
-	// Enable new setting
-	return udc_iface_enable(iface_num, setting_num);
-}
-
-/**
- * \brief Main routine to manage the standard USB SETUP request
- *
- * \return true if the request is supported
- */
-static bool udc_reqstd(void)
-{
-	if (Udd_setup_is_in()) {
-		// GET Standard Requests
-		if (udd_g_ctrlreq.req.wLength == 0) {
-			return false; // Error for USB host
-		}
-
-		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
-			// Standard Get Device request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_GET_STATUS:
-				return udc_req_std_dev_get_status();
-			case USB_REQ_GET_DESCRIPTOR:
-				return udc_req_std_dev_get_descriptor();
-			case USB_REQ_GET_CONFIGURATION:
-				return udc_req_std_dev_get_configuration();
-			default:
-				break;
-			}
-		}
-
-		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
-			// Standard Get Interface request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_GET_INTERFACE:
-				return udc_req_std_iface_get_setting();
-			default:
-				break;
-			}
-		}
-#if (0!=USB_DEVICE_MAX_EP)
-		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
-			// Standard Get Endpoint request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_GET_STATUS:
-				return udc_req_std_ep_get_status();
-			default:
-				break;
-			}
-		}
-#endif
-	} else {
-		// SET Standard Requests
-		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
-			// Standard Set Device request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_SET_ADDRESS:
-				return udc_req_std_dev_set_address();
-			case USB_REQ_CLEAR_FEATURE:
-				return udc_req_std_dev_clear_feature();
-			case USB_REQ_SET_FEATURE:
-				return udc_req_std_dev_set_feature();
-			case USB_REQ_SET_CONFIGURATION:
-				return udc_req_std_dev_set_configuration();
-			case USB_REQ_SET_DESCRIPTOR:
-				/* Not supported (defined as optional by the USB 2.0 spec) */
-				break;
-			default:
-				break;
-			}
-		}
-
-		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
-			// Standard Set Interface request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_SET_INTERFACE:
-				return udc_req_std_iface_set_setting();
-			default:
-				break;
-			}
-		}
-#if (0!=USB_DEVICE_MAX_EP)
-		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
-			// Standard Set Endpoint request
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_CLEAR_FEATURE:
-				return udc_req_std_ep_clear_feature();
-			case USB_REQ_SET_FEATURE:
-				return udc_req_std_ep_set_feature();
-			default:
-				break;
-			}
-		}
-#endif
-	}
-	return false;
-}
-
-/**
- * \brief Send the SETUP interface request to UDI
- *
- * \return true if the request is supported
- */
-static bool udc_req_iface(void)
-{
-	uint8_t iface_num;
-	udi_api_t UDC_DESC_STORAGE *udi_api;
-
-	if (0 == udc_num_configuration) {
-		return false; // The device is not is configured state yet
-	}
-	// Check interface number
-	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
-	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
-		return false;
-	}
-
-	//* To update udc_ptr_iface with the selected interface in request
-	// Select first alternate setting of interface to update udc_ptr_iface
-	// before calling udi_api->getsetting()
-	if (!udc_update_iface_desc(iface_num, 0)) {
-		return false;
-	}
-	// Select the interface with the current alternate setting
-	udi_api = udc_ptr_conf->udi_apis[iface_num];
-	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
-		return false;
-	}
-
-	// Send the SETUP request to the UDI corresponding to the interface number
-	return udi_api->setup();
-}
-
-/**
- * \brief Send the SETUP interface request to UDI
- *
- * \return true if the request is supported
- */
-static bool udc_req_ep(void)
-{
-	uint8_t iface_num;
-	udi_api_t UDC_DESC_STORAGE *udi_api;
-
-	if (0 == udc_num_configuration) {
-		return false; // The device is not is configured state yet
-	}
-	// Send this request on all enabled interfaces
-	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
-	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
-			iface_num++) {
-		// Select the interface with the current alternate setting
-		udi_api = udc_ptr_conf->udi_apis[iface_num];
-		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
-			return false;
-		}
-
-		// Send the SETUP request to the UDI
-		if (udi_api->setup()) {
-			return true;
-		}
-	}
-	return false;
-}
-
-/**
- * \brief Main routine to manage the USB SETUP request.
- *
- * This function parses a USB SETUP request and submits an appropriate
- * response back to the host or, in the case of SETUP OUT requests
- * with data, sets up a buffer for receiving the data payload.
- *
- * The main standard requests defined by the USB 2.0 standard are handled
- * internally. The interface requests are sent to UDI, and the specific request
- * sent to a specific application callback.
- *
- * \return true if the request is supported, else the request is stalled by UDD
- */
-bool udc_process_setup(void)
-{
-	// By default no data (receive/send) and no callbacks registered
-	udd_g_ctrlreq.payload_size = 0;
-	udd_g_ctrlreq.callback = NULL;
-	udd_g_ctrlreq.over_under_run = NULL;
-
-	if (Udd_setup_is_in()) {
-		if (udd_g_ctrlreq.req.wLength == 0) {
-			return false; // Error from USB host
-		}
-	}
-
-	// If standard request then try to decode it in UDC
-	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
-		if (udc_reqstd()) {
-			return true;
-		}
-	}
-
-	// If interface request then try to decode it in UDI
-	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
-		if (udc_req_iface()) {
-			return true;
-		}
-	}
-
-	// If endpoint request then try to decode it in UDI
-	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
-		if (udc_req_ep()) {
-			return true;
-		}
-	}
-
-	// Here SETUP request unknown by UDC and UDIs
-#ifdef USB_DEVICE_SPECIFIC_REQUEST
-	// Try to decode it in specific callback
-	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
-#else
-	return false;
-#endif
-}
-
-//! @}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/udc.h b/Marlin/src/HAL/DUE/usb/udc.h
deleted file mode 100644
index 8d92eb5..0000000
--- a/Marlin/src/HAL/DUE/usb/udc.h
+++ /dev/null
@@ -1,697 +0,0 @@
-/**
- * \file
- *
- * \brief Interface of the USB Device Controller (UDC)
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDC_H_
-#define _UDC_H_
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "udc_desc.h"
-#include "udd.h"
-
-#if USB_DEVICE_VENDOR_ID == 0
-#   error USB_DEVICE_VENDOR_ID cannot be equal to 0
-#endif
-
-#if USB_DEVICE_PRODUCT_ID == 0
-#   error USB_DEVICE_PRODUCT_ID cannot be equal to 0
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \ingroup usb_device_group
- * \defgroup udc_group USB Device Controller (UDC)
- *
- * The UDC provides a high-level abstraction of the usb device.
- * You can use these functions to control the main device state
- * (start/attach/wakeup).
- *
- * \section USB_DEVICE_CONF USB Device Custom configuration
- * The following USB Device configuration must be included in the conf_usb.h
- * file of the application.
- *
- * USB_DEVICE_VENDOR_ID (Word)<br>
- * Vendor ID provided by USB org (ATMEL 0x03EB).
- *
- * USB_DEVICE_PRODUCT_ID (Word)<br>
- * Product ID (Referenced in usb_atmel.h).
- *
- * USB_DEVICE_MAJOR_VERSION (Byte)<br>
- * Major version of the device
- *
- * USB_DEVICE_MINOR_VERSION (Byte)<br>
- * Minor version of the device
- *
- * USB_DEVICE_MANUFACTURE_NAME (string)<br>
- * ASCII name for the manufacture
- *
- * USB_DEVICE_PRODUCT_NAME (string)<br>
- * ASCII name for the product
- *
- * USB_DEVICE_SERIAL_NAME (string)<br>
- * ASCII name to enable and set a serial number
- *
- * USB_DEVICE_POWER (Numeric)<br>
- * (unit mA) Maximum device power
- *
- * USB_DEVICE_ATTR (Byte)<br>
- * USB attributes available:
- *  - USB_CONFIG_ATTR_SELF_POWERED
- *  - USB_CONFIG_ATTR_REMOTE_WAKEUP
- *  Note: if remote wake enabled then defines remotewakeup callbacks,
- * see Table 5-2. External API from UDC - Callback
- *
- * USB_DEVICE_LOW_SPEED (Only defined)<br>
- * Force the USB Device to run in low speed
- *
- * USB_DEVICE_HS_SUPPORT (Only defined)<br>
- * Authorize the USB Device to run in high speed
- *
- * USB_DEVICE_MAX_EP (Byte)<br>
- * Define the maximum endpoint number used by the USB Device.<br>
- * This one is already defined in UDI default configuration.
- * Ex:
- * - When endpoint control 0x00, endpoint 0x01 and
- *   endpoint 0x82 is used then USB_DEVICE_MAX_EP=2
- * - When only endpoint control 0x00 is used then USB_DEVICE_MAX_EP=0
- * - When endpoint 0x01 and endpoint 0x81 is used then USB_DEVICE_MAX_EP=1<br>
- *   (configuration not possible on USBB interface)
- * @{
- */
-
-/**
- * \brief Authorizes the VBUS event
- *
- * \return true, if the VBUS monitoring is possible.
- *
- * \section udc_vbus_monitoring VBus monitoring used cases
- *
- * The VBus monitoring is used only for USB SELF Power application.
- *
- * - By default the USB device is automatically attached when Vbus is high
- * or when USB is start for devices without internal Vbus monitoring.
- * conf_usb.h file does not contains define USB_DEVICE_ATTACH_AUTO_DISABLE.
- * \code //#define USB_DEVICE_ATTACH_AUTO_DISABLE \endcode
- *
- * - Add custom VBUS monitoring. conf_usb.h file contains define
- * USB_DEVICE_ATTACH_AUTO_DISABLE:
- * \code #define USB_DEVICE_ATTACH_AUTO_DISABLE \endcode
- * User C file contains:
- * \code
-	// Authorize VBUS monitoring
-	if (!udc_include_vbus_monitoring()) {
-	  // Implement custom VBUS monitoring via GPIO or other
-	}
-	Event_VBUS_present() // VBUS interrupt or GPIO interrupt or other
-	{
-	  // Attach USB Device
-	  udc_attach();
-	}
-\endcode
- *
- * - Case of battery charging. conf_usb.h file contains define
- * USB_DEVICE_ATTACH_AUTO_DISABLE:
- * \code #define USB_DEVICE_ATTACH_AUTO_DISABLE \endcode
- * User C file contains:
- * \code
-	Event VBUS present() // VBUS interrupt or GPIO interrupt or ..
-	{
-	  // Authorize battery charging, but wait key press to start USB.
-	}
-	Event Key press()
-	{
-	  // Stop batteries charging
-	  // Start USB
-	  udc_attach();
-	}
-\endcode
- */
-static inline bool udc_include_vbus_monitoring(void)
-{
-	return udd_include_vbus_monitoring();
-}
-
-/*! \brief Start the USB Device stack
- */
-void udc_start(void);
-
-/*! \brief Stop the USB Device stack
- */
-void udc_stop(void);
-
-/**
- * \brief Attach device to the bus when possible
- *
- * \warning If a VBus control is included in driver,
- * then it will attach device when an acceptable Vbus
- * level from the host is detected.
- */
-static inline void udc_attach(void)
-{
-	udd_attach();
-}
-
-
-/**
- * \brief Detaches the device from the bus
- *
- * The driver must remove pull-up on USB line D- or D+.
- */
-static inline void udc_detach(void)
-{
-	udd_detach();
-}
-
-
-/*! \brief The USB driver sends a resume signal called \e "Upstream Resume"
- * This is authorized only when the remote wakeup feature is enabled by host.
- */
-static inline void udc_remotewakeup(void)
-{
-	udd_send_remotewakeup();
-}
-
-
-/**
- * \brief Returns a pointer on the current interface descriptor
- *
- * \return pointer on the current interface descriptor.
- */
-usb_iface_desc_t UDC_DESC_STORAGE *udc_get_interface_desc(void);
-
-//@}
-
-/**
- * \ingroup usb_group
- * \defgroup usb_device_group USB Stack Device
- *
- * This module includes USB Stack Device implementation.
- * The stack is divided in three parts:
- * - USB Device Controller (UDC) provides USB chapter 9 compliance
- * - USB Device Interface (UDI) provides USB Class compliance
- * - USB Device Driver (UDD) provides USB Driver for each Atmel MCU
-
- * Many USB Device applications can be implemented on Atmel MCU.
- * Atmel provides many application notes for different applications:
- * - AVR4900, provides general information about Device Stack
- * - AVR4901, explains how to create a new class
- * - AVR4902, explains how to create a composite device
- * - AVR49xx, all device classes provided in ASF have an application note
- *
- * A basic USB knowledge is required to understand the USB Device
- * Class application notes (HID,MS,CDC,PHDC,...).
- * Then, to create an USB device with
- * only one class provided by ASF, refer directly to the application note
- * corresponding to this USB class. The USB Device application note for
- * New Class and Composite is dedicated to advanced USB users.
- *
- * @{
- */
-
-//! @}
-
-#ifdef __cplusplus
-}
-#endif
-
-/**
- * \ingroup udc_group
- * \defgroup udc_basic_use_case_setup_prereq USB Device Controller (UDC) - Prerequisites
- * Common prerequisites for all USB devices.
- *
- * This module is based on USB device stack full interrupt driven, and supporting
- * \ref sleepmgr_group sleepmgr. For AVR and SAM3/4 devices the \ref clk_group clock services
- * is supported. For SAMD devices the \ref asfdoc_sam0_system_clock_group clock driver is supported.
- *
- * The following procedure must be executed to setup the project correctly:
- * - Specify the clock configuration:
- *   - XMEGA USB devices need 48MHz clock input.\n
- *     XMEGA USB devices need CPU frequency higher than 12MHz.\n
- *     You can use either an internal RC48MHz auto calibrated by Start of Frames
- *     or an external OSC.
- *   - UC3 and SAM3/4 devices without USB high speed support need 48MHz clock input.\n
- *     You must use a PLL and an external OSC.
- *   - UC3 and SAM3/4 devices with USB high speed support need 12MHz clock input.\n
- *     You must use an external OSC.
- *   - UC3 devices with USBC hardware need CPU frequency higher than 25MHz.
- *   - SAMD devices without USB high speed support need 48MHz clock input.\n
- *     You should use DFLL with USBCRM.
- * - In conf_board.h, the define CONF_BOARD_USB_PORT must be added to enable USB lines.
- * (Not mandatory for all boards)
- * - Enable interrupts
- * - Initialize the clock service
- *
- * The usage of \ref sleepmgr_group sleepmgr service is optional, but recommended to reduce power
- * consumption:
- * - Initialize the sleep manager service
- * - Activate sleep mode when the application is in IDLE state
- *
- * \subpage udc_conf_clock.
- *
- * for AVR and SAM3/4 devices, add to the initialization code:
- * \code
-	sysclk_init();
-	irq_initialize_vectors();
-	cpu_irq_enable();
-	board_init();
-	sleepmgr_init(); // Optional
-\endcode
- *
- * For SAMD devices, add to the initialization code:
- * \code
-	system_init();
-	irq_initialize_vectors();
-	cpu_irq_enable();
-	sleepmgr_init(); // Optional
-\endcode
- * Add to the main IDLE loop:
- * \code
-	sleepmgr_enter_sleep(); // Optional
-\endcode
- *
- */
-
-/**
- * \ingroup udc_group
- * \defgroup udc_basic_use_case_setup_code USB Device Controller (UDC) - Example code
- * Common example code for all USB devices.
- *
- * Content of conf_usb.h:
- * \code
-	#define USB_DEVICE_VENDOR_ID 0x03EB
-	#define USB_DEVICE_PRODUCT_ID 0xXXXX
-	#define USB_DEVICE_MAJOR_VERSION 1
-	#define USB_DEVICE_MINOR_VERSION 0
-	#define USB_DEVICE_POWER 100
-	#define USB_DEVICE_ATTR USB_CONFIG_ATTR_BUS_POWERED
-\endcode
- *
- * Add to application C-file:
- * \code
-	void usb_init(void)
-	{
-	  udc_start();
-	}
-\endcode
- */
-
-/**
- * \ingroup udc_group
- * \defgroup udc_basic_use_case_setup_flow USB Device Controller (UDC) - Workflow
- * Common workflow for all USB devices.
- *
- * -# Ensure that conf_usb.h is available and contains the following configuration
- * which is the main USB device configuration:
- *   - \code // Vendor ID provided by USB org (ATMEL 0x03EB)
-	#define USB_DEVICE_VENDOR_ID 0x03EB // Type Word
-	// Product ID (Atmel PID referenced in usb_atmel.h)
-	#define USB_DEVICE_PRODUCT_ID 0xXXXX // Type Word
-	// Major version of the device
-	#define USB_DEVICE_MAJOR_VERSION 1 // Type Byte
-	// Minor version of the device
-	#define USB_DEVICE_MINOR_VERSION 0 // Type Byte
-	// Maximum device power (mA)
-	#define USB_DEVICE_POWER 100 // Type 9-bits
-	// USB attributes to enable features
-	#define USB_DEVICE_ATTR USB_CONFIG_ATTR_BUS_POWERED // Flags \endcode
- * -# Call the USB device stack start function to enable stack and start USB:
- *   - \code udc_start(); \endcode
- *     \note In case of USB dual roles (Device and Host) managed through USB OTG connector
- * (USB ID pin), the call of udc_start() must be removed and replaced by uhc_start().
- * SeRefer to "AVR4950 section 6.1 Dual roles" for further information about dual roles.
- */
-
-/**
- * \page udc_conf_clock conf_clock.h examples with USB support
- *
- * Content of XMEGA conf_clock.h:
- * \code
-	// Configuration based on internal RC:
-	// USB clock need of 48Mhz
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_RCOSC
-	#define CONFIG_OSC_RC32_CAL         48000000UL
-	#define CONFIG_OSC_AUTOCAL_RC32MHZ_REF_OSC  OSC_ID_USBSOF
-	// CPU clock need of clock > 12MHz to run with USB (Here 24MHz)
-	#define CONFIG_SYSCLK_SOURCE     SYSCLK_SRC_RC32MHZ
-	#define CONFIG_SYSCLK_PSADIV     SYSCLK_PSADIV_2
-	#define CONFIG_SYSCLK_PSBCDIV    SYSCLK_PSBCDIV_1_1
-\endcode
- *
- * Content of conf_clock.h for AT32UC3A0, AT32UC3A1, AT32UC3B devices (USBB):
- * \code
-	// Configuration based on 12MHz external OSC:
-	#define CONFIG_PLL1_SOURCE          PLL_SRC_OSC0
-	#define CONFIG_PLL1_MUL             8
-	#define CONFIG_PLL1_DIV             2
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_PLL1
-	#define CONFIG_USBCLK_DIV           1 // Fusb = Fsys/(2 ^ USB_div)
-\endcode
- *
- * Content of conf_clock.h for AT32UC3A3, AT32UC3A4 devices (USBB with high speed support):
- * \code
-	// Configuration based on 12MHz external OSC:
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_OSC0
-	#define CONFIG_USBCLK_DIV           1 // Fusb = Fsys/(2 ^ USB_div)
-\endcode
- *
- * Content of conf_clock.h for AT32UC3C, ATUCXXD, ATUCXXL3U, ATUCXXL4U devices (USBC):
- * \code
-	// Configuration based on 12MHz external OSC:
-	#define CONFIG_PLL1_SOURCE          PLL_SRC_OSC0
-	#define CONFIG_PLL1_MUL             8
-	#define CONFIG_PLL1_DIV             2
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_PLL1
-	#define CONFIG_USBCLK_DIV           1 // Fusb = Fsys/(2 ^ USB_div)
-	// CPU clock need of clock > 25MHz to run with USBC
-	#define CONFIG_SYSCLK_SOURCE        SYSCLK_SRC_PLL1
-\endcode
- *
- * Content of conf_clock.h for SAM3S, SAM3SD, SAM4S devices (UPD: USB Peripheral Device):
- * \code
-	// PLL1 (B) Options   (Fpll = (Fclk * PLL_mul) / PLL_div)
-	#define CONFIG_PLL1_SOURCE          PLL_SRC_MAINCK_XTAL
-	#define CONFIG_PLL1_MUL             16
-	#define CONFIG_PLL1_DIV             2
-	// USB Clock Source Options   (Fusb = FpllX / USB_div)
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_PLL1
-	#define CONFIG_USBCLK_DIV           2
-\endcode
- *
- * Content of conf_clock.h for SAM3U device (UPDHS: USB Peripheral Device High Speed):
- * \code
-	// USB Clock Source fixed at UPLL.
-\endcode
- *
- * Content of conf_clock.h for SAM3X, SAM3A devices (UOTGHS: USB OTG High Speed):
- * \code
-	// USB Clock Source fixed at UPLL.
-	#define CONFIG_USBCLK_SOURCE        USBCLK_SRC_UPLL
-	#define CONFIG_USBCLK_DIV           1
-\endcode
- *
- * Content of conf_clocks.h for SAMD devices (USB):
- * \code
-	// System clock bus configuration
-	#  define CONF_CLOCK_FLASH_WAIT_STATES            2
-
-	// USB Clock Source fixed at DFLL.
-	// SYSTEM_CLOCK_SOURCE_DFLL configuration - Digital Frequency Locked Loop
-	#  define CONF_CLOCK_DFLL_ENABLE                  true
-	#  define CONF_CLOCK_DFLL_LOOP_MODE               SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY
-	#  define CONF_CLOCK_DFLL_ON_DEMAND               true
-
-	// Set this to true to configure the GCLK when running clocks_init.
-	// If set to false, none of the GCLK generators will be configured in clocks_init().
-	#  define CONF_CLOCK_CONFIGURE_GCLK               true
-
-	// Configure GCLK generator 0 (Main Clock)
-	#  define CONF_CLOCK_GCLK_0_ENABLE                true
-	#  define CONF_CLOCK_GCLK_0_RUN_IN_STANDBY        true
-	#  define CONF_CLOCK_GCLK_0_CLOCK_SOURCE          SYSTEM_CLOCK_SOURCE_DFLL
-	#  define CONF_CLOCK_GCLK_0_PRESCALER             1
-	#  define CONF_CLOCK_GCLK_0_OUTPUT_ENABLE         false
-\endcode
- */
-
-/**
- * \page udc_use_case_1 Change USB speed
- *
- * In this use case, the USB device is used with different USB speeds.
- *
- * \section udc_use_case_1_setup Setup steps
- *
- * Prior to implement this use case, be sure to have already
- * apply the UDI module "basic use case".
- *
- * \section udc_use_case_1_usage Usage steps
- *
- * \subsection udc_use_case_1_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	 #if // Low speed
-	 #define USB_DEVICE_LOW_SPEED
-	 // #define USB_DEVICE_HS_SUPPORT
-
-	 #elif // Full speed
-	 // #define USB_DEVICE_LOW_SPEED
-	 // #define USB_DEVICE_HS_SUPPORT
-
-	 #elif // High speed
-	 // #define USB_DEVICE_LOW_SPEED
-	 #define USB_DEVICE_HS_SUPPORT
-
-	 #endif
-\endcode
- *
- * \subsection udc_use_case_1_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required for a USB device low speed (1.5Mbit/s):
- *   - \code #define USB_DEVICE_LOW_SPEED
-	 //#define  USB_DEVICE_HS_SUPPORT \endcode
- * -# Ensure that conf_usb.h contains the following parameters
- * required for a USB device full speed (12Mbit/s):
- *   - \code //#define USB_DEVICE_LOW_SPEED
-	 //#define  USB_DEVICE_HS_SUPPORT \endcode
- * -# Ensure that conf_usb.h contains the following parameters
- * required for a USB device high speed (480Mbit/s):
- *   - \code //#define USB_DEVICE_LOW_SPEED
-	 #define  USB_DEVICE_HS_SUPPORT \endcode
- */
-
-/**
- * \page udc_use_case_2 Use USB strings
- *
- * In this use case, the usual USB strings is added in the USB device.
- *
- * \section udc_use_case_2_setup Setup steps
- * Prior to implement this use case, be sure to have already
- * apply the UDI module "basic use case".
- *
- * \section udc_use_case_2_usage Usage steps
- *
- * \subsection udc_use_case_2_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	#define  USB_DEVICE_MANUFACTURE_NAME      "Manufacture name"
-	#define  USB_DEVICE_PRODUCT_NAME          "Product name"
-	#define  USB_DEVICE_SERIAL_NAME           "12...EF"
-\endcode
- *
- * \subsection udc_use_case_2_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required to enable different USB strings:
- *   - \code // Static ASCII name for the manufacture
-	#define  USB_DEVICE_MANUFACTURE_NAME "Manufacture name" \endcode
- *   - \code // Static ASCII name for the product
-	#define  USB_DEVICE_PRODUCT_NAME "Product name" \endcode
- *   - \code // Static ASCII name to enable and set a serial number
-	#define  USB_DEVICE_SERIAL_NAME "12...EF" \endcode
- */
-
-/**
- * \page udc_use_case_3 Use USB remote wakeup feature
- *
- * In this use case, the USB remote wakeup feature is enabled.
- *
- * \section udc_use_case_3_setup Setup steps
- * Prior to implement this use case, be sure to have already
- * apply the UDI module "basic use case".
- *
- * \section udc_use_case_3_usage Usage steps
- *
- * \subsection udc_use_case_3_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	#define  USB_DEVICE_ATTR \
-	  (USB_CONFIG_ATTR_REMOTE_WAKEUP | USB_CONFIG_ATTR_..._POWERED)
-	#define UDC_REMOTEWAKEUP_ENABLE() my_callback_remotewakeup_enable()
-	extern void my_callback_remotewakeup_enable(void);
-	#define UDC_REMOTEWAKEUP_DISABLE() my_callback_remotewakeup_disable()
-	extern void my_callback_remotewakeup_disable(void);
-\endcode
- *
- * Add to application C-file:
- * \code
-	 void my_callback_remotewakeup_enable(void)
-	 {
-	    // Enable application wakeup events (e.g. enable GPIO interrupt)
-	 }
-	 void my_callback_remotewakeup_disable(void)
-	 {
-	    // Disable application wakeup events (e.g. disable GPIO interrupt)
-	 }
-
-	 void my_interrupt_event(void)
-	 {
-	    udc_remotewakeup();
-	 }
-\endcode
- *
- * \subsection udc_use_case_3_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required to enable remote wakeup feature:
- *   - \code // Authorizes the remote wakeup feature
-	     #define  USB_DEVICE_ATTR (USB_CONFIG_ATTR_REMOTE_WAKEUP | USB_CONFIG_ATTR_..._POWERED) \endcode
- *   - \code // Define callback called when the host enables the remotewakeup feature
-	#define UDC_REMOTEWAKEUP_ENABLE() my_callback_remotewakeup_enable()
-	extern void my_callback_remotewakeup_enable(void); \endcode
- *   - \code // Define callback called when the host disables the remotewakeup feature
-	#define UDC_REMOTEWAKEUP_DISABLE() my_callback_remotewakeup_disable()
-	extern void my_callback_remotewakeup_disable(void); \endcode
- * -# Send a remote wakeup (USB upstream):
- *   - \code udc_remotewakeup(); \endcode
- */
-
-/**
- * \page udc_use_case_5 Bus power application recommendations
- *
- * In this use case, the USB device BUS power feature is enabled.
- * This feature requires a correct power consumption management.
- *
- * \section udc_use_case_5_setup Setup steps
- * Prior to implement this use case, be sure to have already
- * apply the UDI module "basic use case".
- *
- * \section udc_use_case_5_usage Usage steps
- *
- * \subsection udc_use_case_5_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	#define  USB_DEVICE_ATTR (USB_CONFIG_ATTR_BUS_POWERED)
-	#define  UDC_SUSPEND_EVENT()         user_callback_suspend_action()
-	extern void user_callback_suspend_action(void)
-	#define  UDC_RESUME_EVENT()          user_callback_resume_action()
-	extern void user_callback_resume_action(void)
-\endcode
- *
- * Add to application C-file:
- * \code
-	void user_callback_suspend_action(void)
-	{
-	   // Disable hardware component to reduce power consumption
-	}
-	void user_callback_resume_action(void)
-	{
-	   // Re-enable hardware component
-	}
-\endcode
- *
- * \subsection udc_use_case_5_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters:
- *   - \code // Authorizes the BUS power feature
-	#define  USB_DEVICE_ATTR (USB_CONFIG_ATTR_BUS_POWERED) \endcode
- *   - \code // Define callback called when the host suspend the USB line
-	#define UDC_SUSPEND_EVENT() user_callback_suspend_action()
-	extern void user_callback_suspend_action(void); \endcode
- *   - \code // Define callback called when the host or device resume the USB line
-	#define UDC_RESUME_EVENT() user_callback_resume_action()
-	extern void user_callback_resume_action(void); \endcode
- * -# Reduce power consumption in suspend mode (max. 2.5mA on Vbus):
- *   - \code void user_callback_suspend_action(void)
-	{
-	turn_off_components();
-	} \endcode
- */
-
-/**
- * \page udc_use_case_6 USB dynamic serial number
- *
- * In this use case, the USB serial strings is dynamic.
- * For a static serial string refer to \ref udc_use_case_2.
- *
- * \section udc_use_case_6_setup Setup steps
- * Prior to implement this use case, be sure to have already
- * apply the UDI module "basic use case".
- *
- * \section udc_use_case_6_usage Usage steps
- *
- * \subsection udc_use_case_6_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	#define  USB_DEVICE_SERIAL_NAME
-	#define  USB_DEVICE_GET_SERIAL_NAME_POINTER serial_number
-	#define  USB_DEVICE_GET_SERIAL_NAME_LENGTH  12
-	extern uint8_t serial_number[];
-\endcode
- *
- * Add to application C-file:
- * \code
-	 uint8_t serial_number[USB_DEVICE_GET_SERIAL_NAME_LENGTH];
-
-	 void init_build_usb_serial_number(void)
-	 {
-	 serial_number[0] = 'A';
-	 serial_number[1] = 'B';
-	 ...
-	 serial_number[USB_DEVICE_GET_SERIAL_NAME_LENGTH-1] = 'C';
-	 } \endcode
- *
- * \subsection udc_use_case_6_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required to enable a USB serial number strings dynamically:
- *   - \code #define  USB_DEVICE_SERIAL_NAME // Define this empty
-	#define  USB_DEVICE_GET_SERIAL_NAME_POINTER serial_number // Give serial array pointer
-	#define  USB_DEVICE_GET_SERIAL_NAME_LENGTH  12 // Give size of serial array
-	extern uint8_t serial_number[]; // Declare external serial array \endcode
- * -# Before start USB stack, initialize the serial array
- *   - \code
-	 uint8_t serial_number[USB_DEVICE_GET_SERIAL_NAME_LENGTH];
-
-	 void init_build_usb_serial_number(void)
-	 {
-	 serial_number[0] = 'A';
-	 serial_number[1] = 'B';
-	 ...
-	 serial_number[USB_DEVICE_GET_SERIAL_NAME_LENGTH-1] = 'C';
-	 } \endcode
- */
-
-
-
-#endif // _UDC_H_
diff --git a/Marlin/src/HAL/DUE/usb/udc_desc.h b/Marlin/src/HAL/DUE/usb/udc_desc.h
deleted file mode 100644
index 052ca08..0000000
--- a/Marlin/src/HAL/DUE/usb/udc_desc.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
- * \file
- *
- * \brief Common API for USB Device Interface
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDC_DESC_H_
-#define _UDC_DESC_H_
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "udi.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \ingroup udc_group
- * \defgroup udc_desc_group USB Device Descriptor
- *
- * @{
- */
-
-/**
- * \brief Defines the memory's location of USB descriptors
- *
- * By default the Descriptor is stored in RAM
- * (UDC_DESC_STORAGE is defined empty).
- *
- * If you have need to free RAM space,
- * it is possible to put descriptor in flash in following case:
- * - USB driver authorize flash transfer (USBB on UC3 and USB on Mega)
- * - USB Device is not high speed (UDC no need to change USB descriptors)
- *
- * For UC3 application used "const".
- *
- * For Mega application used "code".
- */
-#define  UDC_DESC_STORAGE
-	// Descriptor storage in internal RAM
-#if (defined UDC_DATA_USE_HRAM_SUPPORT)
-#	if defined(__GNUC__)
-#		define UDC_DATA(x)              COMPILER_WORD_ALIGNED __attribute__((__section__(".data_hram0")))
-#		define UDC_BSS(x)               COMPILER_ALIGNED(x)   __attribute__((__section__(".bss_hram0")))
-#	elif defined(__ICCAVR32__)
-#		define UDC_DATA(x)              COMPILER_ALIGNED(x)   __data32
-#		define UDC_BSS(x)               COMPILER_ALIGNED(x)   __data32
-#	endif
-#else
-#	define UDC_DATA(x)              COMPILER_ALIGNED(x)
-#	define UDC_BSS(x)               COMPILER_ALIGNED(x)
-#endif
-
-
-
-/**
- * \brief Configuration descriptor and UDI link for one USB speed
- */
-typedef struct {
-	//! USB configuration descriptor
-	usb_conf_desc_t UDC_DESC_STORAGE *desc;
-	//! Array of UDI API pointer
-	udi_api_t UDC_DESC_STORAGE *UDC_DESC_STORAGE * udi_apis;
-} udc_config_speed_t;
-
-
-/**
- * \brief All information about the USB Device
- */
-typedef struct {
-	//! USB device descriptor for low or full speed
-	usb_dev_desc_t UDC_DESC_STORAGE *confdev_lsfs;
-	//! USB configuration descriptor and UDI API pointers for low or full speed
-	udc_config_speed_t UDC_DESC_STORAGE *conf_lsfs;
-#ifdef USB_DEVICE_HS_SUPPORT
-	//! USB device descriptor for high speed
-	usb_dev_desc_t UDC_DESC_STORAGE *confdev_hs;
-	//! USB device qualifier, only use in high speed mode
-	usb_dev_qual_desc_t UDC_DESC_STORAGE *qualifier;
-	//! USB configuration descriptor and UDI API pointers for high speed
-	udc_config_speed_t UDC_DESC_STORAGE *conf_hs;
-#endif
-	usb_dev_bos_desc_t UDC_DESC_STORAGE *conf_bos;
-} udc_config_t;
-
-//! Global variables of USB Device Descriptor and UDI links
-extern UDC_DESC_STORAGE udc_config_t udc_config;
-
-//@}
-
-#ifdef __cplusplus
-}
-#endif
-#endif // _UDC_DESC_H_
diff --git a/Marlin/src/HAL/DUE/usb/udd.h b/Marlin/src/HAL/DUE/usb/udd.h
deleted file mode 100644
index 319d884..0000000
--- a/Marlin/src/HAL/DUE/usb/udd.h
+++ /dev/null
@@ -1,396 +0,0 @@
-/**
- * \file
- *
- * \brief Common API for USB Device Drivers (UDD)
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDD_H_
-#define _UDD_H_
-
-#include "usb_protocol.h"
-#include "udc_desc.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \ingroup usb_device_group
- * \defgroup udd_group USB Device Driver (UDD)
- *
- * The UDD driver provides a low-level abstraction of the device
- * controller hardware. Most events coming from the hardware such as
- * interrupts, which may cause the UDD to call into the UDC and UDI.
- *
- * @{
- */
-
-//! \brief Endpoint identifier
-typedef uint8_t udd_ep_id_t;
-
-//! \brief Endpoint transfer status
-//! Returned in parameters of callback register via udd_ep_run routine.
-typedef enum {
-	UDD_EP_TRANSFER_OK = 0,
-	UDD_EP_TRANSFER_ABORT = 1,
-} udd_ep_status_t;
-
-/**
- * \brief Global variable to give and record information of the setup request management
- *
- * This global variable allows to decode and response a setup request.
- * It can be updated by udc_process_setup() from UDC or *setup() from UDIs.
- */
-typedef struct {
-	//! Data received in USB SETUP packet
-	//! Note: The swap of "req.wValues" from uin16_t to le16_t is done by UDD.
-	usb_setup_req_t req;
-
-	//! Point to buffer to send or fill with data following SETUP packet
-	//! This buffer must be word align for DATA IN phase (use prefix COMPILER_WORD_ALIGNED for buffer)
-	uint8_t *payload;
-
-	//! Size of buffer to send or fill, and content the number of byte transferred
-	uint16_t payload_size;
-
-	//! Callback called after reception of ZLP from setup request
-	void (*callback)(void);
-
-	//! Callback called when the buffer given (.payload) is full or empty.
-	//! This one return false to abort data transfer, or true with a new buffer in .payload.
-	bool (*over_under_run)(void);
-} udd_ctrl_request_t;
-extern udd_ctrl_request_t udd_g_ctrlreq;
-
-//! Return true if the setup request \a udd_g_ctrlreq indicates IN data transfer
-#define  Udd_setup_is_in()       \
-      (USB_REQ_DIR_IN == (udd_g_ctrlreq.req.bmRequestType & USB_REQ_DIR_MASK))
-
-//! Return true if the setup request \a udd_g_ctrlreq indicates OUT data transfer
-#define  Udd_setup_is_out()      \
-      (USB_REQ_DIR_OUT == (udd_g_ctrlreq.req.bmRequestType & USB_REQ_DIR_MASK))
-
-//! Return the type of the SETUP request \a udd_g_ctrlreq. \see usb_reqtype.
-#define  Udd_setup_type()        \
-      (udd_g_ctrlreq.req.bmRequestType & USB_REQ_TYPE_MASK)
-
-//! Return the recipient of the SETUP request \a udd_g_ctrlreq. \see usb_recipient
-#define  Udd_setup_recipient()   \
-      (udd_g_ctrlreq.req.bmRequestType & USB_REQ_RECIP_MASK)
-
-/**
- * \brief End of halt callback function type.
- * Registered by routine udd_ep_wait_stall_clear()
- * Callback called when endpoint stall is cleared.
- */
-typedef void (*udd_callback_halt_cleared_t)(void);
-
-/**
- * \brief End of transfer callback function type.
- * Registered by routine udd_ep_run()
- * Callback called by USB interrupt after data transfer or abort (reset,...).
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer is complete
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer is aborted
- * \param n          number of data transferred
- */
-typedef void (*udd_callback_trans_t) (udd_ep_status_t status,
-		iram_size_t nb_transferred, udd_ep_id_t ep);
-
-/**
- * \brief Authorizes the VBUS event
- *
- * \return true, if the VBUS monitoring is possible.
- */
-bool udd_include_vbus_monitoring(void);
-
-/**
- * \brief Enables the USB Device mode
- */
-void udd_enable(void);
-
-/**
- * \brief Disables the USB Device mode
- */
-void udd_disable(void);
-
-/**
- * \brief Attach device to the bus when possible
- *
- * \warning If a VBus control is included in driver,
- * then it will attach device when an acceptable Vbus
- * level from the host is detected.
- */
-void udd_attach(void);
-
-/**
- * \brief Detaches the device from the bus
- *
- * The driver must remove pull-up on USB line D- or D+.
- */
-void udd_detach(void);
-
-/**
- * \brief Test whether the USB Device Controller is running at high
- * speed or not.
- *
- * \return \c true if the Device is running at high speed mode, otherwise \c false.
- */
-bool udd_is_high_speed(void);
-
-/**
- * \brief Changes the USB address of device
- *
- * \param address    New USB address
- */
-void udd_set_address(uint8_t address);
-
-/**
- * \brief Returns the USB address of device
- *
- * \return USB address
- */
-uint8_t udd_getaddress(void);
-
-/**
- * \brief Returns the current start of frame number
- *
- * \return current start of frame number.
- */
-uint16_t udd_get_frame_number(void);
-
-/**
- * \brief Returns the current micro start of frame number
- *
- * \return current micro start of frame number required in high speed mode.
- */
-uint16_t udd_get_micro_frame_number(void);
-
-/*! \brief The USB driver sends a resume signal called Upstream Resume
- */
-void udd_send_remotewakeup(void);
-
-/**
- * \brief Load setup payload
- *
- * \param payload       Pointer on payload
- * \param payload_size  Size of payload
- */
-void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size );
-
-
-/**
- * \name Endpoint Management
- *
- * The following functions allow drivers to create and remove
- * endpoints, as well as set, clear and query their "halted" and
- * "wedged" states.
- */
-//@{
-
-#if (USB_DEVICE_MAX_EP != 0)
-
-/**
- * \brief Configures and enables an endpoint
- *
- * \param ep               Endpoint number including direction (USB_EP_DIR_IN/USB_EP_DIR_OUT).
- * \param bmAttributes     Attributes of endpoint declared in the descriptor.
- * \param MaxEndpointSize  Endpoint maximum size
- *
- * \return \c 1 if the endpoint is enabled, otherwise \c 0.
- */
-bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
-		uint16_t MaxEndpointSize);
-
-/**
- * \brief Disables an endpoint
- *
- * \param ep               Endpoint number including direction (USB_EP_DIR_IN/USB_EP_DIR_OUT).
- */
-void udd_ep_free(udd_ep_id_t ep);
-
-/**
- * \brief Check if the endpoint \a ep is halted.
- *
- * \param ep The ID of the endpoint to check.
- *
- * \return \c 1 if \a ep is halted, otherwise \c 0.
- */
-bool udd_ep_is_halted(udd_ep_id_t ep);
-
-/**
- * \brief Set the halted state of the endpoint \a ep
- *
- * After calling this function, any transaction on \a ep will result
- * in a STALL handshake being sent. Any pending transactions will be
- * performed first, however.
- *
- * \param ep The ID of the endpoint to be halted
- *
- * \return \c 1 if \a ep is halted, otherwise \c 0.
- */
-bool udd_ep_set_halt(udd_ep_id_t ep);
-
-/**
- * \brief Clear the halted state of the endpoint \a ep
- *
- * After calling this function, any transaction on \a ep will
- * be handled normally, i.e. a STALL handshake will not be sent, and
- * the data toggle sequence will start at DATA0.
- *
- * \param ep The ID of the endpoint to be un-halted
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-bool udd_ep_clear_halt(udd_ep_id_t ep);
-
-/**
- * \brief Registers a callback to call when endpoint halt is cleared
- *
- * \param ep            The ID of the endpoint to use
- * \param callback      NULL or function to call when endpoint halt is cleared
- *
- * \warning if the endpoint is not halted then the \a callback is called immediately.
- *
- * \return \c 1 if the register is accepted, otherwise \c 0.
- */
-bool udd_ep_wait_stall_clear(udd_ep_id_t ep,
-		udd_callback_halt_cleared_t callback);
-
-/**
- * \brief Allows to receive or send data on an endpoint
- *
- * The driver uses a specific DMA USB to transfer data
- * from internal RAM to endpoint, if this one is available.
- * When the transfer is finished or aborted (stall, reset, ...), the \a callback is called.
- * The \a callback returns the transfer status and eventually the number of byte transferred.
- * Note: The control endpoint is not authorized.
- *
- * \param ep            The ID of the endpoint to use
- * \param b_shortpacket Enabled automatic short packet
- * \param buf           Buffer on Internal RAM to send or fill.
- *                      It must be align, then use COMPILER_WORD_ALIGNED.
- * \param buf_size      Buffer size to send or fill
- * \param callback      NULL or function to call at the end of transfer
- *
- * \warning About \a b_shortpacket, for IN endpoint it means that a short packet
- * (or a Zero Length Packet) will be sent to the USB line to properly close the usb
- * transfer at the end of the data transfer.
- * For Bulk and Interrupt OUT endpoint, it will automatically stop the transfer
- * at the end of the data transfer (received short packet).
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
-		uint8_t * buf, iram_size_t buf_size,
-		udd_callback_trans_t callback);
-/**
- * \brief Aborts transfer on going on endpoint
- *
- * If a transfer is on going, then it is stopped and
- * the callback registered is called to signal the end of transfer.
- * Note: The control endpoint is not authorized.
- *
- * \param ep            Endpoint to abort
- */
-void udd_ep_abort(udd_ep_id_t ep);
-
-#endif
-
-//@}
-
-
-/**
- * \name High speed test mode management
- *
- * The following functions allow the device to jump to a specific test mode required in high speed mode.
- */
-//@{
-void udd_test_mode_j(void);
-void udd_test_mode_k(void);
-void udd_test_mode_se0_nak(void);
-void udd_test_mode_packet(void);
-//@}
-
-
-/**
- * \name UDC callbacks to provide for UDD
- *
- * The following callbacks are used by UDD.
- */
-//@{
-
-/**
- * \brief Decodes and manages a setup request
- *
- * The driver call it when a SETUP packet is received.
- * The \c udd_g_ctrlreq contains the data of SETUP packet.
- * If this callback accepts the setup request then it must
- * return \c 1 and eventually update \c udd_g_ctrlreq to send or receive data.
- *
- * \return \c 1 if the request is accepted, otherwise \c 0.
- */
-extern bool udc_process_setup(void);
-
-/**
- * \brief Reset the UDC
- *
- * The UDC must reset all configuration.
- */
-extern void udc_reset(void);
-
-/**
- * \brief To signal that a SOF is occurred
- *
- * The UDC must send the signal to all UDIs enabled
- */
-extern void udc_sof_notify(void);
-
-//@}
-
-//@}
-
-#ifdef __cplusplus
-}
-#endif
-#endif // _UDD_H_
diff --git a/Marlin/src/HAL/DUE/usb/udi.h b/Marlin/src/HAL/DUE/usb/udi.h
deleted file mode 100644
index febf03b..0000000
--- a/Marlin/src/HAL/DUE/usb/udi.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/**
- * \file
- *
- * \brief Common API for USB Device Interface
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDI_H_
-#define _UDI_H_
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \ingroup usb_device_group
- * \defgroup udi_group USB Device Interface (UDI)
- * The UDI provides a common API for all classes,
- * and this is used by UDC for the main control of USB Device interface.
- * @{
- */
-
-/**
- * \brief UDI API.
- *
- * The callbacks within this structure are called only by
- * USB Device Controller (UDC)
- *
- * The udc_get_interface_desc() can be use by UDI to know the interface descriptor
- * selected by UDC.
- */
-typedef struct {
-	/**
-	 * \brief Enable the interface.
-	 *
-	 * This function is called when the host selects a configuration
-	 * to which this interface belongs through a Set Configuration
-	 * request, and when the host selects an alternate setting of
-	 * this interface through a Set Interface request.
-	 *
-	 * \return \c 1 if function was successfully done, otherwise \c 0.
-	 */
-	bool (*enable)(void);
-
-	/**
-	 * \brief Disable the interface.
-	 *
-	 * This function is called when this interface is currently
-	 * active, and
-	 * - the host selects any configuration through a Set
-	 *   Configuration request, or
-	 * - the host issues a USB reset, or
-	 * - the device is detached from the host (i.e. Vbus is no
-	 *   longer present)
-	 */
-	void (*disable)(void);
-
-	/**
-	 * \brief Handle a control request directed at an interface.
-	 *
-	 * This function is called when this interface is currently
-	 * active and the host sends a SETUP request
-	 * with this interface as the recipient.
-	 *
-	 * Use udd_g_ctrlreq to decode and response to SETUP request.
-	 *
-	 * \return \c 1 if this interface supports the SETUP request, otherwise \c 0.
-	 */
-	bool (*setup)(void);
-
-	/**
-	 * \brief Returns the current setting of the selected interface.
-	 *
-	 * This function is called when UDC when know alternate setting of selected interface.
-	 *
-	 * \return alternate setting of selected interface
-	 */
-	uint8_t (*getsetting)(void);
-
-	/**
-	 * \brief To signal that a SOF is occurred
-	 */
-	void (*sof_notify)(void);
-} udi_api_t;
-
-//@}
-
-#ifdef __cplusplus
-}
-#endif
-#endif // _UDI_H_
diff --git a/Marlin/src/HAL/DUE/usb/udi_cdc.c b/Marlin/src/HAL/DUE/usb/udi_cdc.c
deleted file mode 100644
index 89debe5..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_cdc.c
+++ /dev/null
@@ -1,1155 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Communication Device Class (CDC) interface.
- *
- * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "usb_protocol_cdc.h"
-#include "udd.h"
-#include "udc.h"
-#include "udi_cdc.h"
-#include <string.h>
-
-#ifdef UDI_CDC_LOW_RATE
-#  ifdef USB_DEVICE_HS_SUPPORT
-#    define UDI_CDC_TX_BUFFERS     (UDI_CDC_DATA_EPS_HS_SIZE)
-#    define UDI_CDC_RX_BUFFERS     (UDI_CDC_DATA_EPS_HS_SIZE)
-#  else
-#    define UDI_CDC_TX_BUFFERS     (UDI_CDC_DATA_EPS_FS_SIZE)
-#    define UDI_CDC_RX_BUFFERS     (UDI_CDC_DATA_EPS_FS_SIZE)
-#  endif
-#else
-#  ifdef USB_DEVICE_HS_SUPPORT
-#    define UDI_CDC_TX_BUFFERS     (UDI_CDC_DATA_EPS_HS_SIZE)
-#    define UDI_CDC_RX_BUFFERS     (UDI_CDC_DATA_EPS_HS_SIZE)
-#  else
-#    define UDI_CDC_TX_BUFFERS     (5*UDI_CDC_DATA_EPS_FS_SIZE)
-#    define UDI_CDC_RX_BUFFERS     (5*UDI_CDC_DATA_EPS_FS_SIZE)
-#  endif
-#endif
-
-#ifndef UDI_CDC_TX_EMPTY_NOTIFY
-#  define UDI_CDC_TX_EMPTY_NOTIFY(port)
-#endif
-
-/**
- * \ingroup udi_cdc_group
- * \defgroup udi_cdc_group_udc Interface with USB Device Core (UDC)
- *
- * Structures and functions required by UDC.
- *
- * @{
- */
-bool udi_cdc_comm_enable(void);
-void udi_cdc_comm_disable(void);
-bool udi_cdc_comm_setup(void);
-bool udi_cdc_data_enable(void);
-void udi_cdc_data_disable(void);
-bool udi_cdc_data_setup(void);
-uint8_t udi_cdc_getsetting(void);
-void udi_cdc_data_sof_notify(void);
-UDC_DESC_STORAGE udi_api_t udi_api_cdc_comm = {
-	.enable = udi_cdc_comm_enable,
-	.disable = udi_cdc_comm_disable,
-	.setup = udi_cdc_comm_setup,
-	.getsetting = udi_cdc_getsetting,
-};
-UDC_DESC_STORAGE udi_api_t udi_api_cdc_data = {
-	.enable = udi_cdc_data_enable,
-	.disable = udi_cdc_data_disable,
-	.setup = udi_cdc_data_setup,
-	.getsetting = udi_cdc_getsetting,
-	.sof_notify = udi_cdc_data_sof_notify,
-};
-//@}
-
-/**
- * \ingroup udi_cdc_group
- * \defgroup udi_cdc_group_internal Implementation of UDI CDC
- *
- * Class internal implementation
- * @{
- */
-
-/**
- * \name Internal routines
- */
-//@{
-
-/**
- * \name Routines to control serial line
- */
-//@{
-
-/**
- * \brief Returns the port number corresponding at current setup request
- *
- * \return port number
- */
-static uint8_t udi_cdc_setup_to_port(void);
-
-/**
- * \brief Sends line coding to application
- *
- * Called after SETUP request when line coding data is received.
- */
-static void udi_cdc_line_coding_received(void);
-
-/**
- * \brief Records new state
- *
- * \param port       Communication port number to manage
- * \param b_set      State is enabled if true, else disabled
- * \param bit_mask   Field to process (see CDC_SERIAL_STATE_ defines)
- */
-static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask);
-
-/**
- * \brief Check and eventually notify the USB host of new state
- *
- * \param port       Communication port number to manage
- * \param ep         Port communication endpoint
- */
-static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep);
-
-/**
- * \brief Ack sent of serial state message
- * Callback called after serial state message sent
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer finished
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
- * \param n          number of data transferred
- */
-static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
-
-//@}
-
-/**
- * \name Routines to process data transfer
- */
-//@{
-
-/**
- * \brief Enable the reception of data from the USB host
- *
- * The value udi_cdc_rx_trans_sel indicate the RX buffer to fill.
- *
- * \param port       Communication port number to manage
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-static bool udi_cdc_rx_start(uint8_t port);
-
-/**
- * \brief Update rx buffer management with a new data
- * Callback called after data reception on USB line
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer finish
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
- * \param n          number of data received
- */
-static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
-
-/**
- * \brief Ack sent of tx buffer
- * Callback called after data transfer on USB line
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer finished
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
- * \param n          number of data transferred
- */
-static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
-
-/**
- * \brief Send buffer on line or wait a SOF event
- *
- * \param port       Communication port number to manage
- */
-static void udi_cdc_tx_send(uint8_t port);
-
-//@}
-
-//@}
-
-/**
- * \name Information about configuration of communication line
- */
-//@{
-COMPILER_WORD_ALIGNED
-		static usb_cdc_line_coding_t udi_cdc_line_coding[UDI_CDC_PORT_NB];
-static bool udi_cdc_serial_state_msg_ongoing[UDI_CDC_PORT_NB];
-static volatile le16_t udi_cdc_state[UDI_CDC_PORT_NB];
-COMPILER_WORD_ALIGNED static usb_cdc_notify_serial_state_t uid_cdc_state_msg[UDI_CDC_PORT_NB];
-
-//! Status of CDC COMM interfaces
-static volatile uint8_t udi_cdc_nb_comm_enabled = 0;
-//@}
-
-/**
- * \name Variables to manage RX/TX transfer requests
- * Two buffers for each sense are used to optimize the speed.
- */
-//@{
-
-//! Status of CDC DATA interfaces
-static volatile uint8_t udi_cdc_nb_data_enabled = 0;
-static volatile bool udi_cdc_data_running = false;
-//! Buffer to receive data
-COMPILER_WORD_ALIGNED static uint8_t udi_cdc_rx_buf[UDI_CDC_PORT_NB][2][UDI_CDC_RX_BUFFERS];
-//! Data available in RX buffers
-static volatile uint16_t udi_cdc_rx_buf_nb[UDI_CDC_PORT_NB][2];
-//! Give the current RX buffer used (rx0 if 0, rx1 if 1)
-static volatile uint8_t udi_cdc_rx_buf_sel[UDI_CDC_PORT_NB];
-//! Read position in current RX buffer
-static volatile uint16_t udi_cdc_rx_pos[UDI_CDC_PORT_NB];
-//! Signal a transfer on-going
-static volatile bool udi_cdc_rx_trans_ongoing[UDI_CDC_PORT_NB];
-
-//! Define a transfer halted
-#define  UDI_CDC_TRANS_HALTED    2
-
-//! Buffer to send data
-COMPILER_WORD_ALIGNED static uint8_t udi_cdc_tx_buf[UDI_CDC_PORT_NB][2][UDI_CDC_TX_BUFFERS];
-//! Data available in TX buffers
-static uint16_t udi_cdc_tx_buf_nb[UDI_CDC_PORT_NB][2];
-//! Give current TX buffer used (tx0 if 0, tx1 if 1)
-static volatile uint8_t udi_cdc_tx_buf_sel[UDI_CDC_PORT_NB];
-//! Value of SOF during last TX transfer
-static uint16_t udi_cdc_tx_sof_num[UDI_CDC_PORT_NB];
-//! Signal a transfer on-going
-static volatile bool udi_cdc_tx_trans_ongoing[UDI_CDC_PORT_NB];
-//! Signal that both buffer content data to send
-static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];
-
-//@}
-
-bool udi_cdc_comm_enable(void)
-{
-	uint8_t port;
-	uint8_t iface_comm_num;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-	udi_cdc_nb_comm_enabled = 0;
-#else
-	if (udi_cdc_nb_comm_enabled > UDI_CDC_PORT_NB) {
-		udi_cdc_nb_comm_enabled = 0;
-	}
-	port = udi_cdc_nb_comm_enabled;
-#endif
-
-	// Initialize control signal management
-	udi_cdc_state[port] = CPU_TO_LE16(0);
-
-	uid_cdc_state_msg[port].header.bmRequestType =
-			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
-			USB_REQ_RECIP_INTERFACE;
-	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
-	uid_cdc_state_msg[port].header.wValue = LE16(0);
-
-	switch (port) {
-#define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
-	case index: \
-		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
-#undef UDI_CDC_PORT_TO_IFACE_COMM
-	default:
-		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
-		break;
-	}
-
-	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
-	uid_cdc_state_msg[port].header.wLength = LE16(2);
-	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
-
-	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
-	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
-	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
-	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
-	// Call application callback
-	// to initialize memories or indicate that interface is enabled
-	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
-	if (!UDI_CDC_ENABLE_EXT(port)) {
-		return false;
-	}
-	udi_cdc_nb_comm_enabled++;
-	return true;
-}
-
-bool udi_cdc_data_enable(void)
-{
-	uint8_t port;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-	udi_cdc_nb_data_enabled = 0;
-#else
-	if (udi_cdc_nb_data_enabled > UDI_CDC_PORT_NB) {
-		udi_cdc_nb_data_enabled = 0;
-	}
-	port = udi_cdc_nb_data_enabled;
-#endif
-
-	// Initialize TX management
-	udi_cdc_tx_trans_ongoing[port] = false;
-	udi_cdc_tx_both_buf_to_send[port] = false;
-	udi_cdc_tx_buf_sel[port] = 0;
-	udi_cdc_tx_buf_nb[port][0] = 0;
-	udi_cdc_tx_buf_nb[port][1] = 0;
-	udi_cdc_tx_sof_num[port] = 0;
-	udi_cdc_tx_send(port);
-
-	// Initialize RX management
-	udi_cdc_rx_trans_ongoing[port] = false;
-	udi_cdc_rx_buf_sel[port] = 0;
-	udi_cdc_rx_buf_nb[port][0] = 0;
-	udi_cdc_rx_buf_nb[port][1] = 0;
-	udi_cdc_rx_pos[port] = 0;
-	if (!udi_cdc_rx_start(port)) {
-		return false;
-	}
-	udi_cdc_nb_data_enabled++;
-	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
-		udi_cdc_data_running = true;
-	}
-	return true;
-}
-
-void udi_cdc_comm_disable(void)
-{
-	Assert(udi_cdc_nb_comm_enabled != 0);
-	udi_cdc_nb_comm_enabled--;
-}
-
-void udi_cdc_data_disable(void)
-{
-	uint8_t port;
-
-	Assert(udi_cdc_nb_data_enabled != 0);
-	udi_cdc_nb_data_enabled--;
-	port = udi_cdc_nb_data_enabled;
-	UDI_CDC_DISABLE_EXT(port);
-	udi_cdc_data_running = false;
-}
-
-bool udi_cdc_comm_setup(void)
-{
-	uint8_t port = udi_cdc_setup_to_port();
-
-	if (Udd_setup_is_in()) {
-		// GET Interface Requests
-		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-			// Requests Class Interface Get
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_CDC_GET_LINE_CODING:
-				// Get configuration of CDC line
-				if (sizeof(usb_cdc_line_coding_t) !=
-						udd_g_ctrlreq.req.wLength)
-					return false; // Error for USB host
-				udd_g_ctrlreq.payload =
-						(uint8_t *) &
-						udi_cdc_line_coding[port];
-				udd_g_ctrlreq.payload_size =
-						sizeof(usb_cdc_line_coding_t);
-				return true;
-			}
-		}
-	}
-	if (Udd_setup_is_out()) {
-		// SET Interface Requests
-		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-			// Requests Class Interface Set
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_CDC_SET_LINE_CODING:
-				// Change configuration of CDC line
-				if (sizeof(usb_cdc_line_coding_t) !=
-						udd_g_ctrlreq.req.wLength)
-					return false; // Error for USB host
-				udd_g_ctrlreq.callback =
-						udi_cdc_line_coding_received;
-				udd_g_ctrlreq.payload =
-						(uint8_t *) &
-						udi_cdc_line_coding[port];
-				udd_g_ctrlreq.payload_size =
-						sizeof(usb_cdc_line_coding_t);
-				return true;
-			case USB_REQ_CDC_SET_CONTROL_LINE_STATE:
-				// According cdc spec 1.1 chapter 6.2.14
-				UDI_CDC_SET_DTR_EXT(port, (0 !=
-						(udd_g_ctrlreq.req.wValue
-						 & CDC_CTRL_SIGNAL_DTE_PRESENT)));
-				UDI_CDC_SET_RTS_EXT(port, (0 !=
-						(udd_g_ctrlreq.req.wValue
-						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
-				return true;
-			}
-		}
-	}
-	return false;  // request Not supported
-}
-
-bool udi_cdc_data_setup(void)
-{
-	return false;  // request Not supported
-}
-
-uint8_t udi_cdc_getsetting(void)
-{
-	return 0;      // CDC don't have multiple alternate setting
-}
-
-void udi_cdc_data_sof_notify(void)
-{
-	static uint8_t port_notify = 0;
-
-	// A call of udi_cdc_data_sof_notify() is done for each port
-	udi_cdc_tx_send(port_notify);
-#if UDI_CDC_PORT_NB != 1 // To optimize code
-	port_notify++;
-	if (port_notify >= UDI_CDC_PORT_NB) {
-		port_notify = 0;
-	}
-#endif
-}
-
-
-// ------------------------
-//------- Internal routines to control serial line
-
-static uint8_t udi_cdc_setup_to_port(void)
-{
-	uint8_t port;
-
-	switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
-#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
-	case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
-		port = iface; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
-#undef UDI_CDC_IFACE_COMM_TO_PORT
-	default:
-		port = 0;
-		break;
-	}
-	return port;
-}
-
-static void udi_cdc_line_coding_received(void)
-{
-	uint8_t port = udi_cdc_setup_to_port();
-	UNUSED(port);
-
-	UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
-}
-
-static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask)
-{
-	irqflags_t flags;
-	udd_ep_id_t ep_comm;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	// Update state
-	flags = cpu_irq_save(); // Protect udi_cdc_state
-	if (b_set) {
-		udi_cdc_state[port] |= bit_mask;
-	} else {
-		udi_cdc_state[port] &= ~(unsigned)bit_mask;
-	}
-	cpu_irq_restore(flags);
-
-	// Send it if possible and state changed
-	switch (port) {
-#define UDI_CDC_PORT_TO_COMM_EP(index, unused) \
-	case index: \
-		ep_comm = UDI_CDC_COMM_EP_##index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_COMM_EP, ~)
-#undef UDI_CDC_PORT_TO_COMM_EP
-	default:
-		ep_comm = UDI_CDC_COMM_EP_0;
-		break;
-	}
-	udi_cdc_ctrl_state_notify(port, ep_comm);
-}
-
-
-static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep)
-{
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	// Send it if possible and state changed
-	if ((!udi_cdc_serial_state_msg_ongoing[port])
-			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
-		// Fill notification message
-		uid_cdc_state_msg[port].value = udi_cdc_state[port];
-		// Send notification message
-		udi_cdc_serial_state_msg_ongoing[port] =
-				udd_ep_run(ep,
-				false,
-				(uint8_t *) & uid_cdc_state_msg[port],
-				sizeof(uid_cdc_state_msg[0]),
-				udi_cdc_serial_state_msg_sent);
-	}
-}
-
-
-static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
-{
-	uint8_t port;
-	UNUSED(n);
-	UNUSED(status);
-
-	switch (ep) {
-#define UDI_CDC_GET_PORT_FROM_COMM_EP(iface, unused) \
-	case UDI_CDC_COMM_EP_##iface: \
-		port = iface; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_GET_PORT_FROM_COMM_EP, ~)
-#undef UDI_CDC_GET_PORT_FROM_COMM_EP
-	default:
-		port = 0;
-		break;
-	}
-
-	udi_cdc_serial_state_msg_ongoing[port] = false;
-
-	// For the irregular signals like break, the incoming ring signal,
-	// or the overrun error state, this will reset their values to zero
-	// and again will not send another notification until their state changes.
-	udi_cdc_state[port] &= ~(CDC_SERIAL_STATE_BREAK |
-			CDC_SERIAL_STATE_RING |
-			CDC_SERIAL_STATE_FRAMING |
-			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
-	uid_cdc_state_msg[port].value &= ~(CDC_SERIAL_STATE_BREAK |
-			CDC_SERIAL_STATE_RING |
-			CDC_SERIAL_STATE_FRAMING |
-			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
-	// Send it if possible and state changed
-	udi_cdc_ctrl_state_notify(port, ep);
-}
-
-
-// ------------------------
-//------- Internal routines to process data transfer
-
-
-static bool udi_cdc_rx_start(uint8_t port)
-{
-	irqflags_t flags;
-	uint8_t buf_sel_trans;
-	udd_ep_id_t ep;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	flags = cpu_irq_save();
-	buf_sel_trans = udi_cdc_rx_buf_sel[port];
-	if (udi_cdc_rx_trans_ongoing[port] ||
-		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
-		// Transfer already on-going or current buffer no empty
-		cpu_irq_restore(flags);
-		return false;
-	}
-
-	// Change current buffer
-	udi_cdc_rx_pos[port] = 0;
-	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
-
-	// Start transfer on RX
-	udi_cdc_rx_trans_ongoing[port] = true;
-	cpu_irq_restore(flags);
-
-	if (udi_cdc_multi_is_rx_ready(port)) {
-		UDI_CDC_RX_NOTIFY(port);
-	}
-	// Send the buffer with enable of short packet
-	switch (port) {
-#define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
-	case index: \
-		ep = UDI_CDC_DATA_EP_OUT_##index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
-#undef UDI_CDC_PORT_TO_DATA_EP_OUT
-	default:
-		ep = UDI_CDC_DATA_EP_OUT_0;
-		break;
-	}
-	return udd_ep_run(ep,
-			true,
-			udi_cdc_rx_buf[port][buf_sel_trans],
-			UDI_CDC_RX_BUFFERS,
-			udi_cdc_data_received);
-}
-
-
-static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
-{
-	uint8_t buf_sel_trans;
-	uint8_t port;
-
-	switch (ep) {
-#define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
-	case UDI_CDC_DATA_EP_OUT_##index: \
-		port = index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
-#undef UDI_CDC_DATA_EP_OUT_TO_PORT
-	default:
-		port = 0;
-		break;
-	}
-
-	if (UDD_EP_TRANSFER_OK != status) {
-		// Abort reception
-		return;
-	}
-	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
-	if (!n) {
-		udd_ep_run( ep,
-				true,
-				udi_cdc_rx_buf[port][buf_sel_trans],
-				UDI_CDC_RX_BUFFERS,
-				udi_cdc_data_received);
-		return;
-	}
-	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
-	udi_cdc_rx_trans_ongoing[port] = false;
-	udi_cdc_rx_start(port);
-}
-
-
-static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
-{
-	uint8_t port;
-	UNUSED(n);
-
-	switch (ep) {
-#define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
-	case UDI_CDC_DATA_EP_IN_##index: \
-		port = index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
-#undef UDI_CDC_DATA_EP_IN_TO_PORT
-	default:
-		port = 0;
-		break;
-	}
-
-	if (UDD_EP_TRANSFER_OK != status) {
-		// Abort transfer
-		return;
-	}
-	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
-	udi_cdc_tx_both_buf_to_send[port] = false;
-	udi_cdc_tx_trans_ongoing[port] = false;
-
-	if (n != 0) {
-		UDI_CDC_TX_EMPTY_NOTIFY(port);
-	}
-	udi_cdc_tx_send(port);
-}
-
-
-static void udi_cdc_tx_send(uint8_t port)
-{
-	irqflags_t flags;
-	uint8_t buf_sel_trans;
-	bool b_short_packet;
-	udd_ep_id_t ep;
-	static uint16_t sof_zlp_counter = 0;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	if (udi_cdc_tx_trans_ongoing[port]) {
-		return; // Already on going or wait next SOF to send next data
-	}
-	if (udd_is_high_speed()) {
-		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
-			return; // Wait next SOF to send next data
-		}
-	}else{
-		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
-			return; // Wait next SOF to send next data
-		}
-	}
-
-	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
-	buf_sel_trans = udi_cdc_tx_buf_sel[port];
-	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
-		sof_zlp_counter++;
-		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
-				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
-			cpu_irq_restore(flags);
-			return;
-		}
-	}
-	sof_zlp_counter = 0;
-
-	if (!udi_cdc_tx_both_buf_to_send[port]) {
-		// Send current Buffer
-		// and switch the current buffer
-		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
-	}else{
-		// Send the other Buffer
-		// and no switch the current buffer
-		buf_sel_trans = (buf_sel_trans==0)?1:0;
-	}
-	udi_cdc_tx_trans_ongoing[port] = true;
-	cpu_irq_restore(flags);
-
-	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
-	if (b_short_packet) {
-		if (udd_is_high_speed()) {
-			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
-		}else{
-			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
-		}
-	}else{
-		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
-	}
-
-	// Send the buffer with enable of short packet
-	switch (port) {
-#define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
-	case index: \
-		ep = UDI_CDC_DATA_EP_IN_##index; \
-		break;
-	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
-#undef UDI_CDC_PORT_TO_DATA_EP_IN
-	default:
-		ep = UDI_CDC_DATA_EP_IN_0;
-		break;
-	}
-	udd_ep_run( ep,
-			b_short_packet,
-			udi_cdc_tx_buf[port][buf_sel_trans],
-			udi_cdc_tx_buf_nb[port][buf_sel_trans],
-			udi_cdc_data_sent);
-}
-
-
-// ------------------------
-//------- Application interface
-
-
-//------- Application interface
-
-void udi_cdc_ctrl_signal_dcd(bool b_set)
-{
-	udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DCD);
-}
-
-void udi_cdc_ctrl_signal_dsr(bool b_set)
-{
-	udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DSR);
-}
-
-void udi_cdc_signal_framing_error(void)
-{
-	udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_FRAMING);
-}
-
-void udi_cdc_signal_parity_error(void)
-{
-	udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_PARITY);
-}
-
-void udi_cdc_signal_overrun(void)
-{
-	udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_OVERRUN);
-}
-
-void udi_cdc_multi_ctrl_signal_dcd(uint8_t port, bool b_set)
-{
-	udi_cdc_ctrl_state_change(port, b_set, CDC_SERIAL_STATE_DCD);
-}
-
-void udi_cdc_multi_ctrl_signal_dsr(uint8_t port, bool b_set)
-{
-	udi_cdc_ctrl_state_change(port, b_set, CDC_SERIAL_STATE_DSR);
-}
-
-void udi_cdc_multi_signal_framing_error(uint8_t port)
-{
-	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_FRAMING);
-}
-
-void udi_cdc_multi_signal_parity_error(uint8_t port)
-{
-	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_PARITY);
-}
-
-void udi_cdc_multi_signal_overrun(uint8_t port)
-{
-	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
-}
-
-iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
-{
-	irqflags_t flags;
-	uint16_t pos;
-	iram_size_t nb_received;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-	flags = cpu_irq_save();
-	pos = udi_cdc_rx_pos[port];
-	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
-	cpu_irq_restore(flags);
-	return nb_received;
-}
-
-iram_size_t udi_cdc_get_nb_received_data(void)
-{
-	return udi_cdc_multi_get_nb_received_data(0);
-}
-
-bool udi_cdc_multi_is_rx_ready(uint8_t port)
-{
-	return (udi_cdc_multi_get_nb_received_data(port) > 0);
-}
-
-bool udi_cdc_is_rx_ready(void)
-{
-	return udi_cdc_multi_is_rx_ready(0);
-}
-
-int udi_cdc_multi_getc(uint8_t port)
-{
-	irqflags_t flags;
-	int rx_data = 0;
-	bool b_databit_9;
-	uint16_t pos;
-	uint8_t buf_sel;
-	bool again;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
-
-udi_cdc_getc_process_one_byte:
-	// Check available data
-	flags = cpu_irq_save();
-	pos = udi_cdc_rx_pos[port];
-	buf_sel = udi_cdc_rx_buf_sel[port];
-	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
-	cpu_irq_restore(flags);
-	while (again) {
-		if (!udi_cdc_data_running) {
-			return 0;
-		}
-		goto udi_cdc_getc_process_one_byte;
-	}
-
-	// Read data
-	rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
-	udi_cdc_rx_pos[port] = pos+1;
-
-	udi_cdc_rx_start(port);
-
-	if (b_databit_9) {
-		// Receive MSB
-		b_databit_9 = false;
-		rx_data = rx_data << 8;
-		goto udi_cdc_getc_process_one_byte;
-	}
-	return rx_data;
-}
-
-int udi_cdc_getc(void)
-{
-	return udi_cdc_multi_getc(0);
-}
-
-iram_size_t udi_cdc_multi_read_buf(uint8_t port, void* buf, iram_size_t size)
-{
-	irqflags_t flags;
-	uint8_t *ptr_buf = (uint8_t *)buf;
-	iram_size_t copy_nb;
-	uint16_t pos;
-	uint8_t buf_sel;
-	bool again;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-udi_cdc_read_buf_loop_wait:
-	// Check available data
-	flags = cpu_irq_save();
-	pos = udi_cdc_rx_pos[port];
-	buf_sel = udi_cdc_rx_buf_sel[port];
-	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
-	cpu_irq_restore(flags);
-	while (again) {
-		if (!udi_cdc_data_running) {
-			return size;
-		}
-		goto udi_cdc_read_buf_loop_wait;
-	}
-
-	// Read data
-	copy_nb = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
-	if (copy_nb>size) {
-		copy_nb = size;
-	}
-	memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], copy_nb);
-	udi_cdc_rx_pos[port] += copy_nb;
-	ptr_buf += copy_nb;
-	size -= copy_nb;
-	udi_cdc_rx_start(port);
-
-	if (size) {
-		goto udi_cdc_read_buf_loop_wait;
-	}
-	return 0;
-}
-
-static iram_size_t udi_cdc_multi_read_no_polling(uint8_t port, void* buf, iram_size_t size)
-{
-	uint8_t *ptr_buf = (uint8_t *)buf;
-	iram_size_t nb_avail_data;
-	uint16_t pos;
-	uint8_t buf_sel;
-	irqflags_t flags;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	//Data interface not started... exit
-	if (!udi_cdc_data_running) {
-		return 0;
-	}
-
-	//Get number of available data
-	// Check available data
-	flags = cpu_irq_save(); // to protect udi_cdc_rx_pos & udi_cdc_rx_buf_sel
-	pos = udi_cdc_rx_pos[port];
-	buf_sel = udi_cdc_rx_buf_sel[port];
-	nb_avail_data = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
-	cpu_irq_restore(flags);
-	//If the buffer contains less than the requested number of data,
-	//adjust read size
-	if(nb_avail_data<size) {
-		size = nb_avail_data;
-	}
-	if(size>0) {
-		memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], size);
-		flags = cpu_irq_save(); // to protect udi_cdc_rx_pos
-		udi_cdc_rx_pos[port] += size;
-		cpu_irq_restore(flags);
-
-		ptr_buf += size;
-		udi_cdc_rx_start(port);
-	}
-	return(nb_avail_data);
-}
-
-iram_size_t udi_cdc_read_no_polling(void* buf, iram_size_t size)
-{
-	return udi_cdc_multi_read_no_polling(0, buf, size);
-}
-
-iram_size_t udi_cdc_read_buf(void* buf, iram_size_t size)
-{
-	return udi_cdc_multi_read_buf(0, buf, size);
-}
-
-iram_size_t __attribute__((optimize("O0"))) udi_cdc_multi_get_free_tx_buffer(uint8_t port)
-{
-	irqflags_t flags;
-	iram_size_t buf_sel_nb, retval;
-	uint8_t buf_sel;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	flags = cpu_irq_save();
-	buf_sel = udi_cdc_tx_buf_sel[port];
-	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
-	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
-		if ((!udi_cdc_tx_trans_ongoing[port])
-			&& (!udi_cdc_tx_both_buf_to_send[port])) {
-			/* One buffer is full, but the other buffer is not used.
-			 * (not used = transfer on-going)
-			 * then move to the other buffer to store data */
-			udi_cdc_tx_both_buf_to_send[port] = true;
-			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
-			buf_sel_nb = 0;
-		}
-	}
-	retval = UDI_CDC_TX_BUFFERS - buf_sel_nb;
-	cpu_irq_restore(flags);
-	return retval;
-}
-
-iram_size_t udi_cdc_get_free_tx_buffer(void)
-{
-	return udi_cdc_multi_get_free_tx_buffer(0);
-}
-
-bool udi_cdc_multi_is_tx_ready(uint8_t port)
-{
-	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
-}
-
-bool udi_cdc_is_tx_ready(void)
-{
-	return udi_cdc_multi_is_tx_ready(0);
-}
-
-int udi_cdc_multi_putc(uint8_t port, int value)
-{
-	irqflags_t flags;
-	bool b_databit_9;
-	uint8_t buf_sel;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
-
-udi_cdc_putc_process_one_byte:
-	// Check available space
-	if (!udi_cdc_multi_is_tx_ready(port)) {
-		if (!udi_cdc_data_running) {
-			return false;
-		}
-		goto udi_cdc_putc_process_one_byte;
-	}
-
-	// Write value
-	flags = cpu_irq_save();
-	buf_sel = udi_cdc_tx_buf_sel[port];
-	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
-	cpu_irq_restore(flags);
-
-	if (b_databit_9) {
-		// Send MSB
-		b_databit_9 = false;
-		value = value >> 8;
-		goto udi_cdc_putc_process_one_byte;
-	}
-	return true;
-}
-
-int udi_cdc_putc(int value)
-{
-	return udi_cdc_multi_putc(0, value);
-}
-
-iram_size_t __attribute__((optimize("O0"))) udi_cdc_multi_write_buf(uint8_t port, const void* buf, iram_size_t size)
-{
-	irqflags_t flags;
-	uint8_t buf_sel;
-	uint16_t buf_nb;
-	iram_size_t copy_nb;
-	uint8_t *ptr_buf = (uint8_t *)buf;
-
-#if UDI_CDC_PORT_NB == 1 // To optimize code
-	port = 0;
-#endif
-
-	if (9 == udi_cdc_line_coding[port].bDataBits) {
-		size *=2;
-	}
-
-udi_cdc_write_buf_loop_wait:
-	// Check available space
-	if (!udi_cdc_multi_is_tx_ready(port)) {
-		if (!udi_cdc_data_running) {
-			return size;
-		}
-		goto udi_cdc_write_buf_loop_wait;
-	}
-
-	// Write values
-	flags = cpu_irq_save();
-	buf_sel = udi_cdc_tx_buf_sel[port];
-	buf_nb = udi_cdc_tx_buf_nb[port][buf_sel];
-	copy_nb = UDI_CDC_TX_BUFFERS - buf_nb;
-	if (copy_nb > size) {
-		copy_nb = size;
-	}
-	memcpy(&udi_cdc_tx_buf[port][buf_sel][buf_nb], ptr_buf, copy_nb);
-	udi_cdc_tx_buf_nb[port][buf_sel] = buf_nb + copy_nb;
-	cpu_irq_restore(flags);
-
-	// Update buffer pointer
-	ptr_buf = ptr_buf + copy_nb;
-	size -= copy_nb;
-
-	if (size) {
-		goto udi_cdc_write_buf_loop_wait;
-	}
-
-	return 0;
-}
-
-iram_size_t udi_cdc_write_buf(const void* buf, iram_size_t size)
-{
-	return udi_cdc_multi_write_buf(0, buf, size);
-}
-
-//@}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/udi_cdc.h b/Marlin/src/HAL/DUE/usb/udi_cdc.h
deleted file mode 100644
index b618450..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_cdc.h
+++ /dev/null
@@ -1,810 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Communication Device Class (CDC) interface definitions.
- *
- * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDI_CDC_H_
-#define _UDI_CDC_H_
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "usb_protocol_cdc.h"
-#include "udd.h"
-#include "udc_desc.h"
-#include "udi.h"
-
-// Check the number of port
-#ifndef UDI_CDC_PORT_NB
-# define  UDI_CDC_PORT_NB 1
-#endif
-#if (UDI_CDC_PORT_NB < 1) || (UDI_CDC_PORT_NB > 7)
-# error UDI_CDC_PORT_NB must be between 1 and 7
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \addtogroup udi_cdc_group_udc
- * @{
- */
-
-//! Global structure which contains standard UDI API for UDC
-extern UDC_DESC_STORAGE udi_api_t udi_api_cdc_comm;
-extern UDC_DESC_STORAGE udi_api_t udi_api_cdc_data;
-//@}
-
-/**
- * \ingroup udi_cdc_group
- * \defgroup udi_cdc_group_desc USB interface descriptors
- *
- * The following structures provide predefined USB interface descriptors.
- * It must be used to define the final USB descriptors.
- */
-//@{
-
-/**
- * \brief Communication Class interface descriptor
- *
- * Interface descriptor with associated functional and endpoint
- * descriptors for the CDC Communication Class interface.
- */
-typedef struct {
-	//! Standard interface descriptor
-	usb_iface_desc_t iface;
-	//! CDC Header functional descriptor
-	usb_cdc_hdr_desc_t header;
-	//! CDC Abstract Control Model functional descriptor
-	usb_cdc_acm_desc_t acm;
-	//! CDC Union functional descriptor
-	usb_cdc_union_desc_t union_desc;
-	//! CDC Call Management functional descriptor
-	usb_cdc_call_mgmt_desc_t call_mgmt;
-	//! Notification endpoint descriptor
-	usb_ep_desc_t ep_notify;
-} udi_cdc_comm_desc_t;
-
-
-/**
- * \brief Data Class interface descriptor
- *
- * Interface descriptor with associated endpoint descriptors for the
- * CDC Data Class interface.
- */
-typedef struct {
-	//! Standard interface descriptor
-	usb_iface_desc_t iface;
-	//! Data IN/OUT endpoint descriptors
-	usb_ep_desc_t ep_in;
-	usb_ep_desc_t ep_out;
-} udi_cdc_data_desc_t;
-
-
-//! CDC communication endpoints size for all speeds
-#define UDI_CDC_COMM_EP_SIZE        64
-//! CDC data endpoints size for FS speed (8B, 16B, 32B, 64B)
-#define UDI_CDC_DATA_EPS_FS_SIZE    64
-//! CDC data endpoints size for HS speed (512B only)
-#define UDI_CDC_DATA_EPS_HS_SIZE    512
-
-/**
- * \name Content of interface descriptors
- * Up to 7 CDC interfaces can be implemented on a USB device.
- */
-//@{
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_0
-#define UDI_CDC_IAD_STRING_ID_0   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_0
-#define UDI_CDC_COMM_STRING_ID_0   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_0
-#define UDI_CDC_DATA_STRING_ID_0   0
-#endif
-#define UDI_CDC_IAD_DESC_0      UDI_CDC_IAD_DESC(0)
-#define UDI_CDC_COMM_DESC_0     UDI_CDC_COMM_DESC(0)
-#define UDI_CDC_DATA_DESC_0_FS  UDI_CDC_DATA_DESC_FS(0)
-#define UDI_CDC_DATA_DESC_0_HS  UDI_CDC_DATA_DESC_HS(0)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_1
-#define UDI_CDC_IAD_STRING_ID_1  0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_1
-#define UDI_CDC_COMM_STRING_ID_1 0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_1
-#define UDI_CDC_DATA_STRING_ID_1 0
-#endif
-#define UDI_CDC_IAD_DESC_1      UDI_CDC_IAD_DESC(1)
-#define UDI_CDC_COMM_DESC_1     UDI_CDC_COMM_DESC(1)
-#define UDI_CDC_DATA_DESC_1_FS  UDI_CDC_DATA_DESC_FS(1)
-#define UDI_CDC_DATA_DESC_1_HS  UDI_CDC_DATA_DESC_HS(1)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_2
-#define UDI_CDC_IAD_STRING_ID_2   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_2
-#define UDI_CDC_COMM_STRING_ID_2   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_2
-#define UDI_CDC_DATA_STRING_ID_2   0
-#endif
-#define UDI_CDC_IAD_DESC_2      UDI_CDC_IAD_DESC(2)
-#define UDI_CDC_COMM_DESC_2     UDI_CDC_COMM_DESC(2)
-#define UDI_CDC_DATA_DESC_2_FS  UDI_CDC_DATA_DESC_FS(2)
-#define UDI_CDC_DATA_DESC_2_HS  UDI_CDC_DATA_DESC_HS(2)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_3
-#define UDI_CDC_IAD_STRING_ID_3   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_3
-#define UDI_CDC_COMM_STRING_ID_3   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_3
-#define UDI_CDC_DATA_STRING_ID_3   0
-#endif
-#define UDI_CDC_IAD_DESC_3      UDI_CDC_IAD_DESC(3)
-#define UDI_CDC_COMM_DESC_3     UDI_CDC_COMM_DESC(3)
-#define UDI_CDC_DATA_DESC_3_FS  UDI_CDC_DATA_DESC_FS(3)
-#define UDI_CDC_DATA_DESC_3_HS  UDI_CDC_DATA_DESC_HS(3)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_4
-#define UDI_CDC_IAD_STRING_ID_4   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_4
-#define UDI_CDC_COMM_STRING_ID_4   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_4
-#define UDI_CDC_DATA_STRING_ID_4   0
-#endif
-#define UDI_CDC_IAD_DESC_4      UDI_CDC_IAD_DESC(4)
-#define UDI_CDC_COMM_DESC_4     UDI_CDC_COMM_DESC(4)
-#define UDI_CDC_DATA_DESC_4_FS  UDI_CDC_DATA_DESC_FS(4)
-#define UDI_CDC_DATA_DESC_4_HS  UDI_CDC_DATA_DESC_HS(4)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_5
-#define UDI_CDC_IAD_STRING_ID_5   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_5
-#define UDI_CDC_COMM_STRING_ID_5   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_5
-#define UDI_CDC_DATA_STRING_ID_5   0
-#endif
-#define UDI_CDC_IAD_DESC_5      UDI_CDC_IAD_DESC(5)
-#define UDI_CDC_COMM_DESC_5     UDI_CDC_COMM_DESC(5)
-#define UDI_CDC_DATA_DESC_5_FS  UDI_CDC_DATA_DESC_FS(5)
-#define UDI_CDC_DATA_DESC_5_HS  UDI_CDC_DATA_DESC_HS(5)
-
-//! By default no string associated to these interfaces
-#ifndef UDI_CDC_IAD_STRING_ID_6
-#define UDI_CDC_IAD_STRING_ID_6   0
-#endif
-#ifndef UDI_CDC_COMM_STRING_ID_6
-#define UDI_CDC_COMM_STRING_ID_6   0
-#endif
-#ifndef UDI_CDC_DATA_STRING_ID_6
-#define UDI_CDC_DATA_STRING_ID_6   0
-#endif
-#define UDI_CDC_IAD_DESC_6      UDI_CDC_IAD_DESC(6)
-#define UDI_CDC_COMM_DESC_6     UDI_CDC_COMM_DESC(6)
-#define UDI_CDC_DATA_DESC_6_FS  UDI_CDC_DATA_DESC_FS(6)
-#define UDI_CDC_DATA_DESC_6_HS  UDI_CDC_DATA_DESC_HS(6)
-//@}
-
-
-//! Content of CDC IAD interface descriptor for all speeds
-#define UDI_CDC_IAD_DESC(port) { \
-   .bLength                      = sizeof(usb_iad_desc_t),\
-   .bDescriptorType              = USB_DT_IAD,\
-   .bInterfaceCount              = 2,\
-   .bFunctionClass               = CDC_CLASS_COMM,\
-   .bFunctionSubClass            = CDC_SUBCLASS_ACM,\
-   .bFunctionProtocol            = CDC_PROTOCOL_V25TER,\
-   .bFirstInterface              = UDI_CDC_COMM_IFACE_NUMBER_##port,\
-   .iFunction                    = UDI_CDC_IAD_STRING_ID_##port,\
-   }
-
-//! Content of CDC COMM interface descriptor for all speeds
-#define UDI_CDC_COMM_DESC(port) { \
-   .iface.bLength                = sizeof(usb_iface_desc_t),\
-   .iface.bDescriptorType        = USB_DT_INTERFACE,\
-   .iface.bAlternateSetting      = 0,\
-   .iface.bNumEndpoints          = 1,\
-   .iface.bInterfaceClass        = CDC_CLASS_COMM,\
-   .iface.bInterfaceSubClass     = CDC_SUBCLASS_ACM,\
-   .iface.bInterfaceProtocol     = CDC_PROTOCOL_V25TER,\
-   .header.bFunctionLength       = sizeof(usb_cdc_hdr_desc_t),\
-   .header.bDescriptorType       = CDC_CS_INTERFACE,\
-   .header.bDescriptorSubtype    = CDC_SCS_HEADER,\
-   .header.bcdCDC                = LE16(0x0110),\
-   .call_mgmt.bFunctionLength    = sizeof(usb_cdc_call_mgmt_desc_t),\
-   .call_mgmt.bDescriptorType    = CDC_CS_INTERFACE,\
-   .call_mgmt.bDescriptorSubtype = CDC_SCS_CALL_MGMT,\
-   .call_mgmt.bmCapabilities     = \
-			CDC_CALL_MGMT_SUPPORTED | CDC_CALL_MGMT_OVER_DCI,\
-   .acm.bFunctionLength          = sizeof(usb_cdc_acm_desc_t),\
-   .acm.bDescriptorType          = CDC_CS_INTERFACE,\
-   .acm.bDescriptorSubtype       = CDC_SCS_ACM,\
-   .acm.bmCapabilities           = CDC_ACM_SUPPORT_LINE_REQUESTS,\
-   .union_desc.bFunctionLength   = sizeof(usb_cdc_union_desc_t),\
-   .union_desc.bDescriptorType   = CDC_CS_INTERFACE,\
-   .union_desc.bDescriptorSubtype= CDC_SCS_UNION,\
-   .ep_notify.bLength            = sizeof(usb_ep_desc_t),\
-   .ep_notify.bDescriptorType    = USB_DT_ENDPOINT,\
-   .ep_notify.bmAttributes       = USB_EP_TYPE_INTERRUPT,\
-   .ep_notify.wMaxPacketSize     = LE16(UDI_CDC_COMM_EP_SIZE),\
-   .ep_notify.bInterval          = 0x10,\
-   .ep_notify.bEndpointAddress   = UDI_CDC_COMM_EP_##port,\
-   .iface.bInterfaceNumber       = UDI_CDC_COMM_IFACE_NUMBER_##port,\
-   .call_mgmt.bDataInterface     = UDI_CDC_DATA_IFACE_NUMBER_##port,\
-   .union_desc.bMasterInterface  = UDI_CDC_COMM_IFACE_NUMBER_##port,\
-   .union_desc.bSlaveInterface0  = UDI_CDC_DATA_IFACE_NUMBER_##port,\
-   .iface.iInterface             = UDI_CDC_COMM_STRING_ID_##port,\
-   }
-
-//! Content of CDC DATA interface descriptors
-#define UDI_CDC_DATA_DESC_COMMON \
-   .iface.bLength                = sizeof(usb_iface_desc_t),\
-   .iface.bDescriptorType        = USB_DT_INTERFACE,\
-   .iface.bAlternateSetting      = 0,\
-   .iface.bNumEndpoints          = 2,\
-   .iface.bInterfaceClass        = CDC_CLASS_DATA,\
-   .iface.bInterfaceSubClass     = 0,\
-   .iface.bInterfaceProtocol     = 0,\
-   .ep_in.bLength                = sizeof(usb_ep_desc_t),\
-   .ep_in.bDescriptorType        = USB_DT_ENDPOINT,\
-   .ep_in.bmAttributes           = USB_EP_TYPE_BULK,\
-   .ep_in.bInterval              = 0,\
-   .ep_out.bLength               = sizeof(usb_ep_desc_t),\
-   .ep_out.bDescriptorType       = USB_DT_ENDPOINT,\
-   .ep_out.bmAttributes          = USB_EP_TYPE_BULK,\
-   .ep_out.bInterval             = 0,
-
-#define UDI_CDC_DATA_DESC_FS(port) { \
-   UDI_CDC_DATA_DESC_COMMON \
-   .ep_in.wMaxPacketSize         = LE16(UDI_CDC_DATA_EPS_FS_SIZE),\
-   .ep_out.wMaxPacketSize        = LE16(UDI_CDC_DATA_EPS_FS_SIZE),\
-   .ep_in.bEndpointAddress       = UDI_CDC_DATA_EP_IN_##port,\
-   .ep_out.bEndpointAddress      = UDI_CDC_DATA_EP_OUT_##port,\
-   .iface.bInterfaceNumber       = UDI_CDC_DATA_IFACE_NUMBER_##port,\
-   .iface.iInterface             = UDI_CDC_DATA_STRING_ID_##port,\
-   }
-
-#define UDI_CDC_DATA_DESC_HS(port) { \
-   UDI_CDC_DATA_DESC_COMMON \
-   .ep_in.wMaxPacketSize         = LE16(UDI_CDC_DATA_EPS_HS_SIZE),\
-   .ep_out.wMaxPacketSize        = LE16(UDI_CDC_DATA_EPS_HS_SIZE),\
-   .ep_in.bEndpointAddress       = UDI_CDC_DATA_EP_IN_##port,\
-   .ep_out.bEndpointAddress      = UDI_CDC_DATA_EP_OUT_##port,\
-   .iface.bInterfaceNumber       = UDI_CDC_DATA_IFACE_NUMBER_##port,\
-   .iface.iInterface             = UDI_CDC_DATA_STRING_ID_##port,\
-   }
-
-//@}
-
-/**
- * \ingroup udi_group
- * \defgroup udi_cdc_group USB Device Interface (UDI) for Communication Class Device (CDC)
- *
- * Common APIs used by high level application to use this USB class.
- *
- * These routines are used to transfer and control data
- * to/from USB CDC endpoint.
- *
- * See \ref udi_cdc_quickstart.
- * @{
- */
-
-/**
- * \name Interface for application with single CDC interface support
- */
-//@{
-
-/**
- * \brief Notify a state change of DCD signal
- *
- * \param b_set      DCD is enabled if true, else disabled
- */
-void udi_cdc_ctrl_signal_dcd(bool b_set);
-
-/**
- * \brief Notify a state change of DSR signal
- *
- * \param b_set      DSR is enabled if true, else disabled
- */
-void udi_cdc_ctrl_signal_dsr(bool b_set);
-
-/**
- * \brief Notify a framing error
- */
-void udi_cdc_signal_framing_error(void);
-
-/**
- * \brief Notify a parity error
- */
-void udi_cdc_signal_parity_error(void);
-
-/**
- * \brief Notify a overrun
- */
-void udi_cdc_signal_overrun(void);
-
-/**
- * \brief Gets the number of byte received
- *
- * \return the number of data available
- */
-iram_size_t udi_cdc_get_nb_received_data(void);
-
-/**
- * \brief This function checks if a character has been received on the CDC line
- *
- * \return \c 1 if a byte is ready to be read.
- */
-bool udi_cdc_is_rx_ready(void);
-
-/**
- * \brief Waits and gets a value on CDC line
- *
- * \return value read on CDC line
- */
-int udi_cdc_getc(void);
-
-/**
- * \brief Reads a RAM buffer on CDC line
- *
- * \param buf       Values read
- * \param size      Number of value read
- *
- * \return the number of data remaining
- */
-iram_size_t udi_cdc_read_buf(void* buf, iram_size_t size);
-
-/**
- * \brief Non polling reads of a up to 'size' data from CDC line
- *
- * \param port      Communication port number to manage
- * \param buf       Buffer where to store read data
- * \param size      Maximum number of data to read (size of buffer)
- *
- * \return the number of data effectively read
- */
-iram_size_t udi_cdc_read_no_polling(void* buf, iram_size_t size);
-
-/**
- * \brief Gets the number of free byte in TX buffer
- *
- * \return the number of free byte in TX buffer
- */
-iram_size_t udi_cdc_get_free_tx_buffer(void);
-
-/**
- * \brief This function checks if a new character sent is possible
- * The type int is used to support scanf redirection from compiler LIB.
- *
- * \return \c 1 if a new character can be sent
- */
-bool udi_cdc_is_tx_ready(void);
-
-/**
- * \brief Puts a byte on CDC line
- * The type int is used to support printf redirection from compiler LIB.
- *
- * \param value      Value to put
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-int udi_cdc_putc(int value);
-
-/**
- * \brief Writes a RAM buffer on CDC line
- *
- * \param buf       Values to write
- * \param size      Number of value to write
- *
- * \return the number of data remaining
- */
-iram_size_t udi_cdc_write_buf(const void* buf, iram_size_t size);
-//@}
-
-/**
- * \name Interface for application with multi CDC interfaces support
- */
-//@{
-
-/**
- * \brief Notify a state change of DCD signal
- *
- * \param port       Communication port number to manage
- * \param b_set      DCD is enabled if true, else disabled
- */
-void udi_cdc_multi_ctrl_signal_dcd(uint8_t port, bool b_set);
-
-/**
- * \brief Notify a state change of DSR signal
- *
- * \param port       Communication port number to manage
- * \param b_set      DSR is enabled if true, else disabled
- */
-void udi_cdc_multi_ctrl_signal_dsr(uint8_t port, bool b_set);
-
-/**
- * \brief Notify a framing error
- *
- * \param port       Communication port number to manage
- */
-void udi_cdc_multi_signal_framing_error(uint8_t port);
-
-/**
- * \brief Notify a parity error
- *
- * \param port       Communication port number to manage
- */
-void udi_cdc_multi_signal_parity_error(uint8_t port);
-
-/**
- * \brief Notify a overrun
- *
- * \param port       Communication port number to manage
- */
-void udi_cdc_multi_signal_overrun(uint8_t port);
-
-/**
- * \brief Gets the number of byte received
- *
- * \param port       Communication port number to manage
- *
- * \return the number of data available
- */
-iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port);
-
-/**
- * \brief This function checks if a character has been received on the CDC line
- *
- * \param port       Communication port number to manage
- *
- * \return \c 1 if a byte is ready to be read.
- */
-bool udi_cdc_multi_is_rx_ready(uint8_t port);
-
-/**
- * \brief Waits and gets a value on CDC line
- *
- * \param port       Communication port number to manage
- *
- * \return value read on CDC line
- */
-int udi_cdc_multi_getc(uint8_t port);
-
-/**
- * \brief Reads a RAM buffer on CDC line
- *
- * \param port       Communication port number to manage
- * \param buf       Values read
- * \param size      Number of values read
- *
- * \return the number of data remaining
- */
-iram_size_t udi_cdc_multi_read_buf(uint8_t port, void* buf, iram_size_t size);
-
-/**
- * \brief Gets the number of free byte in TX buffer
- *
- * \param port       Communication port number to manage
- *
- * \return the number of free byte in TX buffer
- */
-iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port);
-
-/**
- * \brief This function checks if a new character sent is possible
- * The type int is used to support scanf redirection from compiler LIB.
- *
- * \param port       Communication port number to manage
- *
- * \return \c 1 if a new character can be sent
- */
-bool udi_cdc_multi_is_tx_ready(uint8_t port);
-
-/**
- * \brief Puts a byte on CDC line
- * The type int is used to support printf redirection from compiler LIB.
- *
- * \param port       Communication port number to manage
- * \param value      Value to put
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-int udi_cdc_multi_putc(uint8_t port, int value);
-
-/**
- * \brief Writes a RAM buffer on CDC line
- *
- * \param port       Communication port number to manage
- * \param buf       Values to write
- * \param size      Number of value to write
- *
- * \return the number of data remaining
- */
-iram_size_t udi_cdc_multi_write_buf(uint8_t port, const void* buf, iram_size_t size);
-//@}
-
-//@}
-
-/**
- * \page udi_cdc_quickstart Quick start guide for USB device Communication Class Device module (UDI CDC)
- *
- * This is the quick start guide for the \ref udi_cdc_group
- * "USB device interface CDC module (UDI CDC)" with step-by-step instructions on
- * how to configure and use the modules in a selection of use cases.
- *
- * The use cases contain several code fragments. The code fragments in the
- * steps for setup can be copied into a custom initialization function, while
- * the steps for usage can be copied into, e.g., the main application function.
- *
- * \section udi_cdc_basic_use_case Basic use case
- * In this basic use case, the "USB CDC (Single Interface Device)" module is used
- * with only one communication port.
- * The "USB CDC (Composite Device)" module usage is described in \ref udi_cdc_use_cases
- * "Advanced use cases".
- *
- * \section udi_cdc_basic_use_case_setup Setup steps
- * \subsection udi_cdc_basic_use_case_setup_prereq Prerequisites
- * \copydetails udc_basic_use_case_setup_prereq
- * \subsection udi_cdc_basic_use_case_setup_code Example code
- * \copydetails udc_basic_use_case_setup_code
- * \subsection udi_cdc_basic_use_case_setup_flow Workflow
- * \copydetails udc_basic_use_case_setup_flow
- *
- * \section udi_cdc_basic_use_case_usage Usage steps
- *
- * \subsection udi_cdc_basic_use_case_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	 #define UDI_CDC_ENABLE_EXT(port) my_callback_cdc_enable()
-	 extern bool my_callback_cdc_enable(void);
-	 #define UDI_CDC_DISABLE_EXT(port) my_callback_cdc_disable()
-	 extern void my_callback_cdc_disable(void);
-	 #define  UDI_CDC_LOW_RATE
-
-	 #define  UDI_CDC_DEFAULT_RATE             115200
-	 #define  UDI_CDC_DEFAULT_STOPBITS         CDC_STOP_BITS_1
-	 #define  UDI_CDC_DEFAULT_PARITY           CDC_PAR_NONE
-	 #define  UDI_CDC_DEFAULT_DATABITS         8
-
-	 #include "udi_cdc_conf.h" // At the end of conf_usb.h file
-\endcode
- *
- * Add to application C-file:
- * \code
-	 static bool my_flag_autorize_cdc_transfert = false;
-	 bool my_callback_cdc_enable(void)
-	 {
-	    my_flag_autorize_cdc_transfert = true;
-	    return true;
-	 }
-	 void my_callback_cdc_disable(void)
-	 {
-	    my_flag_autorize_cdc_transfert = false;
-	 }
-
-	 void task(void)
-	 {
-	    if (my_flag_autorize_cdc_transfert) {
-	        udi_cdc_putc('A');
-	        udi_cdc_getc();
-	    }
-	 }
-\endcode
- *
- * \subsection udi_cdc_basic_use_case_setup_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following configuration,
- * which is the USB device CDC configuration:
- *   - \code #define USB_DEVICE_SERIAL_NAME  "12...EF" // Disk SN for CDC \endcode
- *     \note The USB serial number is mandatory when a CDC interface is used.
- *   - \code #define UDI_CDC_ENABLE_EXT(port) my_callback_cdc_enable()
-	 extern bool my_callback_cdc_enable(void); \endcode
- *     \note After the device enumeration (detecting and identifying USB devices),
- *     the USB host starts the device configuration. When the USB CDC interface
- *     from the device is accepted by the host, the USB host enables this interface and the
- *     UDI_CDC_ENABLE_EXT() callback function is called and return true.
- *     Thus, when this event is received, the data transfer on CDC interface are authorized.
- *   - \code #define UDI_CDC_DISABLE_EXT(port) my_callback_cdc_disable()
-	 extern void my_callback_cdc_disable(void); \endcode
- *     \note When the USB device is unplugged or is reset by the USB host, the USB
- *     interface is disabled and the UDI_CDC_DISABLE_EXT() callback function
- *     is called. Thus, the data transfer must be stopped on CDC interface.
- *   - \code #define  UDI_CDC_LOW_RATE \endcode
- *     \note  Define it when the transfer CDC Device to Host is a low rate
- *     (<512000 bauds) to reduce CDC buffers size.
- *   - \code #define  UDI_CDC_DEFAULT_RATE             115200
-	#define  UDI_CDC_DEFAULT_STOPBITS         CDC_STOP_BITS_1
-	#define  UDI_CDC_DEFAULT_PARITY           CDC_PAR_NONE
-	#define  UDI_CDC_DEFAULT_DATABITS         8 \endcode
- *     \note Default configuration of communication port at startup.
- * -# Send or wait data on CDC line:
- *   - \code // Waits and gets a value on CDC line
-	int udi_cdc_getc(void);
-	// Reads a RAM buffer on CDC line
-	iram_size_t udi_cdc_read_buf(int *buf, iram_size_t size);
-	// Puts a byte on CDC line
-	int udi_cdc_putc(int value);
-	// Writes a RAM buffer on CDC line
-	iram_size_t udi_cdc_write_buf(const int *buf, iram_size_t size); \endcode
- *
- * \section udi_cdc_use_cases Advanced use cases
- * For more advanced use of the UDI CDC module, see the following use cases:
- * - \subpage udi_cdc_use_case_composite
- * - \subpage udc_use_case_1
- * - \subpage udc_use_case_2
- * - \subpage udc_use_case_3
- * - \subpage udc_use_case_4
- * - \subpage udc_use_case_5
- * - \subpage udc_use_case_6
- */
-
-/**
- * \page udi_cdc_use_case_composite CDC in a composite device
- *
- * A USB Composite Device is a USB Device which uses more than one USB class.
- * In this use case, the "USB CDC (Composite Device)" module is used to
- * create a USB composite device. Thus, this USB module can be associated with
- * another "Composite Device" module, like "USB HID Mouse (Composite Device)".
- *
- * Also, you can refer to application note
- * <A href="https://www.atmel.com/dyn/resources/prod_documents/doc8445.pdf">
- * AVR4902 ASF - USB Composite Device</A>.
- *
- * \section udi_cdc_use_case_composite_setup Setup steps
- * For the setup code of this use case to work, the
- * \ref udi_cdc_basic_use_case "basic use case" must be followed.
- *
- * \section udi_cdc_use_case_composite_usage Usage steps
- *
- * \subsection udi_cdc_use_case_composite_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	 #define USB_DEVICE_EP_CTRL_SIZE  64
-	 #define USB_DEVICE_NB_INTERFACE (X+2)
-	 #define USB_DEVICE_MAX_EP (X+3)
-
-	 #define  UDI_CDC_DATA_EP_IN_0          (1 | USB_EP_DIR_IN)  // TX
-	 #define  UDI_CDC_DATA_EP_OUT_0         (2 | USB_EP_DIR_OUT) // RX
-	 #define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN)  // Notify endpoint
-	 #define  UDI_CDC_COMM_IFACE_NUMBER_0   X+0
-	 #define  UDI_CDC_DATA_IFACE_NUMBER_0   X+1
-
-	 #define UDI_COMPOSITE_DESC_T \
-	    usb_iad_desc_t udi_cdc_iad; \
-	    udi_cdc_comm_desc_t udi_cdc_comm; \
-	    udi_cdc_data_desc_t udi_cdc_data; \
-	    ...
-	 #define UDI_COMPOSITE_DESC_FS \
-	    .udi_cdc_iad               = UDI_CDC_IAD_DESC_0, \
-	    .udi_cdc_comm              = UDI_CDC_COMM_DESC_0, \
-	    .udi_cdc_data              = UDI_CDC_DATA_DESC_0_FS, \
-	    ...
-	 #define UDI_COMPOSITE_DESC_HS \
-	    .udi_cdc_iad               = UDI_CDC_IAD_DESC_0, \
-	    .udi_cdc_comm              = UDI_CDC_COMM_DESC_0, \
-	    .udi_cdc_data              = UDI_CDC_DATA_DESC_0_HS, \
-	    ...
-	 #define UDI_COMPOSITE_API \
-	    &udi_api_cdc_comm,       \
-	    &udi_api_cdc_data,       \
-	    ...
-\endcode
- *
- * \subsection udi_cdc_use_case_composite_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required for a USB composite device configuration:
- *   - \code // Endpoint control size, This must be:
-	// - 8, 16, 32 or 64 for full speed device (8 is recommended to save RAM)
-	// - 64 for a high speed device
-	#define USB_DEVICE_EP_CTRL_SIZE  64
-	// Total Number of interfaces on this USB device.
-	// Add 2 for CDC.
-	#define USB_DEVICE_NB_INTERFACE (X+2)
-	// Total number of endpoints on this USB device.
-	// This must include each endpoint for each interface.
-	// Add 3 for CDC.
-	#define USB_DEVICE_MAX_EP (X+3) \endcode
- * -# Ensure that conf_usb.h contains the description of
- * composite device:
- *   - \code // The endpoint numbers chosen by you for the CDC.
-	// The endpoint numbers starting from 1.
-	#define  UDI_CDC_DATA_EP_IN_0            (1 | USB_EP_DIR_IN)  // TX
-	#define  UDI_CDC_DATA_EP_OUT_0           (2 | USB_EP_DIR_OUT) // RX
-	#define  UDI_CDC_COMM_EP_0               (3 | USB_EP_DIR_IN)  // Notify endpoint
-	// The interface index of an interface starting from 0
-	#define  UDI_CDC_COMM_IFACE_NUMBER_0     X+0
-	#define  UDI_CDC_DATA_IFACE_NUMBER_0     X+1 \endcode
- * -# Ensure that conf_usb.h contains the following parameters
- * required for a USB composite device configuration:
- *   - \code // USB Interfaces descriptor structure
-	#define UDI_COMPOSITE_DESC_T \
-	   ...
-	   usb_iad_desc_t udi_cdc_iad; \
-	   udi_cdc_comm_desc_t udi_cdc_comm; \
-	   udi_cdc_data_desc_t udi_cdc_data; \
-	   ...
-	// USB Interfaces descriptor value for Full Speed
-	#define UDI_COMPOSITE_DESC_FS \
-	   ...
-	   .udi_cdc_iad               = UDI_CDC_IAD_DESC_0, \
-	   .udi_cdc_comm              = UDI_CDC_COMM_DESC_0, \
-	   .udi_cdc_data              = UDI_CDC_DATA_DESC_0_FS, \
-	   ...
-	// USB Interfaces descriptor value for High Speed
-	#define UDI_COMPOSITE_DESC_HS \
-	   ...
-	   .udi_cdc_iad               = UDI_CDC_IAD_DESC_0, \
-	   .udi_cdc_comm              = UDI_CDC_COMM_DESC_0, \
-	   .udi_cdc_data              = UDI_CDC_DATA_DESC_0_HS, \
-	   ...
-	// USB Interface APIs
-	#define UDI_COMPOSITE_API \
-	   ...
-	   &udi_api_cdc_comm,       \
-	   &udi_api_cdc_data,       \
-	   ... \endcode
- *   - \note The descriptors order given in the four lists above must be the
- *     same as the order defined by all interface indexes. The interface index
- *     orders are defined through UDI_X_IFACE_NUMBER defines.\n
- *     Also, the CDC requires a USB Interface Association Descriptor (IAD) for
- *     composite device.
- */
-
-#ifdef __cplusplus
-}
-#endif
-#endif // _UDI_CDC_H_
diff --git a/Marlin/src/HAL/DUE/usb/udi_cdc_conf.h b/Marlin/src/HAL/DUE/usb/udi_cdc_conf.h
deleted file mode 100644
index e61b8cb..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_cdc_conf.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * \file
- *
- * \brief Default CDC configuration for a USB Device with a single interface
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDI_CDC_CONF_H_
-#define _UDI_CDC_CONF_H_
-
-#include "usb_protocol_cdc.h"
-#include "conf_usb.h"
-
-#ifndef UDI_CDC_PORT_NB
-# define  UDI_CDC_PORT_NB 1
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \addtogroup udi_cdc_group_single_desc
- * @{
- */
-
-//! Control endpoint size (Endpoint 0)
-#define  USB_DEVICE_EP_CTRL_SIZE       64
-
-#if XMEGA
-/**
- * \name Endpoint configuration on XMEGA
- * The XMEGA supports a IN and OUT endpoint with the same number endpoint,
- * thus XMEGA can support up to 7 CDC interfaces.
- */
-//@{
-#define  UDI_CDC_DATA_EP_IN_0          ( 1 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_0         ( 2 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_0             ( 2 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_1          ( 3 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_1         ( 4 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_1             ( 4 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_2          ( 5 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_2         ( 6 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_2             ( 6 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_3          ( 7 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_3         ( 8 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_3             ( 8 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_4          ( 9 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_4         (10 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_4             (10 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_5          (11 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_5         (12 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_5             (12 | USB_EP_DIR_IN)  // Notify endpoint
-#define  UDI_CDC_DATA_EP_IN_6          (13 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_6         (14 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_6             (14 | USB_EP_DIR_IN)  // Notify endpoint
-//! 2 endpoints numbers used per CDC interface
-#define  USB_DEVICE_MAX_EP             (2*UDI_CDC_PORT_NB)
-//@}
-
-#else
-
-/**
- * \name Default endpoint configuration
- * The USBB, UDP, UDPHS and UOTGHS interfaces can support up to 2 CDC interfaces.
- */
-//@{
-#  if UDI_CDC_PORT_NB > 2
-#    error USBB, UDP, UDPHS and UOTGHS interfaces have not enough endpoints.
-#  endif
-#define  UDI_CDC_DATA_EP_IN_0          (1 | USB_EP_DIR_IN)  // TX
-#define  UDI_CDC_DATA_EP_OUT_0         (2 | USB_EP_DIR_OUT) // RX
-#define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN)  // Notify endpoint
-#  if SAM3U
-     /* For 3U max endpoint size of 4 is 64, use 5 and 6 as bulk tx and rx */
-#    define  UDI_CDC_DATA_EP_IN_1          (6 | USB_EP_DIR_IN)  // TX
-#    define  UDI_CDC_DATA_EP_OUT_1         (5 | USB_EP_DIR_OUT) // RX
-#    define  UDI_CDC_COMM_EP_1             (4 | USB_EP_DIR_IN)  // Notify
-#  else
-#    define  UDI_CDC_DATA_EP_IN_1          (4 | USB_EP_DIR_IN)  // TX
-#    define  UDI_CDC_DATA_EP_OUT_1         (5 | USB_EP_DIR_OUT) // RX
-#    define  UDI_CDC_COMM_EP_1             (6 | USB_EP_DIR_IN)  // Notify
-#  endif
-//! 3 endpoints used per CDC interface
-#undef USB_DEVICE_MAX_EP   // undefine this definition in header file
-#define  USB_DEVICE_MAX_EP             (3*UDI_CDC_PORT_NB)
-//@}
-
-#endif
-
-/**
- * \name Default Interface numbers
- */
-//@{
-#define  UDI_CDC_COMM_IFACE_NUMBER_0   0
-#define  UDI_CDC_DATA_IFACE_NUMBER_0   1
-#define  UDI_CDC_COMM_IFACE_NUMBER_1   2
-#define  UDI_CDC_DATA_IFACE_NUMBER_1   3
-#define  UDI_CDC_COMM_IFACE_NUMBER_2   4
-#define  UDI_CDC_DATA_IFACE_NUMBER_2   5
-#define  UDI_CDC_COMM_IFACE_NUMBER_3   6
-#define  UDI_CDC_DATA_IFACE_NUMBER_3   7
-#define  UDI_CDC_COMM_IFACE_NUMBER_4   8
-#define  UDI_CDC_DATA_IFACE_NUMBER_4   9
-#define  UDI_CDC_COMM_IFACE_NUMBER_5   10
-#define  UDI_CDC_DATA_IFACE_NUMBER_5   11
-#define  UDI_CDC_COMM_IFACE_NUMBER_6   12
-#define  UDI_CDC_DATA_IFACE_NUMBER_6   13
-//@}
-
-//@}
-
-#ifdef __cplusplus
-}
-#endif
-#endif // _UDI_CDC_CONF_H_
diff --git a/Marlin/src/HAL/DUE/usb/udi_cdc_desc.c b/Marlin/src/HAL/DUE/usb/udi_cdc_desc.c
deleted file mode 100644
index 97c334e..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_cdc_desc.c
+++ /dev/null
@@ -1,261 +0,0 @@
-/**
- * \file
- *
- * \brief Default descriptors for a USB Device with a single interface CDC
- *
- * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "conf_usb.h"
-#include "udd.h"
-#include "udc_desc.h"
-#include "udi_cdc.h"
-
-#if DISABLED(SDSUPPORT)
-
-/**
- * \defgroup udi_cdc_group_single_desc USB device descriptors for a single interface
- *
- * The following structures provide the USB device descriptors required for
- * USB Device with a single interface CDC.
- *
- * It is ready to use and do not require more definition.
- *
- * @{
- */
-
-//! Two interfaces for a CDC device
-#define  USB_DEVICE_NB_INTERFACE       (2*UDI_CDC_PORT_NB)
-
-#ifdef USB_DEVICE_LPM_SUPPORT
-# define USB_VERSION   USB_V2_1
-#else
-# define USB_VERSION   USB_V2_0
-#endif
-
-//! USB Device Descriptor
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE usb_dev_desc_t udc_device_desc = {
-  .bLength                   = sizeof(usb_dev_desc_t),
-  .bDescriptorType           = USB_DT_DEVICE,
-  .bcdUSB                    = LE16(USB_VERSION),
-#if UDI_CDC_PORT_NB > 1
-  .bDeviceClass              = 0,
-#else
-  .bDeviceClass              = CDC_CLASS_DEVICE,
-#endif
-  .bDeviceSubClass           = 0,
-  .bDeviceProtocol           = 0,
-  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-  .idVendor                  = LE16(USB_DEVICE_VENDOR_ID),
-  .idProduct                 = LE16(USB_DEVICE_PRODUCT_ID),
-  .bcdDevice                 = LE16((USB_DEVICE_MAJOR_VERSION << 8)
-      | USB_DEVICE_MINOR_VERSION),
-#ifdef USB_DEVICE_MANUFACTURE_NAME
-  .iManufacturer = 1,
-#else
-  .iManufacturer             = 0,  // No manufacture string
-#endif
-#ifdef USB_DEVICE_PRODUCT_NAME
-  .iProduct = 2,
-#else
-  .iProduct                  = 0,  // No product string
-#endif
-#if (defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER)
-  .iSerialNumber = 3,
-#else
-  .iSerialNumber             = 0,  // No serial string
-#endif
-  .bNumConfigurations = 1
-};
-
-
-#ifdef USB_DEVICE_HS_SUPPORT
-//! USB Device Qualifier Descriptor for HS
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE usb_dev_qual_desc_t udc_device_qual = {
-  .bLength                   = sizeof(usb_dev_qual_desc_t),
-  .bDescriptorType           = USB_DT_DEVICE_QUALIFIER,
-  .bcdUSB                    = LE16(USB_VERSION),
-#if UDI_CDC_PORT_NB > 1
-  .bDeviceClass              = 0,
-#else
-  .bDeviceClass              = CDC_CLASS_DEVICE,
-#endif
-  .bDeviceSubClass           = 0,
-  .bDeviceProtocol           = 0,
-  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-  .bNumConfigurations        = 1
-};
-#endif
-
-#ifdef USB_DEVICE_LPM_SUPPORT
-//! USB Device Qualifier Descriptor
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE usb_dev_lpm_desc_t udc_device_lpm = {
-  .bos.bLength               = sizeof(usb_dev_bos_desc_t),
-  .bos.bDescriptorType       = USB_DT_BOS,
-  .bos.wTotalLength          = LE16(sizeof(usb_dev_bos_desc_t) + sizeof(usb_dev_capa_ext_desc_t)),
-  .bos.bNumDeviceCaps        = 1,
-  .capa_ext.bLength          = sizeof(usb_dev_capa_ext_desc_t),
-  .capa_ext.bDescriptorType  = USB_DT_DEVICE_CAPABILITY,
-  .capa_ext.bDevCapabilityType = USB_DC_USB20_EXTENSION,
-  .capa_ext.bmAttributes     = USB_DC_EXT_LPM,
-};
-#endif
-
-//! Structure for USB Device Configuration Descriptor
-COMPILER_PACK_SET(1)
-typedef struct {
-  usb_conf_desc_t conf;
-#if UDI_CDC_PORT_NB == 1
-  udi_cdc_comm_desc_t udi_cdc_comm_0;
-  udi_cdc_data_desc_t udi_cdc_data_0;
-#else
-#  define UDI_CDC_DESC_STRUCTURE(index, unused) \
-  usb_iad_desc_t      udi_cdc_iad_##index; \
-  udi_cdc_comm_desc_t udi_cdc_comm_##index; \
-  udi_cdc_data_desc_t udi_cdc_data_##index;
-  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_STRUCTURE, ~)
-#  undef UDI_CDC_DESC_STRUCTURE
-#endif
-} udc_desc_t;
-COMPILER_PACK_RESET()
-
-//! USB Device Configuration Descriptor filled for full and high speed
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE udc_desc_t udc_desc_fs = {
-  .conf.bLength              = sizeof(usb_conf_desc_t),
-  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
-  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-  .conf.bConfigurationValue  = 1,
-  .conf.iConfiguration       = 0,
-  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-#if UDI_CDC_PORT_NB == 1
-  .udi_cdc_comm_0            = UDI_CDC_COMM_DESC_0,
-  .udi_cdc_data_0            = UDI_CDC_DATA_DESC_0_FS,
-#else
-#  define UDI_CDC_DESC_FS(index, unused) \
-  .udi_cdc_iad_##index             = UDI_CDC_IAD_DESC_##index,\
-  .udi_cdc_comm_##index            = UDI_CDC_COMM_DESC_##index,\
-  .udi_cdc_data_##index            = UDI_CDC_DATA_DESC_##index##_FS,
-  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_FS, ~)
-#  undef UDI_CDC_DESC_FS
-#endif
-};
-
-#ifdef USB_DEVICE_HS_SUPPORT
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE udc_desc_t udc_desc_hs = {
-  .conf.bLength              = sizeof(usb_conf_desc_t),
-  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
-  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-  .conf.bConfigurationValue  = 1,
-  .conf.iConfiguration       = 0,
-  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-#if UDI_CDC_PORT_NB == 1
-  .udi_cdc_comm_0            = UDI_CDC_COMM_DESC_0,
-  .udi_cdc_data_0            = UDI_CDC_DATA_DESC_0_HS,
-#else
-#  define UDI_CDC_DESC_HS(index, unused) \
-  .udi_cdc_iad_##index             = UDI_CDC_IAD_DESC_##index, \
-  .udi_cdc_comm_##index            = UDI_CDC_COMM_DESC_##index, \
-  .udi_cdc_data_##index            = UDI_CDC_DATA_DESC_##index##_HS,
-  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_HS, ~)
-#  undef UDI_CDC_DESC_HS
-#endif
-};
-#endif
-
-/**
- * \name UDC structures which content all USB Device definitions
- */
-//@{
-
-//! Associate an UDI for each USB interface
-UDC_DESC_STORAGE udi_api_t *udi_apis[USB_DEVICE_NB_INTERFACE] = {
-#  define UDI_CDC_API(index, unused) \
-  &udi_api_cdc_comm, \
-  &udi_api_cdc_data,
-  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_API, ~)
-#  undef UDI_CDC_API
-};
-
-//! Add UDI with USB Descriptors FS & HS
-UDC_DESC_STORAGE udc_config_speed_t udc_config_fs[1] = { {
-  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_fs,
-  .udi_apis = udi_apis,
-}};
-#ifdef USB_DEVICE_HS_SUPPORT
-UDC_DESC_STORAGE udc_config_speed_t udc_config_hs[1] = { {
-  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_hs,
-  .udi_apis = udi_apis,
-}};
-#endif
-
-//! Add all information about USB Device in global structure for UDC
-UDC_DESC_STORAGE udc_config_t udc_config = {
-  .confdev_lsfs = &udc_device_desc,
-  .conf_lsfs = udc_config_fs,
-#ifdef USB_DEVICE_HS_SUPPORT
-  .confdev_hs = &udc_device_desc,
-  .qualifier = &udc_device_qual,
-  .conf_hs = udc_config_hs,
-#endif
-#ifdef USB_DEVICE_LPM_SUPPORT
-  .conf_bos = &udc_device_lpm.bos,
-#else
-  .conf_bos = NULL,
-#endif
-};
-
-//@}
-//@}
-
-#endif // SDSUPPORT
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/udi_composite_desc.c b/Marlin/src/HAL/DUE/usb/udi_composite_desc.c
deleted file mode 100644
index da74fbe..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_composite_desc.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/**
- * \file
- *
- * \brief Descriptors for an USB Composite Device
- *
- * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "conf_usb.h"
-#include "udd.h"
-#include "udc_desc.h"
-
-#if ENABLED(SDSUPPORT)
-
-/**
- * \defgroup udi_group_desc Descriptors for a USB Device
- * composite
- *
- * @{
- */
-
-/**INDENT-OFF**/
-
-//! USB Device Descriptor
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE usb_dev_desc_t udc_device_desc = {
-  .bLength                   = sizeof(usb_dev_desc_t),
-  .bDescriptorType           = USB_DT_DEVICE,
-  .bcdUSB                    = LE16(USB_V2_0),
-  .bDeviceClass              = CDC_CLASS_MULTI,
-  .bDeviceSubClass           = CDC_SUBCLASS_ACM,
-  .bDeviceProtocol           = CDC_PROTOCOL_V25TER,
-  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-  .idVendor                  = LE16(USB_DEVICE_VENDOR_ID),
-  .idProduct                 = LE16(USB_DEVICE_PRODUCT_ID),
-  .bcdDevice                 = LE16((USB_DEVICE_MAJOR_VERSION << 8)
-    | USB_DEVICE_MINOR_VERSION),
-#ifdef USB_DEVICE_MANUFACTURE_NAME
-  .iManufacturer             = 1,
-#else
-  .iManufacturer             = 0,  // No manufacture string
-#endif
-#ifdef USB_DEVICE_PRODUCT_NAME
-  .iProduct                  = 2,
-#else
-  .iProduct                  = 0,  // No product string
-#endif
-#if (defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER)
-  .iSerialNumber             = 3,
-#else
-  .iSerialNumber             = 0,  // No serial string
-#endif
-  .bNumConfigurations        = 1
-};
-
-
-#ifdef USB_DEVICE_HS_SUPPORT
-//! USB Device Qualifier Descriptor for HS
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE usb_dev_qual_desc_t udc_device_qual = {
-  .bLength                   = sizeof(usb_dev_qual_desc_t),
-  .bDescriptorType           = USB_DT_DEVICE_QUALIFIER,
-  .bcdUSB                    = LE16(USB_V2_0),
-  .bDeviceClass              = CDC_CLASS_MULTI,
-  .bDeviceSubClass           = CDC_SUBCLASS_ACM,
-  .bDeviceProtocol           = CDC_PROTOCOL_V25TER,
-  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-  .bNumConfigurations        = 1
-};
-#endif
-
-//! Structure for USB Device Configuration Descriptor
-COMPILER_PACK_SET(1)
-typedef struct {
-  usb_conf_desc_t conf;
-  UDI_COMPOSITE_DESC_T;
-} udc_desc_t;
-COMPILER_PACK_RESET()
-
-//! USB Device Configuration Descriptor filled for FS
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE udc_desc_t udc_desc_fs = {
-  .conf.bLength              = sizeof(usb_conf_desc_t),
-  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
-  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-  .conf.bConfigurationValue  = 1,
-  .conf.iConfiguration       = 0,
-  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-  UDI_COMPOSITE_DESC_FS
-};
-
-#ifdef USB_DEVICE_HS_SUPPORT
-//! USB Device Configuration Descriptor filled for HS
-COMPILER_WORD_ALIGNED
-UDC_DESC_STORAGE udc_desc_t udc_desc_hs = {
-  .conf.bLength              = sizeof(usb_conf_desc_t),
-  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
-  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-  .conf.bConfigurationValue  = 1,
-  .conf.iConfiguration       = 0,
-  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-  UDI_COMPOSITE_DESC_HS
-};
-#endif
-
-
-/**
- * \name UDC structures which contains all USB Device definitions
- */
-//@{
-
-//! Associate an UDI for each USB interface
-UDC_DESC_STORAGE udi_api_t *udi_apis[USB_DEVICE_NB_INTERFACE] = {
-  UDI_COMPOSITE_API
-};
-
-//! Add UDI with USB Descriptors FS
-UDC_DESC_STORAGE udc_config_speed_t   udc_config_lsfs[1] = {{
-  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_fs,
-  .udi_apis      = udi_apis,
-}};
-
-#ifdef USB_DEVICE_HS_SUPPORT
-//! Add UDI with USB Descriptors HS
-UDC_DESC_STORAGE udc_config_speed_t   udc_config_hs[1] = {{
-  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_hs,
-  .udi_apis      = udi_apis,
-}};
-#endif
-
-//! Add all information about USB Device in global structure for UDC
-UDC_DESC_STORAGE udc_config_t udc_config = {
-  .confdev_lsfs = &udc_device_desc,
-  .conf_lsfs = udc_config_lsfs,
-#ifdef USB_DEVICE_HS_SUPPORT
-  .confdev_hs = &udc_device_desc,
-  .qualifier = &udc_device_qual,
-  .conf_hs = udc_config_hs,
-#endif
-};
-
-//@}
-/**INDENT-ON**/
-//@}
-
-#endif // ARDUINO_ARCH_SAM
-
-#endif // SDSUPPORT
diff --git a/Marlin/src/HAL/DUE/usb/udi_msc.c b/Marlin/src/HAL/DUE/usb/udi_msc.c
deleted file mode 100644
index dd34048..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_msc.c
+++ /dev/null
@@ -1,1132 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Mass Storage Class (MSC) interface.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "usb_protocol_msc.h"
-#include "spc_protocol.h"
-#include "sbc_protocol.h"
-#include "udd.h"
-#include "udc.h"
-#include "udi_msc.h"
-#include "ctrl_access.h"
-#include <string.h>
-
-#if ENABLED(SDSUPPORT)
-
-#ifndef UDI_MSC_NOTIFY_TRANS_EXT
-#  define UDI_MSC_NOTIFY_TRANS_EXT()
-#endif
-
-/**
- * \ingroup udi_msc_group
- * \defgroup udi_msc_group_udc Interface with USB Device Core (UDC)
- *
- * Structures and functions required by UDC.
- *
- * @{
- */
-bool udi_msc_enable(void);
-void udi_msc_disable(void);
-bool udi_msc_setup(void);
-uint8_t udi_msc_getsetting(void);
-
-//! Global structure which contains standard UDI API for UDC
-UDC_DESC_STORAGE udi_api_t udi_api_msc = {
-  .enable = udi_msc_enable,
-  .disable = udi_msc_disable,
-  .setup = udi_msc_setup,
-  .getsetting = udi_msc_getsetting,
-  .sof_notify = NULL,
-};
-//@}
-
-
-/**
- * \ingroup udi_msc_group
- * \defgroup udi_msc_group_internal Implementation of UDI MSC
- *
- * Class internal implementation
- * @{
- */
-
-//! Static block size for all memories
-#define  UDI_MSC_BLOCK_SIZE   512L
-
-/**
- * \name Variables to manage SCSI requests
- */
-//@{
-
-//! Structure to receive a CBW packet
-UDC_BSS(4) static struct usb_msc_cbw udi_msc_cbw;
-//! Structure to send a CSW packet
-UDC_DATA(4) static struct usb_msc_csw udi_msc_csw =
-    {.dCSWSignature = CPU_TO_BE32(USB_CSW_SIGNATURE) };
-//! Number of lun
-UDC_DATA(4) static uint8_t udi_msc_nb_lun = 0;
-//! Structure with current SCSI sense data
-UDC_BSS(4) static struct scsi_request_sense_data udi_msc_sense;
-
-/**
- * \name Variables to manage the background read/write SCSI commands
- */
-//@{
-//! True if an invalid CBW command has been detected
-static bool udi_msc_b_cbw_invalid = false;
-//! True if a transfer command must be processed
-static bool udi_msc_b_trans_req = false;
-//! True if it is a read command, else write command
-static bool udi_msc_b_read;
-//! Memory address to execute the command
-static uint32_t udi_msc_addr;
-//! Number of block to transfer
-static uint16_t udi_msc_nb_block;
-//! Signal end of transfer, if true
-volatile bool udi_msc_b_ack_trans = true;
-//! Status of transfer, aborted if true
-volatile bool udi_msc_b_abort_trans;
-//! Signal (re)init of transfer, if true (by reset/reconnect)
-volatile bool udi_msc_b_reset_trans = true;
-//@}
-
-//@}
-
-
-/**
- * \name Internal routines
- */
-//@{
-
-/**
- * \name Routines to process CBW packet
- */
-//@{
-
-/**
- * \brief Stall CBW request
- */
-static void udi_msc_cbw_invalid(void);
-
-/**
- * \brief Stall CSW request
- */
-static void udi_msc_csw_invalid(void);
-
-/**
- * \brief Links a callback and buffer on endpoint OUT reception
- *
- * Called by:
- * - enable interface
- * - at the end of previous command after sending the CSW
- */
-static void udi_msc_cbw_wait(void);
-
-/**
- * \brief Callback called after CBW reception
- * Called by UDD when a transfer is finished or aborted
- *
- * \param status       UDD_EP_TRANSFER_OK, if transfer is finished
- * \param status       UDD_EP_TRANSFER_ABORT, if transfer is aborted
- * \param nb_received  number of data transferred
- */
-static void udi_msc_cbw_received(udd_ep_status_t status,
-    iram_size_t nb_received, udd_ep_id_t ep);
-
-/**
- * \brief Function to check the CBW length and direction
- * Call it after SCSI command decode to check integrity of command
- *
- * \param alloc_len  number of bytes that device want transfer
- * \param dir_flag   Direction of transfer (USB_CBW_DIRECTION_IN/OUT)
- *
- * \retval true if the command can be processed
- */
-static bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag);
-//@}
-
-
-/**
- * \name Routines to process small data packet
- */
-//@{
-
-/**
- * \brief Sends data on MSC IN endpoint
- * Called by SCSI command which must send a data to host followed by a CSW
- *
- * \param buffer        Internal RAM buffer to send
- * \param buf_size   Size of buffer to send
- */
-static void udi_msc_data_send(uint8_t * buffer, uint8_t buf_size);
-
-/**
- * \brief Callback called after data sent
- * It start CSW packet process
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer finish
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
- * \param nb_sent    number of data transferred
- */
-static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
-    udd_ep_id_t ep);
-//@}
-
-
-/**
- * \name Routines to process CSW packet
- */
-//@{
-
-/**
- * \brief Build CSW packet and send it
- *
- * Called at the end of SCSI command
- */
-static void udi_msc_csw_process(void);
-
-/**
- * \brief Sends CSW
- *
- * Called by #udi_msc_csw_process()
- * or UDD callback when endpoint halt is cleared
- */
-void udi_msc_csw_send(void);
-
-/**
- * \brief Callback called after CSW sent
- * It restart CBW reception.
- *
- * \param status     UDD_EP_TRANSFER_OK, if transfer is finished
- * \param status     UDD_EP_TRANSFER_ABORT, if transfer is aborted
- * \param nb_sent    number of data transferred
- */
-static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
-    udd_ep_id_t ep);
-//@}
-
-
-/**
- * \name Routines manage sense data
- */
-//@{
-
-/**
- * \brief Reinitialize sense data.
- */
-static void udi_msc_clear_sense(void);
-
-/**
- * \brief Update sense data with new value to signal a fail
- *
- * \param sense_key     Sense key
- * \param add_sense     Additional Sense Code
- * \param lba           LBA corresponding at error
- */
-static void udi_msc_sense_fail(uint8_t sense_key, uint16_t add_sense,
-    uint32_t lba);
-
-/**
- * \brief Update sense data with new value to signal success
- */
-static void udi_msc_sense_pass(void);
-
-/**
- * \brief Update sense data to signal that memory is not present
- */
-static void udi_msc_sense_fail_not_present(void);
-
-/**
- * \brief Update sense data to signal that memory is busy
- */
-static void udi_msc_sense_fail_busy_or_change(void);
-
-/**
- * \brief Update sense data to signal a hardware error on memory
- */
-static void udi_msc_sense_fail_hardware(void);
-
-/**
- * \brief Update sense data to signal that memory is protected
- */
-static void udi_msc_sense_fail_protected(void);
-
-/**
- * \brief Update sense data to signal that CDB fields are not valid
- */
-static void udi_msc_sense_fail_cdb_invalid(void);
-
-/**
- * \brief Update sense data to signal that command is not supported
- */
-static void udi_msc_sense_command_invalid(void);
-//@}
-
-
-/**
- * \name Routines manage SCSI Commands
- */
-//@{
-
-/**
- * \brief Process SPC Request Sense command
- * Returns error information about last command
- */
-static void udi_msc_spc_requestsense(void);
-
-/**
- * \brief Process SPC Inquiry command
- * Returns information (name,version) about disk
- */
-static void udi_msc_spc_inquiry(void);
-
-/**
- * \brief Checks state of disk
- *
- * \retval true if disk is ready, otherwise false and updates sense data
- */
-static bool udi_msc_spc_testunitready_global(void);
-
-/**
- * \brief Process test unit ready command
- * Returns state of logical unit
- */
-static void udi_msc_spc_testunitready(void);
-
-/**
- * \brief Process prevent allow medium removal command
- */
-static void udi_msc_spc_prevent_allow_medium_removal(void);
-
-/**
- * \brief Process mode sense command
- *
- * \param b_sense10     Sense10 SCSI command, if true
- * \param b_sense10     Sense6  SCSI command, if false
- */
-static void udi_msc_spc_mode_sense(bool b_sense10);
-
-/**
- * \brief Process start stop command
- */
-static void udi_msc_sbc_start_stop(void);
-
-/**
- * \brief Process read capacity command
- */
-static void udi_msc_sbc_read_capacity(void);
-
-/**
- * \brief Process read10 or write10 command
- *
- * \param b_read     Read transfer, if true,
- * \param b_read     Write transfer, if false
- */
-static void udi_msc_sbc_trans(bool b_read);
-//@}
-
-//@}
-
-
-bool udi_msc_enable(void)
-{
-  uint8_t lun;
-  udi_msc_b_trans_req = false;
-  udi_msc_b_cbw_invalid = false;
-  udi_msc_b_ack_trans = true;
-  udi_msc_b_reset_trans = true;
-  udi_msc_nb_lun = get_nb_lun();
-  if (0 == udi_msc_nb_lun)
-    return false; // No lun available, then not authorize to enable interface
-  udi_msc_nb_lun--;
-  // Call application callback
-  // to initialize memories or signal that interface is enabled
-  if (!UDI_MSC_ENABLE_EXT())
-    return false;
-  // Load the medium on each LUN
-  for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {
-    mem_unload(lun, false);
-  }
-  // Start MSC process by CBW reception
-  udi_msc_cbw_wait();
-  return true;
-}
-
-
-void udi_msc_disable(void)
-{
-  udi_msc_b_trans_req = false;
-  udi_msc_b_ack_trans = true;
-  udi_msc_b_reset_trans = true;
-  UDI_MSC_DISABLE_EXT();
-}
-
-
-bool udi_msc_setup(void)
-{
-  if (Udd_setup_is_in()) {
-    // Requests Interface GET
-    if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-      // Requests Class Interface Get
-      switch (udd_g_ctrlreq.req.bRequest) {
-      case USB_REQ_MSC_GET_MAX_LUN:
-        // Give the number of memories available
-        if (1 != udd_g_ctrlreq.req.wLength)
-          return false; // Error for USB host
-        if (0 != udd_g_ctrlreq.req.wValue)
-          return false;
-        udd_g_ctrlreq.payload = &udi_msc_nb_lun;
-        udd_g_ctrlreq.payload_size = 1;
-        return true;
-      }
-    }
-  }
-  if (Udd_setup_is_out()) {
-    // Requests Interface SET
-    if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-      // Requests Class Interface Set
-      switch (udd_g_ctrlreq.req.bRequest) {
-      case USB_REQ_MSC_BULK_RESET:
-        // Reset MSC interface
-        if (0 != udd_g_ctrlreq.req.wLength)
-          return false;
-        if (0 != udd_g_ctrlreq.req.wValue)
-          return false;
-        udi_msc_b_cbw_invalid = false;
-        udi_msc_b_trans_req = false;
-        // Abort all tasks (transfer or clear stall wait) on endpoints
-        udd_ep_abort(UDI_MSC_EP_OUT);
-        udd_ep_abort(UDI_MSC_EP_IN);
-        // Restart by CBW wait
-        udi_msc_cbw_wait();
-        return true;
-      }
-    }
-  }
-  return false; // Not supported request
-}
-
-uint8_t udi_msc_getsetting(void)
-{
-  return 0; // MSC don't have multiple alternate setting
-}
-
-
-// ------------------------
-//------- Routines to process CBW packet
-
-static void udi_msc_cbw_invalid(void)
-{
-  if (!udi_msc_b_cbw_invalid)
-    return; // Don't re-stall endpoint if error reset by setup
-  udd_ep_set_halt(UDI_MSC_EP_OUT);
-  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it
-  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);
-}
-
-static void udi_msc_csw_invalid(void)
-{
-  if (!udi_msc_b_cbw_invalid)
-    return; // Don't re-stall endpoint if error reset by setup
-  udd_ep_set_halt(UDI_MSC_EP_IN);
-  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it
-  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);
-}
-
-static void udi_msc_cbw_wait(void)
-{
-  // Register buffer and callback on OUT endpoint
-  if (!udd_ep_run(UDI_MSC_EP_OUT, true,
-          (uint8_t *) & udi_msc_cbw,
-          sizeof(udi_msc_cbw),
-          udi_msc_cbw_received)) {
-    // OUT endpoint not available (halted), then wait a clear of halt.
-    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_wait);
-  }
-}
-
-
-static void udi_msc_cbw_received(udd_ep_status_t status,
-    iram_size_t nb_received, udd_ep_id_t ep)
-{
-  UNUSED(ep);
-  // Check status of transfer
-  if (UDD_EP_TRANSFER_OK != status) {
-    // Transfer aborted
-    // Now wait MSC setup reset to relaunch CBW reception
-    return;
-  }
-  // Check CBW integrity:
-  // transfer status/CBW length/CBW signature
-  if ((sizeof(udi_msc_cbw) != nb_received)
-      || (udi_msc_cbw.dCBWSignature !=
-          CPU_TO_BE32(USB_CBW_SIGNATURE))) {
-    // (5.2.1) Devices receiving a CBW with an invalid signature should stall
-    // further traffic on the Bulk In pipe, and either stall further traffic
-    // or accept and discard further traffic on the Bulk Out pipe, until
-    // reset recovery.
-    udi_msc_b_cbw_invalid = true;
-    udi_msc_cbw_invalid();
-    udi_msc_csw_invalid();
-    return;
-  }
-  // Check LUN asked
-  udi_msc_cbw.bCBWLUN &= USB_CBW_LUN_MASK;
-  if (udi_msc_cbw.bCBWLUN > udi_msc_nb_lun) {
-    // Bad LUN, then stop command process
-    udi_msc_sense_fail_cdb_invalid();
-    udi_msc_csw_process();
-    return;
-  }
-  // Prepare CSW residue field with the size requested
-  udi_msc_csw.dCSWDataResidue =
-      le32_to_cpu(udi_msc_cbw.dCBWDataTransferLength);
-
-  // Decode opcode
-  switch (udi_msc_cbw.CDB[0]) {
-  case SPC_REQUEST_SENSE:
-    udi_msc_spc_requestsense();
-    break;
-
-  case SPC_INQUIRY:
-    udi_msc_spc_inquiry();
-    break;
-
-  case SPC_MODE_SENSE6:
-    udi_msc_spc_mode_sense(false);
-    break;
-  case SPC_MODE_SENSE10:
-    udi_msc_spc_mode_sense(true);
-    break;
-
-  case SPC_TEST_UNIT_READY:
-    udi_msc_spc_testunitready();
-    break;
-
-  case SBC_READ_CAPACITY10:
-    udi_msc_sbc_read_capacity();
-    break;
-
-  case SBC_START_STOP_UNIT:
-    udi_msc_sbc_start_stop();
-    break;
-
-    // Accepts request to support plug/plug in case of card reader
-  case SPC_PREVENT_ALLOW_MEDIUM_REMOVAL:
-    udi_msc_spc_prevent_allow_medium_removal();
-    break;
-
-    // Accepts request to support full format from Windows
-  case SBC_VERIFY10:
-    udi_msc_sense_pass();
-    udi_msc_csw_process();
-    break;
-
-  case SBC_READ10:
-    udi_msc_sbc_trans(true);
-    break;
-
-  case SBC_WRITE10:
-    udi_msc_sbc_trans(false);
-    break;
-
-  default:
-    udi_msc_sense_command_invalid();
-    udi_msc_csw_process();
-    break;
-  }
-}
-
-
-static bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag)
-{
-  /*
-   * The following cases should result in a phase error:
-   *  - Case  2: Hn < Di
-   *  - Case  3: Hn < Do
-   *  - Case  7: Hi < Di
-   *  - Case  8: Hi <> Do
-   *  - Case 10: Ho <> Di
-   *  - Case 13: Ho < Do
-   */
-  if (((udi_msc_cbw.bmCBWFlags ^ dir_flag) & USB_CBW_DIRECTION_IN)
-      || (udi_msc_csw.dCSWDataResidue < alloc_len)) {
-    udi_msc_sense_fail_cdb_invalid();
-    udi_msc_csw_process();
-    return false;
-  }
-
-  /*
-   * The following cases should result in a stall and nonzero
-   * residue:
-   *  - Case  4: Hi > Dn
-   *  - Case  5: Hi > Di
-   *  - Case  9: Ho > Dn
-   *  - Case 11: Ho > Do
-   */
-  return true;
-}
-
-
-// ------------------------
-//------- Routines to process small data packet
-
-static void udi_msc_data_send(uint8_t * buffer, uint8_t buf_size)
-{
-  // Sends data on IN endpoint
-  if (!udd_ep_run(UDI_MSC_EP_IN, true,
-          buffer, buf_size, udi_msc_data_sent)) {
-    // If endpoint not available, then exit process command
-    udi_msc_sense_fail_hardware();
-    udi_msc_csw_process();
-  }
-}
-
-
-static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
-    udd_ep_id_t ep)
-{
-  UNUSED(ep);
-  if (UDD_EP_TRANSFER_OK != status) {
-    // Error protocol
-    // Now wait MSC setup reset to relaunch CBW reception
-    return;
-  }
-  // Update sense data
-  udi_msc_sense_pass();
-  // Update CSW
-  udi_msc_csw.dCSWDataResidue -= nb_sent;
-  udi_msc_csw_process();
-}
-
-
-// ------------------------
-//------- Routines to process CSW packet
-
-static void udi_msc_csw_process(void)
-{
-  if (0 != udi_msc_csw.dCSWDataResidue) {
-    // Residue not NULL
-    // then STALL next request from USB host on corresponding endpoint
-    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)
-      udd_ep_set_halt(UDI_MSC_EP_IN);
-    else
-      udd_ep_set_halt(UDI_MSC_EP_OUT);
-  }
-  // Prepare and send CSW
-  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;
-  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);
-  udi_msc_csw_send();
-}
-
-
-void udi_msc_csw_send(void)
-{
-  // Sends CSW on IN endpoint
-  if (!udd_ep_run(UDI_MSC_EP_IN, false,
-          (uint8_t *) & udi_msc_csw,
-          sizeof(udi_msc_csw),
-          udi_msc_csw_sent)) {
-    // Endpoint not available
-    // then restart CSW sent when endpoint IN STALL will be cleared
-    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_send);
-  }
-}
-
-
-static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
-    udd_ep_id_t ep)
-{
-  UNUSED(ep);
-  UNUSED(status);
-  UNUSED(nb_sent);
-  // CSW is sent or not
-  // In all case, restart process and wait CBW
-  udi_msc_cbw_wait();
-}
-
-
-// ------------------------
-//------- Routines manage sense data
-
-static void udi_msc_clear_sense(void)
-{
-  memset((uint8_t*)&udi_msc_sense, 0, sizeof(struct scsi_request_sense_data));
-  udi_msc_sense.valid_reponse_code = SCSI_SENSE_VALID | SCSI_SENSE_CURRENT;
-  udi_msc_sense.AddSenseLen = SCSI_SENSE_ADDL_LEN(sizeof(udi_msc_sense));
-}
-
-static void udi_msc_sense_fail(uint8_t sense_key, uint16_t add_sense,
-    uint32_t lba)
-{
-  udi_msc_clear_sense();
-  udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAIL;
-  udi_msc_sense.sense_flag_key = sense_key;
-  udi_msc_sense.information[0] = lba >> 24;
-  udi_msc_sense.information[1] = lba >> 16;
-  udi_msc_sense.information[2] = lba >> 8;
-  udi_msc_sense.information[3] = lba;
-  udi_msc_sense.AddSenseCode = add_sense >> 8;
-  udi_msc_sense.AddSnsCodeQlfr = add_sense;
-}
-
-static void udi_msc_sense_pass(void)
-{
-  udi_msc_clear_sense();
-  udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;
-}
-
-
-static void udi_msc_sense_fail_not_present(void)
-{
-  udi_msc_sense_fail(SCSI_SK_NOT_READY, SCSI_ASC_MEDIUM_NOT_PRESENT, 0);
-}
-
-static void udi_msc_sense_fail_busy_or_change(void)
-{
-  udi_msc_sense_fail(SCSI_SK_UNIT_ATTENTION,
-      SCSI_ASC_NOT_READY_TO_READY_CHANGE, 0);
-}
-
-static void udi_msc_sense_fail_hardware(void)
-{
-  udi_msc_sense_fail(SCSI_SK_HARDWARE_ERROR,
-      SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
-}
-
-static void udi_msc_sense_fail_protected(void)
-{
-  udi_msc_sense_fail(SCSI_SK_DATA_PROTECT, SCSI_ASC_WRITE_PROTECTED, 0);
-}
-
-static void udi_msc_sense_fail_cdb_invalid(void)
-{
-  udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
-      SCSI_ASC_INVALID_FIELD_IN_CDB, 0);
-}
-
-static void udi_msc_sense_command_invalid(void)
-{
-  udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
-      SCSI_ASC_INVALID_COMMAND_OPERATION_CODE, 0);
-}
-
-
-// ------------------------
-//------- Routines manage SCSI Commands
-
-static void udi_msc_spc_requestsense(void)
-{
-  uint8_t length = udi_msc_cbw.CDB[4];
-
-  // Can't send more than sense data length
-  if (length > sizeof(udi_msc_sense))
-    length = sizeof(udi_msc_sense);
-
-  if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
-    return;
-  // Send sense data
-  udi_msc_data_send((uint8_t*)&udi_msc_sense, length);
-}
-
-
-static void udi_msc_spc_inquiry(void)
-{
-  uint8_t length, i;
-  UDC_DATA(4)
-  // Constant inquiry data for all LUNs
-  static struct scsi_inquiry_data udi_msc_inquiry_data = {
-    .pq_pdt = SCSI_INQ_PQ_CONNECTED | SCSI_INQ_DT_DIR_ACCESS,
-    .version = SCSI_INQ_VER_SPC,
-    .flags3 = SCSI_INQ_RSP_SPC2,
-    .addl_len = SCSI_INQ_ADDL_LEN(sizeof(struct scsi_inquiry_data)),
-    .vendor_id = {UDI_MSC_GLOBAL_VENDOR_ID},
-    .product_rev = {UDI_MSC_GLOBAL_PRODUCT_VERSION},
-  };
-
-  length = udi_msc_cbw.CDB[4];
-
-  // Can't send more than inquiry data length
-  if (length > sizeof(udi_msc_inquiry_data))
-    length = sizeof(udi_msc_inquiry_data);
-
-  if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
-    return;
-  if ((0 != (udi_msc_cbw.CDB[1] & (SCSI_INQ_REQ_EVPD | SCSI_INQ_REQ_CMDT)))
-      || (0 != udi_msc_cbw.CDB[2])) {
-    // CMDT and EPVD bits are not at 0
-    // PAGE or OPERATION CODE fields are not empty
-    //  = No standard inquiry asked
-    udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
-    udi_msc_csw_process();
-    return;
-  }
-
-  udi_msc_inquiry_data.flags1 = mem_removal(udi_msc_cbw.bCBWLUN) ?
-      SCSI_INQ_RMB : 0;
-
-  //* Fill product ID field
-  // Copy name in product id field
-  memcpy(udi_msc_inquiry_data.product_id,
-      mem_name(udi_msc_cbw.bCBWLUN)+1, // To remove first '"'
-      sizeof(udi_msc_inquiry_data.product_id));
-
-  // Search end of name '/0' or '"'
-  i = 0;
-  while (sizeof(udi_msc_inquiry_data.product_id) != i) {
-    if ((0 == udi_msc_inquiry_data.product_id[i])
-        || ('"' == udi_msc_inquiry_data.product_id[i])) {
-      break;
-    }
-    i++;
-  }
-  // Padding with space char
-  while (sizeof(udi_msc_inquiry_data.product_id) != i) {
-    udi_msc_inquiry_data.product_id[i] = ' ';
-    i++;
-  }
-
-  // Send inquiry data
-  udi_msc_data_send((uint8_t *) & udi_msc_inquiry_data, length);
-}
-
-
-static bool udi_msc_spc_testunitready_global(void)
-{
-  switch (mem_test_unit_ready(udi_msc_cbw.bCBWLUN)) {
-  case CTRL_GOOD:
-    return true;  // Don't change sense data
-  case CTRL_BUSY:
-    udi_msc_sense_fail_busy_or_change();
-    break;
-  case CTRL_NO_PRESENT:
-    udi_msc_sense_fail_not_present();
-    break;
-  case CTRL_FAIL:
-  default:
-    udi_msc_sense_fail_hardware();
-    break;
-  }
-  return false;
-}
-
-
-static void udi_msc_spc_testunitready(void)
-{
-  if (udi_msc_spc_testunitready_global()) {
-    // LUN ready, then update sense data with status pass
-    udi_msc_sense_pass();
-  }
-  // Send status in CSW packet
-  udi_msc_csw_process();
-}
-
-
-static void udi_msc_spc_mode_sense(bool b_sense10)
-{
-  // Union of all mode sense structures
-  union sense_6_10 {
-    struct {
-      struct scsi_mode_param_header6 header;
-      struct spc_control_page_info_execpt sense_data;
-    } s6;
-    struct {
-      struct scsi_mode_param_header10 header;
-      struct spc_control_page_info_execpt sense_data;
-    } s10;
-  };
-
-  uint8_t data_sense_lgt;
-  uint8_t mode;
-  uint8_t request_lgt;
-  uint8_t wp;
-  struct spc_control_page_info_execpt *ptr_mode;
-  UDC_BSS(4)  static union sense_6_10 sense;
-
-  // Clear all fields
-  memset(&sense, 0, sizeof(sense));
-
-  // Initialize process
-  if (b_sense10) {
-    request_lgt = udi_msc_cbw.CDB[8];
-    ptr_mode = &sense.s10.sense_data;
-    data_sense_lgt = sizeof(struct scsi_mode_param_header10);
-  } else {
-    request_lgt = udi_msc_cbw.CDB[4];
-    ptr_mode = &sense.s6.sense_data;
-    data_sense_lgt = sizeof(struct scsi_mode_param_header6);
-  }
-
-  // No Block descriptor
-
-  // Fill page(s)
-  mode = udi_msc_cbw.CDB[2] & SCSI_MS_MODE_ALL;
-  if ((SCSI_MS_MODE_INFEXP == mode)
-      || (SCSI_MS_MODE_ALL == mode)) {
-    // Informational exceptions control page (from SPC)
-    ptr_mode->page_code =
-        SCSI_MS_MODE_INFEXP;
-    ptr_mode->page_length =
-        SPC_MP_INFEXP_PAGE_LENGTH;
-    ptr_mode->mrie =
-        SPC_MP_INFEXP_MRIE_NO_SENSE;
-    data_sense_lgt += sizeof(struct spc_control_page_info_execpt);
-  }
-  // Can't send more than mode sense data length
-  if (request_lgt > data_sense_lgt)
-    request_lgt = data_sense_lgt;
-  if (!udi_msc_cbw_validate(request_lgt, USB_CBW_DIRECTION_IN))
-    return;
-
-  // Fill mode parameter header length
-  wp = (mem_wr_protect(udi_msc_cbw.bCBWLUN)) ? SCSI_MS_SBC_WP : 0;
-
-  if (b_sense10) {
-    sense.s10.header.mode_data_length =
-        cpu_to_be16((data_sense_lgt - 2));
-    //sense.s10.header.medium_type                 = 0;
-    sense.s10.header.device_specific_parameter = wp;
-    //sense.s10.header.block_descriptor_length     = 0;
-  } else {
-    sense.s6.header.mode_data_length = data_sense_lgt - 1;
-    //sense.s6.header.medium_type                  = 0;
-    sense.s6.header.device_specific_parameter = wp;
-    //sense.s6.header.block_descriptor_length      = 0;
-  }
-
-  // Send mode sense data
-  udi_msc_data_send((uint8_t *) & sense, request_lgt);
-}
-
-
-static void udi_msc_spc_prevent_allow_medium_removal(void)
-{
-  uint8_t prevent = udi_msc_cbw.CDB[4];
-  if (0 == prevent) {
-    udi_msc_sense_pass();
-  } else {
-    udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
-  }
-  udi_msc_csw_process();
-}
-
-
-static void udi_msc_sbc_start_stop(void)
-{
-  bool start = 0x1 & udi_msc_cbw.CDB[4];
-  bool loej = 0x2 & udi_msc_cbw.CDB[4];
-  if (loej) {
-    mem_unload(udi_msc_cbw.bCBWLUN, !start);
-  }
-  udi_msc_sense_pass();
-  udi_msc_csw_process();
-}
-
-
-static void udi_msc_sbc_read_capacity(void)
-{
-  UDC_BSS(4) static struct sbc_read_capacity10_data udi_msc_capacity;
-
-  if (!udi_msc_cbw_validate(sizeof(udi_msc_capacity),
-          USB_CBW_DIRECTION_IN))
-    return;
-
-  // Get capacity of LUN
-  switch (mem_read_capacity(udi_msc_cbw.bCBWLUN,
-          &udi_msc_capacity.max_lba)) {
-  case CTRL_GOOD:
-    break;
-  case CTRL_BUSY:
-    udi_msc_sense_fail_busy_or_change();
-    udi_msc_csw_process();
-    return;
-  case CTRL_NO_PRESENT:
-    udi_msc_sense_fail_not_present();
-    udi_msc_csw_process();
-    return;
-  default:
-    udi_msc_sense_fail_hardware();
-    udi_msc_csw_process();
-    return;
-  }
-
-  // Format capacity data
-  udi_msc_capacity.block_len = CPU_TO_BE32(UDI_MSC_BLOCK_SIZE);
-  udi_msc_capacity.max_lba = cpu_to_be32(udi_msc_capacity.max_lba);
-  // Send the corresponding sense data
-  udi_msc_data_send((uint8_t *) & udi_msc_capacity,
-      sizeof(udi_msc_capacity));
-}
-
-
-static void udi_msc_sbc_trans(bool b_read)
-{
-  uint32_t trans_size;
-
-  if (!b_read) {
-    // Write operation then check Write Protect
-    if (mem_wr_protect(udi_msc_cbw.bCBWLUN)) {
-      // Write not authorized
-      udi_msc_sense_fail_protected();
-      udi_msc_csw_process();
-      return;
-    }
-  }
-  // Read/Write command fields (address and number of block)
-  MSB0(udi_msc_addr) = udi_msc_cbw.CDB[2];
-  MSB1(udi_msc_addr) = udi_msc_cbw.CDB[3];
-  MSB2(udi_msc_addr) = udi_msc_cbw.CDB[4];
-  MSB3(udi_msc_addr) = udi_msc_cbw.CDB[5];
-  MSB(udi_msc_nb_block) = udi_msc_cbw.CDB[7];
-  LSB(udi_msc_nb_block) = udi_msc_cbw.CDB[8];
-
-  // Compute number of byte to transfer and valid it
-  trans_size = (uint32_t) udi_msc_nb_block *UDI_MSC_BLOCK_SIZE;
-  if (!udi_msc_cbw_validate(trans_size,
-          (b_read) ? USB_CBW_DIRECTION_IN :
-          USB_CBW_DIRECTION_OUT))
-    return;
-
-  // Record transfer request to do it in a task and not under interrupt
-  udi_msc_b_read = b_read;
-  udi_msc_b_trans_req = true;
-  UDI_MSC_NOTIFY_TRANS_EXT();
-}
-
-
-bool udi_msc_process_trans(void)
-{
-  Ctrl_status status;
-
-  if (!udi_msc_b_trans_req)
-    return false; // No Transfer request to do
-  udi_msc_b_trans_req = false;
-  udi_msc_b_reset_trans = false;
-
-  // Start transfer
-  if (udi_msc_b_read) {
-    status = memory_2_usb(udi_msc_cbw.bCBWLUN, udi_msc_addr,
-        udi_msc_nb_block);
-  } else {
-    status = usb_2_memory(udi_msc_cbw.bCBWLUN, udi_msc_addr,
-        udi_msc_nb_block);
-  }
-
-  // Check if transfer is aborted by reset
-  if (udi_msc_b_reset_trans) {
-    udi_msc_b_reset_trans = false;
-    return true;
-  }
-
-  // Check status of transfer
-  switch (status) {
-  case CTRL_GOOD:
-    udi_msc_sense_pass();
-    break;
-  case CTRL_BUSY:
-    udi_msc_sense_fail_busy_or_change();
-    break;
-  case CTRL_NO_PRESENT:
-    udi_msc_sense_fail_not_present();
-    break;
-  default:
-  case CTRL_FAIL:
-    udi_msc_sense_fail_hardware();
-    break;
-  }
-  // Send status of transfer in CSW packet
-  udi_msc_csw_process();
-  return true;
-}
-
-
-static void udi_msc_trans_ack(udd_ep_status_t status, iram_size_t n,
-    udd_ep_id_t ep)
-{
-  UNUSED(ep);
-  UNUSED(n);
-  // Update variable to signal the end of transfer
-  udi_msc_b_abort_trans = (UDD_EP_TRANSFER_OK != status) ? true : false;
-  udi_msc_b_ack_trans = true;
-}
-
-
-bool udi_msc_trans_block(bool b_read, uint8_t * block, iram_size_t block_size,
-    void (*callback) (udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep))
-{
-  if (!udi_msc_b_ack_trans)
-    return false; // No possible, transfer on going
-
-  // Start transfer Internal RAM<->USB line
-  udi_msc_b_ack_trans = false;
-  if (!udd_ep_run((b_read) ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT,
-          false,
-          block,
-          block_size,
-          (NULL == callback) ? udi_msc_trans_ack :
-          callback)) {
-    udi_msc_b_ack_trans = true;
-    return false;
-  }
-  if (NULL == callback) {
-    while (!udi_msc_b_ack_trans);
-    if (udi_msc_b_abort_trans) {
-      return false;
-    }
-    udi_msc_csw.dCSWDataResidue -= block_size;
-    return (!udi_msc_b_abort_trans);
-  }
-  udi_msc_csw.dCSWDataResidue -= block_size;
-  return true;
-}
-
-//@}
-
-#endif // SDSUPPORT
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/udi_msc.h b/Marlin/src/HAL/DUE/usb/udi_msc.h
deleted file mode 100644
index 730dbc8..0000000
--- a/Marlin/src/HAL/DUE/usb/udi_msc.h
+++ /dev/null
@@ -1,376 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Mass Storage Class (MSC) interface definitions.
- *
- * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _UDI_MSC_H_
-#define _UDI_MSC_H_
-
-#include "conf_usb.h"
-#include "usb_protocol.h"
-#include "usb_protocol_msc.h"
-#include "udd.h"
-#include "udc_desc.h"
-#include "udi.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * \addtogroup udi_msc_group_udc
- * @{
- */
-//! Global structure which contains standard UDI interface for UDC
-extern UDC_DESC_STORAGE udi_api_t udi_api_msc;
-//@}
-
-/**
- * \ingroup udi_msc_group
- * \defgroup udi_msc_group USB interface descriptors
- *
- * The following structures provide predefined USB interface descriptors.
- * It must be used to define the final USB descriptors.
- */
-//@{
-
-//! Interface descriptor structure for MSC
-typedef struct {
-	usb_iface_desc_t iface;
-	usb_ep_desc_t ep_in;
-	usb_ep_desc_t ep_out;
-} udi_msc_desc_t;
-
-//! By default no string associated to this interface
-#ifndef UDI_MSC_STRING_ID
-#define UDI_MSC_STRING_ID     0
-#endif
-
-//! MSC endpoints size for full speed
-#define UDI_MSC_EPS_SIZE_FS   64
-//! MSC endpoints size for high speed
-#define UDI_MSC_EPS_SIZE_HS   512
-
-//! Content of MSC interface descriptor for all speeds
-#define UDI_MSC_DESC      \
-   .iface.bLength             = sizeof(usb_iface_desc_t),\
-   .iface.bDescriptorType     = USB_DT_INTERFACE,\
-   .iface.bInterfaceNumber    = UDI_MSC_IFACE_NUMBER,\
-   .iface.bAlternateSetting   = 0,\
-   .iface.bNumEndpoints       = 2,\
-   .iface.bInterfaceClass     = MSC_CLASS,\
-   .iface.bInterfaceSubClass  = MSC_SUBCLASS_TRANSPARENT,\
-   .iface.bInterfaceProtocol  = MSC_PROTOCOL_BULK,\
-   .iface.iInterface          = UDI_MSC_STRING_ID,\
-   .ep_in.bLength             = sizeof(usb_ep_desc_t),\
-   .ep_in.bDescriptorType     = USB_DT_ENDPOINT,\
-   .ep_in.bEndpointAddress    = UDI_MSC_EP_IN,\
-   .ep_in.bmAttributes        = USB_EP_TYPE_BULK,\
-   .ep_in.bInterval           = 0,\
-   .ep_out.bLength            = sizeof(usb_ep_desc_t),\
-   .ep_out.bDescriptorType    = USB_DT_ENDPOINT,\
-   .ep_out.bEndpointAddress   = UDI_MSC_EP_OUT,\
-   .ep_out.bmAttributes       = USB_EP_TYPE_BULK,\
-   .ep_out.bInterval          = 0,
-
-//! Content of MSC interface descriptor for full speed only
-#define UDI_MSC_DESC_FS   {\
-   UDI_MSC_DESC \
-   .ep_in.wMaxPacketSize      = LE16(UDI_MSC_EPS_SIZE_FS),\
-   .ep_out.wMaxPacketSize     = LE16(UDI_MSC_EPS_SIZE_FS),\
-   }
-
-//! Content of MSC interface descriptor for high speed only
-#define UDI_MSC_DESC_HS   {\
-   UDI_MSC_DESC \
-   .ep_in.wMaxPacketSize      = LE16(UDI_MSC_EPS_SIZE_HS),\
-   .ep_out.wMaxPacketSize     = LE16(UDI_MSC_EPS_SIZE_HS),\
-   }
-//@}
-
-
-/**
- * \ingroup udi_group
- * \defgroup udi_msc_group USB Device Interface (UDI) for Mass Storage Class (MSC)
- *
- * Common APIs used by high level application to use this USB class.
- *
- * These routines are used by memory to transfer its data
- * to/from USB MSC endpoints.
- *
- * See \ref udi_msc_quickstart.
- * @{
- */
-
-/**
- * \brief Process the background read/write commands
- *
- * Routine called by the main loop
- */
-bool udi_msc_process_trans(void);
-
-/**
- * \brief Transfers data to/from USB MSC endpoints
- *
- *
- * \param b_read        Memory to USB, if true
- * \param block         Buffer on Internal RAM to send or fill
- * \param block_size    Buffer size to send or fill
- * \param callback      Function to call at the end of transfer.
- *                      If NULL then the routine exit when transfer is finish.
- *
- * \return \c 1 if function was successfully done, otherwise \c 0.
- */
-bool udi_msc_trans_block(bool b_read, uint8_t * block, iram_size_t block_size,
-		void (*callback) (udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep));
-//@}
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/**
- * \page udi_msc_quickstart Quick start guide for USB device Mass Storage module (UDI MSC)
- *
- * This is the quick start guide for the \ref udi_msc_group
- * "USB device interface MSC module (UDI MSC)" with step-by-step instructions on
- * how to configure and use the modules in a selection of use cases.
- *
- * The use cases contain several code fragments. The code fragments in the
- * steps for setup can be copied into a custom initialization function, while
- * the steps for usage can be copied into, e.g., the main application function.
- *
- * \section udi_msc_basic_use_case Basic use case
- * In this basic use case, the "USB MSC (Single Interface Device)" module is used.
- * The "USB MSC (Composite Device)" module usage is described in \ref udi_msc_use_cases
- * "Advanced use cases".
- *
- * \section udi_msc_basic_use_case_setup Setup steps
- * \subsection udi_msc_basic_use_case_setup_prereq Prerequisites
- * \copydetails udc_basic_use_case_setup_prereq
- * \subsection udi_msc_basic_use_case_setup_code Example code
- * \copydetails udc_basic_use_case_setup_code
- * \subsection udi_msc_basic_use_case_setup_flow Workflow
- * \copydetails udc_basic_use_case_setup_flow
- *
- * \section udi_msc_basic_use_case_usage Usage steps
- *
- * \subsection udi_msc_basic_use_case_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	#define  USB_DEVICE_SERIAL_NAME  "12...EF" // Disk SN for MSC
-	#define UDI_MSC_GLOBAL_VENDOR_ID \
-	   'A', 'T', 'M', 'E', 'L', ' ', ' ', ' '
-	#define UDI_MSC_GLOBAL_PRODUCT_VERSION \
-	   '1', '.', '0', '0'
-	#define UDI_MSC_ENABLE_EXT() my_callback_msc_enable()
-	extern bool my_callback_msc_enable(void);
-	#define UDI_MSC_DISABLE_EXT() my_callback_msc_disable()
-	extern void my_callback_msc_disable(void);
-	#include "udi_msc_conf.h" // At the end of conf_usb.h file
-\endcode
- *
- * Add to application C-file:
- * \code
-	 static bool my_flag_autorize_msc_transfert = false;
-	 bool my_callback_msc_enable(void)
-	 {
-	    my_flag_autorize_msc_transfert = true;
-	    return true;
-	 }
-	 void my_callback_msc_disable(void)
-	 {
-	    my_flag_autorize_msc_transfert = false;
-	 }
-
-	 void task(void)
-	 {
-	    udi_msc_process_trans();
-	 }
-\endcode
- *
- * \subsection udi_msc_basic_use_case_setup_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following configuration,
- * which is the USB device MSC configuration:
- *   - \code #define USB_DEVICE_SERIAL_NAME  "12...EF" // Disk SN for MSC \endcode
- *     \note The USB serial number is mandatory when a MSC interface is used.
- *   - \code //! Vendor name and Product version of MSC interface
-	#define UDI_MSC_GLOBAL_VENDOR_ID \
-	   'A', 'T', 'M', 'E', 'L', ' ', ' ', ' '
-	#define UDI_MSC_GLOBAL_PRODUCT_VERSION \
-	   '1', '.', '0', '0' \endcode
- *     \note The USB MSC interface requires a vendor ID (8 ASCII characters)
- *     and a product version (4 ASCII characters).
- *   - \code #define UDI_MSC_ENABLE_EXT() my_callback_msc_enable()
-	extern bool my_callback_msc_enable(void); \endcode
- *     \note After the device enumeration (detecting and identifying USB devices),
- *     the USB host starts the device configuration. When the USB MSC interface
- *     from the device is accepted by the host, the USB host enables this interface and the
- *     UDI_MSC_ENABLE_EXT() callback function is called and return true.
- *     Thus, when this event is received, the tasks which call
- *     udi_msc_process_trans() must be enabled.
- *   - \code #define UDI_MSC_DISABLE_EXT() my_callback_msc_disable()
-	extern void my_callback_msc_disable(void); \endcode
- *     \note When the USB device is unplugged or is reset by the USB host, the USB
- *     interface is disabled and the UDI_MSC_DISABLE_EXT() callback function
- *     is called. Thus, it is recommended to disable the task which is called udi_msc_process_trans().
- * -# The MSC is automatically linked with memory control access component
- * which provides the memories interfaces. However, the memory data transfers
- * must be done outside USB interrupt routine. This is done in the MSC process
- * ("udi_msc_process_trans()") called by main loop:
- *   - \code  * void task(void) {
-	udi_msc_process_trans();
-	} \endcode
- * -# The MSC speed depends on task periodicity. To get the best speed
- * the notification callback "UDI_MSC_NOTIFY_TRANS_EXT" can be used to wakeup
- * this task (Example, through a mutex):
- *   - \code #define  UDI_MSC_NOTIFY_TRANS_EXT()    msc_notify_trans()
-	void msc_notify_trans(void) {
-	wakeup_my_task();
-	} \endcode
- *
- * \section udi_msc_use_cases Advanced use cases
- * For more advanced use of the UDI MSC module, see the following use cases:
- * - \subpage udi_msc_use_case_composite
- * - \subpage udc_use_case_1
- * - \subpage udc_use_case_2
- * - \subpage udc_use_case_3
- * - \subpage udc_use_case_5
- * - \subpage udc_use_case_6
- */
-
-/**
- * \page udi_msc_use_case_composite MSC in a composite device
- *
- * A USB Composite Device is a USB Device which uses more than one USB class.
- * In this use case, the "USB MSC (Composite Device)" module is used to
- * create a USB composite device. Thus, this USB module can be associated with
- * another "Composite Device" module, like "USB HID Mouse (Composite Device)".
- *
- * Also, you can refer to application note
- * <A href="https://www.atmel.com/dyn/resources/prod_documents/doc8445.pdf">
- * AVR4902 ASF - USB Composite Device</A>.
- *
- * \section udi_msc_use_case_composite_setup Setup steps
- * For the setup code of this use case to work, the
- * \ref udi_msc_basic_use_case "basic use case" must be followed.
- *
- * \section udi_msc_use_case_composite_usage Usage steps
- *
- * \subsection udi_msc_use_case_composite_usage_code Example code
- * Content of conf_usb.h:
- * \code
-	 #define USB_DEVICE_EP_CTRL_SIZE  64
-	 #define USB_DEVICE_NB_INTERFACE (X+1)
-	 #define USB_DEVICE_MAX_EP (X+2)
-
-	 #define UDI_MSC_EP_IN  (X | USB_EP_DIR_IN)
-	 #define UDI_MSC_EP_OUT (Y | USB_EP_DIR_OUT)
-	 #define UDI_MSC_IFACE_NUMBER  X
-
-	 #define UDI_COMPOSITE_DESC_T \
-	    udi_msc_desc_t udi_msc; \
-	    ...
-	 #define UDI_COMPOSITE_DESC_FS \
-	    .udi_msc = UDI_MSC_DESC, \
-	    ...
-	 #define UDI_COMPOSITE_DESC_HS \
-	    .udi_msc = UDI_MSC_DESC, \
-	    ...
-	 #define UDI_COMPOSITE_API \
-	    &udi_api_msc, \
-	    ...
-\endcode
- *
- * \subsection udi_msc_use_case_composite_usage_flow Workflow
- * -# Ensure that conf_usb.h is available and contains the following parameters
- * required for a USB composite device configuration:
- *   - \code // Endpoint control size, This must be:
-	// - 8, 16, 32 or 64 for full speed device (8 is recommended to save RAM)
-	// - 64 for a high speed device
-	#define USB_DEVICE_EP_CTRL_SIZE  64
-	// Total Number of interfaces on this USB device.
-	// Add 1 for MSC.
-	#define USB_DEVICE_NB_INTERFACE (X+1)
-	// Total number of endpoints on this USB device.
-	// This must include each endpoint for each interface.
-	// Add 2 for MSC.
-	#define USB_DEVICE_MAX_EP (X+2) \endcode
- * -# Ensure that conf_usb.h contains the description of
- * composite device:
- *   - \code // The endpoint numbers chosen by you for the MSC.
-	// The endpoint numbers starting from 1.
-	#define UDI_MSC_EP_IN  (X | USB_EP_DIR_IN)
-	#define UDI_MSC_EP_OUT (Y | USB_EP_DIR_OUT)
-	// The interface index of an interface starting from 0
-	#define UDI_MSC_IFACE_NUMBER  X \endcode
- * -# Ensure that conf_usb.h contains the following parameters
- * required for a USB composite device configuration:
- *   - \code // USB Interfaces descriptor structure
-	#define UDI_COMPOSITE_DESC_T \
-	   ...
-	   udi_msc_desc_t udi_msc; \
-	   ...
-	// USB Interfaces descriptor value for Full Speed
-	#define UDI_COMPOSITE_DESC_FS \
-	   ...
-	   .udi_msc = UDI_MSC_DESC_FS, \
-	   ...
-	// USB Interfaces descriptor value for High Speed
-	#define UDI_COMPOSITE_DESC_HS \
-	   ...
-	   .udi_msc = UDI_MSC_DESC_HS, \
-	   ...
-	// USB Interface APIs
-	#define UDI_COMPOSITE_API \
-	   ...
-	   &udi_api_msc, \
-	   ... \endcode
- *   - \note The descriptors order given in the four lists above must be the
- *     same as the order defined by all interface indexes. The interface index
- *     orders are defined through UDI_X_IFACE_NUMBER defines.
- */
-
-#endif // _UDI_MSC_H_
diff --git a/Marlin/src/HAL/DUE/usb/uotghs_device_due.c b/Marlin/src/HAL/DUE/usb/uotghs_device_due.c
deleted file mode 100644
index c7e8f8d..0000000
--- a/Marlin/src/HAL/DUE/usb/uotghs_device_due.c
+++ /dev/null
@@ -1,2074 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Driver for UOTGHS. Compliant with common UDD driver.
- *
- * Copyright (c) 2012-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include "compiler.h"
-#include "uotghs_device_due.h"
-
-#include "conf_usb.h"
-#include "sysclk.h"
-#include "udd.h"
-#include "uotghs_otg.h"
-#include <string.h>
-
-#ifndef UDD_NO_SLEEP_MGR
-# include "sleep.h"
-# include "sleepmgr.h"
-#endif
-
-#if !(SAM3XA)
-# error The current UOTGHS Device Driver supports only SAM3X and SAM3A.
-#endif
-#ifndef UDD_USB_INT_FUN
-# define UDD_USB_INT_FUN UOTGHS_Handler
-#endif
-
-#ifndef UDD_USB_INT_LEVEL
-# define UDD_USB_INT_LEVEL 5 // By default USB interrupt have low priority
-#endif
-
-#define UDD_EP_USED(ep)      (USB_DEVICE_MAX_EP >= ep)
-
-#if (     (UDD_EP_USED( 1) && Is_udd_endpoint_dma_supported( 1)) \
-	||(UDD_EP_USED( 2) && Is_udd_endpoint_dma_supported( 2)) \
-	||(UDD_EP_USED( 3) && Is_udd_endpoint_dma_supported( 3)) \
-	||(UDD_EP_USED( 4) && Is_udd_endpoint_dma_supported( 4)) \
-	||(UDD_EP_USED( 5) && Is_udd_endpoint_dma_supported( 5)) \
-	||(UDD_EP_USED( 6) && Is_udd_endpoint_dma_supported( 6)) \
-	||(UDD_EP_USED( 7) && Is_udd_endpoint_dma_supported( 7)) \
-	||(UDD_EP_USED( 8) && Is_udd_endpoint_dma_supported( 8)) \
-	||(UDD_EP_USED( 9) && Is_udd_endpoint_dma_supported( 9)) \
-	||(UDD_EP_USED(10) && Is_udd_endpoint_dma_supported(10)) \
-	||(UDD_EP_USED(11) && Is_udd_endpoint_dma_supported(11)) \
-	||(UDD_EP_USED(12) && Is_udd_endpoint_dma_supported(12)) \
-	||(UDD_EP_USED(13) && Is_udd_endpoint_dma_supported(13)) \
-	||(UDD_EP_USED(14) && Is_udd_endpoint_dma_supported(14)) \
-	||(UDD_EP_USED(15) && Is_udd_endpoint_dma_supported(15)) \
-	)
-# define UDD_EP_DMA_SUPPORTED
-#endif
-
-#if (     (UDD_EP_USED( 1) && !Is_udd_endpoint_dma_supported( 1)) \
-	||(UDD_EP_USED( 2) && !Is_udd_endpoint_dma_supported( 2)) \
-	||(UDD_EP_USED( 3) && !Is_udd_endpoint_dma_supported( 3)) \
-	||(UDD_EP_USED( 4) && !Is_udd_endpoint_dma_supported( 4)) \
-	||(UDD_EP_USED( 5) && !Is_udd_endpoint_dma_supported( 5)) \
-	||(UDD_EP_USED( 6) && !Is_udd_endpoint_dma_supported( 6)) \
-	||(UDD_EP_USED( 7) && !Is_udd_endpoint_dma_supported( 7)) \
-	||(UDD_EP_USED( 8) && !Is_udd_endpoint_dma_supported( 8)) \
-	||(UDD_EP_USED( 9) && !Is_udd_endpoint_dma_supported( 9)) \
-	||(UDD_EP_USED(10) && !Is_udd_endpoint_dma_supported(10)) \
-	||(UDD_EP_USED(11) && !Is_udd_endpoint_dma_supported(11)) \
-	||(UDD_EP_USED(12) && !Is_udd_endpoint_dma_supported(12)) \
-	||(UDD_EP_USED(13) && !Is_udd_endpoint_dma_supported(13)) \
-	||(UDD_EP_USED(14) && !Is_udd_endpoint_dma_supported(14)) \
-	||(UDD_EP_USED(15) && !Is_udd_endpoint_dma_supported(15)) \
-	)
-# define UDD_EP_FIFO_SUPPORTED
-#endif
-
-// for debug text
-//#define dbg_print printf
-#define dbg_print(...)
-
-/**
- * \ingroup udd_group
- * \defgroup udd_udphs_group USB On-The-Go High-Speed Port for device mode (UOTGHS)
- *
- * \section UOTGHS_CONF UOTGHS Custom configuration
- * The following UOTGHS driver configuration must be included in the conf_usb.h
- * file of the application.
- *
- * UDD_USB_INT_LEVEL<br>
- * Option to change the interrupt priority (0 to 15) by default 5 (recommended).
- *
- * UDD_USB_INT_FUN<br>
- * Option to fit interrupt function to what defined in exception table.
- *
- * UDD_ISOCHRONOUS_NB_BANK(ep)<br>
- * Feature to reduce or increase isochronous endpoints buffering (1 to 3).
- * Default value 2.
- *
- * UDD_BULK_NB_BANK(ep)<br>
- * Feature to reduce or increase bulk endpoints buffering (1 to 2).
- * Default value 2.
- *
- * UDD_INTERRUPT_NB_BANK(ep)<br>
- * Feature to reduce or increase interrupt endpoints buffering (1 to 2).
- * Default value 1.
- *
- * \section Callbacks management
- * The USB driver is fully managed by interrupt and does not request periodique
- * task. Thereby, the USB events use callbacks to transfer the information.
- * The callbacks are declared in static during compilation or in variable during
- * code execution.
- *
- * Static declarations defined in conf_usb.h:
- * - UDC_VBUS_EVENT(bool b_present)<br>
- *   To signal Vbus level change
- * - UDC_SUSPEND_EVENT()<br>
- *   Called when USB bus enter in suspend mode
- * - UDC_RESUME_EVENT()<br>
- *   Called when USB bus is wakeup
- * - UDC_SOF_EVENT()<br>
- *   Called for each received SOF, Note: Each 1ms in HS/FS mode only.
- *
- * Dynamic callbacks, called "endpoint job" , are registered
- * in udd_ep_job_t structure via the following functions:
- * - udd_ep_run()<br>
- *   To call it when a transfer is finish
- * - udd_ep_wait_stall_clear()<br>
- *   To call it when a endpoint halt is disabled
- *
- * \section Power mode management
- * The Sleep modes authorized :
- * - in USB IDLE state, the UOTGHS needs of USB clock and authorizes up to sleep mode WFI.
- * - in USB SUSPEND state, the UOTGHS no needs USB clock and authorizes up to sleep mode WAIT.
- * @{
- */
-
-// Check USB Device configuration
-#ifndef USB_DEVICE_EP_CTRL_SIZE
-# error USB_DEVICE_EP_CTRL_SIZE not defined
-#endif
-#ifndef USB_DEVICE_MAX_EP
-# error USB_DEVICE_MAX_EP not defined
-#endif
-
-// Note: USB_DEVICE_MAX_EP does not include control endpoint
-#if USB_DEVICE_MAX_EP > (UDD_MAX_PEP_NB-1)
-#  error USB_DEVICE_MAX_EP is too high and not supported by this part
-#endif
-
-#define UDD_EP_ISO_NBANK_ERROR(ep)            \
-	( (UDD_ISOCHRONOUS_NB_BANK(ep) < 1)   \
-		|| (UDD_ISOCHRONOUS_NB_BANK(ep) > 3) )
-#define UDD_EP_BULK_NBANK_ERROR(ep)           \
-	( (UDD_BULK_NB_BANK(ep) < 1) || (UDD_BULK_NB_BANK(ep) > 2) )
-#define UDD_EP_INT_NBANK_ERROR(ep)            \
-	( (UDD_INTERRUPT_NB_BANK(ep) < 1) || (UDD_INTERRUPT_NB_BANK(ep) > 2) )
-
-#define UDD_EP_ISO_NB_BANK_ERROR(ep)          \
-	(UDD_EP_USED(ep) && UDD_EP_ISO_NBANK_ERROR(ep))
-#define UDD_EP_BULK_NB_BANK_ERROR(ep)         \
-	(UDD_EP_USED(ep) && UDD_EP_ISO_NBANK_ERROR(ep))
-#define UDD_EP_INT_NB_BANK_ERROR(ep)          \
-	(UDD_EP_USED(ep) && UDD_EP_ISO_NBANK_ERROR(ep))
-
-#define UDD_EP_NB_BANK_ERROR(ep, type)        \
-	(ATPASTE3(UDD_EP_, type, _NB_BANK_ERROR(ep)))
-
-#define UDD_ISO_NB_BANK_ERROR \
-	(          UDD_EP_NB_BANK_ERROR( 1, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 2, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 3, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 4, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 5, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 6, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 7, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 8, ISO) \
-		|| UDD_EP_NB_BANK_ERROR( 9, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(10, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(11, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(12, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(13, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(14, ISO) \
-		|| UDD_EP_NB_BANK_ERROR(15, ISO) )
-#define UDD_BULK_NB_BANK_ERROR \
-	(          UDD_EP_NB_BANK_ERROR( 1, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 2, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 3, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 4, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 5, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 6, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 7, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 8, BULK) \
-		|| UDD_EP_NB_BANK_ERROR( 9, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(10, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(11, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(12, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(13, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(14, BULK) \
-		|| UDD_EP_NB_BANK_ERROR(15, BULK) )
-#define UDD_INTERRUPT_NB_BANK_ERROR \
-	(          UDD_EP_NB_BANK_ERROR( 1, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 2, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 3, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 4, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 5, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 6, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 7, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 8, INT) \
-		|| UDD_EP_NB_BANK_ERROR( 9, INT) \
-		|| UDD_EP_NB_BANK_ERROR(10, INT) \
-		|| UDD_EP_NB_BANK_ERROR(11, INT) \
-		|| UDD_EP_NB_BANK_ERROR(12, INT) \
-		|| UDD_EP_NB_BANK_ERROR(13, INT) \
-		|| UDD_EP_NB_BANK_ERROR(14, INT) \
-		|| UDD_EP_NB_BANK_ERROR(15, INT) )
-
-#ifndef UDD_ISOCHRONOUS_NB_BANK
-# define UDD_ISOCHRONOUS_NB_BANK(ep) 2
-#else
-# if UDD_ISO_NB_BANK_ERROR
-#  error UDD_ISOCHRONOUS_NB_BANK(ep) must be define within 1 to 3.
-# endif
-#endif
-
-#ifndef UDD_BULK_NB_BANK
-# define UDD_BULK_NB_BANK(ep) 2
-#else
-# if UDD_BULK_NB_BANK_ERROR
-#  error UDD_BULK_NB_BANK must be define with 1 or 2.
-# endif
-#endif
-
-#ifndef UDD_INTERRUPT_NB_BANK
-# define UDD_INTERRUPT_NB_BANK(ep) 1
-#else
-# if UDD_INTERRUPT_NB_BANK_ERROR
-#  error UDD_INTERRUPT_NB_BANK must be define with 1 or 2.
-# endif
-#endif
-
-
-/**
- * \name Power management routine.
- */
-//@{
-
-#ifndef UDD_NO_SLEEP_MGR
-
-//! Definition of sleep levels
-#define UOTGHS_SLEEP_MODE_USB_SUSPEND  SLEEPMGR_WAIT_FAST
-#define UOTGHS_SLEEP_MODE_USB_IDLE     SLEEPMGR_SLEEP_WFI
-
-//! State of USB line
-static bool udd_b_idle;
-//! State of sleep manager
-static bool udd_b_sleep_initialized = false;
-
-
-/*! \brief Authorize or not the CPU powerdown mode
- *
- * \param b_enable true to authorize idle mode
- */
-static void udd_sleep_mode(bool b_idle)
-{
-	if (!b_idle && udd_b_idle) {
-		dbg_print("_S ");
-		sleepmgr_unlock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
-	}
-	if (b_idle && !udd_b_idle) {
-		dbg_print("_W ");
-		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
-	}
-	udd_b_idle = b_idle;
-}
-#else
-
-static void udd_sleep_mode(bool b_idle)
-{
-	b_idle = b_idle;
-}
-
-#endif // UDD_NO_SLEEP_MGR
-
-//@}
-
-
-/**
- * \name Control endpoint low level management routine.
- *
- * This function performs control endpoint management.
- * It handle the SETUP/DATA/HANDSHAKE phases of a control transaction.
- */
-//@{
-
-//! Global variable to give and record information about setup request management
-COMPILER_WORD_ALIGNED udd_ctrl_request_t udd_g_ctrlreq;
-
-//! Bit definitions about endpoint control state machine for udd_ep_control_state
-typedef enum {
-	UDD_EPCTRL_SETUP                  = 0, //!< Wait a SETUP packet
-	UDD_EPCTRL_DATA_OUT               = 1, //!< Wait a OUT data packet
-	UDD_EPCTRL_DATA_IN                = 2, //!< Wait a IN data packet
-	UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP  = 3, //!< Wait a IN ZLP packet
-	UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP = 4, //!< Wait a OUT ZLP packet
-	UDD_EPCTRL_STALL_REQ              = 5, //!< STALL enabled on IN & OUT packet
-} udd_ctrl_ep_state_t;
-
-//! State of the endpoint control management
-static udd_ctrl_ep_state_t udd_ep_control_state;
-
-//! Total number of data received/sent during data packet phase with previous payload buffers
-static uint16_t udd_ctrl_prev_payload_buf_cnt;
-
-//! Number of data received/sent to/from udd_g_ctrlreq.payload buffer
-static uint16_t udd_ctrl_payload_buf_cnt;
-
-/**
- * \brief Reset control endpoint
- *
- * Called after a USB line reset or when UDD is enabled
- */
-static void udd_reset_ep_ctrl(void);
-
-/**
- * \brief Reset control endpoint management
- *
- * Called after a USB line reset or at the end of SETUP request (after ZLP)
- */
-static void udd_ctrl_init(void);
-
-//! \brief Managed reception of SETUP packet on control endpoint
-static void udd_ctrl_setup_received(void);
-
-//! \brief Managed reception of IN packet on control endpoint
-static void udd_ctrl_in_sent(void);
-
-//! \brief Managed reception of OUT packet on control endpoint
-static void udd_ctrl_out_received(void);
-
-//! \brief Managed underflow event of IN packet on control endpoint
-static void udd_ctrl_underflow(void);
-
-//! \brief Managed overflow event of OUT packet on control endpoint
-static void udd_ctrl_overflow(void);
-
-//! \brief Managed stall event of IN/OUT packet on control endpoint
-static void udd_ctrl_stall_data(void);
-
-//! \brief Send a ZLP IN on control endpoint
-static void udd_ctrl_send_zlp_in(void);
-
-//! \brief Send a ZLP OUT on control endpoint
-static void udd_ctrl_send_zlp_out(void);
-
-//! \brief Call callback associated to setup request
-static void udd_ctrl_endofrequest(void);
-
-
-/**
- * \brief Main interrupt routine for control endpoint
- *
- * This switches control endpoint events to correct sub function.
- *
- * \return \c 1 if an event about control endpoint is occurred, otherwise \c 0.
- */
-static bool udd_ctrl_interrupt(void);
-
-//@}
-
-
-/**
- * \name Management of bulk/interrupt/isochronous endpoints
- *
- * The UDD manages the data transfer on endpoints:
- * - Start data transfer on endpoint with USB Device DMA
- * - Send a ZLP packet if requested
- * - Call callback registered to signal end of transfer
- * The transfer abort and stall feature are supported.
- */
-//@{
-#if (0!=USB_DEVICE_MAX_EP)
-
-//! Structure definition about job registered on an endpoint
-typedef struct {
-	union {
-		//! Callback to call at the end of transfer
-		udd_callback_trans_t call_trans;
-
-		//! Callback to call when the endpoint halt is cleared
-		udd_callback_halt_cleared_t call_nohalt;
-	};
-	//! Buffer located in internal RAM to send or fill during job
-	uint8_t *buf;
-	//! Size of buffer to send or fill
-	iram_size_t buf_size;
-	//!< Size of data transferred
-	iram_size_t buf_cnt;
-	//!< Size of data loaded (or prepared for DMA) last time
-	iram_size_t buf_load;
-	//! A job is registered on this endpoint
-	uint8_t busy:1;
-	//! A short packet is requested for this job on endpoint IN
-	uint8_t b_shortpacket:1;
-	//! A stall has been requested but not executed
-	uint8_t stall_requested:1;
-} udd_ep_job_t;
-
-
-//! Array to register a job on bulk/interrupt/isochronous endpoint
-static udd_ep_job_t udd_ep_job[USB_DEVICE_MAX_EP];
-
-//! \brief Reset all job table
-static void udd_ep_job_table_reset(void);
-
-//! \brief Abort all endpoint jobs on going
-static void udd_ep_job_table_kill(void);
-
-#ifdef UDD_EP_FIFO_SUPPORTED
-	/**
-	 * \brief Fill banks and send them
-	 *
-	 * \param ep endpoint number of job to abort
-	 */
-	static void udd_ep_in_sent(udd_ep_id_t ep);
-
-	/**
-	 * \brief Store received banks
-	 *
-	 * \param ep endpoint number of job to abort
-	 */
-	static void udd_ep_out_received(udd_ep_id_t ep);
-#endif
-
-/**
- * \brief Abort endpoint job on going
- *
- * \param ep endpoint number of job to abort
- */
-static void udd_ep_abort_job(udd_ep_id_t ep);
-
-/**
- * \brief Call the callback associated to the job which is finished
- *
- * \param ptr_job job to complete
- * \param b_abort if true then the job has been aborted
- */
-static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num);
-
-#ifdef UDD_EP_DMA_SUPPORTED
-	/**
-	 * \brief Start the next transfer if necessary or complete the job associated.
-	 *
-	 * \param ep endpoint number without direction flag
-	 */
-	static void udd_ep_trans_done(udd_ep_id_t ep);
-#endif
-
-/**
- * \brief Main interrupt routine for bulk/interrupt/isochronous endpoints
- *
- * This switches endpoint events to correct sub function.
- *
- * \return \c 1 if an event about bulk/interrupt/isochronous endpoints has occurred, otherwise \c 0.
- */
-static bool udd_ep_interrupt(void);
-
-#endif // (0!=USB_DEVICE_MAX_EP)
-//@}
-
-
-// ------------------------
-//--- INTERNAL ROUTINES TO MANAGED GLOBAL EVENTS
-
-/**
- * \internal
- * \brief Function called by UOTGHS interrupt to manage USB Device interrupts
- *
- * USB Device interrupt events are splited in three parts:
- * - USB line events (SOF, reset, suspend, resume, wakeup)
- * - control endpoint events (setup reception, end of data transfer, underflow, overflow, stall)
- * - bulk/interrupt/isochronous endpoints events (end of data transfer)
- *
- * Note:
- * Here, the global interrupt mask is not clear when an USB interrupt is enabled
- * because this one can not be occurred during the USB ISR (=during INTX is masked).
- * See Technical reference $3.8.3 Masking interrupt requests in peripheral modules.
- */
-#ifdef UHD_ENABLE
-void udd_interrupt(void);
-void udd_interrupt(void)
-#else
-ISR(UDD_USB_INT_FUN)
-#endif
-{
-	/* For fast wakeup clocks restore
-	 * In WAIT mode, clocks are switched to FASTRC.
-	 * After wakeup clocks should be restored, before that ISR should not
-	 * be served.
-	 */
-	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
-		cpu_irq_disable();
-		return;
-	}
-
-	if (Is_udd_sof()) {
-		udd_ack_sof();
-		if (Is_udd_full_speed_mode()) {
-			udc_sof_notify();
-		}
-#ifdef UDC_SOF_EVENT
-		UDC_SOF_EVENT();
-#endif
-		goto udd_interrupt_sof_end;
-	}
-
-	if (Is_udd_msof()) {
-		udd_ack_msof();
-		udc_sof_notify();
-		goto udd_interrupt_sof_end;
-	}
-
-	dbg_print("%c ", udd_is_high_speed() ? 'H' : 'F');
-
-	if (udd_ctrl_interrupt()) {
-		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
-	}
-
-#if (0 != USB_DEVICE_MAX_EP)
-	if (udd_ep_interrupt()) {
-		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
-	}
-#endif
-
-	// USB bus reset detection
-	if (Is_udd_reset()) {
-		udd_ack_reset();
-		dbg_print("RST ");
-		// Abort all jobs on-going
-#if (USB_DEVICE_MAX_EP != 0)
-		udd_ep_job_table_kill();
-#endif
-		// Reset USB Device Stack Core
-		udc_reset();
-		// Reset endpoint control
-		udd_reset_ep_ctrl();
-		// Reset endpoint control management
-		udd_ctrl_init();
-		goto udd_interrupt_end;
-	}
-
-	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
-		otg_unfreeze_clock();
-		// The suspend interrupt is automatic acked when a wakeup occur
-		udd_disable_suspend_interrupt();
-		udd_enable_wake_up_interrupt();
-		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
-		udd_sleep_mode(false);  // Enter in SUSPEND mode
-#ifdef UDC_SUSPEND_EVENT
-		UDC_SUSPEND_EVENT();
-#endif
-		goto udd_interrupt_end;
-	}
-
-	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
-		// Ack wakeup interrupt and enable suspend interrupt
-		otg_unfreeze_clock();
-		// Check USB clock ready after suspend and eventually sleep USB clock
-		while (!Is_otg_clock_usable()) {
-			if (Is_udd_suspend()) {
-				break; // In case of USB state change in HS
-			}
-		};
-		// The wakeup interrupt is automatic acked when a suspend occur
-		udd_disable_wake_up_interrupt();
-		udd_enable_suspend_interrupt();
-		udd_sleep_mode(true); // Enter in IDLE mode
-#ifdef UDC_RESUME_EVENT
-		UDC_RESUME_EVENT();
-#endif
-		goto udd_interrupt_end;
-	}
-
-	if (Is_otg_vbus_transition()) {
-		dbg_print("VBus ");
-		// Ack Vbus transition and send status to high level
-		otg_unfreeze_clock();
-		otg_ack_vbus_transition();
-		otg_freeze_clock();
-#ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
-		if (Is_otg_vbus_high()) {
-			udd_attach();
-		} else {
-			udd_detach();
-		}
-#endif
-#ifdef UDC_VBUS_EVENT
-		UDC_VBUS_EVENT(Is_otg_vbus_high());
-#endif
-		goto udd_interrupt_end;
-	}
-udd_interrupt_end:
-	dbg_print("\n\r");
-udd_interrupt_sof_end:
-	return;
-}
-
-
-bool udd_include_vbus_monitoring(void)
-{
-	return true;
-}
-
-
-void udd_enable(void)
-{
-	irqflags_t flags;
-
-	flags = cpu_irq_save();
-
-#ifdef UHD_ENABLE
-	// DUAL ROLE INITIALIZATION
-	if (otg_dual_enable()) {
-		// The current mode has been started by otg_dual_enable()
-		cpu_irq_restore(flags);
-		return;
-	}
-#else
-	// SINGLE DEVICE MODE INITIALIZATION
-	pmc_enable_periph_clk(ID_UOTGHS);
-	sysclk_enable_usb();
-
-	// Here, only the device mode is possible, then link UOTGHS interrupt to UDD interrupt
-	NVIC_SetPriority((IRQn_Type) ID_UOTGHS, UDD_USB_INT_LEVEL);
-	NVIC_EnableIRQ((IRQn_Type) ID_UOTGHS);
-
-	// Always authorize asynchrone USB interrupts to exit of sleep mode
-	// For SAM USB wake up device except BACKUP mode
-	pmc_set_fast_startup_input(PMC_FSMR_USBAL);
-#endif
-
-#if (defined USB_ID_GPIO) && (defined UHD_ENABLE)
-	// Check that the device mode is selected by ID pin
-	if (!Is_otg_id_device()) {
-		cpu_irq_restore(flags);
-		return; // Device is not the current mode
-	}
-#else
-	// ID pin not used then force device mode
-	otg_disable_id_pin();
-	otg_force_device_mode();
-#endif
-	// Enable USB hardware
-	otg_enable_pad();
-	otg_enable();
-
-	// Set the USB speed requested by configuration file
-#ifdef USB_DEVICE_LOW_SPEED
-	udd_low_speed_enable();
-#else
-	udd_low_speed_disable();
-# ifdef USB_DEVICE_HS_SUPPORT
-	udd_high_speed_enable();
-# else
-	udd_high_speed_disable();
-# endif
-#endif // USB_DEVICE_LOW_SPEED
-
-	// Check USB clock
-	otg_unfreeze_clock();
-	while (!Is_otg_clock_usable());
-
-	// Reset internal variables
-#if (0!=USB_DEVICE_MAX_EP)
-	udd_ep_job_table_reset();
-#endif
-
-	otg_ack_vbus_transition();
-	// Force Vbus interrupt in case of Vbus always with a high level
-	// This is possible with a short timing between a Host mode stop/start.
-	if (Is_otg_vbus_high()) {
-		otg_raise_vbus_transition();
-	}
-	otg_enable_vbus_interrupt();
-	otg_freeze_clock();
-
-#ifndef UDD_NO_SLEEP_MGR
-	if (!udd_b_sleep_initialized) {
-		udd_b_sleep_initialized = true;
-		// Initialize the sleep mode authorized for the USB suspend mode
-		udd_b_idle = false;
-		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_SUSPEND);
-	} else {
-		udd_sleep_mode(false); // Enter idle mode
-	}
-#endif
-
-	cpu_irq_restore(flags);
-}
-
-
-void udd_disable(void)
-{
-	irqflags_t flags;
-
-#ifdef UHD_ENABLE
-# ifdef USB_ID_GPIO
-	if (Is_otg_id_host()) {
-		// Freeze clock to switch mode
-		otg_freeze_clock();
-		udd_detach();
-		otg_disable();
-		return; // Host mode running, ignore UDD disable
-	}
-# else
-	if (Is_otg_host_mode_forced()) {
-		return; // Host mode running, ignore UDD disable
-	}
-# endif
-#endif
-
-	flags = cpu_irq_save();
-	otg_unfreeze_clock();
-	udd_detach();
-#ifndef UDD_NO_SLEEP_MGR
-	if (udd_b_sleep_initialized) {
-		udd_b_sleep_initialized = false;
-		sleepmgr_unlock_mode(UOTGHS_SLEEP_MODE_USB_SUSPEND);
-	}
-#endif
-
-#ifndef UHD_ENABLE
-	otg_disable();
-	otg_disable_pad();
-	sysclk_disable_usb();
-	pmc_disable_periph_clk(ID_UOTGHS);
-	// Else the USB clock disable is done by UHC which manage USB dual role
-#endif
-	cpu_irq_restore(flags);
-}
-
-
-void udd_attach(void)
-{
-	irqflags_t flags;
-	flags = cpu_irq_save();
-
-	// At startup the USB bus state is unknown,
-	// therefore the state is considered IDLE to not miss any USB event
-	udd_sleep_mode(true);
-	otg_unfreeze_clock();
-
-	// This section of clock check can be improved with a check of
-	// USB clock source via sysclk()
-	// Check USB clock because the source can be a PLL
-	while (!Is_otg_clock_usable());
-
-	// Authorize attach if Vbus is present
-	udd_attach_device();
-
-	// Enable USB line events
-	udd_enable_reset_interrupt();
-	udd_enable_suspend_interrupt();
-	udd_enable_wake_up_interrupt();
-	udd_enable_sof_interrupt();
-#ifdef USB_DEVICE_HS_SUPPORT
-	udd_enable_msof_interrupt();
-#endif
-	// Reset following interrupts flag
-	udd_ack_reset();
-	udd_ack_sof();
-	udd_ack_msof();
-
-	// The first suspend interrupt must be forced
-	// The first suspend interrupt is not detected else raise it
-	udd_raise_suspend();
-
-	udd_ack_wake_up();
-	otg_freeze_clock();
-	cpu_irq_restore(flags);
-}
-
-
-void udd_detach(void)
-{
-	otg_unfreeze_clock();
-
-	// Detach device from the bus
-	udd_detach_device();
-	otg_freeze_clock();
-	udd_sleep_mode(false);
-}
-
-
-bool udd_is_high_speed(void)
-{
-#ifdef USB_DEVICE_HS_SUPPORT
-	return !Is_udd_full_speed_mode();
-#else
-	return false;
-#endif
-}
-
-
-void udd_set_address(uint8_t address)
-{
-	udd_disable_address();
-	udd_configure_address(address);
-	udd_enable_address();
-}
-
-
-uint8_t udd_getaddress(void)
-{
-	return udd_get_configured_address();
-}
-
-
-uint16_t udd_get_frame_number(void)
-{
-	return udd_frame_number();
-}
-
-uint16_t udd_get_micro_frame_number(void)
-{
-	return udd_micro_frame_number();
-}
-
-void udd_send_remotewakeup(void)
-{
-#ifndef UDD_NO_SLEEP_MGR
-	if (!udd_b_idle)
-#endif
-	{
-		udd_sleep_mode(true); // Enter in IDLE mode
-		otg_unfreeze_clock();
-		udd_initiate_remote_wake_up();
-	}
-}
-
-
-void udd_set_setup_payload(uint8_t *payload, uint16_t payload_size)
-{
-	udd_g_ctrlreq.payload = payload;
-	udd_g_ctrlreq.payload_size = payload_size;
-}
-
-
-#if (0 != USB_DEVICE_MAX_EP)
-bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
-		uint16_t MaxEndpointSize)
-{
-	bool b_dir_in;
-	uint16_t ep_allocated;
-	uint8_t nb_bank, bank, i;
-
-	b_dir_in = ep & USB_EP_DIR_IN;
-	ep = ep & USB_EP_ADDR_MASK;
-
-	if (ep > USB_DEVICE_MAX_EP) {
-		return false;
-	}
-	if (Is_udd_endpoint_enabled(ep)) {
-		return false;
-	}
-	dbg_print("alloc(%x, %d) ", ep, MaxEndpointSize);
-
-	// Bank choice
-	switch (bmAttributes & USB_EP_TYPE_MASK) {
-	case USB_EP_TYPE_ISOCHRONOUS:
-		nb_bank = UDD_ISOCHRONOUS_NB_BANK(ep);
-		break;
-	case USB_EP_TYPE_INTERRUPT:
-		nb_bank = UDD_INTERRUPT_NB_BANK(ep);
-		break;
-	case USB_EP_TYPE_BULK:
-		nb_bank = UDD_BULK_NB_BANK(ep);
-		break;
-	default:
-		Assert(false);
-		return false;
-	}
-	switch (nb_bank) {
-	case 1:
-		bank = UOTGHS_DEVEPTCFG_EPBK_1_BANK >>
-				UOTGHS_DEVEPTCFG_EPBK_Pos;
-		break;
-	case 2:
-		bank = UOTGHS_DEVEPTCFG_EPBK_2_BANK >>
-				UOTGHS_DEVEPTCFG_EPBK_Pos;
-		break;
-	case 3:
-		bank = UOTGHS_DEVEPTCFG_EPBK_3_BANK >>
-				UOTGHS_DEVEPTCFG_EPBK_Pos;
-		break;
-	default:
-		Assert(false);
-		return false;
-	}
-
-	// Check if endpoint size is 8,16,32,64,128,256,512 or 1023
-	Assert(MaxEndpointSize < 1024);
-	Assert((MaxEndpointSize == 1023)
-		|| !(MaxEndpointSize & (MaxEndpointSize - 1)));
-	Assert(MaxEndpointSize >= 8);
-
-	// Set configuration of new endpoint
-	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
-			MaxEndpointSize, bank);
-	ep_allocated = 1 << ep;
-
-	// Unalloc endpoints superior
-	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
-		if (Is_udd_endpoint_enabled(i)) {
-			ep_allocated |= 1 << i;
-			udd_disable_endpoint(i);
-			udd_unallocate_memory(i);
-		}
-	}
-
-	// Realloc/Enable endpoints
-	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
-		if (ep_allocated & (1 << i)) {
-			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
-			bool b_restart = ptr_job->busy;
-			// Restart running job because
-			// memory window slides up and its data is lost
-			ptr_job->busy = false;
-			// Re-allocate memory
-			udd_allocate_memory(i);
-			udd_enable_endpoint(i);
-			if (!Is_udd_endpoint_configured(i)) {
-				dbg_print("ErrRealloc%d ", i);
-				if (NULL == ptr_job->call_trans) {
-					return false;
-				}
-				if (Is_udd_endpoint_in(i)) {
-					i |= USB_EP_DIR_IN;
-				}
-				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
-						ptr_job->buf_cnt, i);
-				return false;
-			}
-			udd_enable_endpoint_bank_autoswitch(i);
-			if (b_restart) {
-				// Re-run the job remaining part
-#  ifdef UDD_EP_FIFO_SUPPORTED
-				if (!Is_udd_endpoint_dma_supported(i)
-					&& !Is_udd_endpoint_in(i)) {
-					ptr_job->buf_cnt -= ptr_job->buf_load;
-				}
-#  else
-				ptr_job->buf_cnt -= ptr_job->buf_load;
-#  endif
-				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
-							(i | USB_EP_DIR_IN) : i,
-						ptr_job->b_shortpacket,
-						&ptr_job->buf[ptr_job->buf_cnt],
-						ptr_job->buf_size
-							- ptr_job->buf_cnt,
-						ptr_job->call_trans);
-				if (!b_restart) {
-					dbg_print("ErrReRun%d ", i);
-					return false;
-				}
-			}
-		}
-	}
-	return true;
-}
-
-
-void udd_ep_free(udd_ep_id_t ep)
-{
-	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
-	if (USB_DEVICE_MAX_EP < ep_index) {
-		return;
-	}
-	udd_disable_endpoint(ep_index);
-	udd_unallocate_memory(ep_index);
-	udd_ep_abort_job(ep);
-	udd_ep_job[ep_index - 1].stall_requested = false;
-}
-
-
-bool udd_ep_is_halted(udd_ep_id_t ep)
-{
-	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
-	return Is_udd_endpoint_stall_requested(ep_index);
-}
-
-
-bool udd_ep_set_halt(udd_ep_id_t ep)
-{
-	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
-	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
-	irqflags_t flags;
-
-	if (USB_DEVICE_MAX_EP < ep_index) {
-		return false;
-	}
-
-	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
-			|| ptr_job->stall_requested) { // Endpoint stall is requested
-		return true; // Already STALL
-	}
-
-	if (ptr_job->busy == true) {
-		return false; // Job on going, stall impossible
-	}
-
-	flags = cpu_irq_save();
-	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(ep_index))) {
-		// Delay the stall after the end of IN transfer on USB line
-		ptr_job->stall_requested = true;
-#ifdef UDD_EP_FIFO_SUPPORTED
-		udd_disable_in_send_interrupt(ep_index);
-		udd_enable_endpoint_bank_autoswitch(ep_index);
-#endif
-		udd_enable_bank_interrupt(ep_index);
-		udd_enable_endpoint_interrupt(ep_index);
-		cpu_irq_restore(flags);
-		return true;
-	}
-	// Stall endpoint immediately
-	udd_disable_endpoint_bank_autoswitch(ep_index);
-	udd_ack_stall(ep_index);
-	udd_enable_stall_handshake(ep_index);
-	cpu_irq_restore(flags);
-	return true;
-}
-
-
-bool udd_ep_clear_halt(udd_ep_id_t ep)
-{
-	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
-	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
-	bool b_stall_cleared = false;
-
-	if (USB_DEVICE_MAX_EP < ep_index)
-		return false;
-
-	if (ptr_job->stall_requested) {
-		// Endpoint stall has been requested but not done
-		// Remove stall request
-		ptr_job->stall_requested = false;
-		udd_disable_bank_interrupt(ep_index);
-		udd_disable_endpoint_interrupt(ep_index);
-		b_stall_cleared = true;
-	}
-	if (Is_udd_endpoint_stall_requested(ep_index)) {
-		if (Is_udd_stall(ep_index)) {
-			udd_ack_stall(ep_index);
-			// A packet has been stalled
-			// then reset datatoggle
-			udd_reset_data_toggle(ep_index);
-		}
-		// Disable stall
-		udd_disable_stall_handshake(ep_index);
-		udd_enable_endpoint_bank_autoswitch(ep_index);
-		b_stall_cleared = true;
-	}
-	if (b_stall_cleared) {
-		// If a job is register on clear halt action
-		// then execute callback
-		if (ptr_job->busy == true) {
-			ptr_job->busy = false;
-			ptr_job->call_nohalt();
-		}
-	}
-	return true;
-}
-
-
-bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
-		uint8_t * buf, iram_size_t buf_size,
-		udd_callback_trans_t callback)
-{
-#ifdef UDD_EP_FIFO_SUPPORTED
-	bool b_dir_in = Is_udd_endpoint_in(ep & USB_EP_ADDR_MASK);
-#endif
-	udd_ep_job_t *ptr_job;
-	irqflags_t flags;
-
-	ep &= USB_EP_ADDR_MASK;
-	if (USB_DEVICE_MAX_EP < ep) {
-		return false;
-	}
-
-	// Get job about endpoint
-	ptr_job = &udd_ep_job[ep - 1];
-
-	if ((!Is_udd_endpoint_enabled(ep))
-			|| Is_udd_endpoint_stall_requested(ep)
-			|| ptr_job->stall_requested) {
-		return false; // Endpoint is halted
-	}
-
-	flags = cpu_irq_save();
-	if (ptr_job->busy == true) {
-		cpu_irq_restore(flags);
-		return false; // Job already on going
-	}
-	ptr_job->busy = true;
-	cpu_irq_restore(flags);
-
-	// No job running. Let's setup a new one.
-	ptr_job->buf = buf;
-	ptr_job->buf_size = buf_size;
-	ptr_job->buf_cnt = 0;
-	ptr_job->buf_load = 0;
-	ptr_job->call_trans = callback;
-	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
-
-#ifdef UDD_EP_FIFO_SUPPORTED
-	// No DMA support
-	if (!Is_udd_endpoint_dma_supported(ep)) {
-		dbg_print("ex%x.%c%d\n\r", ep, b_dir_in ? 'i':'o', buf_size);
-		flags = cpu_irq_save();
-		udd_enable_endpoint_interrupt(ep);
-		if (b_dir_in) {
-			udd_disable_endpoint_bank_autoswitch(ep);
-			udd_enable_in_send_interrupt(ep);
-		} else {
-			udd_disable_endpoint_bank_autoswitch(ep);
-			udd_enable_out_received_interrupt(ep);
-		}
-		cpu_irq_restore(flags);
-		return true;
-	}
-#endif // UDD_EP_FIFO_SUPPORTED
-
-#ifdef UDD_EP_DMA_SUPPORTED
-	// Request first DMA transfer
-	dbg_print("(exDMA%x) ", ep);
-	udd_ep_trans_done(ep);
-	return true;
-#endif
-}
-
-
-void udd_ep_abort(udd_ep_id_t ep)
-{
-	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
-
-#ifdef UDD_EP_FIFO_SUPPORTED
-	if (!Is_udd_endpoint_dma_supported(ep_index)) {
-		// Disable interrupts
-		udd_disable_endpoint_interrupt(ep_index);
-		udd_disable_out_received_interrupt(ep_index);
-		udd_disable_in_send_interrupt(ep_index);
-	} else
-#endif
-	{
-		// Stop DMA transfer
-		udd_disable_endpoint_dma_interrupt(ep_index);
-		udd_endpoint_dma_set_control(ep_index, 0);
-	}
-	udd_disable_endpoint_interrupt(ep_index);
-	// Kill IN banks
-	if (ep & USB_EP_DIR_IN) {
-		while(udd_nb_busy_bank(ep_index)) {
-			udd_kill_last_in_bank(ep_index);
-			while(Is_udd_kill_last(ep_index));
-		}
-	}
-	udd_ep_abort_job(ep);
-}
-
-
-bool udd_ep_wait_stall_clear(udd_ep_id_t ep,
-		udd_callback_halt_cleared_t callback)
-{
-	udd_ep_job_t *ptr_job;
-
-	ep &= USB_EP_ADDR_MASK;
-	if (USB_DEVICE_MAX_EP < ep) {
-		return false;
-	}
-
-	ptr_job = &udd_ep_job[ep - 1];
-
-	if (!Is_udd_endpoint_enabled(ep)) {
-		return false; // Endpoint not enabled
-	}
-
-	// Wait clear halt endpoint
-	if (ptr_job->busy == true) {
-		return false; // Job already on going
-	}
-
-	if (Is_udd_endpoint_stall_requested(ep)
-			|| ptr_job->stall_requested) {
-		// Endpoint halted then registers the callback
-		ptr_job->busy = true;
-		ptr_job->call_nohalt = callback;
-	} else {
-		// endpoint not halted then call directly callback
-		callback();
-	}
-	return true;
-}
-#endif // (0 != USB_DEVICE_MAX_EP)
-
-
-#ifdef USB_DEVICE_HS_SUPPORT
-
-void udd_test_mode_j(void)
-{
-	udd_enable_hs_test_mode();
-	udd_enable_hs_test_mode_j();
-}
-
-
-void udd_test_mode_k(void)
-{
-	udd_enable_hs_test_mode();
-	udd_enable_hs_test_mode_k();
-}
-
-
-void udd_test_mode_se0_nak(void)
-{
-	udd_enable_hs_test_mode();
-}
-
-
-void udd_test_mode_packet(void)
-{
-	uint8_t i;
-	uint8_t *ptr_dest;
-	const uint8_t *ptr_src;
-
-	const uint8_t test_packet[] = {
-		// 00000000 * 9
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		// 01010101 * 8
-		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
-		// 01110111 * 8
-		0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
-		// 0, {111111S * 15}, 111111
-		0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-				0xFF, 0xFF,
-		// S, 111111S, {0111111S * 7}
-		0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD,
-		// 00111111, {S0111111 * 9}, S0
-		0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E
-	};
-
-	// Reconfigure control endpoint to bulk IN endpoint
-	udd_disable_endpoint(0);
-	udd_configure_endpoint(0, USB_EP_TYPE_BULK, 1,
-			64, UOTGHS_DEVEPTCFG_EPBK_1_BANK);
-	udd_allocate_memory(0);
-	udd_enable_endpoint(0);
-
-	udd_enable_hs_test_mode();
-	udd_enable_hs_test_mode_packet();
-
-	// Send packet on endpoint 0
-	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
-	ptr_src = test_packet;
-
-	for (i = 0; i < sizeof(test_packet); i++) {
-		*ptr_dest++ = *ptr_src++;
-	}
-	udd_ack_fifocon(0);
-}
-#endif // USB_DEVICE_HS_SUPPORT
-
-
-
-// ------------------------
-//--- INTERNAL ROUTINES TO MANAGED THE CONTROL ENDPOINT
-
-static void udd_reset_ep_ctrl(void)
-{
-	irqflags_t flags;
-
-	// Reset USB address to 0
-	udd_configure_address(0);
-	udd_enable_address();
-
-	// Alloc and configure control endpoint
-	udd_configure_endpoint(0,
-		USB_EP_TYPE_CONTROL,
-		0,
-		USB_DEVICE_EP_CTRL_SIZE,
-		UOTGHS_DEVEPTCFG_EPBK_1_BANK);
-
-	udd_allocate_memory(0);
-	udd_enable_endpoint(0);
-	flags = cpu_irq_save();
-	udd_enable_setup_received_interrupt(0);
-	udd_enable_out_received_interrupt(0);
-	udd_enable_endpoint_interrupt(0);
-	cpu_irq_restore(flags);
-}
-
-static void udd_ctrl_init(void)
-{
-	irqflags_t flags;
-	flags = cpu_irq_save();
-
-	// In case of abort of IN Data Phase:
-	// No need to abort IN transfer (rise TXINI),
-	// because it is automatically done by hardware when a Setup packet is received.
-	// But the interrupt must be disabled to don't generate interrupt TXINI
-	// after SETUP reception.
-	udd_disable_in_send_interrupt(0);
-	cpu_irq_restore(flags);
-
-	// In case of OUT ZLP event is no processed before Setup event occurs
-	udd_ack_out_received(0);
-
-	udd_g_ctrlreq.callback = NULL;
-	udd_g_ctrlreq.over_under_run = NULL;
-	udd_g_ctrlreq.payload_size = 0;
-	udd_ep_control_state = UDD_EPCTRL_SETUP;
-}
-
-
-static void udd_ctrl_setup_received(void)
-{
-	irqflags_t flags;
-	uint8_t i;
-
-	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
-		// May be a hidden DATA or ZLP phase or protocol abort
-		udd_ctrl_endofrequest();
-
-		// Reinitializes control endpoint management
-		udd_ctrl_init();
-	}
-	// Fill setup request structure
-	if (8 != udd_byte_count(0)) {
-		udd_ctrl_stall_data();
-		udd_ack_setup_received(0);
-		return; // Error data number doesn't correspond to SETUP packet
-	}
-	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
-	for (i = 0; i < 8; i++) {
-		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
-	}
-	// Manage LSB/MSB to fit with CPU usage
-	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
-	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
-	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
-
-	// Decode setup request
-	if (udc_process_setup() == false) {
-		// Setup request unknown then stall it
-		udd_ctrl_stall_data();
-		udd_ack_setup_received(0);
-		return;
-	}
-	udd_ack_setup_received(0);
-
-	if (Udd_setup_is_in()) {
-		// IN data phase requested
-		udd_ctrl_prev_payload_buf_cnt = 0;
-		udd_ctrl_payload_buf_cnt = 0;
-		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
-		udd_ctrl_in_sent(); // Send first data transfer
-	} else {
-		if (0 == udd_g_ctrlreq.req.wLength) {
-			// No data phase requested
-			// Send IN ZLP to ACK setup request
-			udd_ctrl_send_zlp_in();
-			return;
-		}
-		// OUT data phase requested
-		udd_ctrl_prev_payload_buf_cnt = 0;
-		udd_ctrl_payload_buf_cnt = 0;
-		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
-		// To detect a protocol error, enable nak interrupt on data IN phase
-		udd_ack_nak_in(0);
-		flags = cpu_irq_save();
-		udd_enable_nak_in_interrupt(0);
-		cpu_irq_restore(flags);
-	}
-}
-
-
-static void udd_ctrl_in_sent(void)
-{
-	static bool b_shortpacket = false;
-	uint16_t nb_remain;
-	uint8_t i;
-	uint8_t *ptr_dest, *ptr_src;
-	irqflags_t flags;
-
-	flags = cpu_irq_save();
-	udd_disable_in_send_interrupt(0);
-	cpu_irq_restore(flags);
-
-	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
-		// ZLP on IN is sent, then valid end of setup request
-		udd_ctrl_endofrequest();
-		// Reinitializes control endpoint management
-		udd_ctrl_init();
-		return;
-	}
-	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);
-
-	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
-	if (0 == nb_remain) {
-		// All content of current buffer payload are sent
-		// Update number of total data sending by previous playlaod buffer
-		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
-		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_buf_cnt)
-					|| b_shortpacket) {
-			// All data requested are transferred or a short packet has been sent
-			// then it is the end of data phase.
-			// Generate an OUT ZLP for handshake phase.
-			udd_ctrl_send_zlp_out();
-			return;
-		}
-		// Need of new buffer because the data phase is not complete
-		if ((!udd_g_ctrlreq.over_under_run)
-				|| (!udd_g_ctrlreq.over_under_run())) {
-			// Underrun then send zlp on IN
-			// Here nb_remain=0 and allows to send a IN ZLP
-		} else {
-			// A new payload buffer is given
-			udd_ctrl_payload_buf_cnt = 0;
-			nb_remain = udd_g_ctrlreq.payload_size;
-		}
-	}
-	// Continue transfer and send next data
-	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
-		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
-		b_shortpacket = false;
-	} else {
-		b_shortpacket = true;
-	}
-	// Fill buffer of endpoint control
-	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
-	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
-	// Critical section
-	// Only in case of DATA IN phase abort without USB Reset signal after.
-	// The IN data don't must be written in endpoint 0 DPRAM during
-	// a next setup reception in same endpoint 0 DPRAM.
-	// Thereby, an OUT ZLP reception must check before IN data write
-	// and if no OUT ZLP is received the data must be written quickly (800Âµs)
-	// before an eventually ZLP OUT and SETUP reception
-	flags = cpu_irq_save();
-	if (Is_udd_out_received(0)) {
-		// IN DATA phase aborted by OUT ZLP
-		cpu_irq_restore(flags);
-		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
-		return; // Exit of IN DATA phase
-	}
-	// Write quickly the IN data
-	for (i = 0; i < nb_remain; i++) {
-		*ptr_dest++ = *ptr_src++;
-	}
-	udd_ctrl_payload_buf_cnt += nb_remain;
-
-	// Validate and send the data available in the control endpoint buffer
-	udd_ack_in_send(0);
-	udd_enable_in_send_interrupt(0);
-	// In case of abort of DATA IN phase, no need to enable nak OUT interrupt
-	// because OUT endpoint is already free and ZLP OUT accepted.
-	cpu_irq_restore(flags);
-}
-
-
-static void udd_ctrl_out_received(void)
-{
-	irqflags_t flags;
-	uint8_t i;
-	uint16_t nb_data;
-
-	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
-		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
-				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
-						udd_ep_control_state)) {
-			// End of SETUP request:
-			// - Data IN Phase aborted,
-			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
-			// - or ZLP OUT received normally.
-			udd_ctrl_endofrequest();
-		} else {
-			// Protocol error during SETUP request
-			udd_ctrl_stall_data();
-		}
-		// Reinitializes control endpoint management
-		udd_ctrl_init();
-		return;
-	}
-	// Read data received during OUT phase
-	nb_data = udd_byte_count(0);
-	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
-		// Payload buffer too small
-		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
-	}
-	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
-	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
-	for (i = 0; i < nb_data; i++) {
-		*ptr_dest++ = *ptr_src++;
-	}
-	udd_ctrl_payload_buf_cnt += nb_data;
-
-	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
-			|| (udd_g_ctrlreq.req.wLength <=
-					(udd_ctrl_prev_payload_buf_cnt +
-							udd_ctrl_payload_buf_cnt))) {
-		// End of reception because it is a short packet
-		// Before send ZLP, call intermediate callback
-		// in case of data receiv generate a stall
-		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;
-		if (NULL != udd_g_ctrlreq.over_under_run) {
-			if (!udd_g_ctrlreq.over_under_run()) {
-				// Stall ZLP
-				udd_ctrl_stall_data();
-				// Ack reception of OUT to replace NAK by a STALL
-				udd_ack_out_received(0);
-				return;
-			}
-		}
-		// Send IN ZLP to ACK setup request
-		udd_ack_out_received(0);
-		udd_ctrl_send_zlp_in();
-		return;
-	}
-
-	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_buf_cnt) {
-		// Overrun then request a new payload buffer
-		if (!udd_g_ctrlreq.over_under_run) {
-			// No callback available to request a new payload buffer
-			udd_ctrl_stall_data();
-			// Ack reception of OUT to replace NAK by a STALL
-			udd_ack_out_received(0);
-			return;
-		}
-		if (!udd_g_ctrlreq.over_under_run()) {
-			// No new payload buffer delivered
-			udd_ctrl_stall_data();
-			// Ack reception of OUT to replace NAK by a STALL
-			udd_ack_out_received(0);
-			return;
-		}
-		// New payload buffer available
-		// Update number of total data received
-		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
-		// Reinit reception on payload buffer
-		udd_ctrl_payload_buf_cnt = 0;
-	}
-	// Free buffer of control endpoint to authorize next reception
-	udd_ack_out_received(0);
-	// To detect a protocol error, enable nak interrupt on data IN phase
-	udd_ack_nak_in(0);
-	flags = cpu_irq_save();
-	udd_enable_nak_in_interrupt(0);
-	cpu_irq_restore(flags);
-}
-
-
-static void udd_ctrl_underflow(void)
-{
-	if (Is_udd_out_received(0))
-		return; // Underflow ignored if OUT data is received
-
-	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
-		// Host want to stop OUT transaction
-		// then stop to wait OUT data phase and wait IN ZLP handshake
-		udd_ctrl_send_zlp_in();
-	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
-		// A OUT handshake is waiting by device,
-		// but host want extra IN data then stall extra IN data
-		udd_enable_stall_handshake(0);
-	}
-}
-
-
-static void udd_ctrl_overflow(void)
-{
-	if (Is_udd_in_send(0))
-		return; // Overflow ignored if IN data is received
-
-	// The case of UDD_EPCTRL_DATA_IN is not managed
-	// because the OUT endpoint is already free and OUT ZLP accepted
-
-	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
-		// A IN handshake is waiting by device,
-		// but host want extra OUT data then stall extra OUT data
-		udd_enable_stall_handshake(0);
-	}
-}
-
-
-static void udd_ctrl_stall_data(void)
-{
-	// Stall all packets on IN & OUT control endpoint
-	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
-	udd_enable_stall_handshake(0);
-}
-
-
-static void udd_ctrl_send_zlp_in(void)
-{
-	irqflags_t flags;
-
-	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
-
-	// Validate and send empty IN packet on control endpoint
-	flags = cpu_irq_save();
-	// Send ZLP on IN endpoint
-	udd_ack_in_send(0);
-	udd_enable_in_send_interrupt(0);
-	// To detect a protocol error, enable nak interrupt on data OUT phase
-	udd_ack_nak_out(0);
-	udd_enable_nak_out_interrupt(0);
-	cpu_irq_restore(flags);
-}
-
-
-static void udd_ctrl_send_zlp_out(void)
-{
-	irqflags_t flags;
-
-	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
-	// No action is necessary to accept OUT ZLP
-	// because the buffer of control endpoint is already free
-
-	// To detect a protocol error, enable nak interrupt on data IN phase
-	flags = cpu_irq_save();
-	udd_ack_nak_in(0);
-	udd_enable_nak_in_interrupt(0);
-	cpu_irq_restore(flags);
-}
-
-
-static void udd_ctrl_endofrequest(void)
-{
-	// If a callback is registered then call it
-	if (udd_g_ctrlreq.callback) {
-		udd_g_ctrlreq.callback();
-	}
-}
-
-
-static bool udd_ctrl_interrupt(void)
-{
-
-	if (!Is_udd_endpoint_interrupt(0)) {
-		return false; // No interrupt events on control endpoint
-	}
-
-	dbg_print("0: ");
-
-	// By default disable overflow and underflow interrupt
-	udd_disable_nak_in_interrupt(0);
-	udd_disable_nak_out_interrupt(0);
-
-	// Search event on control endpoint
-	if (Is_udd_setup_received(0)) {
-		dbg_print("stup ");
-		// SETUP packet received
-		udd_ctrl_setup_received();
-		return true;
-	}
-	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
-		dbg_print("in ");
-		// IN packet sent
-		udd_ctrl_in_sent();
-		return true;
-	}
-	if (Is_udd_out_received(0)) {
-		dbg_print("out ");
-		// OUT packet received
-		udd_ctrl_out_received();
-		return true;
-	}
-	if (Is_udd_nak_out(0)) {
-		dbg_print("nako ");
-		// Overflow on OUT packet
-		udd_ack_nak_out(0);
-		udd_ctrl_overflow();
-		return true;
-	}
-	if (Is_udd_nak_in(0)) {
-		dbg_print("naki ");
-		// Underflow on IN packet
-		udd_ack_nak_in(0);
-		udd_ctrl_underflow();
-		return true;
-	}
-	dbg_print("n%x ", UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], 0));
-	return false;
-}
-
-
-// ------------------------
-//--- INTERNAL ROUTINES TO MANAGED THE BULK/INTERRUPT/ISOCHRONOUS ENDPOINTS
-
-#if (0 != USB_DEVICE_MAX_EP)
-
-static void udd_ep_job_table_reset(void)
-{
-	uint8_t i;
-	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
-		udd_ep_job[i].busy = false;
-		udd_ep_job[i].stall_requested = false;
-	}
-}
-
-
-static void udd_ep_job_table_kill(void)
-{
-	uint8_t i;
-
-	// For each endpoint, kill job
-	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
-		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
-	}
-}
-
-
-static void udd_ep_abort_job(udd_ep_id_t ep)
-{
-	ep &= USB_EP_ADDR_MASK;
-
-	// Abort job on endpoint
-	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
-}
-
-
-static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
-{
-	if (ptr_job->busy == false) {
-		return; // No on-going job
-	}
-	dbg_print("(JobE%x:%d) ", (ptr_job-udd_ep_job)+1, b_abort);
-	ptr_job->busy = false;
-	if (NULL == ptr_job->call_trans) {
-		return; // No callback linked to job
-	}
-	if (Is_udd_endpoint_in(ep_num)) {
-		ep_num |= USB_EP_DIR_IN;
-	}
-	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
-			UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
-}
-
-#ifdef UDD_EP_DMA_SUPPORTED
-static void udd_ep_trans_done(udd_ep_id_t ep)
-{
-	uint32_t udd_dma_ctrl = 0;
-	udd_ep_job_t *ptr_job;
-	iram_size_t next_trans;
-	irqflags_t flags;
-
-	// Get job corresponding at endpoint
-	ptr_job = &udd_ep_job[ep - 1];
-
-	if (!ptr_job->busy) {
-		return; // No job is running, then ignore it (system error)
-	}
-
-	if (ptr_job->buf_cnt != ptr_job->buf_size) {
-		// Need to send or receiv other data
-		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;
-
-		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
-			// The USB hardware support a maximum
-			// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
-			next_trans = UDD_ENDPOINT_MAX_TRANS;
-
-			// Set 0 to transfer the maximum
-			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
-		} else {
-			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
-		}
-		if (Is_udd_endpoint_in(ep)) {
-			if (0 != (next_trans % udd_get_endpoint_size(ep))) {
-				// Enable short packet option
-				// else the DMA transfer is accepted
-				// and interrupt DMA valid but nothing is sent.
-				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_B_EN;
-				// No need to request another ZLP
-				ptr_job->b_shortpacket = false;
-			}
-		} else {
-			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
-					|| (next_trans <= (iram_size_t) udd_get_endpoint_size(ep))) {
-
-				// Enable short packet reception
-				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_TR_IT
-						| UOTGHS_DEVDMACONTROL_END_TR_EN;
-			}
-		}
-
-		// Start USB DMA to fill or read fifo of the selected endpoint
-		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
-		udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_BUFFIT |
-				UOTGHS_DEVDMACONTROL_CHANN_ENB;
-
-
-		// Disable IRQs to have a short sequence
-		// between read of EOT_STA and DMA enable
-		flags = cpu_irq_save();
-		if (!(udd_endpoint_dma_get_status(ep)
-				& UOTGHS_DEVDMASTATUS_END_TR_ST)) {
-			dbg_print("dmaS%x ", ep);
-			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
-			ptr_job->buf_cnt += next_trans;
-			ptr_job->buf_load = next_trans;
-			udd_enable_endpoint_dma_interrupt(ep);
-			cpu_irq_restore(flags);
-			return;
-		}
-		cpu_irq_restore(flags);
-
-		// Here a ZLP has been received
-		// and the DMA transfer must be not started.
-		// It is the end of transfer
-		ptr_job->buf_size = ptr_job->buf_cnt;
-	}
-	if (Is_udd_endpoint_in(ep)) {
-		if (ptr_job->b_shortpacket) {
-			dbg_print("zlpS%x ", ep);
-			// Need to send a ZLP (No possible with USB DMA)
-			// enable interrupt to wait a free bank to sent ZLP
-			udd_ack_in_send(ep);
-			if (Is_udd_write_enabled(ep)) {
-				// Force interrupt in case of ep already free
-				udd_raise_in_send(ep);
-			}
-			udd_enable_in_send_interrupt(ep);
-			udd_enable_endpoint_interrupt(ep);
-			return;
-		}
-	}
-	dbg_print("dmaE ");
-	// Call callback to signal end of transfer
-	udd_ep_finish_job(ptr_job, false, ep);
-}
-#endif
-
-#ifdef UDD_EP_FIFO_SUPPORTED
-static void udd_ep_in_sent(udd_ep_id_t ep)
-{
-	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
-	uint8_t *ptr_src = &ptr_job->buf[ptr_job->buf_cnt];
-	uint8_t *ptr_dst = (uint8_t *) & udd_get_endpoint_fifo_access(ep, 8);
-	uint32_t pkt_size = udd_get_endpoint_size(ep);
-	uint32_t nb_data = 0, i;
-	uint32_t nb_remain;
-	irqflags_t flags;
-
-	// All transfer done, including ZLP, Finish Job
-	if (ptr_job->buf_cnt >= ptr_job->buf_size && !ptr_job->b_shortpacket) {
-		flags = cpu_irq_save();
-		udd_disable_in_send_interrupt(ep);
-		udd_disable_endpoint_interrupt(ep);
-		cpu_irq_restore(flags);
-
-		ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
-		udd_ep_finish_job(ptr_job, false, ep);
-		return;
-	} else {
-		// ACK TXINI
-		udd_ack_in_send(ep);
-		// Fill FIFO
-		ptr_dst = (uint8_t *) & udd_get_endpoint_fifo_access(ep, 8);
-		ptr_src = &ptr_job->buf[ptr_job->buf_cnt];
-		nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
-		// Fill a bank even if no data (ZLP)
-		nb_data = min(nb_remain, pkt_size);
-		// Modify job information
-		ptr_job->buf_cnt += nb_data;
-		ptr_job->buf_load = nb_data;
-
-		// Copy buffer to FIFO
-		for (i = 0; i < nb_data; i++) {
-			*ptr_dst++ = *ptr_src++;
-		}
-		// Switch to next bank
-		udd_ack_fifocon(ep);
-		// ZLP?
-		if (nb_data < pkt_size) {
-			ptr_job->b_shortpacket = false;
-		}
-	}
-}
-
-static void udd_ep_out_received(udd_ep_id_t ep)
-{
-	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
-	uint32_t nb_data = 0, i;
-	uint32_t nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
-	uint32_t pkt_size = udd_get_endpoint_size(ep);
-	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(ep, 8);
-	uint8_t *ptr_dst = &ptr_job->buf[ptr_job->buf_cnt];
-	bool b_full = false, b_short = false;
-
-	// Clear RX OUT
-	udd_ack_out_received(ep);
-
-	// Read byte count
-	nb_data = udd_byte_count(ep);
-	if (nb_data < pkt_size) {
-		b_short = true;
-	}
-	//dbg_print("o%d ", ep);
-	//dbg_print("%d ", nb_data);
-	// Copy data if there is
-	if (nb_data > 0) {
-		if (nb_data >= nb_remain) {
-			nb_data = nb_remain;
-			b_full = true;
-		}
-		// Modify job information
-		ptr_job->buf_cnt += nb_data;
-		ptr_job->buf_load = nb_data;
-		// Copy FIFO to buffer
-		for (i = 0; i < nb_data; i++) {
-			*ptr_dst++ = *ptr_src++;
-		}
-	}
-	// Clear FIFO Status
-	udd_ack_fifocon(ep);
-	// Finish job on error or short packet
-	if (b_full || b_short) {
-		//dbg_print("EoO%d\n\r", ep);
-		udd_disable_out_received_interrupt(ep);
-		udd_disable_endpoint_interrupt(ep);
-		ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
-		udd_ep_finish_job(ptr_job, false, ep);
-	}
-}
-#endif // #ifdef UDD_EP_FIFO_SUPPORTED
-
-static bool udd_ep_interrupt(void)
-{
-	udd_ep_id_t ep;
-	udd_ep_job_t *ptr_job;
-
-	// For each endpoint different of control endpoint (0)
-	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
-		// Get job corresponding at endpoint
-		ptr_job = &udd_ep_job[ep - 1];
-
-#ifdef UDD_EP_DMA_SUPPORTED
-		// Check DMA event
-		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
-				&& Is_udd_endpoint_dma_interrupt(ep)) {
-			uint32_t nb_remaining;
-			if (udd_endpoint_dma_get_status(ep)
-					& UOTGHS_DEVDMASTATUS_CHANN_ENB) {
-				return true; // Ignore EOT_STA interrupt
-			}
-			dbg_print("dma%x: ", ep);
-			udd_disable_endpoint_dma_interrupt(ep);
-			// Save number of data no transferred
-			nb_remaining = (udd_endpoint_dma_get_status(ep) &
-					UOTGHS_DEVDMASTATUS_BUFF_COUNT_Msk)
-					>> UOTGHS_DEVDMASTATUS_BUFF_COUNT_Pos;
-			if (nb_remaining) {
-				// Transfer no complete (short packet or ZLP) then:
-				// Update number of data transferred
-				ptr_job->buf_cnt -= nb_remaining;
-				// Set transfer complete to stop the transfer
-				ptr_job->buf_size = ptr_job->buf_cnt;
-			}
-			udd_ep_trans_done(ep);
-			return true;
-		}
-#endif
-#ifdef UDD_EP_FIFO_SUPPORTED
-		// Check RXRDY and TXEMPTY event for none DMA endpoints
-		if (!Is_udd_endpoint_dma_supported(ep)
-				&& Is_udd_endpoint_interrupt_enabled(ep)) {
-			dbg_print("ep%x: ", ep);
-			// RXOUT: Full packet received
-			if (Is_udd_out_received(ep)
-				&& Is_udd_out_received_interrupt_enabled(ep)) {
-				dbg_print("Out ");
-				udd_ep_out_received(ep);
-				return true;
-			}
-			// TXIN: packet sent
-			if (Is_udd_in_send(ep)
-					&& Is_udd_in_send_interrupt_enabled(ep)) {
-				dbg_print("In ");
-				udd_ep_in_sent(ep);
-				return true;
-			}
-			// Errors: Abort?
-			if (Is_udd_overflow(ep)
-					|| Is_udd_underflow(ep)
-					|| Is_udd_crc_error(ep)) {
-				dbg_print("Err ");
-				udd_ep_abort(ep);
-				return true;
-			}
-		}
-#endif // UDD_EP_FIFO_SUPPORTED
-		// Check empty bank interrupt event
-		if (Is_udd_endpoint_interrupt_enabled(ep)) {
-			dbg_print("bg%x: ", ep);
-			if (Is_udd_in_send_interrupt_enabled(ep)
-					&& Is_udd_in_send(ep)) {
-				dbg_print("I ");
-				udd_disable_in_send_interrupt(ep);
-				// One bank is free then send a ZLP
-				udd_ack_in_send(ep);
-				udd_ack_fifocon(ep);
-				udd_ep_finish_job(ptr_job, false, ep);
-				return true;
-			}
-			if (Is_udd_bank_interrupt_enabled(ep)
-					&& (0 == udd_nb_busy_bank(ep))) {
-				dbg_print("EoT ");
-				// End of background transfer on IN endpoint
-				udd_disable_bank_interrupt(ep);
-				udd_disable_endpoint_interrupt(ep);
-
-				Assert(ptr_job->stall_requested);
-				// A stall has been requested during background transfer
-				ptr_job->stall_requested = false;
-				udd_disable_endpoint_bank_autoswitch(ep);
-				udd_enable_stall_handshake(ep);
-				udd_reset_data_toggle(ep);
-				return true;
-			}
-		}
-	}
-	return false;
-}
-#endif // (0 != USB_DEVICE_MAX_EP)
-
-//@}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/uotghs_device_due.h b/Marlin/src/HAL/DUE/usb/uotghs_device_due.h
deleted file mode 100644
index 6df26d6..0000000
--- a/Marlin/src/HAL/DUE/usb/uotghs_device_due.h
+++ /dev/null
@@ -1,664 +0,0 @@
-/**
- * \file
- *
- * \brief USB Device Driver for UOTGHS. Compliant with common UDD driver.
- *
- * Copyright (c) 2014-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef UOTGHS_DEVICE_DUE_H_INCLUDED
-#define UOTGHS_DEVICE_DUE_H_INCLUDED
-
-//#include "compiler.h"
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-extern "C" {
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-//! \ingroup udd_group
-//! \defgroup udd_udphs_group USB On-The-Go High-Speed Port for device mode (UOTGHS)
-//! UOTGHS low-level driver for USB device mode
-//!
-//! @{
-
-#ifndef UOTGHS_DEVEPTCFG_EPDIR_Pos
-// Bit pos is not defined in SAM header file but we need it.
-# define UOTGHS_DEVEPTCFG_EPDIR_Pos 8
-#endif
-
-//! @name UOTGHS Device IP properties
-//! These macros give access to IP properties
-//! @{
-  //! Get maximal number of endpoints
-#define udd_get_endpoint_max_nbr()             (9)
-#define UDD_MAX_PEP_NB                         (udd_get_endpoint_max_nbr() + 1)
-  //! Get maximal number of banks of endpoints
-#define udd_get_endpoint_bank_max_nbr(ep)      ((ep == 0) ? 1 : (( ep <= 2) ? 3 : 2))
-  //! Get maximal size of endpoint (3X, 1024/64)
-#define udd_get_endpoint_size_max(ep)          (((ep) == 0) ? 64 : 1024)
-  //! Get DMA support of endpoints
-#define Is_udd_endpoint_dma_supported(ep)      ((((ep) >= 1) && ((ep) <= 6)) ? true : false)
-  //! Get High Band Width support of endpoints
-#define Is_udd_endpoint_high_bw_supported(ep)  (((ep) >= 2) ? true : false)
-//! @}
-
-//! @name UOTGHS Device speeds management
-//! @{
-  //! Enable/disable device low-speed mode
-#define udd_low_speed_enable()               (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_LS))
-#define udd_low_speed_disable()              (Clr_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_LS))
-  //! Test if device low-speed mode is forced
-#define Is_udd_low_speed_enable()            (Tst_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_LS))
-
-#ifdef UOTGHS_DEVCTRL_SPDCONF_HIGH_SPEED
-  //! Enable high speed mode
-# define udd_high_speed_enable()          (Wr_bitfield(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_SPDCONF_Msk, 0))
-  //! Disable high speed mode
-# define udd_high_speed_disable()         (Wr_bitfield(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_SPDCONF_Msk, 3))
-  //! Test if controller is in full speed mode
-# define Is_udd_full_speed_mode()         (Rd_bitfield(UOTGHS->UOTGHS_SR, UOTGHS_SR_SPEED_Msk) == UOTGHS_SR_SPEED_FULL_SPEED)
-#else
-# define udd_high_speed_enable()          do { } while (0)
-# define udd_high_speed_disable()         do { } while (0)
-# define Is_udd_full_speed_mode()         true
-#endif
-//! @}
-
-//! @name UOTGHS Device HS test mode management
-//! @{
-#ifdef UOTGHS_DEVCTRL_SPDCONF_HIGH_SPEED
-  //! Enable high speed test mode
-# define udd_enable_hs_test_mode()        (Wr_bitfield(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_SPDCONF_Msk, 2))
-# define udd_enable_hs_test_mode_j()      (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_TSTJ))
-# define udd_enable_hs_test_mode_k()      (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_TSTK))
-# define udd_enable_hs_test_mode_packet() (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_TSTPCKT))
-#endif
-//! @}
-
-//! @name UOTGHS Device vbus management
-//! @{
-#define udd_enable_vbus_interrupt()       (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define udd_disable_vbus_interrupt()      (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define Is_udd_vbus_interrupt_enabled()   (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define Is_udd_vbus_high()                (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_VBUS))
-#define Is_udd_vbus_low()                 (!Is_udd_vbus_high())
-#define udd_ack_vbus_transition()         (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_VBUSTIC)
-#define udd_raise_vbus_transition()       (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_VBUSTIS)
-#define Is_udd_vbus_transition()          (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_VBUSTI))
-//! @}
-
-
-//! @name UOTGHS device attach control
-//! These macros manage the UOTGHS Device attach.
-//! @{
-  //! Detaches from USB bus
-#define udd_detach_device()               (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_DETACH))
-  //! Attaches to USB bus
-#define udd_attach_device()               (Clr_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_DETACH))
-  //! Test if the device is detached
-#define Is_udd_detached()                 (Tst_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_DETACH))
-//! @}
-
-
-//! @name UOTGHS device bus events control
-//! These macros manage the UOTGHS Device bus events.
-//! @{
-
-//! Initiates a remote wake-up event
-//! @{
-#define udd_initiate_remote_wake_up()     (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_RMWKUP))
-#define Is_udd_pending_remote_wake_up()   (Tst_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_RMWKUP))
-//! @}
-
-//! Manage upstream resume event (=remote wakeup)
-//! The USB driver sends a resume signal called "Upstream Resume"
-//! @{
-#define udd_enable_remote_wake_up_interrupt()     (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_UPRSMES)
-#define udd_disable_remote_wake_up_interrupt()    (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_UPRSMEC)
-#define Is_udd_remote_wake_up_interrupt_enabled() (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_UPRSME))
-#define udd_ack_remote_wake_up_start()            (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_UPRSMC)
-#define udd_raise_remote_wake_up_start()          (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_UPRSMS)
-#define Is_udd_remote_wake_up_start()             (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_UPRSM))
-//! @}
-
-//! Manage downstream resume event (=remote wakeup from host)
-//! The USB controller detects a valid "End of Resume" signal initiated by the host
-//! @{
-#define udd_enable_resume_interrupt()             (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_EORSMES)
-#define udd_disable_resume_interrupt()            (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_EORSMEC)
-#define Is_udd_resume_interrupt_enabled()         (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_EORSME))
-#define udd_ack_resume()                          (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_EORSMC)
-#define udd_raise_resume()                        (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_EORSMS)
-#define Is_udd_resume()                           (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_EORSM))
-//! @}
-
-//! Manage wake-up event (=usb line activity)
-//! The USB controller is reactivated by a filtered non-idle signal from the lines
-//! @{
-#define udd_enable_wake_up_interrupt()            (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_WAKEUPES)
-#define udd_disable_wake_up_interrupt()           (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_WAKEUPEC)
-#define Is_udd_wake_up_interrupt_enabled()        (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_WAKEUPE))
-#define udd_ack_wake_up()                         (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_WAKEUPC)
-#define udd_raise_wake_up()                       (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_WAKEUPS)
-#define Is_udd_wake_up()                          (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_WAKEUP))
-//! @}
-
-//! Manage reset event
-//! Set when a USB "End of Reset" has been detected
-//! @{
-#define udd_enable_reset_interrupt()              (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_EORSTES)
-#define udd_disable_reset_interrupt()             (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_EORSTEC)
-#define Is_udd_reset_interrupt_enabled()          (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_EORSTE))
-#define udd_ack_reset()                           (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_EORSTC)
-#define udd_raise_reset()                         (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_EORSTS)
-#define Is_udd_reset()                            (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_EORST))
-//! @}
-
-//! Manage start of frame event
-//! @{
-#define udd_enable_sof_interrupt()                (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_SOFES)
-#define udd_disable_sof_interrupt()               (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_SOFEC)
-#define Is_udd_sof_interrupt_enabled()            (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_SOFE))
-#define udd_ack_sof()                             (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_SOFC)
-#define udd_raise_sof()                           (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_SOFS)
-#define Is_udd_sof()                              (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_SOF))
-#define udd_frame_number()                        (Rd_bitfield(UOTGHS->UOTGHS_DEVFNUM, UOTGHS_DEVFNUM_FNUM_Msk))
-#define Is_udd_frame_number_crc_error()           (Tst_bits(UOTGHS->UOTGHS_DEVFNUM, UOTGHS_DEVFNUM_FNCERR))
-//! @}
-
-//! Manage Micro start of frame event (High Speed Only)
-//! @{
-#define udd_enable_msof_interrupt()               (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_MSOFES)
-#define udd_disable_msof_interrupt()              (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_MSOFEC)
-#define Is_udd_msof_interrupt_enabled()           (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_MSOFE))
-#define udd_ack_msof()                            (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVIMR_MSOFE)
-#define udd_raise_msof()                          (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_MSOFS)
-#define Is_udd_msof()                             (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_MSOF))
-#define udd_micro_frame_number()                  \
-  (Rd_bitfield(UOTGHS->UOTGHS_DEVFNUM, (UOTGHS_DEVFNUM_FNUM_Msk|UOTGHS_DEVFNUM_MFNUM_Msk)))
-//! @}
-
-//! Manage suspend event
-//! @{
-#define udd_enable_suspend_interrupt()            (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_SUSPES)
-#define udd_disable_suspend_interrupt()           (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_SUSPEC)
-#define Is_udd_suspend_interrupt_enabled()        (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_SUSPE))
-#define udd_ack_suspend()                         (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVICR_SUSPC)
-#define udd_raise_suspend()                       (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_SUSPS)
-#define Is_udd_suspend()                          (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_SUSP))
-//! @}
-
-//! @}
-
-//! @name UOTGHS device address control
-//! These macros manage the UOTGHS Device address.
-//! @{
-  //! enables USB device address
-#define udd_enable_address()                      (Set_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_ADDEN))
-  //! disables USB device address
-#define udd_disable_address()                     (Clr_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_ADDEN))
-#define Is_udd_address_enabled()                  (Tst_bits(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_ADDEN))
-  //! configures the USB device address
-#define udd_configure_address(addr)               (Wr_bitfield(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_UADD_Msk, addr))
-  //! gets the currently configured USB device address
-#define udd_get_configured_address()              (Rd_bitfield(UOTGHS->UOTGHS_DEVCTRL, UOTGHS_DEVCTRL_UADD_Msk))
-//! @}
-
-
-//! @name UOTGHS Device endpoint drivers
-//! These macros manage the common features of the endpoints.
-//! @{
-
-//! Generic macro for UOTGHS registers that can be arrayed
-//! @{
-#define UOTGHS_ARRAY(reg,index)                   ((&(UOTGHS->reg))[(index)])
-//! @}
-
-//! @name UOTGHS Device endpoint configuration
-//! @{
-  //! enables the selected endpoint
-#define udd_enable_endpoint(ep)                   (Set_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPEN0 << (ep)))
-  //! disables the selected endpoint
-#define udd_disable_endpoint(ep)                  (Clr_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPEN0 << (ep)))
-  //! tests if the selected endpoint is enabled
-#define Is_udd_endpoint_enabled(ep)               (Tst_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPEN0 << (ep)))
-  //! resets the selected endpoint
-#define udd_reset_endpoint(ep)                                         \
-  do {                                                               \
-    Set_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPRST0 << (ep)); \
-    Clr_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPRST0 << (ep)); \
-  } while (0)
-  //! Tests if the selected endpoint is being reset
-#define Is_udd_resetting_endpoint(ep)             (Tst_bits(UOTGHS->UOTGHS_DEVEPT, UOTGHS_DEVEPT_EPRST0 << (ep)))
-
-  //! Configures the selected endpoint type
-#define udd_configure_endpoint_type(ep, type)     (Wr_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPTYPE_Msk, type))
-  //! Gets the configured selected endpoint type
-#define udd_get_endpoint_type(ep)                 (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPTYPE_Msk))
-  //! Enables the bank autoswitch for the selected endpoint
-#define udd_enable_endpoint_bank_autoswitch(ep)   (Set_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_AUTOSW))
-  //! Disables the bank autoswitch for the selected endpoint
-#define udd_disable_endpoint_bank_autoswitch(ep)    (Clr_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_AUTOSW))
-#define Is_udd_endpoint_bank_autoswitch_enabled(ep) (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_AUTOSW))
-  //! Configures the selected endpoint direction
-#define udd_configure_endpoint_direction(ep, dir) (Wr_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPDIR, dir))
-  //! Gets the configured selected endpoint direction
-#define udd_get_endpoint_direction(ep)            (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPDIR))
-#define Is_udd_endpoint_in(ep)                    (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPDIR))
-  //! Bounds given integer size to allowed range and rounds it up to the nearest
-  //! available greater size, then applies register format of UOTGHS controller
-  //! for endpoint size bit-field.
-#undef udd_format_endpoint_size
-#define udd_format_endpoint_size(size)            (32 - clz(((uint32_t)min(max(size, 8), 1024) << 1) - 1) - 1 - 3)
-  //! Configures the selected endpoint size
-#define udd_configure_endpoint_size(ep, size)     (Wr_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPSIZE_Msk, udd_format_endpoint_size(size)))
-  //! Gets the configured selected endpoint size
-#define udd_get_endpoint_size(ep)                 (8 << Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPSIZE_Msk))
-  //! Configures the selected endpoint number of banks
-#define udd_configure_endpoint_bank(ep, bank)     (Wr_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPBK_Msk, bank))
-  //! Gets the configured selected endpoint number of banks
-#define udd_get_endpoint_bank(ep)                 (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPBK_Msk)+1)
-  //! Allocates the configuration selected endpoint in DPRAM memory
-#define udd_allocate_memory(ep)                   (Set_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_ALLOC))
-  //! un-allocates the configuration selected endpoint in DPRAM memory
-#define udd_unallocate_memory(ep)                 (Clr_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_ALLOC))
-#define Is_udd_memory_allocated(ep)               (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_ALLOC))
-
-  //! Configures selected endpoint in one step
-#define udd_configure_endpoint(ep, type, dir, size, bank) (\
-  Wr_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTCFG[0], ep), UOTGHS_DEVEPTCFG_EPTYPE_Msk |\
-      UOTGHS_DEVEPTCFG_EPDIR  |\
-      UOTGHS_DEVEPTCFG_EPSIZE_Msk |\
-      UOTGHS_DEVEPTCFG_EPBK_Msk ,   \
-      (((uint32_t)(type) << UOTGHS_DEVEPTCFG_EPTYPE_Pos) & UOTGHS_DEVEPTCFG_EPTYPE_Msk) |\
-      (((uint32_t)(dir ) << UOTGHS_DEVEPTCFG_EPDIR_Pos ) & UOTGHS_DEVEPTCFG_EPDIR) |\
-      ( (uint32_t)udd_format_endpoint_size(size) << UOTGHS_DEVEPTCFG_EPSIZE_Pos) |\
-      (((uint32_t)(bank) << UOTGHS_DEVEPTCFG_EPBK_Pos) & UOTGHS_DEVEPTCFG_EPBK_Msk))\
-)
-  //! Tests if current endpoint is configured
-#define Is_udd_endpoint_configured(ep)            (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_CFGOK))
-  //! Returns the control direction
-#define udd_control_direction()                   (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], EP_CONTROL), UOTGHS_DEVEPTISR_CTRLDIR))
-
-  //! Resets the data toggle sequence
-#define udd_reset_data_toggle(ep)                 (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_RSTDTS)
-  //! Tests if the data toggle sequence is being reset
-#define Is_udd_data_toggle_reset(ep)              (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_RSTDT))
-  //! Returns data toggle
-#define udd_data_toggle(ep)                       (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_DTSEQ_Msk))
-//! @}
-
-
-//! @name UOTGHS Device control endpoint
-//! These macros control the endpoints.
-//! @{
-
-//! @name UOTGHS Device control endpoint interrupts
-//! These macros control the endpoints interrupts.
-//! @{
-  //! Enables the selected endpoint interrupt
-#define udd_enable_endpoint_interrupt(ep)         (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_PEP_0 << (ep))
-  //! Disables the selected endpoint interrupt
-#define udd_disable_endpoint_interrupt(ep)        (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_PEP_0 << (ep))
-  //! Tests if the selected endpoint interrupt is enabled
-#define Is_udd_endpoint_interrupt_enabled(ep)     (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_PEP_0 << (ep)))
-  //! Tests if an interrupt is triggered by the selected endpoint
-#define Is_udd_endpoint_interrupt(ep)             (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_PEP_0 << (ep)))
-  //! Returns the lowest endpoint number generating an endpoint interrupt or MAX_PEP_NB if none
-#define udd_get_interrupt_endpoint_number()       (ctz(((UOTGHS->UOTGHS_DEVISR >> UOTGHS_DEVISR_PEP_Pos) & \
-                                                   (UOTGHS->UOTGHS_DEVIMR >> UOTGHS_DEVIMR_PEP_Pos)) |     \
-                                                   (1 << MAX_PEP_NB)))
-#define UOTGHS_DEVISR_PEP_Pos   12
-#define UOTGHS_DEVIMR_PEP_Pos   12
-//! @}
-
-//! @name UOTGHS Device control endpoint errors
-//! These macros control the endpoint errors.
-//! @{
-  //! Enables the STALL handshake
-#define udd_enable_stall_handshake(ep)            (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_STALLRQS)
-  //! Disables the STALL handshake
-#define udd_disable_stall_handshake(ep)           (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_STALLRQC)
-  //! Tests if STALL handshake request is running
-#define Is_udd_endpoint_stall_requested(ep)       (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_STALLRQ))
-  //! Tests if STALL sent
-#define Is_udd_stall(ep)                          (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_STALLEDI))
-  //! ACKs STALL sent
-#define udd_ack_stall(ep)                         (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_STALLEDIC)
-  //! Raises STALL sent
-#define udd_raise_stall(ep)                       (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_STALLEDIS)
-  //! Enables STALL sent interrupt
-#define udd_enable_stall_interrupt(ep)            (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_STALLEDES)
-  //! Disables STALL sent interrupt
-#define udd_disable_stall_interrupt(ep)           (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_STALLEDEC)
-  //! Tests if STALL sent interrupt is enabled
-#define Is_udd_stall_interrupt_enabled(ep)        (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_STALLEDE))
-
-  //! Tests if NAK OUT received
-#define Is_udd_nak_out(ep)                        (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_NAKOUTI))
-  //! ACKs NAK OUT received
-#define udd_ack_nak_out(ep)                       (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_NAKOUTIC)
-  //! Raises NAK OUT received
-#define udd_raise_nak_out(ep)                     (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_NAKOUTIS)
-  //! Enables NAK OUT interrupt
-#define udd_enable_nak_out_interrupt(ep)          (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_NAKOUTES)
-  //! Disables NAK OUT interrupt
-#define udd_disable_nak_out_interrupt(ep)         (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_NAKOUTEC)
-  //! Tests if NAK OUT interrupt is enabled
-#define Is_udd_nak_out_interrupt_enabled(ep)      (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_NAKOUTE))
-
-  //! Tests if NAK IN received
-#define Is_udd_nak_in(ep)                         (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_NAKINI))
-  //! ACKs NAK IN received
-#define udd_ack_nak_in(ep)                        (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_NAKINIC)
-  //! Raises NAK IN received
-#define udd_raise_nak_in(ep)                      (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_NAKINIS)
-  //! Enables NAK IN interrupt
-#define udd_enable_nak_in_interrupt(ep)           (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_NAKINES)
-  //! Disables NAK IN interrupt
-#define udd_disable_nak_in_interrupt(ep)          (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_NAKINEC)
-  //! Tests if NAK IN interrupt is enabled
-#define Is_udd_nak_in_interrupt_enabled(ep)       (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_NAKINE))
-
-  //! ACKs endpoint isochronous overflow interrupt
-#define udd_ack_overflow_interrupt(ep)            (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_OVERFIC)
-  //! Raises endpoint isochronous overflow interrupt
-#define udd_raise_overflow_interrupt(ep)          (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_OVERFIS)
-  //! Tests if an overflow occurs
-#define Is_udd_overflow(ep)                       (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_OVERFI))
-  //! Enables overflow interrupt
-#define udd_enable_overflow_interrupt(ep)         (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_OVERFES)
-  //! Disables overflow interrupt
-#define udd_disable_overflow_interrupt(ep)        (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_OVERFEC)
-  //! Tests if overflow interrupt is enabled
-#define Is_udd_overflow_interrupt_enabled(ep)     (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_OVERFE))
-
-  //! ACKs endpoint isochronous underflow interrupt
-#define udd_ack_underflow_interrupt(ep)           (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_UNDERFIC)
-  //! Raises endpoint isochronous underflow interrupt
-#define udd_raise_underflow_interrupt(ep)         (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_UNDERFIS)
-  //! Tests if an underflow occurs
-#define Is_udd_underflow(ep)                      (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_UNDERFI))
-  //! Enables underflow interrupt
-#define udd_enable_underflow_interrupt(ep)        (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_UNDERFES)
-  //! Disables underflow interrupt
-#define udd_disable_underflow_interrupt(ep)       (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_UNDERFEC)
-  //! Tests if underflow interrupt is enabled
-#define Is_udd_underflow_interrupt_enabled(ep)    (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_UNDERFE))
-
-  //! Tests if CRC ERROR ISO OUT detected
-#define Is_udd_crc_error(ep)                      (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_CRCERRI))
-  //! ACKs CRC ERROR ISO OUT detected
-#define udd_ack_crc_error(ep)                     (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_CRCERRIC)
-  //! Raises CRC ERROR ISO OUT detected
-#define udd_raise_crc_error(ep)                   (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_CRCERRIS)
-  //! Enables CRC ERROR ISO OUT detected interrupt
-#define udd_enable_crc_error_interrupt(ep)        (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_CRCERRES)
-  //! Disables CRC ERROR ISO OUT detected interrupt
-#define udd_disable_crc_error_interrupt(ep)       (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_CRCERREC)
-  //! Tests if CRC ERROR ISO OUT detected interrupt is enabled
-#define Is_udd_crc_error_interrupt_enabled(ep)    (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_CRCERRE))
-//! @}
-
-//! @name UOTGHS Device control endpoint transfer
-//! These macros control the endpoint transfer.
-//! @{
-
-  //! Tests if endpoint read allowed
-#define Is_udd_read_enabled(ep)                   (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_RWALL))
-  //! Tests if endpoint write allowed
-#define Is_udd_write_enabled(ep)                  (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_RWALL))
-
-  //! Returns the byte count
-#define udd_byte_count(ep)                        (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_BYCT_Msk))
-  //! Clears FIFOCON bit
-#define udd_ack_fifocon(ep)                       (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_FIFOCONC)
-  //! Tests if FIFOCON bit set
-#define Is_udd_fifocon(ep)                        (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_FIFOCON))
-
-  //! Returns the number of busy banks
-#define udd_nb_busy_bank(ep)                      (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_NBUSYBK_Msk))
-  //! Returns the number of the current bank
-#define udd_current_bank(ep)                      (Rd_bitfield(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_CURRBK_Msk))
-  //! Kills last bank
-#define udd_kill_last_in_bank(ep)                 (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_KILLBKS)
-#define Is_udd_kill_last(ep)                      (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_KILLBK))
-  //! Tests if last bank killed
-#define Is_udd_last_in_bank_killed(ep)            (!Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_KILLBK))
-  //! Forces all banks full (OUT) or free (IN) interrupt
-#define udd_force_bank_interrupt(ep)              (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_NBUSYBKS)
-  //! Unforces all banks full (OUT) or free (IN) interrupt
-#define udd_unforce_bank_interrupt(ep)            (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_NBUSYBKS)
-  //! Enables all banks full (OUT) or free (IN) interrupt
-#define udd_enable_bank_interrupt(ep)             (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_NBUSYBKES)
-  //! Disables all banks full (OUT) or free (IN) interrupt
-#define udd_disable_bank_interrupt(ep)            (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_NBUSYBKEC)
-  //! Tests if all banks full (OUT) or free (IN) interrupt enabled
-#define Is_udd_bank_interrupt_enabled(ep)         (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_NBUSYBKE))
-
-  //! Tests if SHORT PACKET received
-#define Is_udd_short_packet(ep)                   (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_SHORTPACKET))
-  //! ACKs SHORT PACKET received
-#define udd_ack_short_packet(ep)                  (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_SHORTPACKETC)
-  //! Raises SHORT PACKET received
-#define udd_raise_short_packet(ep)                (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_SHORTPACKETS)
-  //! Enables SHORT PACKET received interrupt
-#define udd_enable_short_packet_interrupt(ep)     (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_SHORTPACKETES)
-  //! Disables SHORT PACKET received interrupt
-#define udd_disable_short_packet_interrupt(ep)    (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_SHORTPACKETEC)
-  //! Tests if SHORT PACKET received interrupt is enabled
-#define Is_udd_short_packet_interrupt_enabled(ep) (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_SHORTPACKETE))
-
-  //! Tests if SETUP received
-#define Is_udd_setup_received(ep)                    (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_RXSTPI))
-  //! ACKs SETUP received
-#define udd_ack_setup_received(ep)                   (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_RXSTPIC)
-  //! Raises SETUP received
-#define udd_raise_setup_received(ep)                 (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_RXSTPIS)
-  //! Enables SETUP received interrupt
-#define udd_enable_setup_received_interrupt(ep)      (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_RXSTPES)
-  //! Disables SETUP received interrupt
-#define udd_disable_setup_received_interrupt(ep)     (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_RXSTPEC)
-  //! Tests if SETUP received interrupt is enabled
-#define Is_udd_setup_received_interrupt_enabled(ep)  (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_RXSTPE))
-
-  //! Tests if OUT received
-#define Is_udd_out_received(ep)                   (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_RXOUTI))
-  //! ACKs OUT received
-#define udd_ack_out_received(ep)                  (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_RXOUTIC)
-  //! Raises OUT received
-#define udd_raise_out_received(ep)                (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_RXOUTIS)
-  //! Enables OUT received interrupt
-#define udd_enable_out_received_interrupt(ep)     (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_RXOUTES)
-  //! Disables OUT received interrupt
-#define udd_disable_out_received_interrupt(ep)    (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_RXOUTEC)
-  //! Tests if OUT received interrupt is enabled
-#define Is_udd_out_received_interrupt_enabled(ep) (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_RXOUTE))
-
-  //! Tests if IN sending
-#define Is_udd_in_send(ep)                        (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTISR[0], ep), UOTGHS_DEVEPTISR_TXINI))
-  //! ACKs IN sending
-#define udd_ack_in_send(ep)                       (UOTGHS_ARRAY(UOTGHS_DEVEPTICR[0], ep) = UOTGHS_DEVEPTICR_TXINIC)
-  //! Raises IN sending
-#define udd_raise_in_send(ep)                     (UOTGHS_ARRAY(UOTGHS_DEVEPTIFR[0], ep) = UOTGHS_DEVEPTIFR_TXINIS)
-  //! Enables IN sending interrupt
-#define udd_enable_in_send_interrupt(ep)          (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0], ep) = UOTGHS_DEVEPTIER_TXINES)
-  //! Disables IN sending interrupt
-#define udd_disable_in_send_interrupt(ep)         (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0], ep) = UOTGHS_DEVEPTIDR_TXINEC)
-  //! Tests if IN sending interrupt is enabled
-#define Is_udd_in_send_interrupt_enabled(ep)      (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0], ep), UOTGHS_DEVEPTIMR_TXINE))
-
-
-  //! Get 64-, 32-, 16- or 8-bit access to FIFO data register of selected endpoint.
-  //! @param ep Endpoint of which to access FIFO data register
-  //! @param scale Data scale in bits: 64, 32, 16 or 8
-  //! @return Volatile 64-, 32-, 16- or 8-bit data pointer to FIFO data register
-  //! @warning It is up to the user of this macro to make sure that all accesses
-  //! are aligned with their natural boundaries except 64-bit accesses which
-  //! require only 32-bit alignment.
-  //! @warning It is up to the user of this macro to make sure that used HSB
-  //! addresses are identical to the DPRAM internal pointer modulo 32 bits.
-#define udd_get_endpoint_fifo_access(ep, scale) \
-    (((volatile TPASTE2(U, scale) (*)[0x8000 / ((scale) / 8)])UOTGHS_RAM_ADDR)[(ep)])
-
-//! @name UOTGHS endpoint DMA drivers
-//! These macros manage the common features of the endpoint DMA channels.
-//! @{
-
-  //! Maximum transfer size on USB DMA
-#define UDD_ENDPOINT_MAX_TRANS 0x10000
-  //! Enables the disabling of HDMA requests by endpoint interrupts
-#define udd_enable_endpoint_int_dis_hdma_req(ep)     (UOTGHS_ARRAY(UOTGHS_DEVEPTIER[0](ep) = UOTGHS_DEVEPTIER_EPDISHDMAS)
-  //! Disables the disabling of HDMA requests by endpoint interrupts
-#define udd_disable_endpoint_int_dis_hdma_req(ep)    (UOTGHS_ARRAY(UOTGHS_DEVEPTIDR[0](ep) = UOTGHS_DEVEPTIDR_EPDISHDMAC)
-  //! Tests if the disabling of HDMA requests by endpoint interrupts is enabled
-#define Is_udd_endpoint_int_dis_hdma_req_enabled(ep) (Tst_bits(UOTGHS_ARRAY(UOTGHS_DEVEPTIMR[0](ep), UOTGHS_DEVEPTIMR_EPDISHDMA))
-
-  //! Raises the selected endpoint DMA channel interrupt
-#define udd_raise_endpoint_dma_interrupt(ep)         (UOTGHS->UOTGHS_DEVIFR = UOTGHS_DEVIFR_DMA_1 << ((ep) - 1))
-  //! Raises the selected endpoint DMA channel interrupt
-#define udd_clear_endpoint_dma_interrupt(ep)         (UOTGHS->UOTGHS_DEVICR = UOTGHS_DEVISR_DMA_1 << ((ep) - 1))
-  //! Tests if an interrupt is triggered by the selected endpoint DMA channel
-#define Is_udd_endpoint_dma_interrupt(ep)            (Tst_bits(UOTGHS->UOTGHS_DEVISR, UOTGHS_DEVISR_DMA_1 << ((ep) - 1)))
-  //! Enables the selected endpoint DMA channel interrupt
-#define udd_enable_endpoint_dma_interrupt(ep)        (UOTGHS->UOTGHS_DEVIER = UOTGHS_DEVIER_DMA_1 << ((ep) - 1))
-  //! Disables the selected endpoint DMA channel interrupt
-#define udd_disable_endpoint_dma_interrupt(ep)       (UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_DMA_1 << ((ep) - 1))
-  //! Tests if the selected endpoint DMA channel interrupt is enabled
-#define Is_udd_endpoint_dma_interrupt_enabled(ep)    (Tst_bits(UOTGHS->UOTGHS_DEVIMR, UOTGHS_DEVIMR_DMA_1 << ((ep) - 1)))
-
-  //! Access points to the UOTGHS device DMA memory map with arrayed registers
-  //! @{
-      //! Structure for DMA next descriptor register
-typedef struct {
-  uint32_t *NXT_DSC_ADD;
-} uotghs_dma_nextdesc_t;
-      //! Structure for DMA control register
-typedef struct {
-  uint32_t CHANN_ENB:1,
-    LDNXT_DSC:1,
-    END_TR_EN:1,
-    END_B_EN:1,
-    END_TR_IT:1,
-    END_BUFFIT:1,
-    DESC_LD_IT:1,
-    BUST_LCK:1,
-    reserved:8,
-    BUFF_LENGTH:16;
-} uotghs_dma_control_t;
-      //! Structure for DMA status register
-typedef struct {
-  uint32_t CHANN_ENB:1,
-    CHANN_ACT:1,
-    reserved0:2,
-    END_TR_ST:1,
-    END_BF_ST:1,
-    DESC_LDST:1,
-    reserved1:9,
-    BUFF_COUNT:16;
-} uotghs_dma_status_t;
-      //! Structure for DMA descriptor
-typedef struct {
-  union {
-    uint32_t nextdesc;
-    uotghs_dma_nextdesc_t NEXTDESC;
-  };
-  uint32_t addr;
-  union {
-    uint32_t control;
-    uotghs_dma_control_t CONTROL;
-  };
-  uint32_t reserved;
-} sam_uotghs_dmadesc_t, uotghs_dmadesc_t;
-      //! Structure for DMA registers in a channel
-typedef struct {
-  union {
-    uint32_t nextdesc;
-    uotghs_dma_nextdesc_t NEXTDESC;
-  };
-  uint32_t addr;
-  union {
-    uint32_t control;
-    uotghs_dma_control_t CONTROL;
-  };
-  union {
-    unsigned long status;
-    uotghs_dma_status_t STATUS;
-  };
-} sam_uotghs_dmach_t, uotghs_dmach_t;
-      //! DMA channel control command
-#define UDD_ENDPOINT_DMA_STOP_NOW                 (0)
-#define UDD_ENDPOINT_DMA_RUN_AND_STOP             (UOTGHS_DEVDMACONTROL_CHANN_ENB)
-#define UDD_ENDPOINT_DMA_LOAD_NEXT_DESC           (UOTGHS_DEVDMACONTROL_LDNXT_DSC)
-#define UDD_ENDPOINT_DMA_RUN_AND_LINK             (UOTGHS_DEVDMACONTROL_CHANN_ENB|UOTGHS_DEVDMACONTROL_LDNXT_DSC)
-      //! Structure for DMA registers
-#define UOTGHS_UDDMA_ARRAY(ep)                    (((volatile uotghs_dmach_t *)UOTGHS->UOTGHS_DEVDMA)[(ep) - 1])
-
-      //! Set control desc to selected endpoint DMA channel
-#define udd_endpoint_dma_set_control(ep,desc)     (UOTGHS_UDDMA_ARRAY(ep).control = desc)
-      //! Get control desc to selected endpoint DMA channel
-#define udd_endpoint_dma_get_control(ep)          (UOTGHS_UDDMA_ARRAY(ep).control)
-      //! Set RAM address to selected endpoint DMA channel
-#define udd_endpoint_dma_set_addr(ep,add)         (UOTGHS_UDDMA_ARRAY(ep).addr = add)
-      //! Get status to selected endpoint DMA channel
-#define udd_endpoint_dma_get_status(ep)           (UOTGHS_UDDMA_ARRAY(ep).status)
-   //! @}
-//! @}
-
-//! @}
-//! @}
-//! @}
-//! @}
-
-
-/// @cond 0
-/**INDENT-OFF**/
-#ifdef __cplusplus
-}
-#endif
-/**INDENT-ON**/
-/// @endcond
-
-#endif /* UOTGHS_DEVICE_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/uotghs_otg.h b/Marlin/src/HAL/DUE/usb/uotghs_otg.h
deleted file mode 100644
index eca5e93..0000000
--- a/Marlin/src/HAL/DUE/usb/uotghs_otg.h
+++ /dev/null
@@ -1,241 +0,0 @@
-/**
- * \file
- *
- * \brief USB OTG Driver for UOTGHS.
- *
- * Copyright (c) 2012-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef UOTGHS_OTG_H_INCLUDED
-#define UOTGHS_OTG_H_INCLUDED
-
-#include "compiler.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-//! \ingroup usb_group
-//! \defgroup otg_group UOTGHS OTG Driver
-//! UOTGHS low-level driver for OTG features
-//!
-//! @{
-
-/**
- * \brief Initialize the dual role
- * This function is implemented in uotghs_host.c file.
- *
- * \return \c true if the ID pin management has been started, otherwise \c false.
- */
-bool otg_dual_enable(void);
-
-/**
- * \brief Uninitialize the dual role
- * This function is implemented in uotghs_host.c file.
- */
-void otg_dual_disable(void);
-
-
-//! @name UOTGHS OTG ID pin management
-//! The ID pin come from the USB OTG connector (A and B receptable) and
-//! allows to select the USB mode host or device.
-//! The UOTGHS hardware can manage it automatically. This feature is optional.
-//! When USB_ID_GPIO is defined (in board.h), this feature is enabled.
-//!
-//! @{
-   //! Enable external OTG_ID pin (listened to by USB)
-#define otg_enable_id_pin()                 (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIDE))
-   //! Disable external OTG_ID pin (ignored by USB)
-#define otg_disable_id_pin()                (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIDE))
-   //! Test if external OTG_ID pin enabled (listened to by USB)
-#define Is_otg_id_pin_enabled()             (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIDE))
-   //! Disable external OTG_ID pin and force device mode
-#define otg_force_device_mode()             (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIMOD), otg_disable_id_pin())
-   //! Test if device mode is forced
-#define Is_otg_device_mode_forced()         (!Is_otg_id_pin_enabled() && Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIMOD))
-   //! Disable external OTG_ID pin and force host mode
-#define otg_force_host_mode()               (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIMOD), otg_disable_id_pin())
-   //! Test if host mode is forced
-#define Is_otg_host_mode_forced()           (!Is_otg_id_pin_enabled() && !Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UIMOD))
-
-//! @name UOTGHS OTG ID pin interrupt management
-//! These macros manage the ID pin interrupt
-//! @{
-#define otg_enable_id_interrupt()           (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_IDTE))
-#define otg_disable_id_interrupt()          (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_IDTE))
-#define Is_otg_id_interrupt_enabled()       (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_IDTE))
-#define Is_otg_id_device()                  (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_ID))
-#define Is_otg_id_host()                    (!Is_otg_id_device())
-#define otg_ack_id_transition()             (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_IDTIC)
-#define otg_raise_id_transition()           (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_IDTIS)
-#define Is_otg_id_transition()              (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_IDTI))
-//! @}
-//! @}
-
-//! @name OTG Vbus management
-//! @{
-#define otg_enable_vbus_interrupt()         (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define otg_disable_vbus_interrupt()        (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define Is_otg_vbus_interrupt_enabled()     (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_VBUSTE))
-#define Is_otg_vbus_high()                  (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_VBUS))
-#define Is_otg_vbus_low()                   (!Is_otg_vbus_high())
-#define otg_ack_vbus_transition()           (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_VBUSTIC)
-#define otg_raise_vbus_transition()         (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_VBUSTIS)
-#define Is_otg_vbus_transition()            (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_VBUSTI))
-//! @}
-
-//! @name UOTGHS OTG main management
-//! These macros allows to enable/disable pad and UOTGHS hardware
-//! @{
-  //! Reset USB macro
-#define otg_reset()                         \
-	do {                                    \
-		UOTGHS->UOTGHS_CTRL = 0;            \
-		while( UOTGHS->UOTGHS_SR & 0x3FFF) {\
-			UOTGHS->UOTGHS_SCR = 0xFFFFFFFF;\
-		}                                   \
-	} while (0)
-  //! Enable USB macro
-#define otg_enable()                        (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_USBE))
-  //! Disable USB macro
-#define otg_disable()                       (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_USBE))
-#define Is_otg_enabled()                    (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_USBE))
-
-  //! Enable OTG pad
-#define otg_enable_pad()                    (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_OTGPADE))
-  //! Disable OTG pad
-#define otg_disable_pad()                   (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_OTGPADE))
-#define Is_otg_pad_enabled()                (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_OTGPADE))
-
-  //! Check Clock Usable
-  //! For parts with HS feature, this one corresponding at UTMI clock
-#define Is_otg_clock_usable()               (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_CLKUSABLE))
-
-  //! Stop (freeze) internal USB clock
-#define otg_freeze_clock()                  (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_FRZCLK))
-#define otg_unfreeze_clock()                (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_FRZCLK))
-#define Is_otg_clock_frozen()               (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_FRZCLK))
-
-  //! Configure time-out of specified OTG timer
-#define otg_configure_timeout(timer, timeout) (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UNLOCK),\
-		Wr_bitfield(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_TIMPAGE_Msk, timer),\
-		Wr_bitfield(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_TIMVALUE_Msk, timeout),\
-		Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UNLOCK))
-  //! Get configured time-out of specified OTG timer
-#define otg_get_timeout(timer)              (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UNLOCK),\
-		Wr_bitfield(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_TIMPAGE_Msk, timer),\
-		Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_UNLOCK),\
-		Rd_bitfield(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_TIMVALUE_Msk))
-
-
-  //! Get the dual-role device state of the internal USB finite state machine of the UOTGHS controller
-#define otg_get_fsm_drd_state()             (Rd_bitfield(UOTGHS->UOTGHS_FSM, UOTGHS_FSM_DRDSTATE_Msk))
-#define Is_otg_a_suspend()                  (4==otg_get_fsm_drd_state())
-#define Is_otg_a_wait_vrise()               (1==otg_get_fsm_drd_state())
-//! @}
-
-//! @name UOTGHS OTG hardware protocol
-//! These macros manages the hardware OTG protocol
-//! @{
-  //! Initiates a Host negotiation Protocol
-#define otg_device_initiate_hnp()             (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPREQ))
-  //! Accepts a Host negotiation Protocol
-#define otg_host_accept_hnp()                 (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPREQ))
-  //! Rejects a Host negotiation Protocol
-#define otg_host_reject_hnp()                 (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPREQ))
-  //! initiates a Session Request Protocol
-#define otg_device_initiate_srp()             (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPREQ))
-  //! Selects VBus as SRP method
-#define otg_select_vbus_srp_method()          (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPSEL))
-#define Is_otg_vbus_srp_method_selected()     (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPSEL))
-  //! Selects data line as SRP method
-#define otg_select_data_srp_method()          (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPSEL))
-#define Is_otg_data_srp_method_selected()     (!Is_otg_vbus_srp_method_selected())
-  //! Tests if a HNP occurs
-#define Is_otg_hnp()                          (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPREQ))
-  //! Tests if a SRP from device occurs
-#define Is_otg_device_srp()                   (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPREQ))
-
-  //! Enables HNP error interrupt
-#define otg_enable_hnp_error_interrupt()      (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPERRE))
-  //! Disables HNP error interrupt
-#define otg_disable_hnp_error_interrupt()     (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPERRE))
-#define Is_otg_hnp_error_interrupt_enabled()  (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_HNPERRE))
-  //! ACKs HNP error interrupt
-#define otg_ack_hnp_error_interrupt()         (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_HNPERRIC)
-  //! Raises HNP error interrupt
-#define otg_raise_hnp_error_interrupt()       (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_HNPERRIS)
-  //! Tests if a HNP error occurs
-#define Is_otg_hnp_error_interrupt()          (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_HNPERRI))
-
-  //! Enables role exchange interrupt
-#define otg_enable_role_exchange_interrupt()      (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_ROLEEXE))
-  //! Disables role exchange interrupt
-#define otg_disable_role_exchange_interrupt()     (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_ROLEEXE))
-#define Is_otg_role_exchange_interrupt_enabled()  (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_ROLEEXE))
-  //! ACKs role exchange interrupt
-#define otg_ack_role_exchange_interrupt()         (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_ROLEEXIC)
-  //! Raises role exchange interrupt
-#define otg_raise_role_exchange_interrupt()       (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_ROLEEXIS)
-  //! Tests if a role exchange occurs
-#define Is_otg_role_exchange_interrupt()          (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_ROLEEXI))
-
-  //! Enables SRP interrupt
-#define otg_enable_srp_interrupt()          (Set_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPE))
-  //! Disables SRP interrupt
-#define otg_disable_srp_interrupt()         (Clr_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPE))
-#define Is_otg_srp_interrupt_enabled()      (Tst_bits(UOTGHS->UOTGHS_CTRL, UOTGHS_CTRL_SRPE))
-  //! ACKs SRP interrupt
-#define otg_ack_srp_interrupt()             (UOTGHS->UOTGHS_SCR = UOTGHS_SCR_SRPIC)
-  //! Raises SRP interrupt
-#define otg_raise_srp_interrupt()           (UOTGHS->UOTGHS_SFR = UOTGHS_SFR_SRPIS)
-  //! Tests if a SRP occurs
-#define Is_otg_srp_interrupt()              (Tst_bits(UOTGHS->UOTGHS_SR, UOTGHS_SR_SRPI))
-//! @}
-
-//! @}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* UOTGHS_OTG_H_INCLUDED */
diff --git a/Marlin/src/HAL/DUE/usb/usb_protocol.h b/Marlin/src/HAL/DUE/usb/usb_protocol.h
deleted file mode 100644
index ea51a86..0000000
--- a/Marlin/src/HAL/DUE/usb/usb_protocol.h
+++ /dev/null
@@ -1,496 +0,0 @@
-/**
- * \file
- *
- * \brief USB protocol definitions.
- *
- * This file contains the USB definitions and data structures provided by the
- * USB 2.0 specification.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _USB_PROTOCOL_H_
-#define _USB_PROTOCOL_H_
-
-/**
- * \ingroup usb_group
- * \defgroup usb_protocol_group USB Protocol Definitions
- *
- * This module defines constants and data structures provided by the USB
- * 2.0 specification.
- *
- * @{
- */
-
-//! Value for field bcdUSB
-#define  USB_V2_0    0x0200 //!< USB Specification version 2.00
-#define  USB_V2_1    0x0201 //!< USB Specification version 2.01
-
-/*! \name Generic definitions (Class, subclass and protocol)
- */
-//! @{
-#define  NO_CLASS                0x00
-#define  CLASS_VENDOR_SPECIFIC   0xFF
-#define  NO_SUBCLASS             0x00
-#define  NO_PROTOCOL             0x00
-//! @}
-
-//! \name IAD (Interface Association Descriptor) constants
-//! @{
-#define  CLASS_IAD               0xEF
-#define  SUB_CLASS_IAD           0x02
-#define  PROTOCOL_IAD            0x01
-//! @}
-
-/**
- * \brief USB request data transfer direction (bmRequestType)
- */
-#define  USB_REQ_DIR_OUT         (0<<7) //!< Host to device
-#define  USB_REQ_DIR_IN          (1<<7) //!< Device to host
-#define  USB_REQ_DIR_MASK        (1<<7) //!< Mask
-
-/**
- * \brief USB request types (bmRequestType)
- */
-#define  USB_REQ_TYPE_STANDARD   (0<<5) //!< Standard request
-#define  USB_REQ_TYPE_CLASS      (1<<5) //!< Class-specific request
-#define  USB_REQ_TYPE_VENDOR     (2<<5) //!< Vendor-specific request
-#define  USB_REQ_TYPE_MASK       (3<<5) //!< Mask
-
-/**
- * \brief USB recipient codes (bmRequestType)
- */
-#define  USB_REQ_RECIP_DEVICE    (0<<0) //!< Recipient device
-#define  USB_REQ_RECIP_INTERFACE (1<<0) //!< Recipient interface
-#define  USB_REQ_RECIP_ENDPOINT  (2<<0) //!< Recipient endpoint
-#define  USB_REQ_RECIP_OTHER     (3<<0) //!< Recipient other
-#define  USB_REQ_RECIP_MASK      (0x1F) //!< Mask
-
-/**
- * \brief Standard USB requests (bRequest)
- */
-enum usb_reqid {
-	USB_REQ_GET_STATUS = 0,
-	USB_REQ_CLEAR_FEATURE = 1,
-	USB_REQ_SET_FEATURE = 3,
-	USB_REQ_SET_ADDRESS = 5,
-	USB_REQ_GET_DESCRIPTOR = 6,
-	USB_REQ_SET_DESCRIPTOR = 7,
-	USB_REQ_GET_CONFIGURATION = 8,
-	USB_REQ_SET_CONFIGURATION = 9,
-	USB_REQ_GET_INTERFACE = 10,
-	USB_REQ_SET_INTERFACE = 11,
-	USB_REQ_SYNCH_FRAME = 12,
-};
-
-/**
- * \brief Standard USB device status flags
- *
- */
-enum usb_device_status {
-	USB_DEV_STATUS_BUS_POWERED = 0,
-	USB_DEV_STATUS_SELF_POWERED = 1,
-	USB_DEV_STATUS_REMOTEWAKEUP = 2
-};
-
-/**
- * \brief Standard USB Interface status flags
- *
- */
-enum usb_interface_status {
-	USB_IFACE_STATUS_RESERVED = 0
-};
-
-/**
- * \brief Standard USB endpoint status flags
- *
- */
-enum usb_endpoint_status {
-	USB_EP_STATUS_HALTED = 1,
-};
-
-/**
- * \brief Standard USB device feature flags
- *
- * \note valid for SetFeature request.
- */
-enum usb_device_feature {
-	USB_DEV_FEATURE_REMOTE_WAKEUP = 1, //!< Remote wakeup enabled
-	USB_DEV_FEATURE_TEST_MODE = 2,     //!< USB test mode
-	USB_DEV_FEATURE_OTG_B_HNP_ENABLE = 3,
-	USB_DEV_FEATURE_OTG_A_HNP_SUPPORT = 4,
-	USB_DEV_FEATURE_OTG_A_ALT_HNP_SUPPORT = 5
-};
-
-/**
- * \brief Test Mode possible on HS USB device
- *
- * \note valid for USB_DEV_FEATURE_TEST_MODE request.
- */
-enum usb_device_hs_test_mode {
-	USB_DEV_TEST_MODE_J = 1,
-	USB_DEV_TEST_MODE_K = 2,
-	USB_DEV_TEST_MODE_SE0_NAK = 3,
-	USB_DEV_TEST_MODE_PACKET = 4,
-	USB_DEV_TEST_MODE_FORCE_ENABLE = 5,
-};
-
-/**
- * \brief Standard USB endpoint feature/status flags
- */
-enum usb_endpoint_feature {
-	USB_EP_FEATURE_HALT = 0,
-};
-
-/**
- * \brief Standard USB Test Mode Selectors
- */
-enum usb_test_mode_selector {
-	USB_TEST_J = 0x01,
-	USB_TEST_K = 0x02,
-	USB_TEST_SE0_NAK = 0x03,
-	USB_TEST_PACKET = 0x04,
-	USB_TEST_FORCE_ENABLE = 0x05,
-};
-
-/**
- * \brief Standard USB descriptor types
- */
-enum usb_descriptor_type {
-	USB_DT_DEVICE = 1,
-	USB_DT_CONFIGURATION = 2,
-	USB_DT_STRING = 3,
-	USB_DT_INTERFACE = 4,
-	USB_DT_ENDPOINT = 5,
-	USB_DT_DEVICE_QUALIFIER = 6,
-	USB_DT_OTHER_SPEED_CONFIGURATION = 7,
-	USB_DT_INTERFACE_POWER = 8,
-	USB_DT_OTG = 9,
-	USB_DT_IAD = 0x0B,
-	USB_DT_BOS = 0x0F,
-	USB_DT_DEVICE_CAPABILITY = 0x10,
-};
-
-/**
- * \brief USB Device Capability types
- */
-enum usb_capability_type {
-	USB_DC_USB20_EXTENSION = 0x02,
-};
-
-/**
- * \brief USB Device Capability - USB 2.0 Extension
- * To fill bmAttributes field of usb_capa_ext_desc_t structure.
- */
-enum usb_capability_extension_attr {
-	USB_DC_EXT_LPM  = 0x00000002,
-};
-
-#define HIRD_50_US    0
-#define HIRD_125_US   1
-#define HIRD_200_US   2
-#define HIRD_275_US   3
-#define HIRD_350_US   4
-#define HIRD_425_US   5
-#define HIRD_500_US   6
-#define HIRD_575_US  7
-#define HIRD_650_US  8
-#define HIRD_725_US  9
-#define HIRD_800_US  10
-#define HIRD_875_US  11
-#define HIRD_950_US  12
-#define HIRD_1025_US  13
-#define HIRD_1100_US  14
-#define HIRD_1175_US  15
-
-/** Fields definition from a LPM TOKEN  */
-#define  USB_LPM_ATTRIBUT_BLINKSTATE_MASK      (0xF << 0)
-#define  USB_LPM_ATTRIBUT_FIRD_MASK            (0xF << 4)
-#define  USB_LPM_ATTRIBUT_REMOTEWAKE_MASK      (1 << 8)
-#define  USB_LPM_ATTRIBUT_BLINKSTATE(value)    ((value & 0xF) << 0)
-#define  USB_LPM_ATTRIBUT_FIRD(value)          ((value & 0xF) << 4)
-#define  USB_LPM_ATTRIBUT_REMOTEWAKE(value)    ((value & 1) << 8)
-#define  USB_LPM_ATTRIBUT_BLINKSTATE_L1        USB_LPM_ATTRIBUT_BLINKSTATE(1)
-
-/**
- * \brief Standard USB endpoint transfer types
- */
-enum usb_ep_type {
-	USB_EP_TYPE_CONTROL = 0x00,
-	USB_EP_TYPE_ISOCHRONOUS = 0x01,
-	USB_EP_TYPE_BULK = 0x02,
-	USB_EP_TYPE_INTERRUPT = 0x03,
-	USB_EP_TYPE_MASK = 0x03,
-};
-
-/**
- * \brief Standard USB language IDs for string descriptors
- */
-enum usb_langid {
-	USB_LANGID_EN_US = 0x0409, //!< English (United States)
-};
-
-/**
- * \brief Mask selecting the index part of an endpoint address
- */
-#define  USB_EP_ADDR_MASK     0x0F
-
-//! \brief USB address identifier
-typedef uint8_t usb_add_t;
-
-/**
- * \brief Endpoint transfer direction is IN
- */
-#define  USB_EP_DIR_IN        0x80
-
-/**
- * \brief Endpoint transfer direction is OUT
- */
-#define  USB_EP_DIR_OUT       0x00
-
-//! \brief Endpoint identifier
-typedef uint8_t usb_ep_t;
-
-/**
- * \brief Maximum length in bytes of a USB descriptor
- *
- * The maximum length of a USB descriptor is limited by the 8-bit
- * bLength field.
- */
-#define  USB_MAX_DESC_LEN     255
-
-/*
- * 2-byte alignment requested for all USB structures.
- */
-COMPILER_PACK_SET(1)
-
-/**
- * \brief A USB Device SETUP request
- *
- * The data payload of SETUP packets always follows this structure.
- */
-typedef struct {
-	uint8_t bmRequestType;
-	uint8_t bRequest;
-	le16_t wValue;
-	le16_t wIndex;
-	le16_t wLength;
-} usb_setup_req_t;
-
-/**
- * \brief Standard USB device descriptor structure
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	le16_t bcdUSB;
-	uint8_t bDeviceClass;
-	uint8_t bDeviceSubClass;
-	uint8_t bDeviceProtocol;
-	uint8_t bMaxPacketSize0;
-	le16_t idVendor;
-	le16_t idProduct;
-	le16_t bcdDevice;
-	uint8_t iManufacturer;
-	uint8_t iProduct;
-	uint8_t iSerialNumber;
-	uint8_t bNumConfigurations;
-} usb_dev_desc_t;
-
-/**
- * \brief Standard USB device qualifier descriptor structure
- *
- * This descriptor contains information about the device when running at
- * the "other" speed (i.e. if the device is currently operating at high
- * speed, this descriptor can be used to determine what would change if
- * the device was operating at full speed.)
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	le16_t bcdUSB;
-	uint8_t bDeviceClass;
-	uint8_t bDeviceSubClass;
-	uint8_t bDeviceProtocol;
-	uint8_t bMaxPacketSize0;
-	uint8_t bNumConfigurations;
-	uint8_t bReserved;
-} usb_dev_qual_desc_t;
-
-/**
- * \brief USB Device BOS descriptor structure
- *
- * The BOS descriptor (Binary device Object Store) defines a root
- * descriptor that is similar to the configuration descriptor, and is
- * the base descriptor for accessing a family of related descriptors.
- * A host can read a BOS descriptor and learn from the wTotalLength field
- * the entire size of the device-level descriptor set, or it can read in
- * the entire BOS descriptor set of device capabilities.
- * The host accesses this descriptor using the GetDescriptor() request.
- * The descriptor type in the GetDescriptor() request is set to BOS.
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	le16_t  wTotalLength;
-	uint8_t bNumDeviceCaps;
-} usb_dev_bos_desc_t;
-
-
-/**
- * \brief USB Device Capabilities - USB 2.0 Extension Descriptor structure
- *
- * Defines the set of USB 1.1-specific device level capabilities.
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	uint8_t bDevCapabilityType;
-	le32_t  bmAttributes;
-} usb_dev_capa_ext_desc_t;
-
-/**
- * \brief USB Device LPM Descriptor structure
- *
- * The BOS descriptor and capabilities descriptors for LPM.
- */
-typedef struct {
-	usb_dev_bos_desc_t bos;
-	usb_dev_capa_ext_desc_t capa_ext;
-} usb_dev_lpm_desc_t;
-
-/**
- * \brief Standard USB Interface Association Descriptor structure
- */
-typedef struct {
-	uint8_t bLength;          //!< size of this descriptor in bytes
-	uint8_t bDescriptorType;  //!< INTERFACE descriptor type
-	uint8_t bFirstInterface;  //!< Number of interface
-	uint8_t bInterfaceCount;  //!< value to select alternate setting
-	uint8_t bFunctionClass;   //!< Class code assigned by the USB
-	uint8_t bFunctionSubClass;//!< Sub-class code assigned by the USB
-	uint8_t bFunctionProtocol;//!< Protocol code assigned by the USB
-	uint8_t iFunction;        //!< Index of string descriptor
-} usb_association_desc_t;
-
-
-/**
- * \brief Standard USB configuration descriptor structure
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	le16_t wTotalLength;
-	uint8_t bNumInterfaces;
-	uint8_t bConfigurationValue;
-	uint8_t iConfiguration;
-	uint8_t bmAttributes;
-	uint8_t bMaxPower;
-} usb_conf_desc_t;
-
-
-#define  USB_CONFIG_ATTR_MUST_SET         (1 << 7) //!< Must always be set
-#define  USB_CONFIG_ATTR_BUS_POWERED      (0 << 6) //!< Bus-powered
-#define  USB_CONFIG_ATTR_SELF_POWERED     (1 << 6) //!< Self-powered
-#define  USB_CONFIG_ATTR_REMOTE_WAKEUP    (1 << 5) //!< remote wakeup supported
-
-#define  USB_CONFIG_MAX_POWER(ma)         (((ma) + 1) / 2) //!< Max power in mA
-
-/**
- * \brief Standard USB association descriptor structure
- */
-typedef struct {
-	uint8_t bLength;              //!< Size of this descriptor in bytes
-	uint8_t bDescriptorType;      //!< Interface descriptor type
-	uint8_t bFirstInterface;      //!< Number of interface
-	uint8_t bInterfaceCount;      //!< value to select alternate setting
-	uint8_t bFunctionClass;       //!< Class code assigned by the USB
-	uint8_t bFunctionSubClass;    //!< Sub-class code assigned by the USB
-	uint8_t bFunctionProtocol;    //!< Protocol code assigned by the USB
-	uint8_t iFunction;            //!< Index of string descriptor
-} usb_iad_desc_t;
-
-/**
- * \brief Standard USB interface descriptor structure
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	uint8_t bInterfaceNumber;
-	uint8_t bAlternateSetting;
-	uint8_t bNumEndpoints;
-	uint8_t bInterfaceClass;
-	uint8_t bInterfaceSubClass;
-	uint8_t bInterfaceProtocol;
-	uint8_t iInterface;
-} usb_iface_desc_t;
-
-/**
- * \brief Standard USB endpoint descriptor structure
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-	uint8_t bEndpointAddress;
-	uint8_t bmAttributes;
-	le16_t wMaxPacketSize;
-	uint8_t bInterval;
-} usb_ep_desc_t;
-
-
-/**
- * \brief A standard USB string descriptor structure
- */
-typedef struct {
-	uint8_t bLength;
-	uint8_t bDescriptorType;
-} usb_str_desc_t;
-
-typedef struct {
-	usb_str_desc_t desc;
-	le16_t string[1];
-} usb_str_lgid_desc_t;
-
-COMPILER_PACK_RESET()
-
-//! @}
-
-#endif /* _USB_PROTOCOL_H_ */
diff --git a/Marlin/src/HAL/DUE/usb/usb_protocol_cdc.h b/Marlin/src/HAL/DUE/usb/usb_protocol_cdc.h
deleted file mode 100644
index d594db5..0000000
--- a/Marlin/src/HAL/DUE/usb/usb_protocol_cdc.h
+++ /dev/null
@@ -1,320 +0,0 @@
-/**
- * \file
- *
- * \brief USB Communication Device Class (CDC) protocol definitions
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-#ifndef _USB_PROTOCOL_CDC_H_
-#define _USB_PROTOCOL_CDC_H_
-
-#include "compiler.h"
-
-/**
- * \ingroup usb_protocol_group
- * \defgroup cdc_protocol_group Communication Device Class Definitions
- * @{
- */
-
-/**
- * \name Possible values of class
- */
-//@{
-#define  CDC_CLASS_DEVICE     0x02	//!< USB Communication Device Class
-#define  CDC_CLASS_COMM       0x02	//!< CDC Communication Class Interface
-#define  CDC_CLASS_DATA       0x0A	//!< CDC Data Class Interface
-#define  CDC_CLASS_MULTI      0xEF      //!< CDC Multi-interface Function
-
-//@}
-
-//! \name USB CDC Subclass IDs
-//@{
-#define  CDC_SUBCLASS_DLCM    0x01	//!< Direct Line Control Model
-#define  CDC_SUBCLASS_ACM     0x02	//!< Abstract Control Model
-#define  CDC_SUBCLASS_TCM     0x03	//!< Telephone Control Model
-#define  CDC_SUBCLASS_MCCM    0x04	//!< Multi-Channel Control Model
-#define  CDC_SUBCLASS_CCM     0x05	//!< CAPI Control Model
-#define  CDC_SUBCLASS_ETH     0x06	//!< Ethernet Networking Control Model
-#define  CDC_SUBCLASS_ATM     0x07	//!< ATM Networking Control Model
-//@}
-
-//! \name USB CDC Communication Interface Protocol IDs
-//@{
-#define  CDC_PROTOCOL_V25TER  0x01	//!< Common AT commands
-//@}
-
-//! \name USB CDC Data Interface Protocol IDs
-//@{
-#define  CDC_PROTOCOL_I430    0x30	//!< ISDN BRI
-#define  CDC_PROTOCOL_HDLC    0x31	//!< HDLC
-#define  CDC_PROTOCOL_TRANS   0x32	//!< Transparent
-#define  CDC_PROTOCOL_Q921M   0x50	//!< Q.921 management protocol
-#define  CDC_PROTOCOL_Q921    0x51	//!< Q.931 [sic] Data link protocol
-#define  CDC_PROTOCOL_Q921TM  0x52	//!< Q.921 TEI-multiplexor
-#define  CDC_PROTOCOL_V42BIS  0x90	//!< Data compression procedures
-#define  CDC_PROTOCOL_Q931    0x91	//!< Euro-ISDN protocol control
-#define  CDC_PROTOCOL_V120    0x92	//!< V.24 rate adaption to ISDN
-#define  CDC_PROTOCOL_CAPI20  0x93	//!< CAPI Commands
-#define  CDC_PROTOCOL_HOST    0xFD	//!< Host based driver
-/**
- * \brief Describes the Protocol Unit Functional Descriptors [sic]
- * on Communication Class Interface
- */
-#define  CDC_PROTOCOL_PUFD    0xFE
-//@}
-
-//! \name USB CDC Functional Descriptor Types
-//@{
-#define  CDC_CS_INTERFACE     0x24	//!< Interface Functional Descriptor
-#define  CDC_CS_ENDPOINT      0x25	//!< Endpoint Functional Descriptor
-//@}
-
-//! \name USB CDC Functional Descriptor Subtypes
-//@{
-#define  CDC_SCS_HEADER       0x00	//!< Header Functional Descriptor
-#define  CDC_SCS_CALL_MGMT    0x01	//!< Call Management
-#define  CDC_SCS_ACM          0x02	//!< Abstract Control Management
-#define  CDC_SCS_UNION        0x06	//!< Union Functional Descriptor
-//@}
-
-//! \name USB CDC Request IDs
-//@{
-#define  USB_REQ_CDC_SEND_ENCAPSULATED_COMMAND                   0x00
-#define  USB_REQ_CDC_GET_ENCAPSULATED_RESPONSE                   0x01
-#define  USB_REQ_CDC_SET_COMM_FEATURE                            0x02
-#define  USB_REQ_CDC_GET_COMM_FEATURE                            0x03
-#define  USB_REQ_CDC_CLEAR_COMM_FEATURE                          0x04
-#define  USB_REQ_CDC_SET_AUX_LINE_STATE                          0x10
-#define  USB_REQ_CDC_SET_HOOK_STATE                              0x11
-#define  USB_REQ_CDC_PULSE_SETUP                                 0x12
-#define  USB_REQ_CDC_SEND_PULSE                                  0x13
-#define  USB_REQ_CDC_SET_PULSE_TIME                              0x14
-#define  USB_REQ_CDC_RING_AUX_JACK                               0x15
-#define  USB_REQ_CDC_SET_LINE_CODING                             0x20
-#define  USB_REQ_CDC_GET_LINE_CODING                             0x21
-#define  USB_REQ_CDC_SET_CONTROL_LINE_STATE                      0x22
-#define  USB_REQ_CDC_SEND_BREAK                                  0x23
-#define  USB_REQ_CDC_SET_RINGER_PARMS                            0x30
-#define  USB_REQ_CDC_GET_RINGER_PARMS                            0x31
-#define  USB_REQ_CDC_SET_OPERATION_PARMS                         0x32
-#define  USB_REQ_CDC_GET_OPERATION_PARMS                         0x33
-#define  USB_REQ_CDC_SET_LINE_PARMS                              0x34
-#define  USB_REQ_CDC_GET_LINE_PARMS                              0x35
-#define  USB_REQ_CDC_DIAL_DIGITS                                 0x36
-#define  USB_REQ_CDC_SET_UNIT_PARAMETER                          0x37
-#define  USB_REQ_CDC_GET_UNIT_PARAMETER                          0x38
-#define  USB_REQ_CDC_CLEAR_UNIT_PARAMETER                        0x39
-#define  USB_REQ_CDC_GET_PROFILE                                 0x3A
-#define  USB_REQ_CDC_SET_ETHERNET_MULTICAST_FILTERS              0x40
-#define  USB_REQ_CDC_SET_ETHERNET_POWER_MANAGEMENT_PATTERNFILTER 0x41
-#define  USB_REQ_CDC_GET_ETHERNET_POWER_MANAGEMENT_PATTERNFILTER 0x42
-#define  USB_REQ_CDC_SET_ETHERNET_PACKET_FILTER                  0x43
-#define  USB_REQ_CDC_GET_ETHERNET_STATISTIC                      0x44
-#define  USB_REQ_CDC_SET_ATM_DATA_FORMAT                         0x50
-#define  USB_REQ_CDC_GET_ATM_DEVICE_STATISTICS                   0x51
-#define  USB_REQ_CDC_SET_ATM_DEFAULT_VC                          0x52
-#define  USB_REQ_CDC_GET_ATM_VC_STATISTICS                       0x53
-// Added bNotification codes according cdc spec 1.1 chapter 6.3
-#define  USB_REQ_CDC_NOTIFY_RING_DETECT                          0x09
-#define  USB_REQ_CDC_NOTIFY_SERIAL_STATE                         0x20
-#define  USB_REQ_CDC_NOTIFY_CALL_STATE_CHANGE                    0x28
-#define  USB_REQ_CDC_NOTIFY_LINE_STATE_CHANGE                    0x29
-//@}
-
-/*
- * Need to pack structures tightly, or the compiler might insert padding
- * and violate the spec-mandated layout.
- */
-COMPILER_PACK_SET(1)
-
-//! \name USB CDC Descriptors
-//@{
-
-
-//! CDC Header Functional Descriptor
-typedef struct {
-	uint8_t bFunctionLength;
-	uint8_t bDescriptorType;
-	uint8_t bDescriptorSubtype;
-	le16_t bcdCDC;
-} usb_cdc_hdr_desc_t;
-
-//! CDC Call Management Functional Descriptor
-typedef struct {
-	uint8_t bFunctionLength;
-	uint8_t bDescriptorType;
-	uint8_t bDescriptorSubtype;
-	uint8_t bmCapabilities;
-	uint8_t bDataInterface;
-} usb_cdc_call_mgmt_desc_t;
-
-//! CDC ACM Functional Descriptor
-typedef struct {
-	uint8_t bFunctionLength;
-	uint8_t bDescriptorType;
-	uint8_t bDescriptorSubtype;
-	uint8_t bmCapabilities;
-} usb_cdc_acm_desc_t;
-
-//! CDC Union Functional Descriptor
-typedef struct {
-	uint8_t bFunctionLength;
-	uint8_t bDescriptorType;
-	uint8_t bDescriptorSubtype;
-	uint8_t bMasterInterface;
-	uint8_t bSlaveInterface0;
-} usb_cdc_union_desc_t;
-
-
-//! \name USB CDC Call Management Capabilities
-//@{
-//! Device handles call management itself
-#define  CDC_CALL_MGMT_SUPPORTED             (1 << 0)
-//! Device can send/receive call management info over a Data Class interface
-#define  CDC_CALL_MGMT_OVER_DCI              (1 << 1)
-//@}
-
-//! \name USB CDC ACM Capabilities
-//@{
-//! Device supports the request combination of
-//! Set_Comm_Feature, Clear_Comm_Feature, and Get_Comm_Feature.
-#define  CDC_ACM_SUPPORT_FEATURE_REQUESTS    (1 << 0)
-//! Device supports the request combination of
-//! Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding,
-//! and the notification Serial_State.
-#define  CDC_ACM_SUPPORT_LINE_REQUESTS       (1 << 1)
-//! Device supports the request Send_Break
-#define  CDC_ACM_SUPPORT_SENDBREAK_REQUESTS  (1 << 2)
-//! Device supports the notification Network_Connection.
-#define  CDC_ACM_SUPPORT_NOTIFY_REQUESTS     (1 << 3)
-//@}
-//@}
-
-//! \name USB CDC line control
-//@{
-
-//! \name USB CDC line coding
-//@{
-//! Line Coding structure
-typedef struct {
-	le32_t dwDTERate;
-	uint8_t bCharFormat;
-	uint8_t bParityType;
-	uint8_t bDataBits;
-} usb_cdc_line_coding_t;
-//! Possible values of bCharFormat
-enum cdc_char_format {
-	CDC_STOP_BITS_1 = 0,	//!< 1 stop bit
-	CDC_STOP_BITS_1_5 = 1,	//!< 1.5 stop bits
-	CDC_STOP_BITS_2 = 2,	//!< 2 stop bits
-};
-//! Possible values of bParityType
-enum cdc_parity {
-	CDC_PAR_NONE = 0,	//!< No parity
-	CDC_PAR_ODD = 1,	//!< Odd parity
-	CDC_PAR_EVEN = 2,	//!< Even parity
-	CDC_PAR_MARK = 3,	//!< Parity forced to 0 (space)
-	CDC_PAR_SPACE = 4,	//!< Parity forced to 1 (mark)
-};
-//@}
-
-//! \name USB CDC control signals
-//! spec 1.1 chapter 6.2.14
-//@{
-
-//! Control signal structure
-typedef struct {
-	uint16_t value;
-} usb_cdc_control_signal_t;
-
-//! \name Possible values in usb_cdc_control_signal_t
-//@{
-//! Carrier control for half duplex modems.
-//! This signal corresponds to V.24 signal 105 and RS-232 signal RTS.
-//! The device ignores the value of this bit
-//! when operating in full duplex mode.
-#define  CDC_CTRL_SIGNAL_ACTIVATE_CARRIER    (1 << 1)
-//! Indicates to DCE if DTE is present or not.
-//! This signal corresponds to V.24 signal 108/2 and RS-232 signal DTR.
-#define  CDC_CTRL_SIGNAL_DTE_PRESENT         (1 << 0)
-//@}
-//@}
-
-
-//! \name USB CDC notification message
-//@{
-
-typedef struct {
-	uint8_t bmRequestType;
-	uint8_t bNotification;
-	le16_t wValue;
-	le16_t wIndex;
-	le16_t wLength;
-} usb_cdc_notify_msg_t;
-
-//! \name USB CDC serial state
-//@{*
-
-//! Hardware handshake support (cdc spec 1.1 chapter 6.3.5)
-typedef struct {
-	usb_cdc_notify_msg_t header;
-	le16_t value;
-} usb_cdc_notify_serial_state_t;
-
-//! \name Possible values in usb_cdc_notify_serial_state_t
-//@{
-#define  CDC_SERIAL_STATE_DCD       CPU_TO_LE16((1<<0))
-#define  CDC_SERIAL_STATE_DSR       CPU_TO_LE16((1<<1))
-#define  CDC_SERIAL_STATE_BREAK     CPU_TO_LE16((1<<2))
-#define  CDC_SERIAL_STATE_RING      CPU_TO_LE16((1<<3))
-#define  CDC_SERIAL_STATE_FRAMING   CPU_TO_LE16((1<<4))
-#define  CDC_SERIAL_STATE_PARITY    CPU_TO_LE16((1<<5))
-#define  CDC_SERIAL_STATE_OVERRUN   CPU_TO_LE16((1<<6))
-//@}
-//! @}
-
-//! @}
-
-COMPILER_PACK_RESET()
-
-//! @}
-
-#endif // _USB_PROTOCOL_CDC_H_
diff --git a/Marlin/src/HAL/DUE/usb/usb_protocol_msc.h b/Marlin/src/HAL/DUE/usb/usb_protocol_msc.h
deleted file mode 100644
index e1e5923..0000000
--- a/Marlin/src/HAL/DUE/usb/usb_protocol_msc.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/**
- * \file
- *
- * \brief USB Mass Storage Class (MSC) protocol definitions.
- *
- * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _USB_PROTOCOL_MSC_H_
-#define _USB_PROTOCOL_MSC_H_
-
-
-/**
- * \ingroup usb_protocol_group
- * \defgroup usb_msc_protocol USB Mass Storage Class (MSC) protocol definitions
- *
- * @{
- */
-
-/**
- * \name Possible Class value
- */
-//@{
-#define  MSC_CLASS                  0x08
-//@}
-
-/**
- * \name Possible SubClass value
- * \note In practise, most devices should use
- * #MSC_SUBCLASS_TRANSPARENT and specify the actual command set in
- * the standard INQUIRY data block, even if the MSC spec indicates
- * otherwise. In particular, RBC is not supported by certain major
- * operating systems like Windows XP.
- */
-//@{
-#define  MSC_SUBCLASS_RBC           0x01	//!< Reduced Block Commands
-#define  MSC_SUBCLASS_ATAPI         0x02	//!< CD/DVD devices
-#define  MSC_SUBCLASS_QIC_157       0x03	//!< Tape devices
-#define  MSC_SUBCLASS_UFI           0x04	//!< Floppy disk drives
-#define  MSC_SUBCLASS_SFF_8070I     0x05	//!< Floppy disk drives
-#define  MSC_SUBCLASS_TRANSPARENT   0x06	//!< Determined by INQUIRY
-//@}
-
-/**
- * \name Possible protocol value
- * \note Only the BULK protocol should be used in new designs.
- */
-//@{
-#define  MSC_PROTOCOL_CBI           0x00	//!< Command/Bulk/Interrupt
-#define  MSC_PROTOCOL_CBI_ALT       0x01	//!< W/o command completion
-#define  MSC_PROTOCOL_BULK          0x50	//!< Bulk-only
-//@}
-
-
-/**
- * \brief MSC USB requests (bRequest)
- */
-enum usb_reqid_msc {
-	USB_REQ_MSC_BULK_RESET = 0xFF,	//!< Mass Storage Reset
-	USB_REQ_MSC_GET_MAX_LUN = 0xFE 	//!< Get Max LUN
-};
-
-
-COMPILER_PACK_SET(1)
-
-/**
- * \name A Command Block Wrapper (CBW).
- */
-//@{
-struct usb_msc_cbw {
-	le32_t dCBWSignature;	//!< Must contain 'USBC'
-	le32_t dCBWTag;	//!< Unique command ID
-	le32_t dCBWDataTransferLength;	//!< Number of bytes to transfer
-	uint8_t bmCBWFlags;	//!< Direction in bit 7
-	uint8_t bCBWLUN;	//!< Logical Unit Number
-	uint8_t bCBWCBLength;	//!< Number of valid CDB bytes
-	uint8_t CDB[16];	//!< SCSI Command Descriptor Block
-};
-
-#define  USB_CBW_SIGNATURE          0x55534243	//!< dCBWSignature value
-#define  USB_CBW_DIRECTION_IN       (1<<7)	//!< Data from device to host
-#define  USB_CBW_DIRECTION_OUT      (0<<7)	//!< Data from host to device
-#define  USB_CBW_LUN_MASK           0x0F	//!< Valid bits in bCBWLUN
-#define  USB_CBW_LEN_MASK           0x1F	//!< Valid bits in bCBWCBLength
-//@}
-
-
-/**
- * \name A Command Status Wrapper (CSW).
- */
-//@{
-struct usb_msc_csw {
-	le32_t dCSWSignature;	//!< Must contain 'USBS'
-	le32_t dCSWTag;	//!< Same as dCBWTag
-	le32_t dCSWDataResidue;	//!< Number of bytes not transferred
-	uint8_t bCSWStatus;	//!< Status code
-};
-
-#define  USB_CSW_SIGNATURE          0x55534253	//!< dCSWSignature value
-#define  USB_CSW_STATUS_PASS        0x00	//!< Command Passed
-#define  USB_CSW_STATUS_FAIL        0x01	//!< Command Failed
-#define  USB_CSW_STATUS_PE          0x02	//!< Phase Error
-//@}
-
-COMPILER_PACK_RESET()
-
-//@}
-
-#endif // _USB_PROTOCOL_MSC_H_
diff --git a/Marlin/src/HAL/DUE/usb/usb_task.c b/Marlin/src/HAL/DUE/usb/usb_task.c
deleted file mode 100644
index 54a808d..0000000
--- a/Marlin/src/HAL/DUE/usb/usb_task.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/**
- * \file
- *
- * \brief Main functions for USB composite example
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-
-// Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
-
-#ifdef ARDUINO_ARCH_SAM
-
-#include <Arduino.h>
-#include <Reset.h>
-
-#include "conf_usb.h"
-#include "udc.h"
-
-#if ENABLED(SDSUPPORT)
-  static volatile bool main_b_msc_enable = false;
-#endif
-static volatile bool main_b_cdc_enable = false;
-static volatile bool main_b_dtr_active = false;
-
-void usb_task_idle(void) {
-  #if ENABLED(SDSUPPORT)
-    // Attend SD card access from the USB MSD -- Prioritize access to improve speed
-    int delay = 2;
-    while (main_b_msc_enable && --delay > 0) {
-      if (udi_msc_process_trans()) delay = 10000;
-
-      // Reset the watchdog, just to be sure
-      REG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);
-    }
-  #endif
-}
-
-#if ENABLED(SDSUPPORT)
-  bool usb_task_msc_enable(void)                { return ((main_b_msc_enable = true)); }
-  void usb_task_msc_disable(void)               { main_b_msc_enable = false; }
-  bool usb_task_msc_isenabled(void)             { return main_b_msc_enable; }
-#endif
-
-bool usb_task_cdc_enable(const uint8_t port)  { UNUSED(port); return ((main_b_cdc_enable = true)); }
-void usb_task_cdc_disable(const uint8_t port) { UNUSED(port); main_b_cdc_enable = false; main_b_dtr_active = false; }
-bool usb_task_cdc_isenabled(void)             { return main_b_cdc_enable; }
-
-/*! \brief Called by CDC interface
- * Callback running when CDC device have received data
- */
-void usb_task_cdc_rx_notify(const uint8_t port) { UNUSED(port); }
-
-/*! \brief Configures communication line
- *
- * \param cfg      line configuration
- */
-static uint16_t dwDTERate = 0;
-void usb_task_cdc_config(const uint8_t port, usb_cdc_line_coding_t *cfg) {
-  UNUSED(port);
-  // Store last DTE rate
-  dwDTERate = cfg->dwDTERate;
-}
-
-void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable) {
-  UNUSED(port);
-  // Keep DTR status
-  main_b_dtr_active = b_enable;
-
-  //  Implement Arduino-Compatible kludge to enter programming mode from
-  // the native port:
-  //  "Auto-reset into the bootloader is triggered when the port, already
-  // open at 1200 bps, is closed."
-
-  if (1200 == dwDTERate) {
-    // We check DTR state to determine if host port is open (bit 0 of lineState).
-    if (!b_enable) {
-
-      // Set RST pin to go low for 65535 clock cycles on reset
-      //  This helps restarting when firmware flash ends
-      RSTC->RSTC_MR = 0xA5000F01;
-
-      // Schedule delayed reset
-      initiateReset(250);
-    }
-    else
-      cancelReset();
-  }
-}
-
-bool usb_task_cdc_dtr_active(void)             { return main_b_dtr_active; }
-
-/// Microsoft WCID descriptor
-typedef struct USB_MicrosoftCompatibleDescriptor_Interface {
-  uint8_t bFirstInterfaceNumber;
-  uint8_t reserved1;
-  uint8_t compatibleID[8];
-  uint8_t subCompatibleID[8];
-  uint8_t reserved2[6];
-} __attribute__((packed)) USB_MicrosoftCompatibleDescriptor_Interface;
-
-typedef struct USB_MicrosoftCompatibleDescriptor {
-  uint32_t dwLength;
-  uint16_t bcdVersion;
-  uint16_t wIndex;
-  uint8_t bCount;
-  uint8_t reserved[7];
-  USB_MicrosoftCompatibleDescriptor_Interface interfaces[];
-} __attribute__((packed)) USB_MicrosoftCompatibleDescriptor;
-
-// 3D Printer compatible descriptor
-static USB_MicrosoftCompatibleDescriptor microsoft_compatible_id_descriptor = {
-  .dwLength = sizeof(USB_MicrosoftCompatibleDescriptor) +
-              1*sizeof(USB_MicrosoftCompatibleDescriptor_Interface),
-  .bcdVersion = 0x0100,
-  .wIndex = 0x0004,
-  .bCount = 1,
-  .reserved = {0, 0, 0, 0, 0, 0, 0},
-  .interfaces = {
-    {
-      .bFirstInterfaceNumber = 0,
-      .reserved1 = 1,
-      .compatibleID = "3DPRINT",
-      .subCompatibleID = {0, 0, 0, 0, 0, 0, 0, 0},
-      .reserved2 = {0, 0, 0, 0, 0, 0},
-    }
-  }
-};
-
-#define xstr(s) str(s)
-#define str(s) #s
-
-#define MS3DPRINT_CONFIG      u"MS3DPrintConfig"
-#define MS3DPRINT_CONFIG_DATA \
-  u"Base=SD\0"\
-  u"Job3DOutputAreaWidth=" xstr(X_BED_SIZE) "000\0"\
-  u"Job3DOutputAreaDepth=" xstr(Y_BED_SIZE) "000\0"\
-  u"Job3DOutputAreaHeight=" xstr(Z_MAX_POS) "000\0"\
-  u"filamentdiameter=1750\0"
-
-typedef struct USB_MicrosoftExtendedPropertiesDescriptor {
-  uint32_t  dwLength;
-  uint16_t  bcdVersion;
-  uint16_t  wIndex;
-  uint16_t  bCount;
-  uint32_t  dwPropertySize;
-  uint32_t  dwPropertyDataType;
-  uint16_t  wPropertyNameLength;
-  uint16_t  PropertyName[sizeof(MS3DPRINT_CONFIG)/sizeof(uint16_t)];
-  uint32_t  dwPropertyDataLength;
-  uint16_t  PropertyData[sizeof(MS3DPRINT_CONFIG_DATA)/sizeof(uint16_t)];
-} __attribute__((packed)) USB_MicrosoftExtendedPropertiesDescriptor;
-
-static USB_MicrosoftExtendedPropertiesDescriptor microsoft_extended_properties_descriptor = {
-  .dwLength = sizeof(USB_MicrosoftExtendedPropertiesDescriptor),
-  .bcdVersion = 0x0100,
-  .wIndex = 0x0005,
-  .bCount = 1,
-
-  .dwPropertySize = 4 + 4 + 2 + 4 + sizeof(MS3DPRINT_CONFIG) + sizeof(MS3DPRINT_CONFIG_DATA),
-  .dwPropertyDataType = 7, // (1=REG_SZ, 4=REG_DWORD, 7=REG_MULTI_SZ)
-  .wPropertyNameLength = sizeof(MS3DPRINT_CONFIG),
-  .PropertyName = MS3DPRINT_CONFIG,
-  .dwPropertyDataLength = sizeof(MS3DPRINT_CONFIG_DATA),
-  .PropertyData = MS3DPRINT_CONFIG_DATA
-};
-
-/**************************************************************************************************
-** WCID configuration information
-** Hooked into UDC via UDC_GET_EXTRA_STRING #define.
-*/
-bool usb_task_extra_string(void) {
-  static uint8_t udi_msft_magic[] = "MSFT100\xEE";
-  static uint8_t udi_cdc_name[] = "CDC interface";
-  #if ENABLED(SDSUPPORT)
-    static uint8_t udi_msc_name[] = "MSC interface";
-  #endif
-
-  struct extra_strings_desc_t {
-    usb_str_desc_t header;
-    #if ENABLED(SDSUPPORT)
-      le16_t string[Max(Max(sizeof(udi_cdc_name) - 1, sizeof(udi_msc_name) - 1), sizeof(udi_msft_magic) - 1)];
-    #else
-      le16_t string[Max(sizeof(udi_cdc_name) - 1, sizeof(udi_msft_magic) - 1)];
-    #endif
-  };
-  static UDC_DESC_STORAGE struct extra_strings_desc_t extra_strings_desc = {
-    .header.bDescriptorType = USB_DT_STRING
-  };
-
-  uint8_t *str;
-  uint8_t str_lgt = 0;
-
-  // Link payload pointer to the string corresponding at request
-  switch (udd_g_ctrlreq.req.wValue & 0xFF) {
-  case UDI_CDC_IAD_STRING_ID:
-    str_lgt = sizeof(udi_cdc_name) - 1;
-    str = udi_cdc_name;
-    break;
-  #if ENABLED(SDSUPPORT)
-    case UDI_MSC_STRING_ID:
-      str_lgt = sizeof(udi_msc_name) - 1;
-      str = udi_msc_name;
-      break;
-  #endif
-  case 0xEE:
-    str_lgt = sizeof(udi_msft_magic) - 1;
-    str = udi_msft_magic;
-    break;
-  default:
-    return false;
-  }
-
-  for (uint8_t i = 0; i < str_lgt; i++)
-    extra_strings_desc.string[i] = cpu_to_le16((le16_t)str[i]);
-
-  extra_strings_desc.header.bLength = 2 + str_lgt * 2;
-  udd_g_ctrlreq.payload_size = extra_strings_desc.header.bLength;
-  udd_g_ctrlreq.payload = (uint8_t*)&extra_strings_desc;
-
-  // if the string is larger than request length, then cut it
-  if (udd_g_ctrlreq.payload_size > udd_g_ctrlreq.req.wLength) {
-    udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
-  }
-
-  return true;
-}
-
-/**************************************************************************************************
-** Handle device requests that the ASF stack doesn't
-*/
-bool usb_task_other_requests(void) {
-  uint8_t *ptr = 0;
-  uint16_t size = 0;
-
-  if (Udd_setup_type() == USB_REQ_TYPE_VENDOR) {
-    //if (udd_g_ctrlreq.req.bRequest == 0x30)
-    if (1) {
-      if (udd_g_ctrlreq.req.wIndex == 0x04) {
-        ptr = (uint8_t*)&microsoft_compatible_id_descriptor;
-        size = (udd_g_ctrlreq.req.wLength);
-        if (size > microsoft_compatible_id_descriptor.dwLength)
-          size = microsoft_compatible_id_descriptor.dwLength;
-      }
-      else if (udd_g_ctrlreq.req.wIndex == 0x05) {
-        ptr = (uint8_t*)&microsoft_extended_properties_descriptor;
-        size = (udd_g_ctrlreq.req.wLength);
-        if (size > microsoft_extended_properties_descriptor.dwLength)
-          size = microsoft_extended_properties_descriptor.dwLength;
-      }
-      else
-        return false;
-    }
-  }
-
-  udd_g_ctrlreq.payload_size = size;
-  if (size == 0) {
-    udd_g_ctrlreq.callback = 0;
-    udd_g_ctrlreq.over_under_run = 0;
-  }
-  else
-    udd_g_ctrlreq.payload = ptr;
-
-  return true;
-}
-
-void usb_task_init(void) {
-
-  uint16_t *ptr;
-
-  // Disable USB peripheral so we start clean and avoid lockups
-  otg_disable();
-  udd_disable();
-
-  // Set the USB interrupt to our stack
-  UDD_SetStack(&USBD_ISR);
-
-  // Start USB stack to authorize VBus monitoring
-  udc_start();
-
-  // Patch in filament diameter - Be careful: String is in UNICODE (2bytes per char)
-  ptr = &microsoft_extended_properties_descriptor.PropertyData[0];
-  while (ptr[0] || ptr[1]) { // Double 0 flags end of resource
-
-    // Found the filamentdiameter= unicode string
-    if (ptr[0] == 'r' && ptr[1] == '=') {
-      char diam[16];
-      char *sptr;
-
-      // Patch in the filament diameter
-      itoa((int)((DEFAULT_NOMINAL_FILAMENT_DIA) * 1000), diam, 10);
-
-      // And copy it to the proper place, expanding it to unicode
-      sptr = &diam[0];
-      ptr += 2;
-      while (*sptr) *ptr++ = *sptr++;
-
-      // Done!
-      break;
-    }
-
-    // Go to the next character
-    ptr++;
-  }
-}
-
-#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/usb/usb_task.h b/Marlin/src/HAL/DUE/usb/usb_task.h
deleted file mode 100644
index e9831ae..0000000
--- a/Marlin/src/HAL/DUE/usb/usb_task.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * \file
- *
- * \brief Declaration of main function used by Composite example 4
- *
- * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * 4. This software may only be redistributed and used in connection with an
- *    Atmel microcontroller product.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-/*
- * Support and FAQ: visit <a href="https://www.atmel.com/design-support/">Atmel Support</a>
- */
-
-#ifndef _USB_TASK_H_
-#define _USB_TASK_H_
-
-#include "usb_protocol_cdc.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*! \brief Called by MSC interface
- * Callback running when USB Host enable MSC interface
- *
- * \retval true if MSC startup is ok
- */
-bool usb_task_msc_enable(void);
-
-/*! \brief Called by MSC interface
- * Callback running when USB Host disable MSC interface
- */
-void usb_task_msc_disable(void);
-
-/*! \brief Opens the communication port
- * This is called by CDC interface when USB Host enable it.
- *
- * \retval true if cdc startup is successfully done
- */
-bool usb_task_cdc_enable(const uint8_t port);
-
-/*! \brief Closes the communication port
- * This is called by CDC interface when USB Host disable it.
- */
-void usb_task_cdc_disable(const uint8_t port);
-
-/*! \brief Save new DTR state to change led behavior.
- * The DTR notify that the terminal have open or close the communication port.
- */
-void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable);
-
-/*! \brief Check if MSC is enumerated and configured on the PC side
- */
-bool usb_task_msc_isenabled(void);
-
-/*! \brief Check if CDC is enumerated and configured on the PC side
- */
-bool usb_task_cdc_isenabled(void);
-
-/*! \brief Check if CDC is actually OPEN by an application on the PC side
- *  assuming DTR signal means a program is listening to messages
- */
-bool usb_task_cdc_dtr_active(void);
-
-/*! \brief Called by UDC when USB Host request a extra string different
- * of this specified in USB device descriptor
- */
-bool usb_task_extra_string(void);
-
-/*! \brief Called by UDC when USB Host performs unknown requests
- */
-bool usb_task_other_requests(void);
-
-/*! \brief Called by CDC interface
- * Callback running when CDC device have received data
- */
-void usb_task_cdc_rx_notify(const uint8_t port);
-
-/*! \brief Configures communication line
- *
- * \param cfg      line configuration
- */
-void usb_task_cdc_config(const uint8_t port, usb_cdc_line_coding_t *cfg);
-
-/*! \brief The USB device interrupt
- */
-void USBD_ISR(void);
-
-/*! \brief USB task init
- */
-void usb_task_init(void);
-
-/*! \brief USB task idle
- */
-void usb_task_idle(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // _USB_TASK_H_
diff --git a/Marlin/src/HAL/ESP32/FlushableHardwareSerial.cpp b/Marlin/src/HAL/ESP32/FlushableHardwareSerial.cpp
deleted file mode 100644
index 1456622..0000000
--- a/Marlin/src/HAL/ESP32/FlushableHardwareSerial.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "FlushableHardwareSerial.h"
-
-Serial1Class<FlushableHardwareSerial> flushableSerial(false, 0);
-
-#endif
diff --git a/Marlin/src/HAL/ESP32/FlushableHardwareSerial.h b/Marlin/src/HAL/ESP32/FlushableHardwareSerial.h
deleted file mode 100644
index 012dda8..0000000
--- a/Marlin/src/HAL/ESP32/FlushableHardwareSerial.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <HardwareSerial.h>
-
-#include "../shared/Marduino.h"
-#include "../../core/serial_hook.h"
-
-class FlushableHardwareSerial : public HardwareSerial {
-public:
-  FlushableHardwareSerial(int uart_nr) : HardwareSerial(uart_nr) {}
-};
-
-extern Serial1Class<FlushableHardwareSerial> flushableSerial;
diff --git a/Marlin/src/HAL/ESP32/HAL.cpp b/Marlin/src/HAL/ESP32/HAL.cpp
deleted file mode 100644
index 29f3be3..0000000
--- a/Marlin/src/HAL/ESP32/HAL.cpp
+++ /dev/null
@@ -1,429 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-
-#include <rom/rtc.h>
-#include <driver/adc.h>
-#include <esp_adc_cal.h>
-#include <HardwareSerial.h>
-
-#if ENABLED(USE_ESP32_TASK_WDT)
-  #include <esp_task_wdt.h>
-#endif
-
-#if ENABLED(WIFISUPPORT)
-  #include <ESPAsyncWebServer.h>
-  #include "wifi.h"
-  #if ENABLED(OTASUPPORT)
-    #include "ota.h"
-  #endif
-  #if ENABLED(WEBSUPPORT)
-    #include "spiffs.h"
-    #include "web.h"
-  #endif
-#endif
-
-#if ENABLED(ESP3D_WIFISUPPORT)
-  DefaultSerial1 MSerial0(false, Serial2Socket);
-#endif
-
-// ------------------------
-// Externs
-// ------------------------
-
-portMUX_TYPE MarlinHAL::spinlock = portMUX_INITIALIZER_UNLOCKED;
-
-// ------------------------
-// Local defines
-// ------------------------
-
-#define V_REF 1100
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-uint16_t MarlinHAL::adc_result;
-pwm_pin_t MarlinHAL::pwm_pin_data[MAX_EXPANDER_BITS];
-
-// ------------------------
-// Private Variables
-// ------------------------
-
-esp_adc_cal_characteristics_t characteristics[ADC_ATTEN_MAX];
-adc_atten_t attenuations[ADC1_CHANNEL_MAX] = {};
-uint32_t thresholds[ADC_ATTEN_MAX];
-
-volatile int numPWMUsed = 0;
-volatile struct { pin_t pin; int value; } pwmState[MAX_PWM_PINS];
-
-pin_t chan_pin[CHANNEL_MAX_NUM + 1] = { 0 }; // PWM capable IOpins - not 0 or >33 on ESP32
-
-struct {
-  uint32_t freq; // ledcReadFreq doesn't work if a duty hasn't been set yet!
-  uint16_t res;
-} pwmInfo[(CHANNEL_MAX_NUM + 1) / 2];
-
-// ------------------------
-// Public functions
-// ------------------------
-
-#if ENABLED(WIFI_CUSTOM_COMMAND)
-
-  bool wifi_custom_command(char * const command_ptr) {
-    #if ENABLED(ESP3D_WIFISUPPORT)
-      return esp3dlib.parse(command_ptr);
-    #else
-      UNUSED(command_ptr);
-      return false;
-    #endif
-  }
-
-#endif
-
-#if ENABLED(USE_ESP32_EXIO)
-
-  HardwareSerial YSerial2(2);
-
-  void Write_EXIO(uint8_t IO, uint8_t v) {
-    if (hal.isr_state()) {
-      hal.isr_off();
-      YSerial2.write(0x80 | (((char)v) << 5) | (IO - 100));
-      hal.isr_on();
-    }
-    else
-      YSerial2.write(0x80 | (((char)v) << 5) | (IO - 100));
-  }
-
-#endif
-
-void MarlinHAL::init_board() {
-  #if ENABLED(USE_ESP32_TASK_WDT)
-    esp_task_wdt_init(10, true);
-  #endif
-  #if ENABLED(ESP3D_WIFISUPPORT)
-    esp3dlib.init();
-  #elif ENABLED(WIFISUPPORT)
-    wifi_init();
-    TERN_(OTASUPPORT, OTA_init());
-    #if ENABLED(WEBSUPPORT)
-      spiffs_init();
-      web_init();
-    #endif
-    server.begin();
-  #endif
-
-  // ESP32 uses a GPIO matrix that allows pins to be assigned to hardware serial ports.
-  // The following code initializes hardware Serial1 and Serial2 to use user-defined pins
-  // if they have been defined.
-  #if defined(HARDWARE_SERIAL1_RX) && defined(HARDWARE_SERIAL1_TX)
-    HardwareSerial Serial1(1);
-    #ifdef TMC_BAUD_RATE  // use TMC_BAUD_RATE for Serial1 if defined
-      Serial1.begin(TMC_BAUD_RATE, SERIAL_8N1, HARDWARE_SERIAL1_RX, HARDWARE_SERIAL1_TX);
-    #else  // use default BAUDRATE if TMC_BAUD_RATE not defined
-      Serial1.begin(BAUDRATE, SERIAL_8N1, HARDWARE_SERIAL1_RX, HARDWARE_SERIAL1_TX);
-    #endif
-  #endif
-  #if defined(HARDWARE_SERIAL2_RX) && defined(HARDWARE_SERIAL2_TX)
-    HardwareSerial Serial2(2);
-    #ifdef TMC_BAUD_RATE  // use TMC_BAUD_RATE for Serial1 if defined
-      Serial2.begin(TMC_BAUD_RATE, SERIAL_8N1, HARDWARE_SERIAL2_RX, HARDWARE_SERIAL2_TX);
-    #else  // use default BAUDRATE if TMC_BAUD_RATE not defined
-      Serial2.begin(BAUDRATE, SERIAL_8N1, HARDWARE_SERIAL2_RX, HARDWARE_SERIAL2_TX);
-    #endif
-  #endif
-
-  // Initialize the i2s peripheral only if the I2S stepper stream is enabled.
-  // The following initialization is performed after Serial1 and Serial2 are defined as
-  // their native pins might conflict with the i2s stream even when they are remapped.
-  #if ENABLED(USE_ESP32_EXIO)
-    YSerial2.begin(460800 * 3, SERIAL_8N1, 16, 17);
-  #elif ENABLED(I2S_STEPPER_STREAM)
-    i2s_init();
-  #endif
-}
-
-void MarlinHAL::idletask() {
-  #if BOTH(WIFISUPPORT, OTASUPPORT)
-    OTA_handle();
-  #endif
-  TERN_(ESP3D_WIFISUPPORT, esp3dlib.idletask());
-}
-
-uint8_t MarlinHAL::get_reset_source() { return rtc_get_reset_reason(1); }
-
-void MarlinHAL::reboot() { ESP.restart(); }
-
-void _delay_ms(int delay_ms) { delay(delay_ms); }
-
-// return free memory between end of heap (or end bss) and whatever is current
-int MarlinHAL::freeMemory() { return ESP.getFreeHeap(); }
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  #define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
-
-  extern "C" {
-    esp_err_t esp_task_wdt_reset();
-  }
-
-  void watchdogSetup() {
-    // do whatever. don't remove this function.
-  }
-
-  void MarlinHAL::watchdog_init() {
-    // TODO
-  }
-
-  // Reset watchdog.
-  void MarlinHAL::watchdog_refresh() { esp_task_wdt_reset(); }
-
-#endif
-
-// ------------------------
-// ADC
-// ------------------------
-
-#define ADC1_CHANNEL(pin) ADC1_GPIO ## pin ## _CHANNEL
-
-adc1_channel_t get_channel(int pin) {
-  switch (pin) {
-    case 39: return ADC1_CHANNEL(39);
-    case 36: return ADC1_CHANNEL(36);
-    case 35: return ADC1_CHANNEL(35);
-    case 34: return ADC1_CHANNEL(34);
-    case 33: return ADC1_CHANNEL(33);
-    case 32: return ADC1_CHANNEL(32);
-  }
-  return ADC1_CHANNEL_MAX;
-}
-
-void adc1_set_attenuation(adc1_channel_t chan, adc_atten_t atten) {
-  if (attenuations[chan] != atten) {
-    adc1_config_channel_atten(chan, atten);
-    attenuations[chan] = atten;
-  }
-}
-
-void MarlinHAL::adc_init() {
-  // Configure ADC
-  adc1_config_width(ADC_WIDTH_12Bit);
-
-  // Configure channels only if used as (re-)configuring a pin for ADC that is used elsewhere might have adverse effects
-  TERN_(HAS_TEMP_ADC_0,        adc1_set_attenuation(get_channel(TEMP_0_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_1,        adc1_set_attenuation(get_channel(TEMP_1_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_2,        adc1_set_attenuation(get_channel(TEMP_2_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_3,        adc1_set_attenuation(get_channel(TEMP_3_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_4,        adc1_set_attenuation(get_channel(TEMP_4_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_5,        adc1_set_attenuation(get_channel(TEMP_5_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_6,        adc2_set_attenuation(get_channel(TEMP_6_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_ADC_7,        adc3_set_attenuation(get_channel(TEMP_7_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_HEATED_BED,        adc1_set_attenuation(get_channel(TEMP_BED_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_CHAMBER,      adc1_set_attenuation(get_channel(TEMP_CHAMBER_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_PROBE,        adc1_set_attenuation(get_channel(TEMP_PROBE_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_COOLER,       adc1_set_attenuation(get_channel(TEMP_COOLER_PIN), ADC_ATTEN_11db));
-  TERN_(HAS_TEMP_BOARD,        adc1_set_attenuation(get_channel(TEMP_BOARD_PIN), ADC_ATTEN_11db));
-  TERN_(FILAMENT_WIDTH_SENSOR, adc1_set_attenuation(get_channel(FILWIDTH_PIN), ADC_ATTEN_11db));
-
-  // Note that adc2 is shared with the WiFi module, which has higher priority, so the conversion may fail.
-  // That's why we're not setting it up here.
-
-  // Calculate ADC characteristics (i.e., gain and offset factors for each attenuation level)
-  for (int i = 0; i < ADC_ATTEN_MAX; i++) {
-    esp_adc_cal_characterize(ADC_UNIT_1, (adc_atten_t)i, ADC_WIDTH_BIT_12, V_REF, &characteristics[i]);
-
-    // Change attenuation 100mV below the calibrated threshold
-    thresholds[i] = esp_adc_cal_raw_to_voltage(4095, &characteristics[i]);
-  }
-}
-
-#ifndef ADC_REFERENCE_VOLTAGE
-  #define ADC_REFERENCE_VOLTAGE 3.3
-#endif
-
-void MarlinHAL::adc_start(const pin_t pin) {
-  const adc1_channel_t chan = get_channel(pin);
-  uint32_t mv;
-  esp_adc_cal_get_voltage((adc_channel_t)chan, &characteristics[attenuations[chan]], &mv);
-
-  adc_result = mv * isr_float_t(1023) / isr_float_t(ADC_REFERENCE_VOLTAGE) / isr_float_t(1000);
-
-  // Change the attenuation level based on the new reading
-  adc_atten_t atten;
-  if (mv < thresholds[ADC_ATTEN_DB_0] - 100)
-    atten = ADC_ATTEN_DB_0;
-  else if (mv > thresholds[ADC_ATTEN_DB_0] - 50 && mv < thresholds[ADC_ATTEN_DB_2_5] - 100)
-    atten = ADC_ATTEN_DB_2_5;
-  else if (mv > thresholds[ADC_ATTEN_DB_2_5] - 50 && mv < thresholds[ADC_ATTEN_DB_6] - 100)
-    atten = ADC_ATTEN_DB_6;
-  else if (mv > thresholds[ADC_ATTEN_DB_6] - 50)
-    atten = ADC_ATTEN_DB_11;
-  else return;
-
-  adc1_set_attenuation(chan, atten);
-}
-
-// ------------------------
-// PWM
-// ------------------------
-
-int8_t channel_for_pin(const uint8_t pin) {
-  for (int i = 0; i <= CHANNEL_MAX_NUM; i++)
-    if (chan_pin[i] == pin) return i;
-  return -1;
-}
-
-// get PWM channel for pin - if none then attach a new one
-// return -1 if fail or invalid pin#, channel # (0-15) if success
-int8_t get_pwm_channel(const pin_t pin, const uint32_t freq, const uint16_t res) {
-  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return -1; // Not a hardware PWM pin!
-  int8_t cid = channel_for_pin(pin);
-  if (cid >= 0) return cid;
-
-  // Find an empty adjacent channel (same timer & freq/res)
-  for (int i = 0; i <= CHANNEL_MAX_NUM; i++) {
-    if (chan_pin[i] == 0) {
-      if (chan_pin[i ^ 0x1] != 0) {
-        if (pwmInfo[i / 2].freq == freq && pwmInfo[i / 2].res == res) {
-          chan_pin[i] = pin; // Allocate PWM to this channel
-          ledcAttachPin(pin, i);
-          return i;
-        }
-      }
-      else if (cid == -1)    // Pair of empty channels?
-        cid = i & 0xFE;      // Save lower channel number
-    }
-  }
-  // not attached, is an empty timer slot avail?
-  if (cid >= 0) {
-    chan_pin[cid] = pin;
-    pwmInfo[cid / 2].freq = freq;
-    pwmInfo[cid / 2].res = res;
-    ledcSetup(cid, freq, res);
-    ledcAttachPin(pin, cid);
-  }
-  return cid; // -1 if no channel avail
-}
-
-void MarlinHAL::set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size/*=_BV(PWM_RESOLUTION)-1*/, const bool invert/*=false*/) {
-  #if ENABLED(I2S_STEPPER_STREAM)
-    if (pin > 127) {
-      const uint8_t pinlo = pin & 0x7F;
-      pwm_pin_t &pindata = pwm_pin_data[pinlo];
-      const uint32_t duty = map(invert ? v_size - v : v, 0, v_size, 0, pindata.pwm_cycle_ticks);
-      if (duty == 0 || duty == pindata.pwm_cycle_ticks) { // max or min (i.e., on/off)
-        pindata.pwm_duty_ticks = 0;  // turn off PWM for this pin
-        duty ? SBI32(i2s_port_data, pinlo) : CBI32(i2s_port_data, pinlo); // set pin level
-      }
-      else
-        pindata.pwm_duty_ticks = duty; // PWM duty count = # of 4Âµs ticks per full PWM cycle
-    }
-    else
-  #endif
-    {
-      const int8_t cid = get_pwm_channel(pin, PWM_FREQUENCY, PWM_RESOLUTION);
-      if (cid >= 0) {
-        const uint32_t duty = map(invert ? v_size - v : v, 0, v_size, 0, _BV(PWM_RESOLUTION)-1);
-        ledcWrite(cid, duty);
-      }
-    }
-}
-
-int8_t MarlinHAL::set_pwm_frequency(const pin_t pin, const uint32_t f_desired) {
-  #if ENABLED(I2S_STEPPER_STREAM)
-    if (pin > 127) {
-      pwm_pin_data[pin & 0x7F].pwm_cycle_ticks = 1000000UL / f_desired / 4; // # of 4Âµs ticks per full PWM cycle
-      return 0;
-    }
-    else
-  #endif
-    {
-      const int8_t cid = channel_for_pin(pin);
-      if (cid >= 0) {
-        if (f_desired == ledcReadFreq(cid)) return cid; // no freq change
-        ledcDetachPin(chan_pin[cid]);
-        chan_pin[cid] = 0;              // remove old freq channel
-      }
-      return get_pwm_channel(pin, f_desired, PWM_RESOLUTION); // try for new one
-    }
-}
-
-// use hardware PWM if avail, if not then ISR
-void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/) { // always 8 bit resolution!
-  // Use ledc hardware for internal pins
-  const int8_t cid = get_pwm_channel(pin, freq, res);
-  if (cid >= 0) {
-    ledcWrite(cid, value); // set duty value
-    return;
-  }
-
-  // not a hardware PWM pin OR no PWM channels available
-  int idx = -1;
-
-  // Search Pin
-  for (int i = 0; i < numPWMUsed; ++i)
-    if (pwmState[i].pin == pin) { idx = i; break; }
-
-  // not found ?
-  if (idx < 0) {
-    // No slots remaining
-    if (numPWMUsed >= MAX_PWM_PINS) return;
-
-    // Take new slot for pin
-    idx = numPWMUsed;
-    pwmState[idx].pin = pin;
-    // Start timer on first use
-    if (idx == 0) HAL_timer_start(MF_TIMER_PWM, PWM_TIMER_FREQUENCY);
-
-    ++numPWMUsed;
-  }
-
-  // Use 7bit internal value - add 1 to have 100% high at 255
-  pwmState[idx].value = (value + 1) / 2;
-}
-
-// Handle PWM timer interrupt
-HAL_PWM_TIMER_ISR() {
-  HAL_timer_isr_prologue(MF_TIMER_PWM);
-
-  static uint8_t count = 0;
-
-  for (int i = 0; i < numPWMUsed; ++i) {
-    if (count == 0)                   // Start of interval
-      digitalWrite(pwmState[i].pin, pwmState[i].value ? HIGH : LOW);
-    else if (pwmState[i].value == count)   // End of duration
-      digitalWrite(pwmState[i].pin, LOW);
-  }
-
-  // 128 for 7 Bit resolution
-  count = (count + 1) & 0x7F;
-
-  HAL_timer_isr_epilogue(MF_TIMER_PWM);
-}
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/HAL.h b/Marlin/src/HAL/ESP32/HAL.h
deleted file mode 100644
index ddfedf9..0000000
--- a/Marlin/src/HAL/ESP32/HAL.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Espressif ESP32 WiFi
- */
-
-#define CPU_32_BIT
-
-#include <stdint.h>
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-
-#include "fastio.h"
-#include "i2s.h"
-
-#if ENABLED(WIFISUPPORT)
-  #include "WebSocketSerial.h"
-#endif
-
-#if ENABLED(ESP3D_WIFISUPPORT)
-  #include "esp3dlib.h"
-#endif
-
-#include "FlushableHardwareSerial.h"
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define MYSERIAL1 flushableSerial
-
-#if EITHER(WIFISUPPORT, ESP3D_WIFISUPPORT)
-  #if ENABLED(ESP3D_WIFISUPPORT)
-    typedef ForwardSerial1Class< decltype(Serial2Socket) > DefaultSerial1;
-    extern DefaultSerial1 MSerial0;
-    #define MYSERIAL2 MSerial0
-  #else
-    #define MYSERIAL2 webSocketSerial
-  #endif
-#endif
-
-#define CRITICAL_SECTION_START() portENTER_CRITICAL(&hal.spinlock)
-#define CRITICAL_SECTION_END()   portEXIT_CRITICAL(&hal.spinlock)
-
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
-#define PWM_FREQUENCY  1000u   // Default PWM frequency when set_pwm_duty() is called without set_pwm_frequency()
-#define PWM_RESOLUTION   10u   // Default PWM bit resolution
-#define CHANNEL_MAX_NUM  15u   // max PWM channel # to allocate (7 to only use low speed, 15 to use low & high)
-#define MAX_PWM_IOPIN    33u   // hardware pwm pins < 34
-#ifndef MAX_EXPANDER_BITS
-  #define MAX_EXPANDER_BITS 32 // I2S expander bit width (max 32)
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef double isr_float_t;   // FPU ops are used for single-precision, so use double for ISRs.
-typedef int16_t pin_t;
-
-typedef struct pwm_pin {
-  uint32_t pwm_cycle_ticks = 1000000UL / (PWM_FREQUENCY) / 4; // # ticks per pwm cycle
-  uint32_t pwm_tick_count = 0;  // current tick count
-  uint32_t pwm_duty_ticks = 0;  // # of ticks for current duty cycle
-} pwm_pin_t;
-
-class Servo;
-typedef Servo hal_servo_t;
-
-// ------------------------
-// Public functions
-// ------------------------
-
-//
-// Tone
-//
-void tone(const pin_t _pin, const unsigned int frequency, const unsigned long duration=0);
-void noTone(const pin_t _pin);
-int8_t get_pwm_channel(const pin_t pin, const uint32_t freq, const uint16_t res);
-void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq=PWM_FREQUENCY, const uint16_t res=8);
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-#if ENABLED(USE_ESP32_EXIO)
-  void Write_EXIO(uint8_t IO, uint8_t v);
-#endif
-
-//
-// Delay in cycles (used by DELAY_NS / DELAY_US)
-//
-FORCE_INLINE static void DELAY_CYCLES(uint32_t x) {
-  unsigned long start, ccount, stop;
-
-  /**
-   * It's important to care for race conditions (and overflows) here.
-   * Race condition example: If `stop` calculates to being close to the upper boundary of
-   * `uint32_t` and if at the same time a longer loop interruption kicks in (e.g. due to other
-   * FreeRTOS tasks or interrupts), `ccount` might overflow (and therefore be below `stop` again)
-   * without the loop ever being able to notice that `ccount` had already been above `stop` once
-   * (and that therefore the number of cycles to delay has already passed).
-   * As DELAY_CYCLES (through DELAY_NS / DELAY_US) is used by software SPI bit banging to drive
-   * LCDs and therefore might be called very, very often, this seemingly improbable situation did
-   * actually happen in reality. It resulted in apparently random print pauses of ~17.9 seconds
-   * (0x100000000 / 240 MHz) or multiples thereof, essentially ruining the current print by causing
-   * large blobs of filament.
-   */
-
-  __asm__ __volatile__ ( "rsr     %0, ccount" : "=a" (start) );
-  stop = start + x;
-  ccount = start;
-
-  if (stop >= start) {
-    // no overflow, so only loop while in between start and stop:
-    // 0x00000000 -----------------start****stop-- 0xFFFFFFFF
-    while (ccount >= start && ccount < stop) {
-      __asm__ __volatile__ ( "rsr     %0, ccount" : "=a" (ccount) );
-    }
-  }
-  else {
-    // stop did overflow, so only loop while outside of stop and start:
-    // 0x00000000 **stop-------------------start** 0xFFFFFFFF
-    while (ccount >= start || ccount < stop) {
-      __asm__ __volatile__ ( "rsr     %0, ccount" : "=a" (ccount) );
-    }
-  }
-
-}
-
-// ------------------------
-// Class Utilities
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-int freeMemory();
-
-#pragma GCC diagnostic pop
-
-void _delay_ms(const int ms);
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init() {}        // Called early in setup()
-  static void init_board();    // Called less early in setup()
-  static void reboot();        // Restart the firmware
-
-  // Interrupts
-  static portMUX_TYPE spinlock;
-  static bool isr_state() { return spinlock.owner == portMUX_FREE_VAL; }
-  static void isr_on()  { if (spinlock.owner != portMUX_FREE_VAL) portEXIT_CRITICAL(&spinlock); }
-  static void isr_off() { portENTER_CRITICAL(&spinlock); }
-
-  static void delay_ms(const int ms) { _delay_ms(ms); }
-
-  // Tasks, called from idle()
-  static void idletask();
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory();
-
-  static pwm_pin_t pwm_pin_data[MAX_EXPANDER_BITS];
-
-  //
-  // ADC Methods
-  //
-
-  static uint16_t adc_result;
-
-  // Called by Temperature::init once at startup
-  static void adc_init();
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const pin_t pin) {}
-
-  // Begin ADC sampling on the given pin. Called from Temperature::isr!
-  static void adc_start(const pin_t pin);
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value() { return adc_result; }
-
-  /**
-   * If not already allocated, allocate a hardware PWM channel
-   * to the pin and set the duty cycle..
-   * Optionally invert the duty cycle [default = false]
-   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
-
-  /**
-   * Allocate and set the frequency of a hardware PWM pin
-   * Returns -1 if no pin available.
-   */
-  static int8_t set_pwm_frequency(const pin_t pin, const uint32_t f_desired);
-
-};
diff --git a/Marlin/src/HAL/ESP32/HAL_SPI.cpp b/Marlin/src/HAL/ESP32/HAL_SPI.cpp
deleted file mode 100644
index 868ab1b..0000000
--- a/Marlin/src/HAL/ESP32/HAL_SPI.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- * Copyright (c) 2017 Victor Perez
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-
-#include "../shared/HAL_SPI.h"
-
-#include <pins_arduino.h>
-#include <SPI.h>
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-static SPISettings spiConfig;
-
-// ------------------------
-// Public functions
-// ------------------------
-
-#if ENABLED(SOFTWARE_SPI)
-
-  // ------------------------
-  // Software SPI
-  // ------------------------
-  #error "Software SPI not supported for ESP32. Use Hardware SPI."
-
-#else
-
-// ------------------------
-// Hardware SPI
-// ------------------------
-
-void spiBegin() {
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_SS)
-    OUT_WRITE(SD_SS_PIN, HIGH);
-  #endif
-}
-
-void spiInit(uint8_t spiRate) {
-  uint32_t clock;
-
-  switch (spiRate) {
-    case SPI_FULL_SPEED:      clock = 16000000; break;
-    case SPI_HALF_SPEED:      clock = 8000000;  break;
-    case SPI_QUARTER_SPEED:   clock = 4000000;  break;
-    case SPI_EIGHTH_SPEED:    clock = 2000000;  break;
-    case SPI_SIXTEENTH_SPEED: clock = 1000000;  break;
-    case SPI_SPEED_5:         clock = 500000;   break;
-    case SPI_SPEED_6:         clock = 250000;   break;
-    default:                  clock = 1000000; // Default from the SPI library
-  }
-
-  spiConfig = SPISettings(clock, MSBFIRST, SPI_MODE0);
-  SPI.begin();
-}
-
-uint8_t spiRec() {
-  SPI.beginTransaction(spiConfig);
-  uint8_t returnByte = SPI.transfer(0xFF);
-  SPI.endTransaction();
-  return returnByte;
-}
-
-void spiRead(uint8_t *buf, uint16_t nbyte) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transferBytes(0, buf, nbyte);
-  SPI.endTransaction();
-}
-
-void spiSend(uint8_t b) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(b);
-  SPI.endTransaction();
-}
-
-void spiSendBlock(uint8_t token, const uint8_t *buf) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(token);
-  SPI.writeBytes(const_cast<uint8_t*>(buf), 512);
-  SPI.endTransaction();
-}
-
-void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-  spiConfig = SPISettings(spiClock, bitOrder, dataMode);
-
-  SPI.beginTransaction(spiConfig);
-}
-
-#endif // !SOFTWARE_SPI
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/MarlinSPI.h b/Marlin/src/HAL/ESP32/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/ESP32/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/ESP32/Servo.cpp b/Marlin/src/HAL/ESP32/Servo.cpp
deleted file mode 100644
index ca3950d..0000000
--- a/Marlin/src/HAL/ESP32/Servo.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "Servo.h"
-
-// Adjacent channels (0/1, 2/3 etc.) share the same timer and therefore the same frequency and resolution settings on ESP32,
-// so we only allocate servo channels up high to avoid side effects with regards to analogWrite (fans, leds, laser pwm etc.)
-int Servo::channel_next_free = 12;
-
-Servo::Servo() {}
-
-int8_t Servo::attach(const int inPin) {
-  if (inPin > 0) pin = inPin;
-  channel = get_pwm_channel(pin, 50u, 16u);
-  return channel; // -1 if no PWM avail.
-}
-
-// leave channel connected to servo - set duty to zero
-void Servo::detach() {
-  if (channel >= 0) ledcWrite(channel, 0);
-}
-
-int Servo::read() { return degrees; }
-
-void Servo::write(int inDegrees) {
-  degrees = constrain(inDegrees, MIN_ANGLE, MAX_ANGLE);
-  int us = map(degrees, MIN_ANGLE, MAX_ANGLE, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
-  int duty = map(us, 0, TAU_USEC, 0, MAX_COMPARE);
-  if (channel >= 0) ledcWrite(channel, duty); // don't save duty for servos!
-}
-
-void Servo::move(const int value) {
-  constexpr uint16_t servo_delay[] = SERVO_DELAY;
-  static_assert(COUNT(servo_delay) == NUM_SERVOS, "SERVO_DELAY must be an array NUM_SERVOS long.");
-  if (attach(0) >= 0) {
-    write(value);
-    safe_delay(servo_delay[channel]);
-    TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());
-  }
-}
-#endif // HAS_SERVOS
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/Servo.h b/Marlin/src/HAL/ESP32/Servo.h
deleted file mode 100644
index 1dbb416..0000000
--- a/Marlin/src/HAL/ESP32/Servo.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <Arduino.h>
-
-class Servo {
-  static const int MIN_ANGLE =   0,
-                   MAX_ANGLE = 180,
-                   MIN_PULSE_WIDTH =  544,  // Shortest pulse sent to a servo
-                   MAX_PULSE_WIDTH = 2400,  // Longest pulse sent to a servo
-                   TAU_MSEC = 20,
-                   TAU_USEC = (TAU_MSEC * 1000),
-                   MAX_COMPARE = _BV(16) - 1; // 65535
-
-public:
-  Servo();
-  int8_t attach(const int pin);   // attach the given pin to the next free channel, set pinMode, return channel number (-1 on fail)
-  void detach();
-  void write(int degrees);        // set angle
-  void move(const int degrees);   // attach the servo, then move to value
-  int read();                     // returns current pulse width as an angle between 0 and 180 degrees
-
-private:
-  static int channel_next_free;
-  int channel;
-  int pin;
-  int degrees;
-};
diff --git a/Marlin/src/HAL/ESP32/Tone.cpp b/Marlin/src/HAL/ESP32/Tone.cpp
deleted file mode 100644
index 839c612..0000000
--- a/Marlin/src/HAL/ESP32/Tone.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * Copypaste of SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Description: Tone function for ESP32
- * Derived from https://forum.arduino.cc/index.php?topic=136500.msg2903012#msg2903012
- */
-
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-static pin_t tone_pin;
-volatile static int32_t toggles;
-
-void tone(const pin_t _pin, const unsigned int frequency, const unsigned long duration/*=0*/) {
-  tone_pin = _pin;
-  toggles = 2 * frequency * duration / 1000;
-  HAL_timer_start(MF_TIMER_TONE, 2 * frequency);
-}
-
-void noTone(const pin_t _pin) {
-  HAL_timer_disable_interrupt(MF_TIMER_TONE);
-  WRITE(_pin, LOW);
-}
-
-HAL_TONE_TIMER_ISR() {
-  HAL_timer_isr_prologue(MF_TIMER_TONE);
-
-  if (toggles) {
-    toggles--;
-    TOGGLE(tone_pin);
-  }
-  else noTone(tone_pin);                         // turn off interrupt
-}
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/WebSocketSerial.cpp b/Marlin/src/HAL/ESP32/WebSocketSerial.cpp
deleted file mode 100644
index eb5b9d6..0000000
--- a/Marlin/src/HAL/ESP32/WebSocketSerial.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if ENABLED(WIFISUPPORT)
-
-#include "WebSocketSerial.h"
-#include "wifi.h"
-#include <ESPAsyncWebServer.h>
-
-MSerialWebSocketT webSocketSerial(false);
-AsyncWebSocket ws("/ws"); // TODO Move inside the class.
-
-// RingBuffer impl
-
-#define NEXT_INDEX(I, SIZE) ((I + 1) & (ring_buffer_pos_t)(SIZE - 1))
-
-RingBuffer::RingBuffer(ring_buffer_pos_t size)
-  : data(new uint8_t[size]),
-    size(size),
-    read_index(0),
-    write_index(0)
-{}
-
-RingBuffer::~RingBuffer() { delete[] data; }
-
-ring_buffer_pos_t RingBuffer::write(const uint8_t c) {
-  const ring_buffer_pos_t n = NEXT_INDEX(write_index, size);
-
-  if (n != read_index) {
-    this->data[write_index] = c;
-    write_index = n;
-    return 1;
-  }
-
-  // TODO: buffer is full, handle?
-  return 0;
-}
-
-ring_buffer_pos_t RingBuffer::write(const uint8_t *buffer, ring_buffer_pos_t size) {
-  ring_buffer_pos_t written = 0;
-  for (ring_buffer_pos_t i = 0; i < size; i++) {
-    written += write(buffer[i]);
-  }
-  return written;
-}
-
-int RingBuffer::available() {
-  return (size - read_index + write_index) & (size - 1);
-}
-
-int RingBuffer::peek() {
-  return available() ? data[read_index] : -1;
-}
-
-int RingBuffer::read() {
-  if (available()) {
-    const int ret = data[read_index];
-    read_index = NEXT_INDEX(read_index, size);
-    return ret;
-  }
-  return -1;
-}
-
-ring_buffer_pos_t RingBuffer::read(uint8_t *buffer) {
-   ring_buffer_pos_t len = available();
-
-  for (ring_buffer_pos_t i = 0; read_index != write_index; i++) {
-    buffer[i] = data[read_index];
-    read_index = NEXT_INDEX(read_index, size);
-  }
-
-  return len;
-}
-
-void RingBuffer::flush() { read_index = write_index; }
-
-// WebSocketSerial impl
-WebSocketSerial::WebSocketSerial()
-    : rx_buffer(RingBuffer(RX_BUFFER_SIZE)),
-      tx_buffer(RingBuffer(TX_BUFFER_SIZE))
-{}
-
-void WebSocketSerial::begin(const long baud_setting) {
-  ws.onEvent([this](AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
-    switch (type) {
-      case WS_EVT_CONNECT: client->ping(); break; // client connected
-      case WS_EVT_DISCONNECT:                     // client disconnected
-      case WS_EVT_ERROR:                          // error was received from the other end
-      case WS_EVT_PONG: break;                    // pong message was received (in response to a ping request maybe)
-      case WS_EVT_DATA: {                         // data packet
-        AwsFrameInfo * info = (AwsFrameInfo*)arg;
-        if (info->opcode == WS_TEXT || info->message_opcode == WS_TEXT)
-          this->rx_buffer.write(data, len);
-      }
-    }
-  });
-  server.addHandler(&ws);
-}
-
-void WebSocketSerial::end() { }
-int WebSocketSerial::peek() { return rx_buffer.peek(); }
-int WebSocketSerial::read() { return rx_buffer.read(); }
-int WebSocketSerial::available() { return rx_buffer.available(); }
-void WebSocketSerial::flush() { rx_buffer.flush(); }
-
-size_t WebSocketSerial::write(const uint8_t c) {
-  size_t ret = tx_buffer.write(c);
-
-  if (ret && c == '\n') {
-    uint8_t tmp[TX_BUFFER_SIZE];
-    ring_buffer_pos_t size = tx_buffer.read(tmp);
-    ws.textAll(tmp, size);
-  }
-
-  return ret;
-}
-
-size_t WebSocketSerial::write(const uint8_t *buffer, size_t size) {
-  size_t written = 0;
-  for (size_t i = 0; i < size; i++)
-    written += write(buffer[i]);
-  return written;
-}
-
-#endif // WIFISUPPORT
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/WebSocketSerial.h b/Marlin/src/HAL/ESP32/WebSocketSerial.h
deleted file mode 100644
index 6b3e419..0000000
--- a/Marlin/src/HAL/ESP32/WebSocketSerial.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../inc/MarlinConfig.h"
-#include "../../core/serial_hook.h"
-
-#include <Stream.h>
-
-#ifndef TX_BUFFER_SIZE
-  #define TX_BUFFER_SIZE 32
-#endif
-#if ENABLED(WIFISUPPORT)
-  #ifndef RX_BUFFER_SIZE
-    #define RX_BUFFER_SIZE 128
-  #endif
-  #if TX_BUFFER_SIZE <= 0
-    #error "TX_BUFFER_SIZE is required for the WebSocket."
-  #endif
-#endif
-
-typedef uint16_t ring_buffer_pos_t;
-
-class RingBuffer {
-  uint8_t *data;
-  ring_buffer_pos_t size, read_index, write_index;
-
-public:
-  RingBuffer(ring_buffer_pos_t size);
-  ~RingBuffer();
-
-  int available();
-  int peek();
-  int read();
-  ring_buffer_pos_t read(uint8_t *buffer);
-  void flush();
-  ring_buffer_pos_t write(const uint8_t c);
-  ring_buffer_pos_t write(const uint8_t *buffer, ring_buffer_pos_t size);
-};
-
-class WebSocketSerial: public Stream {
-  RingBuffer rx_buffer;
-  RingBuffer tx_buffer;
-
-public:
-  WebSocketSerial();
-  void begin(const long);
-  void end();
-  int available();
-  int peek();
-  int read();
-  void flush();
-  size_t write(const uint8_t c);
-  size_t write(const uint8_t *buffer, size_t size);
-
-  #if ENABLED(SERIAL_STATS_DROPPED_RX)
-    FORCE_INLINE uint32_t dropped() { return 0; }
-  #endif
-
-  #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-    FORCE_INLINE int rxMaxEnqueued() { return 0; }
-  #endif
-};
-
-typedef Serial1Class<WebSocketSerial> MSerialWebSocketT;
-extern MSerialWebSocketT webSocketSerial;
diff --git a/Marlin/src/HAL/ESP32/eeprom.cpp b/Marlin/src/HAL/ESP32/eeprom.cpp
deleted file mode 100644
index cb5f881..0000000
--- a/Marlin/src/HAL/ESP32/eeprom.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(EEPROM_SETTINGS)
-
-#include "../shared/eeprom_api.h"
-#include <EEPROM.h>
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE 0x1000 // 4KB
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { return EEPROM.begin(MARLIN_EEPROM_SIZE); }
-bool PersistentStore::access_finish() { EEPROM.end(); return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  for (size_t i = 0; i < size; i++) {
-    EEPROM.write(pos++, value[i]);
-    crc16(crc, &value[i], 1);
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  for (size_t i = 0; i < size; i++) {
-    uint8_t c = EEPROM.read(pos++);
-    if (writing) value[i] = c;
-    crc16(crc, &c, 1);
-  }
-  return false;
-}
-
-#endif // EEPROM_SETTINGS
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/endstop_interrupts.h b/Marlin/src/HAL/ESP32/endstop_interrupts.h
deleted file mode 100644
index 0536864..0000000
--- a/Marlin/src/HAL/ESP32/endstop_interrupts.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the stepper-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void ICACHE_RAM_ATTR endstop_ISR() { endstops.update(); }
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  TERN_(HAS_X_MAX, _ATTACH(X_MAX_PIN));
-  TERN_(HAS_X_MIN, _ATTACH(X_MIN_PIN));
-  TERN_(HAS_Y_MAX, _ATTACH(Y_MAX_PIN));
-  TERN_(HAS_Y_MIN, _ATTACH(Y_MIN_PIN));
-  TERN_(HAS_Z_MAX, _ATTACH(Z_MAX_PIN));
-  TERN_(HAS_Z_MIN, _ATTACH(Z_MIN_PIN));
-  TERN_(HAS_X2_MAX, _ATTACH(X2_MAX_PIN));
-  TERN_(HAS_X2_MIN, _ATTACH(X2_MIN_PIN));
-  TERN_(HAS_Y2_MAX, _ATTACH(Y2_MAX_PIN));
-  TERN_(HAS_Y2_MIN, _ATTACH(Y2_MIN_PIN));
-  TERN_(HAS_Z2_MAX, _ATTACH(Z2_MAX_PIN));
-  TERN_(HAS_Z2_MIN, _ATTACH(Z2_MIN_PIN));
-  TERN_(HAS_Z3_MAX, _ATTACH(Z3_MAX_PIN));
-  TERN_(HAS_Z3_MIN, _ATTACH(Z3_MIN_PIN));
-  TERN_(HAS_Z4_MAX, _ATTACH(Z4_MAX_PIN));
-  TERN_(HAS_Z4_MIN, _ATTACH(Z4_MIN_PIN));
-  TERN_(HAS_Z_MIN_PROBE_PIN, _ATTACH(Z_MIN_PROBE_PIN));
-  TERN_(HAS_I_MAX, _ATTACH(I_MAX_PIN));
-  TERN_(HAS_I_MIN, _ATTACH(I_MIN_PIN));
-  TERN_(HAS_J_MAX, _ATTACH(J_MAX_PIN));
-  TERN_(HAS_J_MIN, _ATTACH(J_MIN_PIN));
-  TERN_(HAS_K_MAX, _ATTACH(K_MAX_PIN));
-  TERN_(HAS_K_MIN, _ATTACH(K_MIN_PIN));
-  TERN_(HAS_U_MAX, _ATTACH(U_MAX_PIN));
-  TERN_(HAS_U_MIN, _ATTACH(U_MIN_PIN));
-  TERN_(HAS_V_MAX, _ATTACH(V_MAX_PIN));
-  TERN_(HAS_V_MIN, _ATTACH(V_MIN_PIN));
-  TERN_(HAS_W_MAX, _ATTACH(W_MAX_PIN));
-  TERN_(HAS_W_MIN, _ATTACH(W_MIN_PIN));
-}
diff --git a/Marlin/src/HAL/ESP32/esp32.csv b/Marlin/src/HAL/ESP32/esp32.csv
deleted file mode 100644
index 8f6e101..0000000
--- a/Marlin/src/HAL/ESP32/esp32.csv
+++ /dev/null
@@ -1,6 +0,0 @@
-# Name,   Type, SubType, Offset,  Size, Flags
-nvs,      data, nvs,     0x9000,   0x5000,
-otadata,  data, ota,     0xe000,   0x2000,
-app0,     app,  ota_0,   0x10000,  0x180000,
-app1,     app,  ota_1,   0x190000, 0x180000,
-spiffs,   data, spiffs,  0x310000, 0xF0000,
diff --git a/Marlin/src/HAL/ESP32/fastio.h b/Marlin/src/HAL/ESP32/fastio.h
deleted file mode 100644
index c8e3f7e..0000000
--- a/Marlin/src/HAL/ESP32/fastio.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "i2s.h"
-
-/**
- * Utility functions
- */
-
-// I2S expander pin mapping.
-#define IS_I2S_EXPANDER_PIN(IO) TEST(IO, 7)
-#define I2S_EXPANDER_PIN_INDEX(IO) (IO & 0x7F)
-
-// Set pin as input
-#define _SET_INPUT(IO)          pinMode(IO, INPUT)
-
-// Set pin as output
-#define _SET_OUTPUT(IO)         pinMode(IO, OUTPUT)
-
-// Set pin as input with pullup mode
-#define _PULLUP(IO, v)          pinMode(IO, v ? INPUT_PULLUP : INPUT)
-
-#if ENABLED(USE_ESP32_EXIO)
-  // Read a pin wrapper
-  #define READ(IO)                digitalRead(IO)
-  // Write to a pin wrapper
-  #define WRITE(IO, v)            (IO >= 100 ? Write_EXIO(IO, v) : digitalWrite(IO, v))
-#else
-  // Read a pin wrapper
-  #define READ(IO)                (IS_I2S_EXPANDER_PIN(IO) ? i2s_state(I2S_EXPANDER_PIN_INDEX(IO)) : digitalRead(IO))
-  // Write to a pin wrapper
-  #define WRITE(IO, v)            (IS_I2S_EXPANDER_PIN(IO) ? i2s_write(I2S_EXPANDER_PIN_INDEX(IO), v) : digitalWrite(IO, v))
-#endif
-
-// Set pin as input wrapper (0x80 | (v << 5) | (IO - 100))
-#define SET_INPUT(IO)           _SET_INPUT(IO)
-
-// Set pin as input with pullup wrapper
-#define SET_INPUT_PULLUP(IO)    do{ _SET_INPUT(IO); _PULLUP(IO, HIGH); }while(0)
-
-// Set pin as input with pulldown (substitution)
-#define SET_INPUT_PULLDOWN      SET_INPUT
-
-// Set pin as output wrapper
-#define SET_OUTPUT(IO)          do{ _SET_OUTPUT(IO); }while(0)
-
-// Set pin as PWM
-#define SET_PWM                 SET_OUTPUT
-
-// Set pin as output and init
-#define OUT_WRITE(IO,V)         do{ _SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)      digitalRead(IO)
-#define extDigitalWrite(IO,V)   digitalWrite(IO,V)
-
-// PWM outputs
-#define PWM_PIN(P)              (P < 34 || P > 127) // NOTE Pins >= 34 are input only on ESP32, so they can't be used for output.
-
-// Toggle pin value
-#define TOGGLE(IO)              WRITE(IO, !READ(IO))
-
-//
-// Ports and functions
-//
-
-// UART
-#define RXD        3
-#define TXD        1
-
-// TWI (I2C)
-#define SCL        5
-#define SDA        4
diff --git a/Marlin/src/HAL/ESP32/i2s.cpp b/Marlin/src/HAL/ESP32/i2s.cpp
deleted file mode 100644
index cf337ee..0000000
--- a/Marlin/src/HAL/ESP32/i2s.cpp
+++ /dev/null
@@ -1,364 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if DISABLED(USE_ESP32_EXIO)
-
-#include "i2s.h"
-
-#include "../shared/Marduino.h"
-#include <driver/periph_ctrl.h>
-#include <rom/lldesc.h>
-#include <soc/i2s_struct.h>
-#include <freertos/queue.h>
-#include "../../module/stepper.h"
-
-#define DMA_BUF_COUNT 8                                // number of DMA buffers to store data
-#define DMA_BUF_LEN   4092                             // maximum size in bytes
-#define I2S_SAMPLE_SIZE 4                              // 4 bytes, 32 bits per sample
-#define DMA_SAMPLE_COUNT DMA_BUF_LEN / I2S_SAMPLE_SIZE // number of samples per buffer
-
-typedef enum {
-  I2S_NUM_0 = 0x0,  /*!< I2S 0*/
-  I2S_NUM_1 = 0x1,  /*!< I2S 1*/
-  I2S_NUM_MAX,
-} i2s_port_t;
-
-typedef struct {
-  uint32_t     **buffers;
-  uint32_t     *current;
-  uint32_t     rw_pos;
-  lldesc_t     **desc;
-  xQueueHandle queue;
-} i2s_dma_t;
-
-static portMUX_TYPE i2s_spinlock[I2S_NUM_MAX] = {portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED};
-static i2s_dev_t* I2S[I2S_NUM_MAX] = {&I2S0, &I2S1};
-static i2s_dma_t dma;
-
-// output value
-uint32_t i2s_port_data = 0;
-
-#define I2S_ENTER_CRITICAL()  portENTER_CRITICAL(&i2s_spinlock[i2s_num])
-#define I2S_EXIT_CRITICAL()   portEXIT_CRITICAL(&i2s_spinlock[i2s_num])
-
-static inline void gpio_matrix_out_check(uint32_t gpio, uint32_t signal_idx, bool out_inv, bool oen_inv) {
-  PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[gpio], PIN_FUNC_GPIO);
-  gpio_set_direction((gpio_num_t)gpio, (gpio_mode_t)GPIO_MODE_DEF_OUTPUT);
-  gpio_matrix_out(gpio, signal_idx, out_inv, oen_inv);
-}
-
-static esp_err_t i2s_reset_fifo(i2s_port_t i2s_num) {
-  I2S_ENTER_CRITICAL();
-  I2S[i2s_num]->conf.rx_fifo_reset = 1;
-  I2S[i2s_num]->conf.rx_fifo_reset = 0;
-  I2S[i2s_num]->conf.tx_fifo_reset = 1;
-  I2S[i2s_num]->conf.tx_fifo_reset = 0;
-  I2S_EXIT_CRITICAL();
-
-  return ESP_OK;
-}
-
-esp_err_t i2s_start(i2s_port_t i2s_num) {
-  //start DMA link
-  I2S_ENTER_CRITICAL();
-  i2s_reset_fifo(i2s_num);
-
-  //reset dma
-  I2S[i2s_num]->lc_conf.in_rst = 1;
-  I2S[i2s_num]->lc_conf.in_rst = 0;
-  I2S[i2s_num]->lc_conf.out_rst = 1;
-  I2S[i2s_num]->lc_conf.out_rst = 0;
-
-  I2S[i2s_num]->conf.tx_reset = 1;
-  I2S[i2s_num]->conf.tx_reset = 0;
-  I2S[i2s_num]->conf.rx_reset = 1;
-  I2S[i2s_num]->conf.rx_reset = 0;
-
-  I2S[i2s_num]->int_clr.val = 0xFFFFFFFF;
-  I2S[i2s_num]->out_link.start = 1;
-  I2S[i2s_num]->conf.tx_start = 1;
-  I2S_EXIT_CRITICAL();
-
-  return ESP_OK;
-}
-
-esp_err_t i2s_stop(i2s_port_t i2s_num) {
-  I2S_ENTER_CRITICAL();
-  I2S[i2s_num]->out_link.stop = 1;
-  I2S[i2s_num]->conf.tx_start = 0;
-
-  I2S[i2s_num]->int_clr.val = I2S[i2s_num]->int_st.val; //clear pending interrupt
-  I2S_EXIT_CRITICAL();
-
-  return ESP_OK;
-}
-
-static void IRAM_ATTR i2s_intr_handler_default(void *arg) {
-  int dummy;
-  lldesc_t *finish_desc;
-  portBASE_TYPE high_priority_task_awoken = pdFALSE;
-
-  if (I2S0.int_st.out_eof) {
-    // Get the descriptor of the last item in the linkedlist
-    finish_desc = (lldesc_t*) I2S0.out_eof_des_addr;
-
-    // If the queue is full it's because we have an underflow,
-    // more than buf_count isr without new data, remove the front buffer
-    if (xQueueIsQueueFullFromISR(dma.queue))
-      xQueueReceiveFromISR(dma.queue, &dummy, &high_priority_task_awoken);
-
-    xQueueSendFromISR(dma.queue, (void *)(&finish_desc->buf), &high_priority_task_awoken);
-  }
-
-  if (high_priority_task_awoken == pdTRUE) portYIELD_FROM_ISR();
-
-  // clear interrupt
-  I2S0.int_clr.val = I2S0.int_st.val; //clear pending interrupt
-}
-
-void stepperTask(void *parameter) {
-  uint32_t remaining = 0;
-
-  while (1) {
-    xQueueReceive(dma.queue, &dma.current, portMAX_DELAY);
-    dma.rw_pos = 0;
-
-    while (dma.rw_pos < DMA_SAMPLE_COUNT) {
-      // Fill with the port data post pulse_phase until the next step
-      if (remaining) {
-        i2s_push_sample();
-        remaining--;
-      }
-      else {
-        Stepper::pulse_phase_isr();
-        remaining = Stepper::block_phase_isr();
-      }
-    }
-  }
-}
-
-int i2s_init() {
-  periph_module_enable(PERIPH_I2S0_MODULE);
-
-  /**
-   * Each i2s transfer will take
-   *   fpll = PLL_D2_CLK      -- clka_en = 0
-   *
-   *   fi2s = fpll / N + b/a  -- N = clkm_div_num
-   *   fi2s = 160MHz / 2
-   *   fi2s = 80MHz
-   *
-   *   fbclk = fi2s / M   -- M = tx_bck_div_num
-   *   fbclk = 80MHz / 2
-   *   fbclk = 40MHz
-   *
-   *   fwclk = fbclk / 32
-   *
-   *   for fwclk = 250kHz (4ÂµS pulse time)
-   *      N = 10
-   *      M = 20
-   */
-
-  // Allocate the array of pointers to the buffers
-  dma.buffers = (uint32_t **)malloc(sizeof(uint32_t*) * DMA_BUF_COUNT);
-  if (!dma.buffers) return -1;
-
-  // Allocate each buffer that can be used by the DMA controller
-  for (int buf_idx = 0; buf_idx < DMA_BUF_COUNT; buf_idx++) {
-    dma.buffers[buf_idx] = (uint32_t*) heap_caps_calloc(1, DMA_BUF_LEN, MALLOC_CAP_DMA);
-    if (dma.buffers[buf_idx] == nullptr) return -1;
-  }
-
-  // Allocate the array of DMA descriptors
-  dma.desc = (lldesc_t**) malloc(sizeof(lldesc_t*) * DMA_BUF_COUNT);
-  if (!dma.desc) return -1;
-
-  // Allocate each DMA descriptor that will be used by the DMA controller
-  for (int buf_idx = 0; buf_idx < DMA_BUF_COUNT; buf_idx++) {
-    dma.desc[buf_idx] = (lldesc_t*) heap_caps_malloc(sizeof(lldesc_t), MALLOC_CAP_DMA);
-    if (dma.desc[buf_idx] == nullptr) return -1;
-  }
-
-  // Initialize
-  for (int buf_idx = 0; buf_idx < DMA_BUF_COUNT; buf_idx++) {
-    dma.desc[buf_idx]->owner = 1;
-    dma.desc[buf_idx]->eof = 1; // set to 1 will trigger the interrupt
-    dma.desc[buf_idx]->sosf = 0;
-    dma.desc[buf_idx]->length = DMA_BUF_LEN;
-    dma.desc[buf_idx]->size = DMA_BUF_LEN;
-    dma.desc[buf_idx]->buf = (uint8_t *) dma.buffers[buf_idx];
-    dma.desc[buf_idx]->offset = 0;
-    dma.desc[buf_idx]->empty = (uint32_t)((buf_idx < (DMA_BUF_COUNT - 1)) ? (dma.desc[buf_idx + 1]) : dma.desc[0]);
-  }
-
-  dma.queue = xQueueCreate(DMA_BUF_COUNT, sizeof(uint32_t *));
-
-  // Set the first DMA descriptor
-  I2S0.out_link.addr = (uint32_t)dma.desc[0];
-
-  // stop i2s
-  i2s_stop(I2S_NUM_0);
-
-  // configure I2S data port interface.
-  i2s_reset_fifo(I2S_NUM_0);
-
-  //reset i2s
-  I2S0.conf.tx_reset = 1;
-  I2S0.conf.tx_reset = 0;
-  I2S0.conf.rx_reset = 1;
-  I2S0.conf.rx_reset = 0;
-
-  //reset dma
-  I2S0.lc_conf.in_rst = 1;
-  I2S0.lc_conf.in_rst = 0;
-  I2S0.lc_conf.out_rst = 1;
-  I2S0.lc_conf.out_rst = 0;
-
-  //Enable and configure DMA
-  I2S0.lc_conf.check_owner = 0;
-  I2S0.lc_conf.out_loop_test = 0;
-  I2S0.lc_conf.out_auto_wrback = 0;
-  I2S0.lc_conf.out_data_burst_en = 0;
-  I2S0.lc_conf.outdscr_burst_en = 0;
-  I2S0.lc_conf.out_no_restart_clr = 0;
-  I2S0.lc_conf.indscr_burst_en = 0;
-  I2S0.lc_conf.out_eof_mode = 1;
-
-  I2S0.conf2.lcd_en = 0;
-  I2S0.conf2.camera_en = 0;
-  I2S0.pdm_conf.pcm2pdm_conv_en = 0;
-  I2S0.pdm_conf.pdm2pcm_conv_en = 0;
-
-  I2S0.fifo_conf.dscr_en = 0;
-
-  I2S0.conf_chan.tx_chan_mod = TERN(I2S_STEPPER_SPLIT_STREAM, 4, 0);
-  I2S0.fifo_conf.tx_fifo_mod = 0;
-  I2S0.conf.tx_mono = 0;
-
-  I2S0.conf_chan.rx_chan_mod = 0;
-  I2S0.fifo_conf.rx_fifo_mod = 0;
-  I2S0.conf.rx_mono = 0;
-
-  I2S0.fifo_conf.dscr_en = 1; //connect dma to fifo
-
-  I2S0.conf.tx_start = 0;
-  I2S0.conf.rx_start = 0;
-
-  I2S0.conf.tx_msb_right = 1;
-  I2S0.conf.tx_right_first = 1;
-
-  I2S0.conf.tx_slave_mod = 0; // Master
-  I2S0.fifo_conf.tx_fifo_mod_force_en = 1;
-
-  I2S0.pdm_conf.rx_pdm_en = 0;
-  I2S0.pdm_conf.tx_pdm_en = 0;
-
-  I2S0.conf.tx_short_sync = 0;
-  I2S0.conf.rx_short_sync = 0;
-  I2S0.conf.tx_msb_shift = 0;
-  I2S0.conf.rx_msb_shift = 0;
-
-  // set clock
-  I2S0.clkm_conf.clka_en = 0;       // Use PLL/2 as reference
-  I2S0.clkm_conf.clkm_div_num = 10; // minimum value of 2, reset value of 4, max 256
-  I2S0.clkm_conf.clkm_div_a = 0;    // 0 at reset, what about divide by 0? (not an issue)
-  I2S0.clkm_conf.clkm_div_b = 0;    // 0 at reset
-
-  // fbck = fi2s / tx_bck_div_num
-  I2S0.sample_rate_conf.tx_bck_div_num = 2; // minimum value of 2 defaults to 6
-
-  // Enable TX interrupts
-  I2S0.int_ena.out_eof = 1;
-  I2S0.int_ena.out_dscr_err = 0;
-  I2S0.int_ena.out_total_eof = 0;
-  I2S0.int_ena.out_done = 0;
-
-  // Allocate and Enable the I2S interrupt
-  intr_handle_t i2s_isr_handle;
-  esp_intr_alloc(ETS_I2S0_INTR_SOURCE, 0, i2s_intr_handler_default, nullptr, &i2s_isr_handle);
-  esp_intr_enable(i2s_isr_handle);
-
-  // Create the task that will feed the buffer
-  xTaskCreatePinnedToCore(stepperTask, "StepperTask", 10000, nullptr, 1, nullptr, CONFIG_ARDUINO_RUNNING_CORE); // run I2S stepper task on same core as rest of Marlin
-
-  // Route the i2s pins to the appropriate GPIO
-  // If a pin is not defined, no need to configure
-  #if defined(I2S_DATA) && I2S_DATA >= 0
-    gpio_matrix_out_check(I2S_DATA, I2S0O_DATA_OUT23_IDX, 0, 0);
-  #endif
-  #if defined(I2S_BCK) && I2S_BCK >= 0
-    gpio_matrix_out_check(I2S_BCK, I2S0O_BCK_OUT_IDX, 0, 0);
-  #endif
-  #if defined(I2S_WS) && I2S_WS >= 0
-    gpio_matrix_out_check(I2S_WS, I2S0O_WS_OUT_IDX, 0, 0);
-  #endif
-
-  // Start the I2S peripheral
-  return i2s_start(I2S_NUM_0);
-}
-
-void i2s_write(uint8_t pin, uint8_t val) {
-  #if ENABLED(I2S_STEPPER_SPLIT_STREAM)
-    if (pin >= 16) {
-      SET_BIT_TO(I2S0.conf_single_data, pin, val);
-      return;
-    }
-  #endif
-  SET_BIT_TO(i2s_port_data, pin, val);
-}
-
-uint8_t i2s_state(uint8_t pin) {
-  #if ENABLED(I2S_STEPPER_SPLIT_STREAM)
-    if (pin >= 16) return TEST(I2S0.conf_single_data, pin);
-  #endif
-  return TEST(i2s_port_data, pin);
-}
-
-void i2s_push_sample() {
-  // Every 4Âµs (when space in DMA buffer) toggle each expander PWM output using
-  // the current duty cycle/frequency so they sync with any steps (once
-  // through the DMA/FIFO buffers).  PWM signal inversion handled by other functions
-  LOOP_L_N(p, MAX_EXPANDER_BITS) {
-    if (hal.pwm_pin_data[p].pwm_duty_ticks > 0) { // pin has active pwm?
-      if (hal.pwm_pin_data[p].pwm_tick_count == 0) {
-        if (TEST32(i2s_port_data, p)) {  // hi->lo
-          CBI32(i2s_port_data, p);
-          hal.pwm_pin_data[p].pwm_tick_count = hal.pwm_pin_data[p].pwm_cycle_ticks - hal.pwm_pin_data[p].pwm_duty_ticks;
-        }
-        else { // lo->hi
-          SBI32(i2s_port_data, p);
-          hal.pwm_pin_data[p].pwm_tick_count = hal.pwm_pin_data[p].pwm_duty_ticks;
-        }
-      }
-      else
-        hal.pwm_pin_data[p].pwm_tick_count--;
-    }
-  }
-
-  dma.current[dma.rw_pos++] = i2s_port_data;
-}
-
-#endif // !USE_ESP32_EXIO
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/i2s.h b/Marlin/src/HAL/ESP32/i2s.h
deleted file mode 100644
index 573b983..0000000
--- a/Marlin/src/HAL/ESP32/i2s.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-
-// current value of the outputs provided over i2s
-extern uint32_t i2s_port_data;
-
-int i2s_init();
-
-uint8_t i2s_state(uint8_t pin);
-
-void i2s_write(uint8_t pin, uint8_t val);
-
-void i2s_push_sample();
diff --git a/Marlin/src/HAL/ESP32/inc/Conditionals_LCD.h b/Marlin/src/HAL/ESP32/inc/Conditionals_LCD.h
deleted file mode 100644
index 4da6001..0000000
--- a/Marlin/src/HAL/ESP32/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/ESP32."
-#endif
diff --git a/Marlin/src/HAL/ESP32/inc/Conditionals_adv.h b/Marlin/src/HAL/ESP32/inc/Conditionals_adv.h
deleted file mode 100644
index 3ca8068..0000000
--- a/Marlin/src/HAL/ESP32/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-//
-// Board-specific options need to be defined before HAL.h
-//
-#if MB(MKS_TINYBEE)
-  #define MAX_EXPANDER_BITS 24  // TinyBee has 3 x HC595
-#endif
diff --git a/Marlin/src/HAL/ESP32/inc/Conditionals_post.h b/Marlin/src/HAL/ESP32/inc/Conditionals_post.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/ESP32/inc/Conditionals_post.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/ESP32/inc/SanityCheck.h b/Marlin/src/HAL/ESP32/inc/SanityCheck.h
deleted file mode 100644
index 3ccb159..0000000
--- a/Marlin/src/HAL/ESP32/inc/SanityCheck.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if ENABLED(EMERGENCY_PARSER)
-  #error "EMERGENCY_PARSER is not yet implemented for ESP32. Disable EMERGENCY_PARSER to continue."
-#endif
-
-#if (ENABLED(SPINDLE_LASER_USE_PWM) && SPINDLE_LASER_FREQUENCY > 78125) || (ENABLED(FAST_PWM_FAN_FREQUENCY) && FAST_PWM_FAN_FREQUENCY > 78125)
-  #error "SPINDLE_LASER_FREQUENCY and FAST_PWM_FREQUENCY maximum value is 78125Hz for ESP32."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on ESP32."
-#endif
-
-#if BOTH(WIFISUPPORT, ESP3D_WIFISUPPORT)
-  #error "Only enable one WiFi option, either WIFISUPPORT or ESP3D_WIFISUPPORT."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on ESP32."
-#endif
-
-#if MB(MKS_TINYBEE) && ENABLED(FAST_PWM_FAN)
-  #error "FAST_PWM_FAN is not available on TinyBee."
-#endif
-
-#if USING_PULLDOWNS
-  #error "PULLDOWN pin mode is not available on ESP32 boards."
-#endif
-
-#if BOTH(I2S_STEPPER_STREAM, LIN_ADVANCE)
-  #error "I2S stream is currently incompatible with LIN_ADVANCE."
-#endif
diff --git a/Marlin/src/HAL/ESP32/ota.cpp b/Marlin/src/HAL/ESP32/ota.cpp
deleted file mode 100644
index 69a3e25..0000000
--- a/Marlin/src/HAL/ESP32/ota.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if BOTH(WIFISUPPORT, OTASUPPORT)
-
-#include <WiFi.h>
-#include <ESPmDNS.h>
-#include <WiFiUdp.h>
-#include <ArduinoOTA.h>
-#include <driver/timer.h>
-
-void OTA_init() {
-  ArduinoOTA
-    .onStart([]() {
-      timer_pause(TIMER_GROUP_0, TIMER_0);
-      timer_pause(TIMER_GROUP_0, TIMER_1);
-
-      // U_FLASH or U_SPIFFS
-      String type = (ArduinoOTA.getCommand() == U_FLASH) ? "sketch" : "filesystem";
-
-      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
-      Serial.println("Start updating " + type);
-    })
-    .onEnd([]() {
-      Serial.println("\nEnd");
-    })
-    .onProgress([](unsigned int progress, unsigned int total) {
-      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
-    })
-    .onError([](ota_error_t error) {
-      Serial.printf("Error[%u]: ", error);
-      char *str;
-      switch (error) {
-        case OTA_AUTH_ERROR:    str = "Auth Failed";    break;
-        case OTA_BEGIN_ERROR:   str = "Begin Failed";   break;
-        case OTA_CONNECT_ERROR: str = "Connect Failed"; break;
-        case OTA_RECEIVE_ERROR: str = "Receive Failed"; break;
-        case OTA_END_ERROR:     str = "End Failed";     break;
-      }
-      Serial.println(str);
-    });
-
-  ArduinoOTA.begin();
-}
-
-void OTA_handle() {
-  ArduinoOTA.handle();
-}
-
-#endif // WIFISUPPORT && OTASUPPORT
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/ota.h b/Marlin/src/HAL/ESP32/ota.h
deleted file mode 100644
index 546ace8..0000000
--- a/Marlin/src/HAL/ESP32/ota.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-void OTA_init();
-void OTA_handle();
diff --git a/Marlin/src/HAL/ESP32/servotimers.h b/Marlin/src/HAL/ESP32/servotimers.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/ESP32/servotimers.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/ESP32/spi_pins.h b/Marlin/src/HAL/ESP32/spi_pins.h
deleted file mode 100644
index 58881f0..0000000
--- a/Marlin/src/HAL/ESP32/spi_pins.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define SD_SS_PIN   SDSS
-#define SD_SCK_PIN  18
-#define SD_MISO_PIN 19
-#define SD_MOSI_PIN 23
diff --git a/Marlin/src/HAL/ESP32/spiffs.cpp b/Marlin/src/HAL/ESP32/spiffs.cpp
deleted file mode 100644
index a0e713b..0000000
--- a/Marlin/src/HAL/ESP32/spiffs.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if BOTH(WIFISUPPORT, WEBSUPPORT)
-
-#include "../../core/serial.h"
-
-#include <FS.h>
-#include <SPIFFS.h>
-
-bool spiffs_initialized;
-
-void spiffs_init() {
-  if (SPIFFS.begin(true))  // formatOnFail = true
-    spiffs_initialized = true;
-  else
-    SERIAL_ERROR_MSG("SPIFFS mount failed");
-}
-
-#endif // WIFISUPPORT && WEBSUPPORT
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/spiffs.h b/Marlin/src/HAL/ESP32/spiffs.h
deleted file mode 100644
index 64ec7dd..0000000
--- a/Marlin/src/HAL/ESP32/spiffs.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-extern bool spiffs_initialized;
-
-void spiffs_init();
diff --git a/Marlin/src/HAL/ESP32/timers.cpp b/Marlin/src/HAL/ESP32/timers.cpp
deleted file mode 100644
index c37ad24..0000000
--- a/Marlin/src/HAL/ESP32/timers.cpp
+++ /dev/null
@@ -1,171 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include <stdio.h>
-#include <esp_types.h>
-#include <soc/timer_group_struct.h>
-#include <driver/periph_ctrl.h>
-#include <driver/timer.h>
-
-#include "../../inc/MarlinConfig.h"
-
-// ------------------------
-// Local defines
-// ------------------------
-
-#define NUM_HARDWARE_TIMERS 4
-
-// ------------------------
-// Private Variables
-// ------------------------
-
-static timg_dev_t *TG[2] = {&TIMERG0, &TIMERG1};
-
-const tTimerConfig timer_config[NUM_HARDWARE_TIMERS] = {
-  { TIMER_GROUP_0, TIMER_0, STEPPER_TIMER_PRESCALE, stepTC_Handler }, // 0 - Stepper
-  { TIMER_GROUP_0, TIMER_1,    TEMP_TIMER_PRESCALE, tempTC_Handler }, // 1 - Temperature
-  { TIMER_GROUP_1, TIMER_0,     PWM_TIMER_PRESCALE, pwmTC_Handler  }, // 2 - PWM
-  { TIMER_GROUP_1, TIMER_1,    TONE_TIMER_PRESCALE, toneTC_Handler }, // 3 - Tone
-};
-
-// ------------------------
-// Public functions
-// ------------------------
-
-void IRAM_ATTR timer_isr(void *para) {
-  const tTimerConfig& timer = timer_config[(int)para];
-
-  // Retrieve the interrupt status and the counter value
-  // from the timer that reported the interrupt
-  uint32_t intr_status = TG[timer.group]->int_st_timers.val;
-  TG[timer.group]->hw_timer[timer.idx].update = 1;
-
-  // Clear the interrupt
-  if (intr_status & BIT(timer.idx)) {
-    switch (timer.idx) {
-      case TIMER_0: TG[timer.group]->int_clr_timers.t0 = 1; break;
-      case TIMER_1: TG[timer.group]->int_clr_timers.t1 = 1; break;
-      case TIMER_MAX: break;
-    }
-  }
-
-  timer.fn();
-
-  // After the alarm has been triggered
-  // Enable it again so it gets triggered the next time
-  TG[timer.group]->hw_timer[timer.idx].config.alarm_en = TIMER_ALARM_EN;
-}
-
-/**
- * Enable and initialize the timer
- * @param timer_num timer number to initialize
- * @param frequency frequency of the timer
- */
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  const tTimerConfig timer = timer_config[timer_num];
-
-  timer_config_t config;
-  config.divider     = timer.divider;
-  config.counter_dir = TIMER_COUNT_UP;
-  config.counter_en  = TIMER_PAUSE;
-  config.alarm_en    = TIMER_ALARM_EN;
-  config.intr_type   = TIMER_INTR_LEVEL;
-  config.auto_reload = true;
-
-  // Select and initialize the timer
-  timer_init(timer.group, timer.idx, &config);
-
-  // Timer counter initial value and auto reload on alarm
-  timer_set_counter_value(timer.group, timer.idx, 0x00000000ULL);
-
-  // Configure the alam value and the interrupt on alarm
-  timer_set_alarm_value(timer.group, timer.idx, (HAL_TIMER_RATE) / timer.divider / frequency - 1);
-
-  timer_enable_intr(timer.group, timer.idx);
-
-  timer_isr_register(timer.group, timer.idx, timer_isr, (void*)(uint32_t)timer_num, 0, nullptr);
-
-  timer_start(timer.group, timer.idx);
-}
-
-/**
- * Set the upper value of the timer, when the timer reaches this upper value the
- * interrupt should be triggered and the counter reset
- * @param timer_num timer number to set the count to
- * @param count     threshold at which the interrupt is triggered
- */
-void HAL_timer_set_compare(const uint8_t timer_num, hal_timer_t count) {
-  const tTimerConfig timer = timer_config[timer_num];
-  timer_set_alarm_value(timer.group, timer.idx, count);
-}
-
-/**
- * Get the current upper value of the timer
- * @param  timer_num timer number to get the count from
- * @return           the timer current threshold for the alarm to be triggered
- */
-hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  const tTimerConfig timer = timer_config[timer_num];
-
-  uint64_t alarm_value;
-  timer_get_alarm_value(timer.group, timer.idx, &alarm_value);
-
-  return alarm_value;
-}
-
-/**
- * Get the current counter value between 0 and the maximum count (HAL_timer_set_count)
- * @param  timer_num timer number to get the current count
- * @return           the current counter of the alarm
- */
-hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  const tTimerConfig timer = timer_config[timer_num];
-  uint64_t counter_value;
-  timer_get_counter_value(timer.group, timer.idx, &counter_value);
-  return counter_value;
-}
-
-/**
- * Enable timer interrupt on the timer
- * @param timer_num timer number to enable interrupts on
- */
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  //const tTimerConfig timer = timer_config[timer_num];
-  //timer_enable_intr(timer.group, timer.idx);
-}
-
-/**
- * Disable timer interrupt on the timer
- * @param timer_num timer number to disable interrupts on
- */
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  //const tTimerConfig timer = timer_config[timer_num];
-  //timer_disable_intr(timer.group, timer.idx);
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  const tTimerConfig timer = timer_config[timer_num];
-  return TG[timer.group]->int_ena.val | BIT(timer_num);
-}
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/timers.h b/Marlin/src/HAL/ESP32/timers.h
deleted file mode 100644
index aa4e155..0000000
--- a/Marlin/src/HAL/ESP32/timers.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-#include <driver/timer.h>
-
-// ------------------------
-// Defines
-// ------------------------
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint64_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFFFFFFFFFFULL
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-#ifndef MF_TIMER_PWM
-  #define MF_TIMER_PWM          2  // index of timer to use for PWM outputs
-#endif
-#ifndef MF_TIMER_TONE
-  #define MF_TIMER_TONE         3  // index of timer for beeper tones
-#endif
-
-#define HAL_TIMER_RATE APB_CLK_FREQ // frequency of timer peripherals
-
-#if ENABLED(I2S_STEPPER_STREAM)
-  #define STEPPER_TIMER_PRESCALE     1
-  #define STEPPER_TIMER_RATE         250000                           // 250khz, 4Âµs pulses of i2s word clock
-  #define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // stepper timer ticks per Âµs // wrong would be 0.25
-#else
-  #define STEPPER_TIMER_PRESCALE     40
-  #define STEPPER_TIMER_RATE         ((HAL_TIMER_RATE) / (STEPPER_TIMER_PRESCALE)) // frequency of stepper timer, 2MHz
-  #define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000)              // stepper timer ticks per Âµs
-#endif
-
-#define STEP_TIMER_MIN_INTERVAL   8 // minimum time in Âµs between stepper interrupts
-
-#define TONE_TIMER_PRESCALE    1000 // Arbitrary value, no idea what i'm doing here
-
-#define TEMP_TIMER_PRESCALE    1000 // prescaler for setting Temp timer, 72Khz
-#define TEMP_TIMER_FREQUENCY   1000 // temperature interrupt frequency
-
-#define PWM_TIMER_PRESCALE       10
-#if ENABLED(FAST_PWM_FAN)
-  #define PWM_TIMER_FREQUENCY  FAST_PWM_FAN_FREQUENCY
-#else
-  #define PWM_TIMER_FREQUENCY  (50*128) // 50Hz and 7bit resolution
-#endif
-#define MAX_PWM_PINS             32 // Number of PWM pin-slots
-
-#define PULSE_TIMER_RATE         STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE     STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT()  HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT()  HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() extern "C" void tempTC_Handler()
-#endif
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() extern "C" void stepTC_Handler()
-#endif
-#ifndef HAL_PWM_TIMER_ISR
-  #define HAL_PWM_TIMER_ISR() extern "C" void pwmTC_Handler()
-#endif
-#ifndef HAL_TONE_TIMER_ISR
-  #define HAL_TONE_TIMER_ISR() extern "C" void toneTC_Handler()
-#endif
-
-extern "C" {
-  void tempTC_Handler();
-  void stepTC_Handler();
-  void pwmTC_Handler();
-  void toneTC_Handler();
-}
-
-// ------------------------
-// Types
-// ------------------------
-
-typedef struct {
-  timer_group_t  group;
-  timer_idx_t    idx;
-  uint32_t       divider;
-  void           (*fn)();
-} tTimerConfig;
-
-// ------------------------
-// Public Variables
-// ------------------------
-
-extern const tTimerConfig timer_config[];
-
-// ------------------------
-// Public functions
-// ------------------------
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t count);
-hal_timer_t HAL_timer_get_compare(const uint8_t timer_num);
-hal_timer_t HAL_timer_get_count(const uint8_t timer_num);
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-#define HAL_timer_isr_prologue(T) NOOP
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/ESP32/u8g_esp32_spi.cpp b/Marlin/src/HAL/ESP32/u8g_esp32_spi.cpp
deleted file mode 100644
index a445035..0000000
--- a/Marlin/src/HAL/ESP32/u8g_esp32_spi.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2022 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * Copypaste of SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfig.h"
-
-#if EITHER(MKS_MINI_12864, FYSETC_MINI_12864_2_1)
-
-#include <U8glib-HAL.h>
-#include "../shared/HAL_SPI.h"
-#include "HAL.h"
-#include "SPI.h"
-
-static SPISettings spiConfig;
-
-
-#ifndef LCD_SPI_SPEED
-  #ifdef SD_SPI_SPEED
-    #define LCD_SPI_SPEED SD_SPI_SPEED    // Assume SPI speed shared with SD
-  #else
-    #define LCD_SPI_SPEED SPI_FULL_SPEED  // Use full speed if SD speed is not supplied
-  #endif
-#endif
-
-uint8_t u8g_eps_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  static uint8_t msgInitCount = 2; // Ignore all messages until 2nd U8G_COM_MSG_INIT
-  if (msgInitCount) {
-    if (msg == U8G_COM_MSG_INIT) msgInitCount--;
-    if (msgInitCount) return -1;
-  }
-
-  switch (msg) {
-    case U8G_COM_MSG_STOP: break;
-
-    case U8G_COM_MSG_INIT:
-      OUT_WRITE(DOGLCD_CS, HIGH);
-      OUT_WRITE(DOGLCD_A0, HIGH);
-      OUT_WRITE(LCD_RESET_PIN, HIGH);
-      u8g_Delay(5);
-      spiBegin();
-      spiInit(LCD_SPI_SPEED);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:           /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      WRITE(DOGLCD_A0, arg_val ? HIGH : LOW);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:       /* arg_val == 0 means HIGH level of U8G_PI_CS */
-      WRITE(DOGLCD_CS, arg_val ? LOW : HIGH);
-      break;
-
-    case U8G_COM_MSG_RESET:
-      WRITE(LCD_RESET_PIN, arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      spiSend((uint8_t)arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ:
-      uint8_t *ptr = (uint8_t*) arg_ptr;
-      while (arg_val > 0) {
-        spiSend(*ptr++);
-        arg_val--;
-      }
-      break;
-  }
-  return 1;
-}
-
-#endif // EITHER(MKS_MINI_12864, FYSETC_MINI_12864_2_1)
-
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/web.cpp b/Marlin/src/HAL/ESP32/web.cpp
deleted file mode 100644
index 7a27707..0000000
--- a/Marlin/src/HAL/ESP32/web.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if BOTH(WIFISUPPORT, WEBSUPPORT)
-
-#include "../../inc/MarlinConfig.h"
-
-#undef DISABLED  // esp32-hal-gpio.h
-#include <SPIFFS.h>
-#include "wifi.h"
-
-AsyncEventSource events("/events"); // event source (Server-Sent events)
-
-void onNotFound(AsyncWebServerRequest *request) {
-  request->send(404);
-}
-
-void web_init() {
-  server.addHandler(&events);       // attach AsyncEventSource
-  server.serveStatic("/", SPIFFS, "/www").setDefaultFile("index.html");
-  server.onNotFound(onNotFound);
-}
-
-#endif // WIFISUPPORT && WEBSUPPORT
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/web.h b/Marlin/src/HAL/ESP32/web.h
deleted file mode 100644
index 60023ac..0000000
--- a/Marlin/src/HAL/ESP32/web.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-void web_init();
diff --git a/Marlin/src/HAL/ESP32/wifi.cpp b/Marlin/src/HAL/ESP32/wifi.cpp
deleted file mode 100644
index 060f3bd..0000000
--- a/Marlin/src/HAL/ESP32/wifi.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ARDUINO_ARCH_ESP32
-
-#include "../../core/serial.h"
-#include "../../inc/MarlinConfigPre.h"
-
-#if ENABLED(WIFISUPPORT)
-
-#include <WiFi.h>
-#include <ESPmDNS.h>
-#include <ESPAsyncWebServer.h>
-#include "wifi.h"
-
-AsyncWebServer server(80);
-
-#ifndef WIFI_HOSTNAME
-  #define WIFI_HOSTNAME DEFAULT_WIFI_HOSTNAME
-#endif
-
-void wifi_init() {
-
-  SERIAL_ECHO_MSG("Starting WiFi...");
-
-  WiFi.mode(WIFI_STA);
-  WiFi.begin(WIFI_SSID, WIFI_PWD);
-
-  while (WiFi.waitForConnectResult() != WL_CONNECTED) {
-    SERIAL_ERROR_MSG("Unable to connect to WiFi with SSID '" WIFI_SSID "', restarting.");
-    delay(5000);
-    ESP.restart();
-  }
-
-  delay(10);
-  if (!MDNS.begin(WIFI_HOSTNAME)) {
-    SERIAL_ERROR_MSG("Unable to start mDNS with hostname '" WIFI_HOSTNAME "', restarting.");
-    delay(5000);
-    ESP.restart();
-  }
-
-  MDNS.addService("http", "tcp", 80);
-
-  SERIAL_ECHOLNPGM("Successfully connected to WiFi with SSID '" WIFI_SSID "', hostname: '" WIFI_HOSTNAME "', IP address: ", WiFi.localIP().toString().c_str());
-}
-
-#endif // WIFISUPPORT
-#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/wifi.h b/Marlin/src/HAL/ESP32/wifi.h
deleted file mode 100644
index 759a73b..0000000
--- a/Marlin/src/HAL/ESP32/wifi.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <ESPAsyncWebServer.h>
-
-extern AsyncWebServer server;
-
-#define DEFAULT_WIFI_HOSTNAME "marlin"
-
-void wifi_init();
diff --git a/Marlin/src/HAL/LINUX/HAL.cpp b/Marlin/src/HAL/LINUX/HAL.cpp
deleted file mode 100644
index db43f42..0000000
--- a/Marlin/src/HAL/LINUX/HAL.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "../../inc/MarlinConfig.h"
-#include "../shared/Delay.h"
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-MSerialT usb_serial(TERN0(EMERGENCY_PARSER, true));
-
-// U8glib required functions
-extern "C" {
-  void u8g_xMicroDelay(uint16_t val) { DELAY_US(val); }
-  void u8g_MicroDelay()              { u8g_xMicroDelay(1); }
-  void u8g_10MicroDelay()            { u8g_xMicroDelay(10); }
-  void u8g_Delay(uint16_t val)       { delay(val); }
-}
-
-//************************//
-
-// return free heap space
-int freeMemory() { return 0; }
-
-// ------------------------
-// ADC
-// ------------------------
-
-uint8_t MarlinHAL::active_ch = 0;
-
-uint16_t MarlinHAL::adc_value() {
-  const pin_t pin = analogInputToDigitalPin(active_ch);
-  if (!VALID_PIN(pin)) return 0;
-  const uint16_t data = ((Gpio::get(pin) >> 2) & 0x3FF);
-  return data;    // return 10bit value as Marlin expects
-}
-
-void MarlinHAL::reboot() { /* Reset the application state and GPIO */ }
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/HAL.h b/Marlin/src/HAL/LINUX/HAL.h
deleted file mode 100644
index 22c3e52..0000000
--- a/Marlin/src/HAL/LINUX/HAL.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../inc/MarlinConfigPre.h"
-
-#include <iostream>
-#include <stdint.h>
-#include <stdarg.h>
-#undef min
-#undef max
-#include <algorithm>
-
-#include "hardware/Clock.h"
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-#include "fastio.h"
-#include "serial.h"
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define CPU_32_BIT
-#define SHARED_SERVOS HAS_SERVOS  // Use shared/servos.cpp
-
-#define F_CPU 100000000UL
-#define SystemCoreClock F_CPU
-
-#define DELAY_CYCLES(x) Clock::delayCycles(x)
-
-#define CPU_ST7920_DELAY_1 600
-#define CPU_ST7920_DELAY_2 750
-#define CPU_ST7920_DELAY_3 750
-
-void _printf(const  char *format, ...);
-void _putc(uint8_t c);
-uint8_t _getc();
-
-//arduino: Print.h
-#define DEC 10
-#define HEX 16
-#define OCT  8
-#define BIN  2
-//arduino: binary.h (weird defines)
-#define B01 1
-#define B10 2
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-extern MSerialT usb_serial;
-#define MYSERIAL1 usb_serial
-
-//
-// Interrupts
-//
-#define CRITICAL_SECTION_START()
-#define CRITICAL_SECTION_END()
-
-// ADC
-#define HAL_ADC_VREF           5.0
-#define HAL_ADC_RESOLUTION    10
-
-// ------------------------
-// Class Utilities
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-int freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init() {}
-  static void watchdog_refresh() {}
-
-  static void init() {}        // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Reset the application state and GPIO
-
-  // Interrupts
-  static bool isr_state() { return true; }
-  static void isr_on()  {}
-  static void isr_off() {}
-
-  static void delay_ms(const int ms) { _delay_ms(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static constexpr uint8_t reset_reason = RST_POWER_ON;
-  static uint8_t get_reset_source() { return reset_reason; }
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  static uint8_t active_ch;
-
-  // Called by Temperature::init once at startup
-  static void adc_init() {}
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const uint8_t) {}
-
-  // Begin ADC sampling on the given channel
-  static void adc_start(const uint8_t ch) { active_ch = ch; }
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value();
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No option to change the resolution or invert the duty cycle.
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-  static void set_pwm_frequency(const pin_t, int) {}
-};
diff --git a/Marlin/src/HAL/LINUX/MarlinSPI.h b/Marlin/src/HAL/LINUX/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/LINUX/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/LINUX/arduino.cpp b/Marlin/src/HAL/LINUX/arduino.cpp
deleted file mode 100644
index 075b4cc..0000000
--- a/Marlin/src/HAL/LINUX/arduino.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include <iostream>
-#include "../../inc/MarlinConfig.h"
-#include "hardware/Clock.h"
-#include "../shared/Delay.h"
-
-// Interrupts
-void cli() { } // Disable
-void sei() { } // Enable
-
-// Time functions
-void _delay_ms(const int ms) { delay(ms); }
-
-uint32_t millis() {
-  return (uint32_t)Clock::millis();
-}
-
-// This is required for some Arduino libraries we are using
-void delayMicroseconds(uint32_t us) {
-  Clock::delayMicros(us);
-}
-
-extern "C" void delay(const int msec) {
-  Clock::delayMillis(msec);
-}
-
-// IO functions
-// As defined by Arduino INPUT(0x0), OUTPUT(0x1), INPUT_PULLUP(0x2)
-void pinMode(const pin_t pin, const uint8_t mode) {
-  if (!VALID_PIN(pin)) return;
-  Gpio::setMode(pin, mode);
-}
-
-void digitalWrite(pin_t pin, uint8_t pin_status) {
-  if (!VALID_PIN(pin)) return;
-  Gpio::set(pin, pin_status);
-}
-
-bool digitalRead(pin_t pin) {
-  if (!VALID_PIN(pin)) return false;
-  return Gpio::get(pin);
-}
-
-void analogWrite(pin_t pin, int pwm_value) {  // 1 - 254: pwm_value, 0: LOW, 255: HIGH
-  if (!VALID_PIN(pin)) return;
-  Gpio::set(pin, pwm_value);
-}
-
-uint16_t analogRead(pin_t adc_pin) {
-  if (!VALID_PIN(DIGITAL_PIN_TO_ANALOG_PIN(adc_pin))) return 0;
-  return Gpio::get(DIGITAL_PIN_TO_ANALOG_PIN(adc_pin));
-}
-
-char *dtostrf(double __val, signed char __width, unsigned char __prec, char *__s) {
-  char format_string[20];
-  snprintf(format_string, 20, "%%%d.%df", __width, __prec);
-  sprintf(__s, format_string, __val);
-  return __s;
-}
-
-int32_t random(int32_t max) {
-  return rand() % max;
-}
-
-int32_t random(int32_t min, int32_t max) {
-  return min + rand() % (max - min);
-}
-
-void randomSeed(uint32_t value) {
-  srand(value);
-}
-
-int map(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max) {
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/eeprom.cpp b/Marlin/src/HAL/LINUX/eeprom.cpp
deleted file mode 100644
index f878bba..0000000
--- a/Marlin/src/HAL/LINUX/eeprom.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(EEPROM_SETTINGS)
-
-#include "../shared/eeprom_api.h"
-#include <stdio.h>
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE 0x1000 // 4KB of Emulated EEPROM
-#endif
-
-uint8_t buffer[MARLIN_EEPROM_SIZE];
-char filename[] = "eeprom.dat";
-
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start() {
-  const char eeprom_erase_value = 0xFF;
-  FILE * eeprom_file = fopen(filename, "rb");
-  if (!eeprom_file) return false;
-
-  fseek(eeprom_file, 0L, SEEK_END);
-  std::size_t file_size = ftell(eeprom_file);
-
-  if (file_size < MARLIN_EEPROM_SIZE) {
-    memset(buffer + file_size, eeprom_erase_value, MARLIN_EEPROM_SIZE - file_size);
-  }
-  else {
-    fseek(eeprom_file, 0L, SEEK_SET);
-    fread(buffer, sizeof(uint8_t), sizeof(buffer), eeprom_file);
-  }
-
-  fclose(eeprom_file);
-  return true;
-}
-
-bool PersistentStore::access_finish() {
-  FILE * eeprom_file = fopen(filename, "wb");
-  if (!eeprom_file) return false;
-  fwrite(buffer, sizeof(uint8_t), sizeof(buffer), eeprom_file);
-  fclose(eeprom_file);
-  return true;
-}
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  std::size_t bytes_written = 0;
-
-  for (std::size_t i = 0; i < size; i++) {
-    buffer[pos + i] = value[i];
-    bytes_written++;
-  }
-
-  crc16(crc, value, size);
-  pos += size;
-  return (bytes_written != size);  // return true for any error
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  std::size_t bytes_read = 0;
-  if (writing) {
-    for (std::size_t i = 0; i < size; i++) {
-      value[i] = buffer[pos + i];
-      bytes_read++;
-    }
-    crc16(crc, value, size);
-  }
-  else {
-    uint8_t temp[size];
-    for (std::size_t i = 0; i < size; i++) {
-      temp[i] = buffer[pos + i];
-      bytes_read++;
-    }
-    crc16(crc, temp, size);
-  }
-
-  pos += size;
-  return bytes_read != size;  // return true for any error
-}
-
-#endif // EEPROM_SETTINGS
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/fastio.h b/Marlin/src/HAL/LINUX/fastio.h
deleted file mode 100644
index 4567c62..0000000
--- a/Marlin/src/HAL/LINUX/fastio.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for X86_64
- */
-
-#include "../shared/Marduino.h"
-#include <pinmapping.h>
-
-#define SET_DIR_INPUT(IO)     Gpio::setDir(IO, 1)
-#define SET_DIR_OUTPUT(IO)    Gpio::setDir(IO, 0)
-
-#define SET_MODE(IO, mode)    Gpio::setMode(IO, mode)
-
-#define WRITE_PIN_SET(IO)     Gpio::set(IO)
-#define WRITE_PIN_CLR(IO)     Gpio::clear(IO)
-
-#define READ_PIN(IO)          Gpio::get(IO)
-#define WRITE_PIN(IO,V)       Gpio::set(IO, V)
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(STEP); WRITE(STEP, HIGH); WRITE(STEP, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html
- */
-
-/// Read a pin
-#define _READ(IO)             READ_PIN(IO)
-
-/// Write to a pin
-#define _WRITE(IO,V)          WRITE_PIN(IO,V)
-
-/// toggle a pin
-#define _TOGGLE(IO)          _WRITE(IO, !READ(IO))
-
-/// set pin as input
-#define _SET_INPUT(IO)        SET_DIR_INPUT(IO)
-
-/// set pin as output
-#define _SET_OUTPUT(IO)       SET_DIR_OUTPUT(IO)
-
-/// set pin as input with pullup mode
-#define _PULLUP(IO,V)         pinMode(IO, (V) ? INPUT_PULLUP : INPUT)
-
-/// set pin as input with pulldown mode
-#define _PULLDOWN(IO,V)       pinMode(IO, (V) ? INPUT_PULLDOWN : INPUT)
-
-// hg42: all pins can be input or output (I hope)
-// hg42: undefined pins create compile error (IO, is no pin)
-// hg42: currently not used, but was used by pinsDebug
-
-/// check if pin is an input
-#define _IS_INPUT(IO)         (LPC1768_PIN_PIN(IO) >= 0)
-
-/// check if pin is an output
-#define _IS_OUTPUT(IO)        (LPC1768_PIN_PIN(IO) >= 0)
-
-/// Read a pin wrapper
-#define READ(IO)             _READ(IO)
-
-/// Write to a pin wrapper
-#define WRITE(IO,V)          _WRITE(IO,V)
-
-/// toggle a pin wrapper
-#define TOGGLE(IO)           _TOGGLE(IO)
-
-/// set pin as input wrapper
-#define SET_INPUT(IO)        _SET_INPUT(IO)
-/// set pin as input with pullup wrapper
-#define SET_INPUT_PULLUP(IO)  do{ _SET_INPUT(IO); _PULLUP(IO, HIGH); }while(0)
-/// set pin as input with pulldown wrapper
-#define SET_INPUT_PULLDOWN(IO) do{ _SET_INPUT(IO); _PULLDOWN(IO, HIGH); }while(0)
-/// set pin as output wrapper  -  reads the pin and sets the output to that value
-#define SET_OUTPUT(IO)        do{ _WRITE(IO, _READ(IO)); _SET_OUTPUT(IO); }while(0)
-// set pin as PWM
-#define SET_PWM(IO)           SET_OUTPUT(IO)
-
-/// check if pin is an input wrapper
-#define IS_INPUT(IO)         _IS_INPUT(IO)
-/// check if pin is an output wrapper
-#define IS_OUTPUT(IO)        _IS_OUTPUT(IO)
-
-// Shorthand
-#define OUT_WRITE(IO,V)       do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
diff --git a/Marlin/src/HAL/LINUX/hardware/Clock.cpp b/Marlin/src/HAL/LINUX/hardware/Clock.cpp
deleted file mode 100644
index 1984a4a..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Clock.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "../../../inc/MarlinConfig.h"
-#include "Clock.h"
-
-std::chrono::nanoseconds Clock::startup = std::chrono::high_resolution_clock::now().time_since_epoch();
-uint32_t Clock::frequency = F_CPU;
-double Clock::time_multiplier = 1.0;
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/Clock.h b/Marlin/src/HAL/LINUX/hardware/Clock.h
deleted file mode 100644
index 072eacf..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Clock.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <chrono>
-#include <thread>
-
-class Clock {
-public:
-  static uint64_t ticks(uint32_t frequency = Clock::frequency) {
-    return (Clock::nanos() - Clock::startup.count()) / (1000000000ULL / frequency);
-  }
-
-  static uint64_t nanosToTicks(uint64_t ns, uint32_t frequency = Clock::frequency) {
-    return ns / (1000000000ULL / frequency);
-  }
-
-  // Time acceleration compensated
-  static uint64_t ticksToNanos(uint64_t tick, uint32_t frequency = Clock::frequency) {
-    return (tick * (1000000000ULL / frequency)) / Clock::time_multiplier;
-  }
-
-  static void setFrequency(uint32_t freq) {
-    Clock::frequency = freq;
-  }
-
-  // Time Acceleration compensated
-  static uint64_t nanos() {
-    auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
-    return (now.count() - Clock::startup.count()) * Clock::time_multiplier;
-  }
-
-  static uint64_t micros() {
-    return Clock::nanos() / 1000;
-  }
-
-  static uint64_t millis() {
-    return Clock::micros() / 1000;
-  }
-
-  static double seconds() {
-    return Clock::nanos() / 1000000000.0;
-  }
-
-  static void delayCycles(uint64_t cycles) {
-    std::this_thread::sleep_for(std::chrono::nanoseconds( (1000000000L / frequency) * cycles) / Clock::time_multiplier );
-  }
-
-  static void delayMicros(uint64_t micros) {
-    std::this_thread::sleep_for(std::chrono::microseconds( micros ) / Clock::time_multiplier);
-  }
-
-  static void delayMillis(uint64_t millis) {
-    std::this_thread::sleep_for(std::chrono::milliseconds( millis ) / Clock::time_multiplier);
-  }
-
-  static void delaySeconds(double secs) {
-    std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(secs * 1000) / Clock::time_multiplier);
-  }
-
-  // Will reduce timer resolution increasing likelihood of overflows
-  static void setTimeMultiplier(double tm) {
-    Clock::time_multiplier = tm;
-  }
-
-private:
-  static std::chrono::nanoseconds startup;
-  static uint32_t frequency;
-  static double time_multiplier;
-};
diff --git a/Marlin/src/HAL/LINUX/hardware/Gpio.cpp b/Marlin/src/HAL/LINUX/hardware/Gpio.cpp
deleted file mode 100644
index 61a7be7..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Gpio.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "Gpio.h"
-
-pin_data Gpio::pin_map[Gpio::pin_count+1] = {};
-IOLogger* Gpio::logger = nullptr;
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/Gpio.h b/Marlin/src/HAL/LINUX/hardware/Gpio.h
deleted file mode 100644
index f946be6..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Gpio.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "Clock.h"
-#include "../../../inc/MarlinConfigPre.h"
-#include <stdint.h>
-
-typedef int16_t pin_type;
-
-struct GpioEvent {
-  enum Type {
-    NOP,
-    FALL,
-    RISE,
-    SET_VALUE,
-    SETM,
-    SETD
-  };
-  uint64_t timestamp;
-  pin_type pin_id;
-  GpioEvent::Type event;
-
-  GpioEvent(uint64_t timestamp, pin_type pin_id, GpioEvent::Type event) {
-    this->timestamp = timestamp;
-    this->pin_id = pin_id;
-    this->event = event;
-  }
-};
-
-class IOLogger {
-public:
-  virtual ~IOLogger(){};
-  virtual void log(GpioEvent ev) = 0;
-};
-
-class Peripheral {
-public:
-  virtual ~Peripheral(){};
-  virtual void interrupt(GpioEvent ev) = 0;
-  virtual void update() = 0;
-};
-
-struct pin_data {
-  uint8_t dir;
-  uint8_t mode;
-  uint16_t value;
-  Peripheral* cb;
-};
-
-class Gpio {
-public:
-
-  static const pin_type pin_count = 255;
-  static pin_data pin_map[pin_count+1];
-
-  static bool valid_pin(pin_type pin) {
-    return pin >= 0 && pin <= pin_count;
-  }
-
-  static void set(pin_type pin) {
-    set(pin, 1);
-  }
-
-  static void set(pin_type pin, uint16_t value) {
-    if (!valid_pin(pin)) return;
-    GpioEvent::Type evt_type = value > 1 ? GpioEvent::SET_VALUE : value > pin_map[pin].value ? GpioEvent::RISE : value < pin_map[pin].value ? GpioEvent::FALL : GpioEvent::NOP;
-    pin_map[pin].value = value;
-    GpioEvent evt(Clock::nanos(), pin, evt_type);
-    if (pin_map[pin].cb) {
-      pin_map[pin].cb->interrupt(evt);
-    }
-    if (Gpio::logger) Gpio::logger->log(evt);
-  }
-
-  static uint16_t get(pin_type pin) {
-    if (!valid_pin(pin)) return 0;
-    return pin_map[pin].value;
-  }
-
-  static void clear(pin_type pin) {
-    set(pin, 0);
-  }
-
-  static void setMode(pin_type pin, uint8_t value) {
-    if (!valid_pin(pin)) return;
-    pin_map[pin].mode = value;
-    GpioEvent evt(Clock::nanos(), pin, GpioEvent::Type::SETM);
-    if (pin_map[pin].cb) pin_map[pin].cb->interrupt(evt);
-    if (Gpio::logger) Gpio::logger->log(evt);
-  }
-
-  static uint8_t getMode(pin_type pin) {
-    if (!valid_pin(pin)) return 0;
-    return pin_map[pin].mode;
-  }
-
-  static void setDir(pin_type pin, uint8_t value) {
-    if (!valid_pin(pin)) return;
-    pin_map[pin].dir = value;
-    GpioEvent evt(Clock::nanos(), pin, GpioEvent::Type::SETD);
-    if (pin_map[pin].cb) pin_map[pin].cb->interrupt(evt);
-    if (Gpio::logger) Gpio::logger->log(evt);
-  }
-
-  static uint8_t getDir(pin_type pin) {
-    if (!valid_pin(pin)) return 0;
-    return pin_map[pin].dir;
-  }
-
-  static void attachPeripheral(pin_type pin, Peripheral* per) {
-    if (!valid_pin(pin)) return;
-    pin_map[pin].cb = per;
-  }
-
-  static void attachLogger(IOLogger* logger) {
-    Gpio::logger = logger;
-  }
-
-private:
-  static IOLogger* logger;
-};
diff --git a/Marlin/src/HAL/LINUX/hardware/Heater.cpp b/Marlin/src/HAL/LINUX/hardware/Heater.cpp
deleted file mode 100644
index 44f1198..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Heater.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "Clock.h"
-#include <stdio.h>
-#include "../../../inc/MarlinConfig.h"
-
-#include "Heater.h"
-
-Heater::Heater(pin_t heater, pin_t adc) {
-  heater_state = 0;
-  room_temp_raw = 150;
-  last = Clock::micros();
-  heater_pin = heater;
-  adc_pin = adc;
-  heat = 0.0;
-}
-
-Heater::~Heater() {
-}
-
-void Heater::update() {
-  // crude pwm read and cruder heat simulation
-  auto now = Clock::micros();
-  double delta = (now - last);
-  if (delta > 1000 ) {
-    heater_state = pwmcap.update(0xFFFF * Gpio::pin_map[heater_pin].value);
-    last = now;
-    heat += (heater_state - heat) * (delta / 1000000000.0);
-
-    NOLESS(heat, room_temp_raw);
-    Gpio::pin_map[analogInputToDigitalPin(adc_pin)].value = 0xFFFF - (uint16_t)heat;
-  }
-}
-
-void Heater::interrupt(GpioEvent ev) {
-  // unused
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/Heater.h b/Marlin/src/HAL/LINUX/hardware/Heater.h
deleted file mode 100644
index 6d590ce..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Heater.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "Gpio.h"
-
-struct LowpassFilter {
-  uint64_t data_delay = 0;
-  uint16_t update(uint16_t value) {
-    data_delay += value - (data_delay >> 6);
-    return uint16_t(data_delay >> 6);
-  }
-};
-
-class Heater: public Peripheral {
-public:
-  Heater(pin_t heater, pin_t adc);
-  virtual ~Heater();
-  void interrupt(GpioEvent ev);
-  void update();
-
-  pin_t heater_pin, adc_pin;
-  uint16_t room_temp_raw;
-  uint16_t heater_state;
-  LowpassFilter pwmcap;
-  double heat;
-  uint64_t last;
-};
diff --git a/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.cpp b/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.cpp
deleted file mode 100644
index c11fd1f..0000000
--- a/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "IOLoggerCSV.h"
-
-IOLoggerCSV::IOLoggerCSV(std::string filename) {
-  file.open(filename);
-}
-
-IOLoggerCSV::~IOLoggerCSV() {
-  file.close();
-}
-
-void IOLoggerCSV::log(GpioEvent ev) {
-  std::lock_guard<std::mutex> lock(vector_lock);
-  events.push_back(ev); //minimal impact to signal handler
-}
-
-void IOLoggerCSV::flush() {
-  { std::lock_guard<std::mutex> lock(vector_lock);
-    while (!events.empty()) {
-      file << events.front().timestamp << ", "<< events.front().pin_id << ", " << events.front().event << std::endl;
-      events.pop_front();
-    }
-  }
-  file.flush();
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.h b/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.h
deleted file mode 100644
index d8fe738..0000000
--- a/Marlin/src/HAL/LINUX/hardware/IOLoggerCSV.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <mutex>
-#include <list>
-#include <fstream>
-#include "Gpio.h"
-
-class IOLoggerCSV: public IOLogger {
-public:
-  IOLoggerCSV(std::string filename);
-  virtual ~IOLoggerCSV();
-  void flush();
-  void log(GpioEvent ev);
-
-private:
-  std::ofstream file;
-  std::list<GpioEvent> events;
-  std::mutex vector_lock;
-};
diff --git a/Marlin/src/HAL/LINUX/hardware/LinearAxis.cpp b/Marlin/src/HAL/LINUX/hardware/LinearAxis.cpp
deleted file mode 100644
index e122ef3..0000000
--- a/Marlin/src/HAL/LINUX/hardware/LinearAxis.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include <random>
-#include <stdio.h>
-#include "Clock.h"
-#include "LinearAxis.h"
-
-LinearAxis::LinearAxis(pin_type enable, pin_type dir, pin_type step, pin_type end_min, pin_type end_max) {
-  enable_pin = enable;
-  dir_pin = dir;
-  step_pin = step;
-  min_pin = end_min;
-  max_pin = end_max;
-
-  min_position = 50;
-  max_position = (200*80) + min_position;
-  position = rand() % ((max_position - 40) - min_position) + (min_position + 20);
-  last_update = Clock::nanos();
-
-  Gpio::attachPeripheral(step_pin, this);
-
-}
-
-LinearAxis::~LinearAxis() {
-
-}
-
-void LinearAxis::update() {
-
-}
-
-void LinearAxis::interrupt(GpioEvent ev) {
-  if (ev.pin_id == step_pin && !Gpio::pin_map[enable_pin].value) {
-    if (ev.event == GpioEvent::RISE) {
-      last_update = ev.timestamp;
-      position += -1 + 2 * Gpio::pin_map[dir_pin].value;
-      Gpio::pin_map[min_pin].value = (position < min_position);
-      //Gpio::pin_map[max_pin].value = (position > max_position);
-      //if (position < min_position) printf("axis(%d) endstop : pos: %d, mm: %f, min: %d\n", step_pin, position, position / 80.0, Gpio::pin_map[min_pin].value);
-    }
-  }
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/LinearAxis.h b/Marlin/src/HAL/LINUX/hardware/LinearAxis.h
deleted file mode 100644
index 34541e7..0000000
--- a/Marlin/src/HAL/LINUX/hardware/LinearAxis.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <chrono>
-#include "Gpio.h"
-
-class LinearAxis: public Peripheral {
-public:
-  LinearAxis(pin_type enable, pin_type dir, pin_type step, pin_type end_min, pin_type end_max);
-  virtual ~LinearAxis();
-  void update();
-  void interrupt(GpioEvent ev);
-
-  pin_type enable_pin;
-  pin_type dir_pin;
-  pin_type step_pin;
-  pin_type min_pin;
-  pin_type max_pin;
-
-  int32_t position;
-  int32_t min_position;
-  int32_t max_position;
-  uint64_t last_update;
-
-};
diff --git a/Marlin/src/HAL/LINUX/hardware/Timer.cpp b/Marlin/src/HAL/LINUX/hardware/Timer.cpp
deleted file mode 100644
index 9f0d6a8..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Timer.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "Timer.h"
-#include <stdio.h>
-
-Timer::Timer() {
-  active = false;
-  compare = 0;
-  frequency = 0;
-  overruns = 0;
-  timerid = 0;
-  cbfn = nullptr;
-  period = 0;
-  start_time = 0;
-  avg_error = 0;
-}
-
-Timer::~Timer() {
-  timer_delete(timerid);
-}
-
-void Timer::init(uint32_t sig_id, uint32_t sim_freq, callback_fn* fn) {
-  struct sigaction sa;
-  struct sigevent sev;
-
-  frequency = sim_freq;
-  cbfn = fn;
-
-  sa.sa_flags = SA_SIGINFO;
-  sa.sa_sigaction = Timer::handler;
-  sigemptyset(&sa.sa_mask);
-  if (sigaction(SIGRTMIN, &sa, nullptr) == -1) {
-    return; // todo: handle error
-  }
-
-  sigemptyset(&mask);
-  sigaddset(&mask, SIGRTMIN);
-
-  disable();
-
-  sev.sigev_notify = SIGEV_SIGNAL;
-  sev.sigev_signo = SIGRTMIN;
-  sev.sigev_value.sival_ptr = (void*)this;
-  if (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1) {
-    return; // todo: handle error
-  }
-}
-
-void Timer::start(uint32_t frequency) {
-  setCompare(this->frequency / frequency);
-  //printf("timer(%ld) started\n", getID());
-}
-
-void Timer::enable() {
-  if (sigprocmask(SIG_UNBLOCK, &mask, nullptr) == -1) {
-    return; // todo: handle error
-  }
-  active = true;
-  //printf("timer(%ld) enabled\n", getID());
-}
-
-void Timer::disable() {
-  if (sigprocmask(SIG_SETMASK, &mask, nullptr) == -1) {
-    return; // todo: handle error
-  }
-  active = false;
-}
-
-void Timer::setCompare(uint32_t compare) {
-  uint32_t nsec_offset = 0;
-  if (active) {
-    nsec_offset = Clock::nanos() - this->start_time; // calculate how long the timer would have been running for
-    nsec_offset = nsec_offset < 1000 ? nsec_offset : 0; // constrain, this shouldn't be needed but apparently Marlin enables interrupts on the stepper timer before initialising it, todo: investigate ?bug?
-  }
-  this->compare = compare;
-  uint64_t ns = Clock::ticksToNanos(compare, frequency) - nsec_offset;
-  struct itimerspec its;
-  its.it_value.tv_sec = ns / 1000000000;
-  its.it_value.tv_nsec = ns % 1000000000;
-  its.it_interval.tv_sec = its.it_value.tv_sec;
-  its.it_interval.tv_nsec = its.it_value.tv_nsec;
-
-  if (timer_settime(timerid, 0, &its, nullptr) == -1) {
-    printf("timer(%ld) failed, compare: %d(%ld)\n", getID(), compare, its.it_value.tv_nsec);
-    return; // todo: handle error
-  }
-  //printf("timer(%ld) started, compare: %d(%d)\n", getID(), compare, its.it_value.tv_nsec);
-  this->period = its.it_value.tv_nsec;
-  this->start_time = Clock::nanos();
-}
-
-uint32_t Timer::getCount() {
-  return Clock::nanosToTicks(Clock::nanos() - this->start_time, frequency);
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/hardware/Timer.h b/Marlin/src/HAL/LINUX/hardware/Timer.h
deleted file mode 100644
index 1b3b800..0000000
--- a/Marlin/src/HAL/LINUX/hardware/Timer.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <signal.h>
-#include <time.h>
-#include <stdio.h>
-
-#include "Clock.h"
-
-class Timer {
-public:
-  Timer();
-  virtual ~Timer();
-
-  typedef void (callback_fn)();
-
-  void init(uint32_t sig_id, uint32_t sim_freq, callback_fn* fn);
-  void start(uint32_t frequency);
-  void enable();
-  bool enabled() {return active;}
-  void disable();
-  void setCompare(uint32_t compare);
-  uint32_t getCount();
-  uint32_t getCompare() {return compare;}
-  uint32_t getOverruns() {return overruns;}
-  uint32_t getAvgError() {return avg_error;}
-
-  intptr_t getID() {
-    return (*(intptr_t*)timerid);
-  }
-
-  static void handler(int sig, siginfo_t *si, void *uc) {
-    Timer* _this = (Timer*)si->si_value.sival_ptr;
-    _this->avg_error += (Clock::nanos() - _this->start_time) - _this->period; //high_resolution_clock is also limited in precision, but best we have
-    _this->avg_error /= 2; //very crude precision analysis (actually within +-500ns usually)
-    _this->start_time = Clock::nanos(); // wrap
-    _this->cbfn();
-    _this->overruns += timer_getoverrun(_this->timerid); // even at 50Khz this doesn't stay zero, again demonstrating the limitations
-                                                         // using a realtime linux kernel would help somewhat
-  }
-
-private:
-  bool active;
-  uint32_t compare;
-  uint32_t frequency;
-  uint32_t overruns;
-  timer_t timerid;
-  sigset_t mask;
-  callback_fn* cbfn;
-  uint64_t period;
-  uint64_t avg_error;
-  uint64_t start_time;
-};
diff --git a/Marlin/src/HAL/LINUX/inc/Conditionals_LCD.h b/Marlin/src/HAL/LINUX/inc/Conditionals_LCD.h
deleted file mode 100644
index 99a6fc2..0000000
--- a/Marlin/src/HAL/LINUX/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/LINUX."
-#endif
diff --git a/Marlin/src/HAL/LINUX/inc/Conditionals_adv.h b/Marlin/src/HAL/LINUX/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/LINUX/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/LINUX/inc/Conditionals_post.h b/Marlin/src/HAL/LINUX/inc/Conditionals_post.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/LINUX/inc/Conditionals_post.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/LINUX/inc/SanityCheck.h b/Marlin/src/HAL/LINUX/inc/SanityCheck.h
deleted file mode 100644
index 36d3190..0000000
--- a/Marlin/src/HAL/LINUX/inc/SanityCheck.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test X86_64-specific configuration values for errors at compile-time.
- */
-
-// Emulating RAMPS
-#if ENABLED(SPINDLE_LASER_USE_PWM) && !(SPINDLE_LASER_PWM_PIN == 4 || SPINDLE_LASER_PWM_PIN == 6 || SPINDLE_LASER_PWM_PIN == 11)
-  #error "SPINDLE_LASER_PWM_PIN must use SERVO0, SERVO1 or SERVO3 connector"
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on LINUX."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on LINUX."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on LINUX."
-#endif
diff --git a/Marlin/src/HAL/LINUX/include/Arduino.h b/Marlin/src/HAL/LINUX/include/Arduino.h
deleted file mode 100644
index f05aaed..0000000
--- a/Marlin/src/HAL/LINUX/include/Arduino.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stddef.h>
-#include <stdint.h>
-#include <math.h>
-#include <cstring>
-
-#include <pinmapping.h>
-
-#define HIGH         0x01
-#define LOW          0x00
-
-#define INPUT          0x00
-#define OUTPUT         0x01
-#define INPUT_PULLUP   0x02
-#define INPUT_PULLDOWN 0x03
-
-#define LSBFIRST     0
-#define MSBFIRST     1
-
-#define CHANGE       0x02
-#define FALLING      0x03
-#define RISING       0x04
-
-typedef uint8_t byte;
-#define PROGMEM
-#define PSTR(v) (v)
-#define PGM_P const char *
-
-// Used for libraries, preprocessor, and constants
-#define abs(x) ((x)>0?(x):-(x))
-
-#ifndef isnan
-  #define isnan std::isnan
-#endif
-#ifndef isinf
-  #define isinf std::isinf
-#endif
-
-#define sq(v) ((v) * (v))
-#define constrain(value, arg_min, arg_max) ((value) < (arg_min) ? (arg_min) :((value) > (arg_max) ? (arg_max) : (value)))
-
-// Interrupts
-void cli(); // Disable
-void sei(); // Enable
-void attachInterrupt(uint32_t pin, void (*callback)(), uint32_t mode);
-void detachInterrupt(uint32_t pin);
-
-extern "C" {
-  void GpioEnableInt(uint32_t port, uint32_t pin, uint32_t mode);
-  void GpioDisableInt(uint32_t port, uint32_t pin);
-}
-
-// Time functions
-extern "C" void delay(const int ms);
-void _delay_ms(const int ms);
-void delayMicroseconds(unsigned long);
-uint32_t millis();
-
-//IO functions
-void pinMode(const pin_t, const uint8_t);
-void digitalWrite(pin_t, uint8_t);
-bool digitalRead(pin_t);
-void analogWrite(pin_t, int);
-uint16_t analogRead(pin_t);
-
-int32_t random(int32_t);
-int32_t random(int32_t, int32_t);
-void randomSeed(uint32_t);
-
-char *dtostrf(double __val, signed char __width, unsigned char __prec, char *__s);
-
-int map(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max);
diff --git a/Marlin/src/HAL/LINUX/include/pinmapping.cpp b/Marlin/src/HAL/LINUX/include/pinmapping.cpp
deleted file mode 100644
index 5823668..0000000
--- a/Marlin/src/HAL/LINUX/include/pinmapping.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include <pinmapping.h>
-
-#include "../../../gcode/parser.h"
-
-int16_t PARSED_PIN_INDEX(const char code, const int16_t dval) {
-  return parser.intval(code, dval);
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/include/pinmapping.h b/Marlin/src/HAL/LINUX/include/pinmapping.h
deleted file mode 100644
index cfac5e3..0000000
--- a/Marlin/src/HAL/LINUX/include/pinmapping.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#include <stdint.h>
-#include "../hardware/Gpio.h"
-
-typedef pin_type pin_t;
-
-#define P_NC -1
-constexpr uint16_t NUM_DIGITAL_PINS = Gpio::pin_count;
-constexpr uint8_t NUM_ANALOG_INPUTS = 16;
-
-#define HAL_SENSITIVE_PINS
-
-constexpr uint8_t analog_offset = NUM_DIGITAL_PINS - NUM_ANALOG_INPUTS;
-
-// Get the digital pin for an analog index
-constexpr pin_t analogInputToDigitalPin(const int8_t p) {
-  return (WITHIN(p, 0, NUM_ANALOG_INPUTS) ? analog_offset + p : P_NC);
-}
-
-// Get the analog index for a digital pin
-constexpr int8_t DIGITAL_PIN_TO_ANALOG_PIN(const pin_t p) {
-  return (WITHIN(p, analog_offset, NUM_DIGITAL_PINS) ? p - analog_offset : P_NC);
-}
-
-// Return the index of a pin number
-constexpr int16_t GET_PIN_MAP_INDEX(const pin_t pin) { return pin; }
-
-// Test whether the pin is valid
-constexpr bool VALID_PIN(const pin_t p) { return WITHIN(p, 0, NUM_DIGITAL_PINS); }
-
-// Test whether the pin is PWM
-constexpr bool PWM_PIN(const pin_t p) { return false; }
-
-// Test whether the pin is interruptible
-constexpr bool INTERRUPT_PIN(const pin_t p) { return false; }
-
-// Get the pin number at the given index
-constexpr pin_t GET_PIN_MAP_PIN(const int16_t ind) { return ind; }
-
-// Parse a G-code word into a pin index
-int16_t PARSED_PIN_INDEX(const char code, const int16_t dval);
diff --git a/Marlin/src/HAL/LINUX/include/serial.h b/Marlin/src/HAL/LINUX/include/serial.h
deleted file mode 100644
index ebae066..0000000
--- a/Marlin/src/HAL/LINUX/include/serial.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../../inc/MarlinConfigPre.h"
-#if ENABLED(EMERGENCY_PARSER)
-  #include "../../../feature/e_parser.h"
-#endif
-#include "../../../core/serial_hook.h"
-
-#include <stdarg.h>
-#include <stdio.h>
-
-/**
- * Generic RingBuffer
- * T type of the buffer array
- * S size of the buffer (must be power of 2)
- */
-template <typename T, uint32_t S> class RingBuffer {
-public:
-  RingBuffer() { index_read = index_write = 0; }
-  uint32_t available() volatile { return index_write - index_read; }
-  uint32_t free() volatile      { return buffer_size - available(); }
-  bool empty() volatile         { return index_read == index_write; }
-  bool full() volatile          { return available() == buffer_size; }
-  void clear() volatile         { index_read = index_write = 0; }
-
-  bool peek(T *value) volatile {
-    if (value == 0 || available() == 0)
-      return false;
-    *value = buffer[mask(index_read)];
-    return true;
-  }
-
-  int read() volatile {
-    if (empty()) return -1;
-    return buffer[mask(index_read++)];
-  }
-
-  bool write(T value) volatile {
-    if (full()) return false;
-    buffer[mask(index_write++)] = value;
-    return true;
-  }
-
-private:
-  uint32_t mask(uint32_t val) volatile {
-    return buffer_mask & val;
-  }
-
-  static const uint32_t buffer_size = S;
-  static const uint32_t buffer_mask = buffer_size - 1;
-  volatile T buffer[buffer_size];
-  volatile uint32_t index_write;
-  volatile uint32_t index_read;
-};
-
-struct HalSerial {
-  HalSerial() { host_connected = true; }
-
-  void begin(int32_t) {}
-  void end()          {}
-
-  int peek() {
-    uint8_t value;
-    return receive_buffer.peek(&value) ? value : -1;
-  }
-
-  int read() { return receive_buffer.read(); }
-
-  size_t write(char c) {
-    if (!host_connected) return 0;
-    while (!transmit_buffer.free());
-    return transmit_buffer.write(c);
-  }
-
-  bool connected() { return host_connected; }
-
-  uint16_t available() {
-    return (uint16_t)receive_buffer.available();
-  }
-
-  void flush() { receive_buffer.clear(); }
-
-  uint8_t availableForWrite() {
-    return transmit_buffer.free() > 255 ? 255 : (uint8_t)transmit_buffer.free();
-  }
-
-  void flushTX() {
-    if (host_connected)
-      while (transmit_buffer.available()) { /* nada */ }
-  }
-
-  volatile RingBuffer<uint8_t, 128> receive_buffer;
-  volatile RingBuffer<uint8_t, 128> transmit_buffer;
-  volatile bool host_connected;
-};
-
-typedef Serial1Class<HalSerial> MSerialT;
diff --git a/Marlin/src/HAL/LINUX/main.cpp b/Marlin/src/HAL/LINUX/main.cpp
deleted file mode 100644
index f2af2ff..0000000
--- a/Marlin/src/HAL/LINUX/main.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#ifdef __PLAT_LINUX__
-
-//#define GPIO_LOGGING // Full GPIO and Positional Logging
-
-#include "../../inc/MarlinConfig.h"
-#include "../shared/Delay.h"
-#include "hardware/IOLoggerCSV.h"
-#include "hardware/Heater.h"
-#include "hardware/LinearAxis.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <thread>
-#include <iostream>
-#include <fstream>
-
-extern void setup();
-extern void loop();
-
-// simple stdout / stdin implementation for fake serial port
-void write_serial_thread() {
-  for (;;) {
-    for (std::size_t i = usb_serial.transmit_buffer.available(); i > 0; i--) {
-      fputc(usb_serial.transmit_buffer.read(), stdout);
-    }
-    std::this_thread::yield();
-  }
-}
-
-void read_serial_thread() {
-  char buffer[255] = {};
-  for (;;) {
-    std::size_t len = _MIN(usb_serial.receive_buffer.free(), 254U);
-    if (fgets(buffer, len, stdin))
-      for (std::size_t i = 0; i < strlen(buffer); i++)
-        usb_serial.receive_buffer.write(buffer[i]);
-    std::this_thread::yield();
-  }
-}
-
-void simulation_loop() {
-  Heater hotend(HEATER_0_PIN, TEMP_0_PIN);
-  Heater bed(HEATER_BED_PIN, TEMP_BED_PIN);
-  LinearAxis x_axis(X_ENABLE_PIN, X_DIR_PIN, X_STEP_PIN, X_MIN_PIN, X_MAX_PIN);
-  LinearAxis y_axis(Y_ENABLE_PIN, Y_DIR_PIN, Y_STEP_PIN, Y_MIN_PIN, Y_MAX_PIN);
-  LinearAxis z_axis(Z_ENABLE_PIN, Z_DIR_PIN, Z_STEP_PIN, Z_MIN_PIN, Z_MAX_PIN);
-  LinearAxis extruder0(E0_ENABLE_PIN, E0_DIR_PIN, E0_STEP_PIN, P_NC, P_NC);
-
-  #ifdef GPIO_LOGGING
-    IOLoggerCSV logger("all_gpio_log.csv");
-    Gpio::attachLogger(&logger);
-
-    std::ofstream position_log;
-    position_log.open("axis_position_log.csv");
-
-    int32_t x,y,z;
-  #endif
-
-  for (;;) {
-
-    hotend.update();
-    bed.update();
-
-    x_axis.update();
-    y_axis.update();
-    z_axis.update();
-    extruder0.update();
-
-    #ifdef GPIO_LOGGING
-      if (x_axis.position != x || y_axis.position != y || z_axis.position != z) {
-        uint64_t update = _MAX(x_axis.last_update, y_axis.last_update, z_axis.last_update);
-        position_log << update << ", " << x_axis.position << ", " << y_axis.position << ", " << z_axis.position << std::endl;
-        position_log.flush();
-        x = x_axis.position;
-        y = y_axis.position;
-        z = z_axis.position;
-      }
-      // flush the logger
-      logger.flush();
-    #endif
-
-    std::this_thread::yield();
-  }
-}
-
-int main() {
-  std::thread write_serial (write_serial_thread);
-  std::thread read_serial (read_serial_thread);
-
-  #ifdef MYSERIAL1
-    MYSERIAL1.begin(BAUDRATE);
-    SERIAL_ECHOLNPGM("x86_64 Initialized");
-    SERIAL_FLUSHTX();
-  #endif
-
-  Clock::setFrequency(F_CPU);
-  Clock::setTimeMultiplier(1.0); // some testing at 10x
-
-  HAL_timer_init();
-
-  std::thread simulation (simulation_loop);
-
-  DELAY_US(10000);
-
-  setup();
-  for (;;) {
-    loop();
-    std::this_thread::yield();
-  }
-
-  simulation.join();
-  write_serial.join();
-  read_serial.join();
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/pinsDebug.h b/Marlin/src/HAL/LINUX/pinsDebug.h
deleted file mode 100644
index 7bfd97d..0000000
--- a/Marlin/src/HAL/LINUX/pinsDebug.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Support routines for X86_64
- */
-
-/**
- * Translation of routines & variables used by pinsDebug.h
- */
-
-#define NUMBER_PINS_TOTAL NUM_DIGITAL_PINS
-#define pwm_details(pin)    NOOP          // (do nothing)
-#define pwm_status(pin)     false         // Print a pin's PWM status. Return true if it's currently a PWM pin.
-#define IS_ANALOG(P)        (DIGITAL_PIN_TO_ANALOG_PIN(P) >= 0 ? 1 : 0)
-#define digitalRead_mod(p)  digitalRead(p)
-#define PRINT_PORT(p)
-#define GET_ARRAY_PIN(p)    pin_array[p].pin
-#define PRINT_ARRAY_NAME(x) do{ sprintf_P(buffer, PSTR("%-" STRINGIFY(MAX_NAME_LENGTH) "s"), pin_array[x].name); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN(p)        do{ sprintf_P(buffer, PSTR("%3d "), p); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR(" (A%2d)  "), DIGITAL_PIN_TO_ANALOG_PIN(pin)); SERIAL_ECHO(buffer); }while(0)
-#define MULTI_NAME_PAD  16 // space needed to be pretty if not first name assigned to a pin
-
-// active ADC function/mode/code values for PINSEL registers
-constexpr int8_t ADC_pin_mode(pin_t pin) {
-  return (-1);
-}
-
-int8_t get_pin_mode(pin_t pin) {
-  if (!VALID_PIN(pin)) return -1;
-  return 0;
-}
-
-bool GET_PINMODE(pin_t pin) {
-  int8_t pin_mode = get_pin_mode(pin);
-  if (pin_mode == -1 || pin_mode == ADC_pin_mode(pin)) // found an invalid pin or active analog pin
-    return false;
-
-  return (Gpio::getMode(pin) != 0); //input/output state
-}
-
-bool GET_ARRAY_IS_DIGITAL(pin_t pin) {
-  return (!IS_ANALOG(pin) || get_pin_mode(pin) != ADC_pin_mode(pin));
-}
diff --git a/Marlin/src/HAL/LINUX/servo_private.h b/Marlin/src/HAL/LINUX/servo_private.h
deleted file mode 100644
index bcc8d20..0000000
--- a/Marlin/src/HAL/LINUX/servo_private.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * servo.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
- * Copyright (c) 2009 Michael Margolis.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/**
- * Based on "servo.h - Interrupt driven Servo library for Arduino using 16 bit timers -
- *           Version 2 Copyright (c) 2009 Michael Margolis.  All right reserved.
- *
- * The only modification was to update/delete macros to match the LPC176x.
- */
-
-#include <stdint.h>
-
-// Macros
-//values in microseconds
-#define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo
-#define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo
-#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
-#define REFRESH_INTERVAL    20000     // minimum time to refresh servos in microseconds
-
-#define MAX_SERVOS             4
-
-#define INVALID_SERVO         255     // flag indicating an invalid servo index
-
-
-// Types
-
-typedef struct {
-  uint8_t nbr        : 8 ;            // a pin number from 0 to 254 (255 signals invalid pin)
-  uint8_t isActive   : 1 ;            // true if this channel is enabled, pin not pulsed if false
-} ServoPin_t;
-
-typedef struct {
-  ServoPin_t Pin;
-  unsigned int pulse_width;           // pulse width in microseconds
-} ServoInfo_t;
-
-// Global variables
-
-extern uint8_t ServoCount;
-extern ServoInfo_t servo_info[MAX_SERVOS];
diff --git a/Marlin/src/HAL/LINUX/spi_pins.h b/Marlin/src/HAL/LINUX/spi_pins.h
deleted file mode 100644
index 33136ac..0000000
--- a/Marlin/src/HAL/LINUX/spi_pins.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../core/macros.h"
-#include "../../inc/MarlinConfigPre.h"
-
-#if BOTH(HAS_MARLINUI_U8GLIB, SDSUPPORT) && (LCD_PINS_D4 == SD_SCK_PIN || LCD_PINS_ENABLE == SD_MOSI_PIN || DOGLCD_SCK == SD_SCK_PIN || DOGLCD_MOSI == SD_MOSI_PIN)
-  #define LPC_SOFTWARE_SPI  // If the SD card and LCD adapter share the same SPI pins, then software SPI is currently
-                            // needed due to the speed and mode required for communicating with each device being different.
-                            // This requirement can be removed if the SPI access to these devices is updated to use
-                            // spiBeginTransaction.
-#endif
-
-// Onboard SD
-//#define SD_SCK_PIN     P0_07
-//#define SD_MISO_PIN    P0_08
-//#define SD_MOSI_PIN    P0_09
-//#define SD_SS_PIN      P0_06
-
-// External SD
-#ifndef SD_SCK_PIN
-  #define SD_SCK_PIN        50
-#endif
-#ifndef SD_MISO_PIN
-  #define SD_MISO_PIN       51
-#endif
-#ifndef SD_MOSI_PIN
-  #define SD_MOSI_PIN       52
-#endif
-#ifndef SD_SS_PIN
-  #define SD_SS_PIN         53
-#endif
-#ifndef SDSS
-  #define SDSS       SD_SS_PIN
-#endif
diff --git a/Marlin/src/HAL/LINUX/timers.cpp b/Marlin/src/HAL/LINUX/timers.cpp
deleted file mode 100644
index 66d80f2..0000000
--- a/Marlin/src/HAL/LINUX/timers.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __PLAT_LINUX__
-
-#include "hardware/Timer.h"
-
-#include "../../inc/MarlinConfig.h"
-
-/**
- * Use POSIX signals to attempt to emulate Interrupts
- * This has many limitations and is not fit for the purpose
- */
-
-HAL_STEP_TIMER_ISR();
-HAL_TEMP_TIMER_ISR();
-
-Timer timers[2];
-
-void HAL_timer_init() {
-  timers[0].init(0, STEPPER_TIMER_RATE, TIMER0_IRQHandler);
-  timers[1].init(1, TEMP_TIMER_RATE, TIMER1_IRQHandler);
-}
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  timers[timer_num].start(frequency);
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  timers[timer_num].enable();
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  timers[timer_num].disable();
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  return timers[timer_num].enabled();
-}
-
-void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  timers[timer_num].setCompare(compare);
-}
-
-hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  return timers[timer_num].getCompare();
-}
-
-hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  return timers[timer_num].getCount();
-}
-
-#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/timers.h b/Marlin/src/HAL/LINUX/timers.h
deleted file mode 100644
index 2d2a957..0000000
--- a/Marlin/src/HAL/LINUX/timers.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL timers for Linux X86_64
- */
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define HAL_TIMER_RATE         ((SystemCoreClock) / 4)  // frequency of timers peripherals
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-
-#define TEMP_TIMER_RATE        1000000
-#define TEMP_TIMER_FREQUENCY   1000 // temperature interrupt frequency
-
-#define STEPPER_TIMER_RATE     HAL_TIMER_RATE   // frequency of stepper timer (HAL_TIMER_RATE / STEPPER_TIMER_PRESCALE)
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // stepper timer ticks per Âµs
-#define STEPPER_TIMER_PRESCALE (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR()  extern "C" void TIMER0_IRQHandler()
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR()  extern "C" void TIMER1_IRQHandler()
-#endif
-
-// PWM timer
-#define HAL_PWM_TIMER
-#define HAL_PWM_TIMER_ISR()   extern "C" void TIMER3_IRQHandler()
-#define HAL_PWM_TIMER_IRQn
-
-void HAL_timer_init();
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare);
-hal_timer_t HAL_timer_get_compare(const uint8_t timer_num);
-hal_timer_t HAL_timer_get_count(const uint8_t timer_num);
-FORCE_INLINE static void HAL_timer_restrain(const uint8_t timer_num, const uint16_t interval_ticks) {
-  const hal_timer_t mincmp = HAL_timer_get_count(timer_num) + interval_ticks;
-  if (HAL_timer_get_compare(timer_num) < mincmp) HAL_timer_set_compare(timer_num, mincmp);
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-#define HAL_timer_isr_prologue(T) NOOP
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/LPC1768/HAL.cpp b/Marlin/src/HAL/LPC1768/HAL.cpp
deleted file mode 100644
index 9ff3a6b..0000000
--- a/Marlin/src/HAL/LPC1768/HAL.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-#include "../shared/Delay.h"
-#include "../../../gcode/parser.h"
-
-DefaultSerial1 USBSerial(false, UsbSerial);
-
-uint32_t MarlinHAL::adc_result = 0;
-
-// U8glib required functions
-extern "C" {
-  void u8g_xMicroDelay(uint16_t val) { DELAY_US(val); }
-  void u8g_MicroDelay()              { u8g_xMicroDelay(1); }
-  void u8g_10MicroDelay()            { u8g_xMicroDelay(10); }
-  void u8g_Delay(uint16_t val)       { delay(val); }
-}
-
-// return free heap space
-int freeMemory() {
-  char stack_end;
-  void *heap_start = malloc(sizeof(uint32_t));
-  if (heap_start == 0) return 0;
-
-  uint32_t result = (uint32_t)&stack_end - (uint32_t)heap_start;
-  free(heap_start);
-  return result;
-}
-
-void MarlinHAL::reboot() { NVIC_SystemReset(); }
-
-uint8_t MarlinHAL::get_reset_source() {
-  #if ENABLED(USE_WATCHDOG)
-    if (watchdog_timed_out()) return RST_WATCHDOG;
-  #endif
-  return RST_POWER_ON;
-}
-
-void MarlinHAL::clear_reset_source() { watchdog_clear_timeout_flag(); }
-
-void flashFirmware(const int16_t) {
-  delay(500);          // Give OS time to disconnect
-  USB_Connect(false);  // USB clear connection
-  delay(1000);         // Give OS time to notice
-  hal.reboot();
-}
-
-#if ENABLED(USE_WATCHDOG)
-
-  #include <lpc17xx_wdt.h>
-
-  #define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
-
-  void MarlinHAL::watchdog_init() {
-    #if ENABLED(WATCHDOG_RESET_MANUAL)
-      // We enable the watchdog timer, but only for the interrupt.
-
-      // Configure WDT to only trigger an interrupt
-      // Disable WDT interrupt (just in case, to avoid triggering it!)
-      NVIC_DisableIRQ(WDT_IRQn);
-
-      // We NEED memory barriers to ensure Interrupts are actually disabled!
-      // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-      __DSB();
-      __ISB();
-
-      // Configure WDT to only trigger an interrupt
-      // Initialize WDT with the given parameters
-      WDT_Init(WDT_CLKSRC_IRC, WDT_MODE_INT_ONLY);
-
-      // Configure and enable WDT interrupt.
-      NVIC_ClearPendingIRQ(WDT_IRQn);
-      NVIC_SetPriority(WDT_IRQn, 0); // Use highest priority, so we detect all kinds of lockups
-      NVIC_EnableIRQ(WDT_IRQn);
-    #else
-      WDT_Init(WDT_CLKSRC_IRC, WDT_MODE_RESET);
-    #endif
-    WDT_Start(WDT_TIMEOUT_US);
-  }
-
-  void MarlinHAL::watchdog_refresh() {
-    WDT_Feed();
-    #if DISABLED(PINS_DEBUGGING) && PIN_EXISTS(LED)
-      TOGGLE(LED_PIN);  // heartbeat indicator
-    #endif
-  }
-
-  // Timeout state
-  bool MarlinHAL::watchdog_timed_out() { return TEST(WDT_ReadTimeOutFlag(), 0); }
-  void MarlinHAL::watchdog_clear_timeout_flag() { WDT_ClrTimeOutFlag(); }
-
-#endif // USE_WATCHDOG
-
-// For M42/M43, scan command line for pin code
-//   return index into pin map array if found and the pin is valid.
-//   return dval if not found or not a valid pin.
-int16_t PARSED_PIN_INDEX(const char code, const int16_t dval) {
-  const uint16_t val = (uint16_t)parser.intval(code, -1), port = val / 100, pin = val % 100;
-  const  int16_t ind = (port < ((NUM_DIGITAL_PINS) >> 5) && pin < 32) ? ((port << 5) | pin) : -2;
-  return ind > -1 ? ind : dval;
-}
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/HAL.h b/Marlin/src/HAL/LPC1768/HAL.h
deleted file mode 100644
index b0eeb98..0000000
--- a/Marlin/src/HAL/LPC1768/HAL.h
+++ /dev/null
@@ -1,267 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL_LPC1768/HAL.h
- * Hardware Abstraction Layer for NXP LPC1768
- */
-
-#define CPU_32_BIT
-
-#include <stdint.h>
-#include <stdarg.h>
-#include <algorithm>
-
-extern "C" volatile uint32_t _millis;
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-#include "fastio.h"
-#include "MarlinSerial.h"
-
-#include <adc.h>
-#include <pinmapping.h>
-#include <CDCSerial.h>
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-typedef ForwardSerial1Class< decltype(UsbSerial) > DefaultSerial1;
-extern DefaultSerial1 USBSerial;
-
-#define _MSERIAL(X) MSerial##X
-#define MSERIAL(X) _MSERIAL(X)
-
-#if SERIAL_PORT == -1
-  #define MYSERIAL1 USBSerial
-#elif WITHIN(SERIAL_PORT, 0, 3)
-  #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-#else
-  #error "SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-#endif
-
-#ifdef SERIAL_PORT_2
-  #if SERIAL_PORT_2 == -1
-    #define MYSERIAL2 USBSerial
-  #elif WITHIN(SERIAL_PORT_2, 0, 3)
-    #define MYSERIAL2 MSERIAL(SERIAL_PORT_2)
-  #else
-    #error "SERIAL_PORT_2 must be from 0 to 3. You can also use -1 if the board supports Native USB."
-  #endif
-#endif
-
-#ifdef SERIAL_PORT_3
-  #if SERIAL_PORT_3 == -1
-    #define MYSERIAL3 USBSerial
-  #elif WITHIN(SERIAL_PORT_3, 0, 3)
-    #define MYSERIAL3 MSERIAL(SERIAL_PORT_3)
-  #else
-    #error "SERIAL_PORT_3 must be from 0 to 3. You can also use -1 if the board supports Native USB."
-  #endif
-#endif
-
-#ifdef MMU2_SERIAL_PORT
-  #if MMU2_SERIAL_PORT == -1
-    #define MMU2_SERIAL USBSerial
-  #elif WITHIN(MMU2_SERIAL_PORT, 0, 3)
-    #define MMU2_SERIAL MSERIAL(MMU2_SERIAL_PORT)
-  #else
-    #error "MMU2_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-  #endif
-#endif
-
-#ifdef LCD_SERIAL_PORT
-  #if LCD_SERIAL_PORT == -1
-    #define LCD_SERIAL USBSerial
-  #elif WITHIN(LCD_SERIAL_PORT, 0, 3)
-    #define LCD_SERIAL MSERIAL(LCD_SERIAL_PORT)
-  #else
-    #error "LCD_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-  #endif
-  #if HAS_DGUS_LCD
-    #define SERIAL_GET_TX_BUFFER_FREE() LCD_SERIAL.available()
-  #endif
-#endif
-
-//
-// Interrupts
-//
-
-#define CRITICAL_SECTION_START()  const bool irqon = !__get_PRIMASK(); __disable_irq()
-#define CRITICAL_SECTION_END()    if (irqon) __enable_irq()
-
-//
-// ADC
-//
-
-#define ADC_MEDIAN_FILTER_SIZE (23) // Higher values increase step delay (phase shift),
-                                    // (ADC_MEDIAN_FILTER_SIZE + 1) / 2 sample step delay (12 samples @ 500Hz: 24ms phase shift)
-                                    // Memory usage per ADC channel (bytes): (6 * ADC_MEDIAN_FILTER_SIZE) + 16
-                                    // 8 * ((6 * 23) + 16 ) = 1232 Bytes for 8 channels
-
-#define ADC_LOWPASS_K_VALUE    (2)  // Higher values increase rise time
-                                    // Rise time sample delays for 100% signal convergence on full range step
-                                    // (1 : 13, 2 : 32, 3 : 67, 4 : 139, 5 : 281, 6 : 565, 7 : 1135, 8 : 2273)
-                                    // K = 6, 565 samples, 500Hz sample rate, 1.13s convergence on full range step
-                                    // Memory usage per ADC channel (bytes): 4 (32 Bytes for 8 channels)
-
-#define HAL_ADC_VREF            3.3 // ADC voltage reference
-
-#define HAL_ADC_RESOLUTION     12   // 15 bit maximum, raw temperature is stored as int16_t
-#define HAL_ADC_FILTERED            // Disable oversampling done in Marlin as ADC values already filtered in HAL
-
-//
-// Pin Mapping for M42, M43, M226
-//
-
-// Test whether the pin is valid
-constexpr bool VALID_PIN(const pin_t pin) {
-  return LPC176x::pin_is_valid(pin);
-}
-
-// Get the analog index for a digital pin
-constexpr int8_t DIGITAL_PIN_TO_ANALOG_PIN(const pin_t pin) {
-  return (LPC176x::pin_is_valid(pin) && LPC176x::pin_has_adc(pin)) ? pin : -1;
-}
-
-// Return the index of a pin number
-constexpr int16_t GET_PIN_MAP_INDEX(const pin_t pin) {
-  return LPC176x::pin_index(pin);
-}
-
-// Get the pin number at the given index
-constexpr pin_t GET_PIN_MAP_PIN(const int16_t index) {
-  return LPC176x::pin_index(index);
-}
-
-// Parse a G-code word into a pin index
-int16_t PARSED_PIN_INDEX(const char code, const int16_t dval);
-// P0.6 thru P0.9 are for the onboard SD card
-#define HAL_SENSITIVE_PINS P0_06, P0_07, P0_08, P0_09,
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define PLATFORM_M997_SUPPORT
-void flashFirmware(const int16_t);
-
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
-
-// Default graphical display delays
-#define CPU_ST7920_DELAY_1 600
-#define CPU_ST7920_DELAY_2 750
-#define CPU_ST7920_DELAY_3 750
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-int freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  static void init();          // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return !__get_PRIMASK(); }
-  static void isr_on()  { __enable_irq(); }
-  static void isr_off() { __disable_irq(); }
-
-  static void delay_ms(const int ms) { _delay_ms(ms); }
-
-  // Watchdog
-  static void watchdog_init() IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-  static bool watchdog_timed_out() IF_DISABLED(USE_WATCHDOG, { return false; });
-  static void watchdog_clear_timeout_flag() IF_DISABLED(USE_WATCHDOG, {});
-
-  // Tasks, called from idle()
-  static void idletask();
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source();
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  using FilteredADC = LPC176x::ADC<ADC_LOWPASS_K_VALUE, ADC_MEDIAN_FILTER_SIZE>;
-
-  // Called by Temperature::init once at startup
-  static void adc_init() {}
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const pin_t pin) {
-    FilteredADC::enable_channel(pin);
-  }
-
-  // Begin ADC sampling on the given pin. Called from Temperature::isr!
-  static uint32_t adc_result;
-  static void adc_start(const pin_t pin) {
-    adc_result = FilteredADC::read(pin) >> (16 - HAL_ADC_RESOLUTION); // returns 16bit value, reduce to required bits
-  }
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value() { return uint16_t(adc_result); }
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * Optionally invert the duty cycle [default = false]
-   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
-
-  /**
-   * Set the frequency of the timer corresponding to the provided pin
-   * All Hardware PWM pins will run at the same frequency and
-   * All Software PWM pins will run at the same frequency
-   */
-  static void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
-};
diff --git a/Marlin/src/HAL/LPC1768/HAL_SPI.cpp b/Marlin/src/HAL/LPC1768/HAL_SPI.cpp
deleted file mode 100644
index 29f9b43..0000000
--- a/Marlin/src/HAL/LPC1768/HAL_SPI.cpp
+++ /dev/null
@@ -1,406 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Software SPI functions originally from Arduino Sd2Card Library
- * Copyright (c) 2009 by William Greiman
- */
-
-/**
- * For TARGET_LPC1768
- */
-
-/**
- * Hardware SPI and Software SPI implementations are included in this file.
- * The hardware SPI runs faster and has higher throughput but is not compatible
- * with some LCD interfaces/adapters.
- *
- * Control of the slave select pin(s) is handled by the calling routines.
- *
- * Some of the LCD interfaces/adapters result in the LCD SPI and the SD card
- * SPI sharing pins. The SCK, MOSI & MISO pins can NOT be set/cleared with
- * WRITE nor digitalWrite when the hardware SPI module within the LPC17xx is
- * active. If any of these pins are shared then the software SPI must be used.
- *
- * A more sophisticated hardware SPI can be found at the following link.
- * This implementation has not been fully debugged.
- * https://github.com/MarlinFirmware/Marlin/tree/071c7a78f27078fd4aee9a3ef365fcf5e143531e
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-#include <SPI.h>
-
-// Hardware SPI and SPIClass
-#include <lpc17xx_pinsel.h>
-#include <lpc17xx_clkpwr.h>
-
-#include "../shared/HAL_SPI.h"
-
-// ------------------------
-// Public functions
-// ------------------------
-#if ENABLED(LPC_SOFTWARE_SPI)
-
-  // Software SPI
-
-  #include <SoftwareSPI.h>
-
-  static uint8_t SPI_speed = SPI_FULL_SPEED;
-
-  static uint8_t spiTransfer(uint8_t b) {
-    return swSpiTransfer(b, SPI_speed, SD_SCK_PIN, SD_MISO_PIN, SD_MOSI_PIN);
-  }
-
-  void spiBegin() {
-    swSpiBegin(SD_SCK_PIN, SD_MISO_PIN, SD_MOSI_PIN);
-  }
-
-  void spiInit(uint8_t spiRate) {
-    SPI_speed = swSpiInit(spiRate, SD_SCK_PIN, SD_MOSI_PIN);
-  }
-
-  uint8_t spiRec() { return spiTransfer(0xFF); }
-
-  void spiRead(uint8_t*buf, uint16_t nbyte) {
-    for (int i = 0; i < nbyte; i++)
-      buf[i] = spiTransfer(0xFF);
-  }
-
-  void spiSend(uint8_t b) { (void)spiTransfer(b); }
-
-  void spiSend(const uint8_t *buf, size_t nbyte) {
-    for (uint16_t i = 0; i < nbyte; i++)
-      (void)spiTransfer(buf[i]);
-  }
-
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-    (void)spiTransfer(token);
-    for (uint16_t i = 0; i < 512; i++)
-      (void)spiTransfer(buf[i]);
-  }
-
-#else
-
-  #ifdef SD_SPI_SPEED
-    #define INIT_SPI_SPEED SD_SPI_SPEED
-  #else
-    #define INIT_SPI_SPEED SPI_FULL_SPEED
-  #endif
-
-  void spiBegin() { spiInit(INIT_SPI_SPEED); } // Set up SCK, MOSI & MISO pins for SSP0
-
-  void spiInit(uint8_t spiRate) {
-    #if SD_MISO_PIN == BOARD_SPI1_MISO_PIN
-      SPI.setModule(1);
-    #elif SD_MISO_PIN == BOARD_SPI2_MISO_PIN
-      SPI.setModule(2);
-    #endif
-    SPI.setDataSize(DATA_SIZE_8BIT);
-    SPI.setDataMode(SPI_MODE0);
-
-    SPI.setClock(SPISettings::spiRate2Clock(spiRate));
-    SPI.begin();
-  }
-
-  static uint8_t doio(uint8_t b) {
-    return SPI.transfer(b & 0x00FF) & 0x00FF;
-  }
-
-  void spiSend(uint8_t b) { doio(b); }
-
-  void spiSend(const uint8_t *buf, size_t nbyte) {
-    for (uint16_t i = 0; i < nbyte; i++) doio(buf[i]);
-  }
-
-  void spiSend(uint32_t chan, byte b) {}
-
-  void spiSend(uint32_t chan, const uint8_t *buf, size_t nbyte) {}
-
-  // Read single byte from SPI
-  uint8_t spiRec() { return doio(0xFF); }
-
-  uint8_t spiRec(uint32_t chan) { return 0; }
-
-  // Read from SPI into buffer
-  void spiRead(uint8_t *buf, uint16_t nbyte) {
-    for (uint16_t i = 0; i < nbyte; i++) buf[i] = doio(0xFF);
-  }
-
-  uint8_t spiTransfer(uint8_t b) { return doio(b); }
-
-  // Write from buffer to SPI
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-   (void)spiTransfer(token);
-    for (uint16_t i = 0; i < 512; i++)
-      (void)spiTransfer(buf[i]);
-  }
-
-  // Begin SPI transaction, set clock, bit order, data mode
-  void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-    // TODO: Implement this method
-  }
-
-#endif // LPC_SOFTWARE_SPI
-
-/**
- * @brief Wait until TXE (tx empty) flag is set and BSY (busy) flag unset.
- */
-static inline void waitSpiTxEnd(LPC_SSP_TypeDef *spi_d) {
-  while (SSP_GetStatus(spi_d, SSP_STAT_TXFIFO_EMPTY) == RESET) { /* nada */ } // wait until TXE=1
-  while (SSP_GetStatus(spi_d, SSP_STAT_BUSY) == SET) { /* nada */ }     // wait until BSY=0
-}
-
-// Retain the pin init state of the SPI, to avoid init more than once,
-// even if more instances of SPIClass exist
-static bool spiInitialised[BOARD_NR_SPI] = { false };
-
-SPIClass::SPIClass(uint8_t device) {
-  // Init things specific to each SPI device
-  // clock divider setup is a bit of hack, and needs to be improved at a later date.
-
-  #if BOARD_NR_SPI >= 1
-    _settings[0].spi_d = LPC_SSP0;
-    _settings[0].dataMode = SPI_MODE0;
-    _settings[0].dataSize = DATA_SIZE_8BIT;
-    _settings[0].clock = SPI_CLOCK_MAX;
-    //_settings[0].clockDivider = determine_baud_rate(_settings[0].spi_d, _settings[0].clock);
-  #endif
-
-  #if BOARD_NR_SPI >= 2
-    _settings[1].spi_d = LPC_SSP1;
-    _settings[1].dataMode = SPI_MODE0;
-    _settings[1].dataSize = DATA_SIZE_8BIT;
-    _settings[1].clock = SPI_CLOCK_MAX;
-    //_settings[1].clockDivider = determine_baud_rate(_settings[1].spi_d, _settings[1].clock);
-  #endif
-
-  setModule(device);
-
-  // Init the GPDMA controller
-  // TODO: call once in the constructor? or each time?
-  GPDMA_Init();
-}
-
-SPIClass::SPIClass(pin_t mosi, pin_t miso, pin_t sclk, pin_t ssel) {
-  #if BOARD_NR_SPI >= 1
-    if (mosi == BOARD_SPI1_MOSI_PIN) SPIClass(1);
-  #endif
-  #if BOARD_NR_SPI >= 2
-    if (mosi == BOARD_SPI2_MOSI_PIN) SPIClass(2);
-  #endif
-}
-
-void SPIClass::begin() {
-  // Init the SPI pins in the first begin call
-  if ((_currentSetting->spi_d == LPC_SSP0 && spiInitialised[0] == false) ||
-      (_currentSetting->spi_d == LPC_SSP1 && spiInitialised[1] == false)) {
-    pin_t sck, miso, mosi;
-    if (_currentSetting->spi_d == LPC_SSP0) {
-      sck = BOARD_SPI1_SCK_PIN;
-      miso = BOARD_SPI1_MISO_PIN;
-      mosi = BOARD_SPI1_MOSI_PIN;
-      spiInitialised[0] = true;
-    }
-    else if (_currentSetting->spi_d == LPC_SSP1) {
-      sck = BOARD_SPI2_SCK_PIN;
-      miso = BOARD_SPI2_MISO_PIN;
-      mosi = BOARD_SPI2_MOSI_PIN;
-      spiInitialised[1] = true;
-    }
-    PINSEL_CFG_Type PinCfg;  // data structure to hold init values
-    PinCfg.Funcnum = 2;
-    PinCfg.OpenDrain = 0;
-    PinCfg.Pinmode = 0;
-    PinCfg.Pinnum = LPC176x::pin_bit(sck);
-    PinCfg.Portnum = LPC176x::pin_port(sck);
-    PINSEL_ConfigPin(&PinCfg);
-    SET_OUTPUT(sck);
-
-    PinCfg.Pinnum = LPC176x::pin_bit(miso);
-    PinCfg.Portnum = LPC176x::pin_port(miso);
-    PINSEL_ConfigPin(&PinCfg);
-    SET_INPUT(miso);
-
-    PinCfg.Pinnum = LPC176x::pin_bit(mosi);
-    PinCfg.Portnum = LPC176x::pin_port(mosi);
-    PINSEL_ConfigPin(&PinCfg);
-    SET_OUTPUT(mosi);
-  }
-
-  updateSettings();
-  SSP_Cmd(_currentSetting->spi_d, ENABLE);  // start SSP running
-}
-
-void SPIClass::beginTransaction(const SPISettings &cfg) {
-  setBitOrder(cfg.bitOrder);
-  setDataMode(cfg.dataMode);
-  setDataSize(cfg.dataSize);
-  //setClockDivider(determine_baud_rate(_currentSetting->spi_d, settings.clock));
-  begin();
-}
-
-uint8_t SPIClass::transfer(const uint16_t b) {
-  // Send and receive a single byte
-  SSP_ReceiveData(_currentSetting->spi_d); // read any previous data
-  SSP_SendData(_currentSetting->spi_d, b);
-  waitSpiTxEnd(_currentSetting->spi_d);  // wait for it to finish
-  return SSP_ReceiveData(_currentSetting->spi_d);
-}
-
-uint16_t SPIClass::transfer16(const uint16_t data) {
-  return (transfer((data >> 8) & 0xFF) << 8) | (transfer(data & 0xFF) & 0xFF);
-}
-
-void SPIClass::end() {
-  // Neither is needed for Marlin
-  //SSP_Cmd(_currentSetting->spi_d, DISABLE);
-  //SSP_DeInit(_currentSetting->spi_d);
-}
-
-void SPIClass::send(uint8_t data) {
-  SSP_SendData(_currentSetting->spi_d, data);
-}
-
-void SPIClass::dmaSend(void *buf, uint16_t length, bool minc) {
-  //TODO: LPC dma can only write 0xFFF bytes at once.
-  GPDMA_Channel_CFG_Type GPDMACfg;
-
-  /* Configure GPDMA channel 0 -------------------------------------------------------------*/
-  /* DMA Channel 0 */
-  GPDMACfg.ChannelNum = 0;
-  // Source memory
-  GPDMACfg.SrcMemAddr = (uint32_t)buf;
-  // Destination memory - Not used
-  GPDMACfg.DstMemAddr = 0;
-  // Transfer size
-  GPDMACfg.TransferSize = length;
-  // Transfer width
-  GPDMACfg.TransferWidth = (_currentSetting->dataSize == DATA_SIZE_16BIT) ? GPDMA_WIDTH_HALFWORD : GPDMA_WIDTH_BYTE;
-  // Transfer type
-  GPDMACfg.TransferType = GPDMA_TRANSFERTYPE_M2P;
-  // Source connection - unused
-  GPDMACfg.SrcConn = 0;
-  // Destination connection
-  GPDMACfg.DstConn = (_currentSetting->spi_d == LPC_SSP0) ? GPDMA_CONN_SSP0_Tx : GPDMA_CONN_SSP1_Tx;
-
-  GPDMACfg.DMALLI = 0;
-
-  // Enable dma on SPI
-  SSP_DMACmd(_currentSetting->spi_d, SSP_DMA_TX, ENABLE);
-
-  // Only increase memory if minc is true
-  GPDMACfg.MemoryIncrease = (minc ? GPDMA_DMACCxControl_SI : 0);
-
-  // Setup channel with given parameter
-  GPDMA_Setup(&GPDMACfg);
-
-  // Enable DMA
-  GPDMA_ChannelCmd(0, ENABLE);
-
-  // Wait for data transfer
-  while (!GPDMA_IntGetStatus(GPDMA_STAT_RAWINTTC, 0) && !GPDMA_IntGetStatus(GPDMA_STAT_RAWINTERR, 0)) { }
-
-  // Clear err and int
-  GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, 0);
-  GPDMA_ClearIntPending (GPDMA_STATCLR_INTERR, 0);
-
-  // Disable DMA
-  GPDMA_ChannelCmd(0, DISABLE);
-
-  waitSpiTxEnd(_currentSetting->spi_d);
-
-  SSP_DMACmd(_currentSetting->spi_d, SSP_DMA_TX, DISABLE);
-}
-
-uint16_t SPIClass::read() {
-  return SSP_ReceiveData(_currentSetting->spi_d);
-}
-
-void SPIClass::read(uint8_t *buf, uint32_t len) {
-  for (uint16_t i = 0; i < len; i++) buf[i] = transfer(0xFF);
-}
-
-void SPIClass::setClock(uint32_t clock) { _currentSetting->clock = clock; }
-
-void SPIClass::setModule(uint8_t device) { _currentSetting = &_settings[device - 1]; } // SPI channels are called 1, 2, and 3 but the array is zero-indexed
-
-void SPIClass::setBitOrder(uint8_t bitOrder) { _currentSetting->bitOrder = bitOrder; }
-
-void SPIClass::setDataMode(uint8_t dataMode) { _currentSetting->dataMode = dataMode; }
-
-void SPIClass::setDataSize(uint32_t dataSize) { _currentSetting->dataSize = dataSize; }
-
-/**
- * Set up/tear down
- */
-void SPIClass::updateSettings() {
-  //SSP_DeInit(_currentSetting->spi_d); //todo: need force de init?!
-
-  // Divide PCLK by 2 for SSP0
-  //CLKPWR_SetPCLKDiv(_currentSetting->spi_d == LPC_SSP0 ? CLKPWR_PCLKSEL_SSP0 : CLKPWR_PCLKSEL_SSP1, CLKPWR_PCLKSEL_CCLK_DIV_2);
-
-  SSP_CFG_Type HW_SPI_init; // data structure to hold init values
-  SSP_ConfigStructInit(&HW_SPI_init);  // set values for SPI mode
-  HW_SPI_init.ClockRate = _currentSetting->clock;
-  HW_SPI_init.Databit = _currentSetting->dataSize;
-
-  /**
-   * SPI Mode  CPOL  CPHA  Shift SCK-edge  Capture SCK-edge
-   * 0       0     0     Falling     Rising
-   * 1       0     1     Rising      Falling
-   * 2       1     0     Rising      Falling
-   * 3       1     1     Falling     Rising
-   */
-  switch (_currentSetting->dataMode) {
-    case SPI_MODE0:
-      HW_SPI_init.CPHA = SSP_CPHA_FIRST;
-      HW_SPI_init.CPOL = SSP_CPOL_HI;
-      break;
-    case SPI_MODE1:
-      HW_SPI_init.CPHA = SSP_CPHA_SECOND;
-      HW_SPI_init.CPOL = SSP_CPOL_HI;
-      break;
-    case SPI_MODE2:
-      HW_SPI_init.CPHA = SSP_CPHA_FIRST;
-      HW_SPI_init.CPOL = SSP_CPOL_LO;
-      break;
-    case SPI_MODE3:
-      HW_SPI_init.CPHA = SSP_CPHA_SECOND;
-      HW_SPI_init.CPOL = SSP_CPOL_LO;
-      break;
-    default:
-      break;
-  }
-
-  // TODO: handle bitOrder
-  SSP_Init(_currentSetting->spi_d, &HW_SPI_init);  // puts the values into the proper bits in the SSP0 registers
-}
-
-#if SD_MISO_PIN == BOARD_SPI1_MISO_PIN
-  SPIClass SPI(1);
-#elif SD_MISO_PIN == BOARD_SPI2_MISO_PIN
-  SPIClass SPI(2);
-#endif
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/MarlinSPI.h b/Marlin/src/HAL/LPC1768/MarlinSPI.h
deleted file mode 100644
index fab245f..0000000
--- a/Marlin/src/HAL/LPC1768/MarlinSPI.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-/**
- * Marlin currently requires 3 SPI classes:
- *
- * SPIClass:
- *  This class is normally provided by frameworks and has a semi-default interface.
- *  This is needed because some libraries reference it globally.
- *
- * SPISettings:
- *  Container for SPI configs for SPIClass. As above, libraries may reference it globally.
- *
- * These two classes are often provided by frameworks so we cannot extend them to add
- * useful methods for Marlin.
- *
- * MarlinSPI:
- *  Provides the default SPIClass interface plus some Marlin goodies such as a simplified
- *  interface for SPI DMA transfer.
- *
- */
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/LPC1768/MarlinSerial.cpp b/Marlin/src/HAL/LPC1768/MarlinSerial.cpp
deleted file mode 100644
index f2aecf5..0000000
--- a/Marlin/src/HAL/LPC1768/MarlinSerial.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "MarlinSerial.h"
-
-#include "../../inc/MarlinConfig.h"
-
-#if USING_HW_SERIAL0
-  MarlinSerial _MSerial0(LPC_UART0);
-  MSerialT MSerial0(true, _MSerial0);
-  extern "C" void UART0_IRQHandler() { _MSerial0.IRQHandler(); }
-#endif
-#if USING_HW_SERIAL1
-  MarlinSerial _MSerial1((LPC_UART_TypeDef *) LPC_UART1);
-  MSerialT MSerial1(true, _MSerial1);
-  extern "C" void UART1_IRQHandler() { _MSerial1.IRQHandler(); }
-#endif
-#if USING_HW_SERIAL2
-  MarlinSerial _MSerial2(LPC_UART2);
-  MSerialT MSerial2(true, _MSerial2);
-  extern "C" void UART2_IRQHandler() { _MSerial2.IRQHandler(); }
-#endif
-#if USING_HW_SERIAL3
-  MarlinSerial _MSerial3(LPC_UART3);
-  MSerialT MSerial3(true, _MSerial3);
-  extern "C" void UART3_IRQHandler() { _MSerial3.IRQHandler(); }
-#endif
-
-#if ENABLED(EMERGENCY_PARSER)
-
-  bool MarlinSerial::recv_callback(const char c) {
-    // Need to figure out which serial port we are and react in consequence (Marlin does not have CONTAINER_OF macro)
-    if (false) {}
-    #if USING_HW_SERIAL0
-      else if (this == &_MSerial0) emergency_parser.update(MSerial0.emergency_state, c);
-    #endif
-    #if USING_HW_SERIAL1
-      else if (this == &_MSerial1) emergency_parser.update(MSerial1.emergency_state, c);
-    #endif
-    #if USING_HW_SERIAL2
-      else if (this == &_MSerial2) emergency_parser.update(MSerial2.emergency_state, c);
-    #endif
-    #if USING_HW_SERIAL3
-      else if (this == &_MSerial3) emergency_parser.update(MSerial3.emergency_state, c);
-    #endif
-    return true;
-  }
-
-#endif
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/MarlinSerial.h b/Marlin/src/HAL/LPC1768/MarlinSerial.h
deleted file mode 100644
index 3e6848a..0000000
--- a/Marlin/src/HAL/LPC1768/MarlinSerial.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <HardwareSerial.h>
-#include <WString.h>
-
-#include "../../inc/MarlinConfigPre.h"
-#if ENABLED(EMERGENCY_PARSER)
-  #include "../../feature/e_parser.h"
-#endif
-#include "../../core/serial_hook.h"
-
-#ifndef SERIAL_PORT
-  #define SERIAL_PORT 0
-#endif
-#ifndef RX_BUFFER_SIZE
-  #define RX_BUFFER_SIZE 128
-#endif
-#ifndef TX_BUFFER_SIZE
-  #define TX_BUFFER_SIZE 32
-#endif
-
-class MarlinSerial : public HardwareSerial<RX_BUFFER_SIZE, TX_BUFFER_SIZE> {
-public:
-  MarlinSerial(LPC_UART_TypeDef *UARTx) : HardwareSerial<RX_BUFFER_SIZE, TX_BUFFER_SIZE>(UARTx) { }
-
-  void end() {}
-
-  uint8_t availableForWrite(void) { /* flushTX(); */ return TX_BUFFER_SIZE; }
-
-  #if ENABLED(EMERGENCY_PARSER)
-    bool recv_callback(const char c) override;
-  #endif
-};
-
-// On LPC176x framework, HardwareSerial does not implement the same interface as Arduino's Serial, so overloads
-// of 'available' and 'read' method are not used in this multiple inheritance scenario.
-// Instead, use a ForwardSerial here that adapts the interface.
-typedef ForwardSerial1Class<MarlinSerial> MSerialT;
-extern MSerialT MSerial0;
-extern MSerialT MSerial1;
-extern MSerialT MSerial2;
-extern MSerialT MSerial3;
-
-// Consequently, we can't use a RuntimeSerial either. The workaround would be to use
-// a RuntimeSerial<ForwardSerial<MarlinSerial>> type here. Ignore for now until it's actually required.
-#if ENABLED(SERIAL_RUNTIME_HOOK)
-  #error "SERIAL_RUNTIME_HOOK is not yet supported for LPC176x."
-#endif
diff --git a/Marlin/src/HAL/LPC1768/MinSerial.cpp b/Marlin/src/HAL/LPC1768/MinSerial.cpp
deleted file mode 100644
index 7a1c038..0000000
--- a/Marlin/src/HAL/LPC1768/MinSerial.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-
-#include "../shared/MinSerial.h"
-#include <debug_frmwrk.h>
-
-static void TX(char c) { _DBC(c); }
-void install_min_serial() { HAL_min_serial_out = &TX; }
-
-#if DISABLED(DYNAMIC_VECTORTABLE)
-extern "C" {
-  __attribute__((naked)) void JumpHandler_ASM() {
-    __asm__ __volatile__ (
-      "b CommonHandler_ASM\n"
-    );
-  }
-  void __attribute__((naked, alias("JumpHandler_ASM"))) HardFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) BusFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) UsageFault_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) MemManage_Handler();
-  void __attribute__((naked, alias("JumpHandler_ASM"))) NMI_Handler();
-}
-#endif
-
-#endif // POSTMORTEM_DEBUGGING
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/Servo.h b/Marlin/src/HAL/LPC1768/Servo.h
deleted file mode 100644
index f02f503..0000000
--- a/Marlin/src/HAL/LPC1768/Servo.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * servo.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
- * Copyright (c) 2009 Michael Margolis.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#pragma once
-
-/**
- * Based on "servo.h - Interrupt driven Servo library for Arduino using 16 bit timers -
- *           Version 2 Copyright (c) 2009 Michael Margolis.  All right reserved.
- *
- * The only modification was to update/delete macros to match the LPC176x.
- */
-
-#include <Servo.h>
-
-class libServo: public Servo {
-  public:
-  void move(const int value) {
-    constexpr uint16_t servo_delay[] = SERVO_DELAY;
-    static_assert(COUNT(servo_delay) == NUM_SERVOS, "SERVO_DELAY must be an array NUM_SERVOS long.");
-
-    if (attach(servo_info[servoIndex].Pin.nbr) >= 0) {    // try to reattach
-      write(value);
-      safe_delay(servo_delay[servoIndex]); // delay to allow servo to reach position
-      TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());
-    }
-
-  }
-};
-
-class libServo;
-typedef libServo hal_servo_t;
diff --git a/Marlin/src/HAL/LPC1768/eeprom_flash.cpp b/Marlin/src/HAL/LPC1768/eeprom_flash.cpp
deleted file mode 100644
index 38d2705..0000000
--- a/Marlin/src/HAL/LPC1768/eeprom_flash.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-/**
- * Emulate EEPROM storage using Flash Memory
- *
- * Use a single 32K flash sector to store EEPROM data. To reduce the
- * number of erase operations a simple "leveling" scheme is used that
- * maintains a number of EEPROM "slots" within the larger flash sector.
- * Each slot is used in turn and the entire sector is only erased when all
- * slots have been used.
- *
- * A simple RAM image is used to hold the EEPROM data during I/O operations
- * and this is flushed to the next available slot when an update is complete.
- * If RAM usage becomes an issue we could store this image in one of the two
- * 16Kb I/O buffers (intended to hold DMA USB and Ethernet data, but currently
- * unused).
- */
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(FLASH_EEPROM_EMULATION)
-
-#include "../shared/eeprom_api.h"
-
-extern "C" {
-  #include <lpc17xx_iap.h>
-}
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE 0x1000 // 4KB
-#endif
-
-#define SECTOR_START(sector)  ((sector < 16) ? (sector << 12) : ((sector - 14) << 15))
-#define EEPROM_SECTOR 29
-#define SECTOR_SIZE 32768
-#define EEPROM_SLOTS ((SECTOR_SIZE)/(MARLIN_EEPROM_SIZE))
-#define EEPROM_ERASE 0xFF
-#define SLOT_ADDRESS(sector, slot) (((uint8_t *)SECTOR_START(sector)) + slot * (MARLIN_EEPROM_SIZE))
-
-static uint8_t ram_eeprom[MARLIN_EEPROM_SIZE] __attribute__((aligned(4))) = {0};
-static bool eeprom_dirty = false;
-static int current_slot = 0;
-
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start() {
-  uint32_t first_nblank_loc, first_nblank_val;
-  IAP_STATUS_CODE status;
-
-  // discover which slot we are currently using.
-  __disable_irq();
-  status = BlankCheckSector(EEPROM_SECTOR, EEPROM_SECTOR, &first_nblank_loc, &first_nblank_val);
-  __enable_irq();
-
-  if (status == CMD_SUCCESS) {
-    // sector is blank so nothing stored yet
-    for (int i = 0; i < MARLIN_EEPROM_SIZE; i++) ram_eeprom[i] = EEPROM_ERASE;
-    current_slot = EEPROM_SLOTS;
-  }
-  else {
-    // current slot is the first non blank one
-    current_slot = first_nblank_loc / (MARLIN_EEPROM_SIZE);
-    uint8_t *eeprom_data = SLOT_ADDRESS(EEPROM_SECTOR, current_slot);
-    // load current settings
-    for (int i = 0; i < MARLIN_EEPROM_SIZE; i++) ram_eeprom[i] = eeprom_data[i];
-  }
-  eeprom_dirty = false;
-
-  return true;
-}
-
-bool PersistentStore::access_finish() {
-  if (eeprom_dirty) {
-    IAP_STATUS_CODE status;
-    if (--current_slot < 0) {
-      // all slots have been used, erase everything and start again
-      __disable_irq();
-      status = EraseSector(EEPROM_SECTOR, EEPROM_SECTOR);
-      __enable_irq();
-
-      current_slot = EEPROM_SLOTS - 1;
-    }
-
-    __disable_irq();
-    status = CopyRAM2Flash(SLOT_ADDRESS(EEPROM_SECTOR, current_slot), ram_eeprom, IAP_WRITE_4096);
-    __enable_irq();
-
-    if (status != CMD_SUCCESS) return false;
-    eeprom_dirty = false;
-  }
-  return true;
-}
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  for (size_t i = 0; i < size; i++) ram_eeprom[pos + i] = value[i];
-  eeprom_dirty = true;
-  crc16(crc, value, size);
-  pos += size;
-  return false;  // return true for any error
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  const uint8_t * const buff = writing ? &value[0] : &ram_eeprom[pos];
-  if (writing) for (size_t i = 0; i < size; i++) value[i] = ram_eeprom[pos + i];
-  crc16(crc, buff, size);
-  pos += size;
-  return false;  // return true for any error
-}
-
-#endif // FLASH_EEPROM_EMULATION
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/eeprom_sdcard.cpp b/Marlin/src/HAL/LPC1768/eeprom_sdcard.cpp
deleted file mode 100644
index 1991d79..0000000
--- a/Marlin/src/HAL/LPC1768/eeprom_sdcard.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Implementation of EEPROM settings in SD Card
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(SDCARD_EEPROM_EMULATION)
-
-//#define DEBUG_SD_EEPROM_EMULATION
-
-#include "../shared/eeprom_api.h"
-
-#include <chanfs/diskio.h>
-#include <chanfs/ff.h>
-
-extern uint32_t MSC_Aquire_Lock();
-extern uint32_t MSC_Release_Lock();
-
-FATFS fat_fs;
-FIL eeprom_file;
-bool eeprom_file_open = false;
-
-#define EEPROM_FILENAME "eeprom.dat"
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE size_t(0x1000) // 4KiB of Emulated EEPROM
-#endif
-
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start() {
-  const char eeprom_erase_value = 0xFF;
-  MSC_Aquire_Lock();
-  if (f_mount(&fat_fs, "", 1)) {
-    MSC_Release_Lock();
-    return false;
-  }
-  FRESULT res = f_open(&eeprom_file, EEPROM_FILENAME, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
-  if (res) MSC_Release_Lock();
-
-  if (res == FR_OK) {
-    UINT bytes_written;
-    FSIZE_t file_size = f_size(&eeprom_file);
-    f_lseek(&eeprom_file, file_size);
-    while (file_size < capacity() && res == FR_OK) {
-      res = f_write(&eeprom_file, &eeprom_erase_value, 1, &bytes_written);
-      file_size++;
-    }
-  }
-  if (res == FR_OK) {
-    f_lseek(&eeprom_file, 0);
-    f_sync(&eeprom_file);
-    eeprom_file_open = true;
-  }
-  return res == FR_OK;
-}
-
-bool PersistentStore::access_finish() {
-  f_close(&eeprom_file);
-  f_unmount("");
-  MSC_Release_Lock();
-  eeprom_file_open = false;
-  return true;
-}
-
-// This extra chit-chat goes away soon, but is helpful for now
-// to see errors that are happening in read_data / write_data
-static void debug_rw(const bool write, int &pos, const uint8_t *value, const size_t size, const FRESULT s, const size_t total=0) {
-  #if ENABLED(DEBUG_SD_EEPROM_EMULATION)
-    FSTR_P const rw_str = write ? F("write") : F("read");
-    SERIAL_CHAR(' ');
-    SERIAL_ECHOF(rw_str);
-    SERIAL_ECHOLNPGM("_data(", pos, ",", *value, ",", size, ", ...)");
-    if (total) {
-      SERIAL_ECHOPGM(" f_");
-      SERIAL_ECHOF(rw_str);
-      SERIAL_ECHOPGM("()=", s, "\n size=", size, "\n bytes_");
-      SERIAL_ECHOLNF(write ? F("written=") : F("read="), total);
-    }
-    else
-      SERIAL_ECHOLNPGM(" f_lseek()=", s);
-  #endif
-}
-
-// File function return codes for type FRESULT. This goes away soon, but
-// is helpful right now to see any errors in read_data and write_data.
-//
-//  typedef enum {
-//    FR_OK = 0,               /* (0) Succeeded */
-//    FR_DISK_ERR,             /* (1) A hard error occurred in the low level disk I/O layer */
-//    FR_INT_ERR,              /* (2) Assertion failed */
-//    FR_NOT_READY,            /* (3) The physical drive cannot work */
-//    FR_NO_FILE,              /* (4) Could not find the file */
-//    FR_NO_PATH,              /* (5) Could not find the path */
-//    FR_INVALID_NAME,         /* (6) The path name format is invalid */
-//    FR_DENIED,               /* (7) Access denied due to prohibited access or directory full */
-//    FR_EXIST,                /* (8) Access denied due to prohibited access */
-//    FR_INVALID_OBJECT,       /* (9) The file/directory object is invalid */
-//    FR_WRITE_PROTECTED,      /* (10) The physical drive is write protected */
-//    FR_INVALID_DRIVE,        /* (11) The logical drive number is invalid */
-//    FR_NOT_ENABLED,          /* (12) The volume has no work area */
-//    FR_NO_FILESYSTEM,        /* (13) There is no valid FAT volume */
-//    FR_MKFS_ABORTED,         /* (14) The f_mkfs() aborted due to any problem */
-//    FR_TIMEOUT,              /* (15) Could not get a grant to access the volume within defined period */
-//    FR_LOCKED,               /* (16) The operation is rejected according to the file sharing policy */
-//    FR_NOT_ENOUGH_CORE,      /* (17) LFN working buffer could not be allocated */
-//    FR_TOO_MANY_OPEN_FILES,  /* (18) Number of open files > FF_FS_LOCK */
-//    FR_INVALID_PARAMETER     /* (19) Given parameter is invalid */
-//  } FRESULT;
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  if (!eeprom_file_open) return true;
-  FRESULT s;
-  UINT bytes_written = 0;
-
-  s = f_lseek(&eeprom_file, pos);
-  if (s) {
-    debug_rw(true, pos, value, size, s);
-    return s;
-  }
-
-  s = f_write(&eeprom_file, (void*)value, size, &bytes_written);
-  if (s) {
-    debug_rw(true, pos, value, size, s, bytes_written);
-    return s;
-  }
-  crc16(crc, value, size);
-  pos += size;
-  return bytes_written != size;  // return true for any error
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  if (!eeprom_file_open) return true;
-  UINT bytes_read = 0;
-  FRESULT s;
-  s = f_lseek(&eeprom_file, pos);
-
-  if (s) {
-    debug_rw(false, pos, value, size, s);
-    return true;
-  }
-
-  if (writing) {
-    s = f_read(&eeprom_file, (void*)value, size, &bytes_read);
-    crc16(crc, value, size);
-  }
-  else {
-    uint8_t temp[size];
-    s = f_read(&eeprom_file, (void*)temp, size, &bytes_read);
-    crc16(crc, temp, size);
-  }
-
-  if (s) {
-    debug_rw(false, pos, value, size, s, bytes_read);
-    return true;
-  }
-
-  pos += size;
-  return bytes_read != size;  // return true for any error
-}
-
-#endif // SDCARD_EEPROM_EMULATION
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/eeprom_wired.cpp b/Marlin/src/HAL/LPC1768/eeprom_wired.cpp
deleted file mode 100644
index 1bbc39d..0000000
--- a/Marlin/src/HAL/LPC1768/eeprom_wired.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-/**
- * PersistentStore for Arduino-style EEPROM interface
- * with implementations supplied by the framework.
- */
-
-#include "../shared/eeprom_if.h"
-#include "../shared/eeprom_api.h"
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE           0x8000 // 32K
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { eeprom_init(); return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t v = *value;
-    uint8_t * const p = (uint8_t * const)pos;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    // Read from external EEPROM
-    const uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/endstop_interrupts.h b/Marlin/src/HAL/LPC1768/endstop_interrupts.h
deleted file mode 100644
index e4ac17f..0000000
--- a/Marlin/src/HAL/LPC1768/endstop_interrupts.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  #define LPC1768_PIN_INTERRUPT_M(pin) ((pin >> 0x5 & 0x7) == 0 || (pin >> 0x5 & 0x7) == 2)
-
-  #if HAS_X_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(X_MAX_PIN)
-      #error "X_MAX_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(X_MAX_PIN);
-  #endif
-  #if HAS_X_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(X_MIN_PIN)
-      #error "X_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(X_MIN_PIN);
-  #endif
-  #if HAS_Y_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(Y_MAX_PIN)
-      #error "Y_MAX_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Y_MAX_PIN);
-  #endif
-  #if HAS_Y_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(Y_MIN_PIN)
-      #error "Y_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Y_MIN_PIN);
-  #endif
-  #if HAS_Z_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(Z_MAX_PIN)
-      #error "Z_MAX_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z_MAX_PIN);
-  #endif
-  #if HAS_Z_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(Z_MIN_PIN)
-      #error "Z_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-     _ATTACH(Z_MIN_PIN);
-  #endif
-  #if HAS_Z2_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(Z2_MAX_PIN)
-      #error "Z2_MAX_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z2_MAX_PIN);
-  #endif
-  #if HAS_Z2_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(Z2_MIN_PIN)
-      #error "Z2_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z2_MIN_PIN);
-  #endif
-  #if HAS_Z3_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(Z3_MAX_PIN)
-      #error "Z3_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z3_MAX_PIN);
-  #endif
-  #if HAS_Z3_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(Z3_MIN_PIN)
-      #error "Z3_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z3_MIN_PIN);
-  #endif
-  #if HAS_Z4_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(Z4_MAX_PIN)
-      #error "Z4_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z4_MAX_PIN);
-  #endif
-  #if HAS_Z4_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(Z4_MIN_PIN)
-      #error "Z4_MIN_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z4_MIN_PIN);
-  #endif
-  #if HAS_Z_MIN_PROBE_PIN
-    #if !LPC1768_PIN_INTERRUPT_M(Z_MIN_PROBE_PIN)
-      #error "Z_MIN_PROBE_PIN is not INTERRUPT-capable. Disable ENDSTOP_INTERRUPTS_FEATURE to continue."
-    #endif
-    _ATTACH(Z_MIN_PROBE_PIN);
-  #endif
-  #if HAS_I_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(I_MAX_PIN)
-      #error "I_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(I_MAX_PIN);
-  #elif HAS_I_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(I_MIN_PIN)
-      #error "I_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(I_MIN_PIN);
-  #endif
-  #if HAS_J_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(J_MAX_PIN)
-      #error "J_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(J_MAX_PIN);
-  #elif HAS_J_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(J_MIN_PIN)
-      #error "J_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(J_MIN_PIN);
-  #endif
-  #if HAS_K_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(K_MAX_PIN)
-      #error "K_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(K_MAX_PIN);
-  #elif HAS_K_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(K_MIN_PIN)
-      #error "K_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(K_MIN_PIN);
-  #endif
-  #if HAS_U_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(U_MAX_PIN)
-      #error "U_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(U_MAX_PIN);
-  #elif HAS_U_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(U_MIN_PIN)
-      #error "U_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(U_MIN_PIN);
-  #endif
-  #if HAS_V_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(V_MAX_PIN)
-      #error "V_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(V_MAX_PIN);
-  #elif HAS_V_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(V_MIN_PIN)
-      #error "V_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(V_MIN_PIN);
-  #endif
-  #if HAS_W_MAX
-    #if !LPC1768_PIN_INTERRUPT_M(W_MAX_PIN)
-      #error "W_MAX_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(W_MAX_PIN);
-  #elif HAS_W_MIN
-    #if !LPC1768_PIN_INTERRUPT_M(W_MIN_PIN)
-      #error "W_MIN_PIN is not INTERRUPT-capable."
-    #endif
-    _ATTACH(W_MIN_PIN);
-  #endif
-}
diff --git a/Marlin/src/HAL/LPC1768/fast_pwm.cpp b/Marlin/src/HAL/LPC1768/fast_pwm.cpp
deleted file mode 100644
index 6d2b1a9..0000000
--- a/Marlin/src/HAL/LPC1768/fast_pwm.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-#include <pwm.h>
-
-void MarlinHAL::set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size/*=255*/, const bool invert/*=false*/) {
-  if (!LPC176x::pin_is_valid(pin)) return;
-  if (LPC176x::pwm_attach_pin(pin))
-    LPC176x::pwm_write_ratio(pin, invert ? 1.0f - (float)v / v_size : (float)v / v_size);  // map 1-254 onto PWM range
-}
-
-void MarlinHAL::set_pwm_frequency(const pin_t pin, const uint16_t f_desired) {
-  LPC176x::pwm_set_frequency(pin, f_desired);
-}
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/fastio.h b/Marlin/src/HAL/LPC1768/fastio.h
deleted file mode 100644
index c553ffb..0000000
--- a/Marlin/src/HAL/LPC1768/fastio.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for LPC1768/9
- * Use direct port manipulation to save scads of processor time.
- * Contributed by Triffid_Hunter and modified by Kliment, thinkyhead, Bob-the-Kuhn, et.al.
- */
-
-/**
- * Description: Fast IO functions LPC1768
- *
- * For TARGET LPC1768
- */
-
-#include "../shared/Marduino.h"
-
-#define PWM_PIN(P)            true // all pins are PWM capable
-
-#define LPC_PIN(pin)          LPC176x::gpio_pin(pin)
-#define LPC_GPIO(port)        LPC176x::gpio_port(port)
-
-#define SET_DIR_INPUT(IO)     LPC176x::gpio_set_input(IO)
-#define SET_DIR_OUTPUT(IO)    LPC176x::gpio_set_output(IO)
-
-#define SET_MODE(IO, mode)    pinMode(IO, mode)
-
-#define WRITE_PIN_SET(IO)     LPC176x::gpio_set(IO)
-#define WRITE_PIN_CLR(IO)     LPC176x::gpio_clear(IO)
-
-#define READ_PIN(IO)          LPC176x::gpio_get(IO)
-#define WRITE_PIN(IO,V)       LPC176x::gpio_set(IO, V)
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(STEP); WRITE(STEP, HIGH); WRITE(STEP, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html
- */
-
-/// Read a pin
-#define _READ(IO)             READ_PIN(IO)
-
-/// Write to a pin
-#define _WRITE(IO,V)          WRITE_PIN(IO,V)
-
-/// toggle a pin
-#define _TOGGLE(IO)           _WRITE(IO, !READ(IO))
-
-/// set pin as input
-#define _SET_INPUT(IO)        SET_DIR_INPUT(IO)
-
-/// set pin as output
-#define _SET_OUTPUT(IO)       SET_DIR_OUTPUT(IO)
-
-/// set pin as input with pullup mode
-#define _PULLUP(IO,V)         pinMode(IO, (V) ? INPUT_PULLUP : INPUT)
-
-/// set pin as input with pulldown mode
-#define _PULLDOWN(IO,V)       pinMode(IO, (V) ? INPUT_PULLDOWN : INPUT)
-
-/// check if pin is an input
-#define _IS_INPUT(IO)         (!LPC176x::gpio_get_dir(IO))
-
-/// check if pin is an output
-#define _IS_OUTPUT(IO)        (LPC176x::gpio_get_dir(IO))
-
-/// Read a pin wrapper
-#define READ(IO)              _READ(IO)
-
-/// Write to a pin wrapper
-#define WRITE(IO,V)           _WRITE(IO,V)
-
-/// toggle a pin wrapper
-#define TOGGLE(IO)            _TOGGLE(IO)
-
-/// set pin as input wrapper
-#define SET_INPUT(IO)         _SET_INPUT(IO)
-/// set pin as input with pullup wrapper
-#define SET_INPUT_PULLUP(IO)  do{ _SET_INPUT(IO); _PULLUP(IO, HIGH); }while(0)
-/// set pin as input with pulldown wrapper
-#define SET_INPUT_PULLDOWN(IO) do{ _SET_INPUT(IO); _PULLDOWN(IO, HIGH); }while(0)
-/// set pin as output wrapper  -  reads the pin and sets the output to that value
-#define SET_OUTPUT(IO)        do{ _WRITE(IO, _READ(IO)); _SET_OUTPUT(IO); }while(0)
-// set pin as PWM
-#define SET_PWM               SET_OUTPUT
-
-/// check if pin is an input wrapper
-#define IS_INPUT(IO)          _IS_INPUT(IO)
-/// check if pin is an output wrapper
-#define IS_OUTPUT(IO)         _IS_OUTPUT(IO)
-
-// Shorthand
-#define OUT_WRITE(IO,V)       do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
diff --git a/Marlin/src/HAL/LPC1768/inc/Conditionals_LCD.h b/Marlin/src/HAL/LPC1768/inc/Conditionals_LCD.h
deleted file mode 100644
index 32ef908..0000000
--- a/Marlin/src/HAL/LPC1768/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_FSMC_TFT
-  #error "Sorry! FSMC TFT displays are not current available for HAL/LPC1768."
-#endif
diff --git a/Marlin/src/HAL/LPC1768/inc/Conditionals_adv.h b/Marlin/src/HAL/LPC1768/inc/Conditionals_adv.h
deleted file mode 100644
index 8e7cab1..0000000
--- a/Marlin/src/HAL/LPC1768/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if DISABLED(NO_SD_HOST_DRIVE)
-  #define HAS_SD_HOST_DRIVE 1
-#endif
diff --git a/Marlin/src/HAL/LPC1768/inc/Conditionals_post.h b/Marlin/src/HAL/LPC1768/inc/Conditionals_post.h
deleted file mode 100644
index be574a9..0000000
--- a/Marlin/src/HAL/LPC1768/inc/Conditionals_post.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define FLASH_EEPROM_EMULATION
-#elif EITHER(I2C_EEPROM, SPI_EEPROM)
-  #define USE_SHARED_EEPROM 1
-#endif
-
-// LPC1768 boards seem to lose steps when saving to EEPROM during print (issue #20785)
-// TODO: Which other boards are incompatible?
-#if defined(MCU_LPC1768) && PRINTCOUNTER_SAVE_INTERVAL > 0
-  #define PRINTCOUNTER_SYNC 1
-#endif
diff --git a/Marlin/src/HAL/LPC1768/inc/SanityCheck.h b/Marlin/src/HAL/LPC1768/inc/SanityCheck.h
deleted file mode 100644
index 8265d58..0000000
--- a/Marlin/src/HAL/LPC1768/inc/SanityCheck.h
+++ /dev/null
@@ -1,276 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if PIO_PLATFORM_VERSION < 1001
-  #error "nxplpc-arduino-lpc176x package is out of date, Please update the PlatformIO platforms, frameworks and libraries. You may need to remove the platform and let it reinstall automatically."
-#endif
-#if PIO_FRAMEWORK_VERSION < 2006
-  #error "framework-arduino-lpc176x package is out of date, Please update the PlatformIO platforms, frameworks and libraries."
-#endif
-
-/**
- * Detect an old pins file by checking for old ADC pins values.
- */
-#define _OLD_TEMP_PIN(P) PIN_EXISTS(P) && _CAT(P,_PIN) <= 7 && !WITHIN(_CAT(P,_PIN), TERN(LPC1768_IS_SKRV1_3, 0, 2), 3)  // Include P0_00 and P0_01 for SKR V1.3 board
-#if _OLD_TEMP_PIN(TEMP_BED)
-  #error "TEMP_BED_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_0)
-  #error "TEMP_0_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_1)
-  #error "TEMP_1_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_2)
-  #error "TEMP_2_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_3)
-  #error "TEMP_3_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_4)
-  #error "TEMP_4_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_5)
-  #error "TEMP_5_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_6)
-  #error "TEMP_6_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#elif _OLD_TEMP_PIN(TEMP_7)
-  #error "TEMP_7_PIN must be defined using the Pn_nn or Pn_nn_An format. (See the included pins files)."
-#endif
-#undef _OLD_TEMP_PIN
-
-/**
- * Because PWM hardware channels all share the same frequency, along with the
- * fallback software channels, FAST_PWM_FAN is incompatible with Servos.
- */
-static_assert(!(NUM_SERVOS && ENABLED(FAST_PWM_FAN)), "BLTOUCH and Servos are incompatible with FAST_PWM_FAN on LPC176x boards.");
-
-#if SPINDLE_LASER_FREQUENCY
-  static_assert(!NUM_SERVOS, "BLTOUCH and Servos are incompatible with SPINDLE_LASER_FREQUENCY on LPC176x boards.");
-#endif
-
-/**
- * Test LPC176x-specific configuration values for errors at compile-time.
- */
-
-//#if ENABLED(SPINDLE_LASER_USE_PWM) && !(SPINDLE_LASER_PWM_PIN == 4 || SPINDLE_LASER_PWM_PIN == 6 || SPINDLE_LASER_PWM_PIN == 11)
-//  #error "SPINDLE_LASER_PWM_PIN must use SERVO0, SERVO1 or SERVO3 connector"
-//#endif
-
-#if MB(RAMPS_14_RE_ARM_EFB, RAMPS_14_RE_ARM_EEB, RAMPS_14_RE_ARM_EFF, RAMPS_14_RE_ARM_EEF, RAMPS_14_RE_ARM_SF)
-  #if IS_RRD_FG_SC && HAS_DRIVER(TMC2130) && DISABLED(TMC_USE_SW_SPI)
-    #error "Re-ARM with REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER and TMC2130 requires TMC_USE_SW_SPI."
-  #endif
-#endif
-
-static_assert(DISABLED(BAUD_RATE_GCODE), "BAUD_RATE_GCODE is not yet supported on LPC176x.");
-
-/**
- * Flag any serial port conflicts
- *
- *   Port  |  TX   |  RX   |
- *    ---  |  ---  |  ---  |
- * Serial  | P0_02 | P0_03 |
- * Serial1 | P0_15 | P0_16 |
- * Serial2 | P0_10 | P0_11 |
- * Serial3 | P0_00 | P0_01 |
- */
-#define ANY_TX(N,V...) DO(IS_TX##N,||,V)
-#define ANY_RX(N,V...) DO(IS_RX##N,||,V)
-
-#if USING_HW_SERIAL0
-  #define IS_TX0(P) (P == P0_02)
-  #define IS_RX0(P) (P == P0_03)
-  #if IS_TX0(TMC_SW_MISO) || IS_RX0(TMC_SW_MOSI)
-    #error "Serial port pins (0) conflict with Trinamic SPI pins!"
-  #elif HAS_PRUSA_MMU1 && (IS_TX0(E_MUX1_PIN) || IS_RX0(E_MUX0_PIN))
-    #error "Serial port pins (0) conflict with Multi-Material-Unit multiplexer pins!"
-  #elif (AXIS_HAS_SPI(X) && IS_TX0(X_CS_PIN)) || (AXIS_HAS_SPI(Y) && IS_RX0(Y_CS_PIN))
-    #error "Serial port pins (0) conflict with X/Y axis SPI pins!"
-  #endif
-  #undef IS_TX0
-  #undef IS_RX0
-#endif
-
-#if USING_HW_SERIAL1
-  #define IS_TX1(P) (P == P0_15)
-  #define IS_RX1(P) (P == P0_16)
-  #define _IS_TX1_1 IS_TX1
-  #define _IS_RX1_1 IS_RX1
-  #if IS_TX1(TMC_SW_SCK)
-    #error "Serial port pins (1) conflict with other pins!"
-  #elif HAS_ROTARY_ENCODER
-    #if IS_TX1(BTN_EN2) || IS_RX1(BTN_EN1)
-      #error "Serial port pins (1) conflict with Encoder Buttons!"
-    #elif ANY_TX(1, SD_SCK_PIN, LCD_PINS_D4, DOGLCD_SCK, LCD_RESET_PIN, LCD_PINS_RS, SHIFT_CLK_PIN) \
-       || ANY_RX(1, LCD_SDSS, LCD_PINS_RS, SD_MISO_PIN, DOGLCD_A0, SD_SS_PIN, LCD_SDSS, DOGLCD_CS, LCD_RESET_PIN, LCD_BACKLIGHT_PIN)
-      #error "Serial port pins (1) conflict with LCD pins!"
-    #endif
-  #endif
-  #undef IS_TX1
-  #undef IS_RX1
-  #undef _IS_TX1_1
-  #undef _IS_RX1_1
-#endif
-
-#if USING_HW_SERIAL2
-  #define IS_TX2(P) (P == P0_10)
-  #define IS_RX2(P) (P == P0_11)
-  #define _IS_TX2_1 IS_TX2
-  #define _IS_RX2_1 IS_RX2
-  #if IS_TX2(X2_ENABLE_PIN) || ANY_RX(2, X2_DIR_PIN, X2_STEP_PIN) || (AXIS_HAS_SPI(X2) && IS_TX2(X2_CS_PIN))
-    #error "Serial port pins (2) conflict with X2 pins!"
-  #elif IS_TX2(Y2_ENABLE_PIN) || ANY_RX(2, Y2_DIR_PIN, Y2_STEP_PIN) || (AXIS_HAS_SPI(Y2) && IS_TX2(Y2_CS_PIN))
-    #error "Serial port pins (2) conflict with Y2 pins!"
-  #elif IS_TX2(Z2_ENABLE_PIN) || ANY_RX(2, Z2_DIR_PIN, Z2_STEP_PIN) || (AXIS_HAS_SPI(Z2) && IS_TX2(Z2_CS_PIN))
-    #error "Serial port pins (2) conflict with Z2 pins!"
-  #elif IS_TX2(Z3_ENABLE_PIN) || ANY_RX(2, Z3_DIR_PIN, Z3_STEP_PIN) || (AXIS_HAS_SPI(Z3) && IS_TX2(Z3_CS_PIN))
-    #error "Serial port pins (2) conflict with Z3 pins!"
-  #elif IS_TX2(Z4_ENABLE_PIN) || ANY_RX(2, Z4_DIR_PIN, Z4_STEP_PIN) || (AXIS_HAS_SPI(Z4) && IS_TX2(Z4_CS_PIN))
-    #error "Serial port pins (2) conflict with Z4 pins!"
-  #elif ANY_RX(2, X_DIR_PIN, Y_DIR_PIN)
-    #error "Serial port pins (2) conflict with other pins!"
-  #elif Y_HOME_TO_MIN && IS_TX2(Y_STOP_PIN)
-    #error "Serial port pins (2) conflict with Y endstop pin!"
-  #elif USES_Z_MIN_PROBE_PIN && IS_TX2(Z_MIN_PROBE_PIN)
-    #error "Serial port pins (2) conflict with probe pin!"
-  #elif ANY_TX(2, X_ENABLE_PIN, Y_ENABLE_PIN) || ANY_RX(2, X_DIR_PIN, Y_DIR_PIN)
-    #error "Serial port pins (2) conflict with X/Y stepper pins!"
-  #elif HAS_MULTI_EXTRUDER && (IS_TX2(E1_ENABLE_PIN) || (AXIS_HAS_SPI(E1) && IS_TX2(E1_CS_PIN)))
-    #error "Serial port pins (2) conflict with E1 stepper pins!"
-  #elif EXTRUDERS && ANY_RX(2, E0_DIR_PIN, E0_STEP_PIN)
-    #error "Serial port pins (2) conflict with E stepper pins!"
-  #endif
-  #undef IS_TX2
-  #undef IS_RX2
-  #undef _IS_TX2_1
-  #undef _IS_RX2_1
-#endif
-
-#if USING_HW_SERIAL3
-  #define PIN_IS_TX3(P) (PIN_EXISTS(P) && P##_PIN == P0_00)
-  #define PIN_IS_RX3(P) (P##_PIN == P0_01)
-  #if PIN_IS_TX3(X_MIN) || PIN_IS_RX3(X_MAX)
-    #error "Serial port pins (3) conflict with X endstop pins!"
-  #elif PIN_IS_TX3(Y_SERIAL_TX) || PIN_IS_TX3(Y_SERIAL_RX) || PIN_IS_RX3(X_SERIAL_TX) || PIN_IS_RX3(X_SERIAL_RX)
-    #error "Serial port pins (3) conflict with X/Y axis UART pins!"
-  #elif PIN_IS_TX3(X2_DIR) || PIN_IS_RX3(X2_STEP)
-    #error "Serial port pins (3) conflict with X2 pins!"
-  #elif PIN_IS_TX3(Y2_DIR) || PIN_IS_RX3(Y2_STEP)
-    #error "Serial port pins (3) conflict with Y2 pins!"
-  #elif PIN_IS_TX3(Z2_DIR) || PIN_IS_RX3(Z2_STEP)
-    #error "Serial port pins (3) conflict with Z2 pins!"
-  #elif PIN_IS_TX3(Z3_DIR) || PIN_IS_RX3(Z3_STEP)
-    #error "Serial port pins (3) conflict with Z3 pins!"
-  #elif PIN_IS_TX3(Z4_DIR) || PIN_IS_RX3(Z4_STEP)
-    #error "Serial port pins (3) conflict with Z4 pins!"
-  #elif HAS_MULTI_EXTRUDER && (PIN_IS_TX3(E1_DIR) || PIN_IS_RX3(E1_STEP))
-    #error "Serial port pins (3) conflict with E1 pins!"
-  #endif
-  #undef PIN_IS_TX3
-  #undef PIN_IS_RX3
-#endif
-
-#undef ANY_TX
-#undef ANY_RX
-
-//
-// Flag any i2c pin conflicts
-//
-#if ANY(HAS_MOTOR_CURRENT_I2C, HAS_MOTOR_CURRENT_DAC, EXPERIMENTAL_I2CBUS, I2C_POSITION_ENCODERS, PCA9632, I2C_EEPROM)
-  #define USEDI2CDEV_M 1  // <Arduino>/Wire.cpp
-
-  #if USEDI2CDEV_M == 0         // P0_27 [D57] (AUX-1) .......... P0_28 [D58] (AUX-1)
-    #define PIN_IS_SDA0(P) (P##_PIN == P0_27)
-    #define IS_SCL0(P)     (P == P0_28)
-    #if ENABLED(SDSUPPORT) && PIN_IS_SDA0(SD_DETECT)
-      #error "SDA0 overlaps with SD_DETECT_PIN!"
-    #elif PIN_IS_SDA0(E0_AUTO_FAN)
-      #error "SDA0 overlaps with E0_AUTO_FAN_PIN!"
-    #elif PIN_IS_SDA0(BEEPER)
-      #error "SDA0 overlaps with BEEPER_PIN!"
-    #elif IS_SCL0(BTN_ENC)
-      #error "SCL0 overlaps with Encoder Button!"
-    #elif IS_SCL0(SD_SS_PIN)
-      #error "SCL0 overlaps with SD_SS_PIN!"
-    #elif IS_SCL0(LCD_SDSS)
-      #error "SCL0 overlaps with LCD_SDSS!"
-    #endif
-    #undef PIN_IS_SDA0
-    #undef IS_SCL0
-  #elif USEDI2CDEV_M == 1       // P0_00 [D20] (SCA) ............ P0_01 [D21] (SCL)
-    #define PIN_IS_SDA1(P) (PIN_EXISTS(P) && P##_PIN == P0_00)
-    #define PIN_IS_SCL1(P) (P##_PIN == P0_01)
-    #if PIN_IS_SDA1(X_MIN) || PIN_IS_SCL1(X_MAX)
-      #error "One or more i2c (1) pins overlaps with X endstop pins! Disable i2c peripherals."
-    #elif PIN_IS_SDA1(X2_DIR) || PIN_IS_SCL1(X2_STEP)
-      #error "One or more i2c (1) pins overlaps with X2 pins! Disable i2c peripherals."
-    #elif PIN_IS_SDA1(Y2_DIR) || PIN_IS_SCL1(Y2_STEP)
-      #error "One or more i2c (1) pins overlaps with Y2 pins! Disable i2c peripherals."
-    #elif PIN_IS_SDA1(Z2_DIR) || PIN_IS_SCL1(Z2_STEP)
-      #error "One or more i2c (1) pins overlaps with Z2 pins! Disable i2c peripherals."
-    #elif PIN_IS_SDA1(Z3_DIR) || PIN_IS_SCL1(Z3_STEP)
-      #error "One or more i2c (1) pins overlaps with Z3 pins! Disable i2c peripherals."
-    #elif PIN_IS_SDA1(Z4_DIR) || PIN_IS_SCL1(Z4_STEP)
-      #error "One or more i2c (1) pins overlaps with Z4 pins! Disable i2c peripherals."
-    #elif HAS_MULTI_EXTRUDER && (PIN_IS_SDA1(E1_DIR) || PIN_IS_SCL1(E1_STEP))
-      #error "One or more i2c (1) pins overlaps with E1 pins! Disable i2c peripherals."
-    #endif
-    #undef PIN_IS_SDA1
-    #undef PIN_IS_SCL1
-  #elif USEDI2CDEV_M == 2     // P0_10 [D38] (X_ENABLE_PIN) ... P0_11 [D55] (X_DIR_PIN)
-    #define PIN_IS_SDA2(P) (P##_PIN == P0_10)
-    #define PIN_IS_SCL2(P) (P##_PIN == P0_11)
-    #if PIN_IS_SDA2(Y_STOP)
-      #error "i2c SDA2 overlaps with Y endstop pin!"
-    #elif USES_Z_MIN_PROBE_PIN && PIN_IS_SDA2(Z_MIN_PROBE)
-      #error "i2c SDA2 overlaps with Z probe pin!"
-    #elif PIN_IS_SDA2(X_ENABLE) || PIN_IS_SDA2(Y_ENABLE)
-      #error "i2c SDA2 overlaps with X/Y ENABLE pin!"
-    #elif AXIS_HAS_SPI(X) && PIN_IS_SDA2(X_CS)
-      #error "i2c SDA2 overlaps with X CS pin!"
-    #elif PIN_IS_SDA2(X2_ENABLE)
-      #error "i2c SDA2 overlaps with X2 enable pin! Disable i2c peripherals."
-    #elif PIN_IS_SDA2(Y2_ENABLE)
-      #error "i2c SDA2 overlaps with Y2 enable pin! Disable i2c peripherals."
-    #elif PIN_IS_SDA2(Z2_ENABLE)
-      #error "i2c SDA2 overlaps with Z2 enable pin! Disable i2c peripherals."
-    #elif PIN_IS_SDA2(Z3_ENABLE)
-      #error "i2c SDA2 overlaps with Z3 enable pin! Disable i2c peripherals."
-    #elif PIN_IS_SDA2(Z4_ENABLE)
-      #error "i2c SDA2 overlaps with Z4 enable pin! Disable i2c peripherals."
-    #elif HAS_MULTI_EXTRUDER && PIN_IS_SDA2(E1_ENABLE)
-      #error "i2c SDA2 overlaps with E1 enable pin! Disable i2c peripherals."
-    #elif HAS_MULTI_EXTRUDER && AXIS_HAS_SPI(E1) && PIN_IS_SDA2(E1_CS)
-      #error "i2c SDA2 overlaps with E1 CS pin! Disable i2c peripherals."
-    #elif EXTRUDERS && (PIN_IS_SDA2(E0_STEP) || PIN_IS_SDA2(E0_DIR))
-      #error "i2c SCL2 overlaps with E0 STEP/DIR pin! Disable i2c peripherals."
-    #elif PIN_IS_SDA2(X_DIR) || PIN_IS_SDA2(Y_DIR)
-      #error "One or more i2c pins overlaps with X/Y DIR pin! Disable i2c peripherals."
-    #endif
-    #undef PIN_IS_SDA2
-    #undef PIN_IS_SCL2
-  #endif
-
-  #undef USEDI2CDEV_M
-#endif
-
-#if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-  #error "SERIAL_STATS_MAX_RX_QUEUED is not supported on LPC176x."
-#elif ENABLED(SERIAL_STATS_DROPPED_RX)
-  #error "SERIAL_STATS_DROPPED_RX is not supported on LPX176x."
-#endif
diff --git a/Marlin/src/HAL/LPC1768/include/SPI.h b/Marlin/src/HAL/LPC1768/include/SPI.h
deleted file mode 100644
index 24f4759..0000000
--- a/Marlin/src/HAL/LPC1768/include/SPI.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../shared/HAL_SPI.h"
-
-#include <stdint.h>
-#include <lpc17xx_ssp.h>
-#include <lpc17xx_gpdma.h>
-
-//#define MSBFIRST 1
-
-#define SPI_MODE0 0
-#define SPI_MODE1 1
-#define SPI_MODE2 2
-#define SPI_MODE3 3
-
-#define DATA_SIZE_8BIT SSP_DATABIT_8
-#define DATA_SIZE_16BIT SSP_DATABIT_16
-
-#define SPI_CLOCK_MAX_TFT  30000000UL
-#define SPI_CLOCK_DIV2     8333333 //(SCR:  2)  desired: 8,000,000  actual: 8,333,333  +4.2%  SPI_FULL_SPEED
-#define SPI_CLOCK_DIV4     4166667 //(SCR:  5)  desired: 4,000,000  actual: 4,166,667  +4.2%  SPI_HALF_SPEED
-#define SPI_CLOCK_DIV8     2083333 //(SCR: 11)  desired: 2,000,000  actual: 2,083,333  +4.2%  SPI_QUARTER_SPEED
-#define SPI_CLOCK_DIV16    1000000 //(SCR: 24)  desired: 1,000,000  actual: 1,000,000         SPI_EIGHTH_SPEED
-#define SPI_CLOCK_DIV32     500000 //(SCR: 49)  desired:   500,000  actual:   500,000         SPI_SPEED_5
-#define SPI_CLOCK_DIV64     250000 //(SCR: 99)  desired:   250,000  actual:   250,000         SPI_SPEED_6
-#define SPI_CLOCK_DIV128    125000 //(SCR:199)  desired:   125,000  actual:   125,000         Default from HAL.h
-
-#define SPI_CLOCK_MAX SPI_CLOCK_DIV2
-
-#define BOARD_NR_SPI 2
-
-//#define BOARD_SPI1_NSS_PIN      PA4 ?!
-#define BOARD_SPI1_SCK_PIN      P0_15
-#define BOARD_SPI1_MISO_PIN     P0_17
-#define BOARD_SPI1_MOSI_PIN     P0_18
-
-//#define BOARD_SPI2_NSS_PIN      PB12 ?!
-#define BOARD_SPI2_SCK_PIN      P0_07
-#define BOARD_SPI2_MISO_PIN     P0_08
-#define BOARD_SPI2_MOSI_PIN     P0_09
-
-class SPISettings {
-public:
-  SPISettings(uint32_t spiRate, int inBitOrder, int inDataMode) {
-    init_AlwaysInline(spiRate2Clock(spiRate), inBitOrder, inDataMode, DATA_SIZE_8BIT);
-  }
-  SPISettings(uint32_t inClock, uint8_t inBitOrder, uint8_t inDataMode, uint32_t inDataSize) {
-    if (__builtin_constant_p(inClock))
-      init_AlwaysInline(inClock, inBitOrder, inDataMode, inDataSize);
-    else
-      init_MightInline(inClock, inBitOrder, inDataMode, inDataSize);
-  }
-  SPISettings() {
-    init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0, DATA_SIZE_8BIT);
-  }
-
-  //uint32_t spiRate() const { return spi_speed; }
-
-  static uint32_t spiRate2Clock(uint32_t spiRate) {
-    uint32_t Marlin_speed[7]; // CPSR is always 2
-    Marlin_speed[0] = 8333333; //(SCR:  2)  desired: 8,000,000  actual: 8,333,333  +4.2%  SPI_FULL_SPEED
-    Marlin_speed[1] = 4166667; //(SCR:  5)  desired: 4,000,000  actual: 4,166,667  +4.2%  SPI_HALF_SPEED
-    Marlin_speed[2] = 2083333; //(SCR: 11)  desired: 2,000,000  actual: 2,083,333  +4.2%  SPI_QUARTER_SPEED
-    Marlin_speed[3] = 1000000; //(SCR: 24)  desired: 1,000,000  actual: 1,000,000         SPI_EIGHTH_SPEED
-    Marlin_speed[4] =  500000; //(SCR: 49)  desired:   500,000  actual:   500,000         SPI_SPEED_5
-    Marlin_speed[5] =  250000; //(SCR: 99)  desired:   250,000  actual:   250,000         SPI_SPEED_6
-    Marlin_speed[6] =  125000; //(SCR:199)  desired:   125,000  actual:   125,000         Default from HAL.h
-    return Marlin_speed[spiRate > 6 ? 6 : spiRate];
-  }
-
-private:
-  void init_MightInline(uint32_t inClock, uint8_t inBitOrder, uint8_t inDataMode, uint32_t inDataSize) {
-    init_AlwaysInline(inClock, inBitOrder, inDataMode, inDataSize);
-  }
-  void init_AlwaysInline(uint32_t inClock, uint8_t inBitOrder, uint8_t inDataMode, uint32_t inDataSize) __attribute__((__always_inline__)) {
-    clock    = inClock;
-    bitOrder = inBitOrder;
-    dataMode = inDataMode;
-    dataSize = inDataSize;
-  }
-
-  //uint32_t spi_speed;
-  uint32_t clock;
-  uint32_t dataSize;
-  //uint32_t clockDivider;
-  uint8_t bitOrder;
-  uint8_t dataMode;
-  LPC_SSP_TypeDef *spi_d;
-
-  friend class SPIClass;
-};
-
-/**
- * @brief Wirish SPI interface.
- *
- * This is the same interface is available across HAL
- *
- * This implementation uses software slave management, so the caller
- * is responsible for controlling the slave select line.
- */
-class SPIClass {
-public:
-  /**
-   * @param spiPortNumber Number of the SPI port to manage.
-   */
-  SPIClass(uint8_t spiPortNumber);
-
-  /**
-   * Init using pins
-   */
-  SPIClass(pin_t mosi, pin_t miso, pin_t sclk, pin_t ssel = (pin_t)-1);
-
-  /**
-   * Select and configure the current selected SPI device to use
-   */
-  void begin();
-
-  /**
-   * Disable the current SPI device
-   */
-  void end();
-
-  void beginTransaction(const SPISettings&);
-  void endTransaction() {}
-
-  // Transfer using 1 "Data Size"
-  uint8_t transfer(uint16_t data);
-  // Transfer 2 bytes in 8 bit mode
-  uint16_t transfer16(uint16_t data);
-
-  void send(uint8_t data);
-
-  uint16_t read();
-  void read(uint8_t *buf, uint32_t len);
-
-  void dmaSend(void *buf, uint16_t length, bool minc);
-
-  /**
-   * @brief Sets the number of the SPI peripheral to be used by
-   *        this HardwareSPI instance.
-   *
-   * @param spi_num Number of the SPI port. 1-2 in low density devices
-   *     or 1-3 in high density devices.
-   */
-  void setModule(uint8_t device);
-
-  void setClock(uint32_t clock);
-  void setBitOrder(uint8_t bitOrder);
-  void setDataMode(uint8_t dataMode);
-  void setDataSize(uint32_t ds);
-
-  inline uint32_t getDataSize() { return _currentSetting->dataSize; }
-
-private:
-  SPISettings _settings[BOARD_NR_SPI];
-  SPISettings *_currentSetting;
-
-  void updateSettings();
-};
-
-extern SPIClass SPI;
diff --git a/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.c b/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.c
deleted file mode 100644
index c489c16..0000000
--- a/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * digipot_mcp4451_I2C_routines.c
- * Adapted from https://www-users.cs.york.ac.uk/~pcc/MCP/HAPR-Course-web/CMSIS/examples/html/master_8c_source.html
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if ENABLED(DIGIPOT_MCP4451) && MB(MKS_SBASE)
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-#include "digipot_mcp4451_I2C_routines.h"
-
-uint8_t digipot_mcp4451_start(uint8_t sla) {  // send slave address and write bit
-  // Sometimes TX data ACK or NAK status is returned.  That mean the start state didn't
-  // happen which means only the value of the slave address was send.  Keep looping until
-  // the slave address and write bit are actually sent.
-  do {
-    _I2C_Stop(I2CDEV_M); // output stop state on I2C bus
-    _I2C_Start(I2CDEV_M); // output start state on I2C bus
-    while ((I2C_status != I2C_I2STAT_M_TX_START)
-        && (I2C_status != I2C_I2STAT_M_TX_RESTART)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_NACK));  //wait for start to be asserted
-
-    LPC_I2C1->I2CONCLR = I2C_I2CONCLR_STAC; // clear start state before tansmitting slave address
-    LPC_I2C1->I2DAT = (sla << 1) & I2C_I2DAT_BITMASK; // transmit slave address & write bit
-    LPC_I2C1->I2CONSET = I2C_I2CONSET_AA;
-    LPC_I2C1->I2CONCLR = I2C_I2CONCLR_SIC;
-    while ((I2C_status != I2C_I2STAT_M_TX_SLAW_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_SLAW_NACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_NACK)) { /* wait for slaw to finish */ }
-  } while ( (I2C_status == I2C_I2STAT_M_TX_DAT_ACK) || (I2C_status == I2C_I2STAT_M_TX_DAT_NACK));
-  return 1;
-}
-
-uint8_t digipot_mcp4451_send_byte(uint8_t data) {
-  LPC_I2C1->I2DAT = data & I2C_I2DAT_BITMASK; // transmit data
-  LPC_I2C1->I2CONSET = I2C_I2CONSET_AA;
-  LPC_I2C1->I2CONCLR = I2C_I2CONCLR_SIC;
-  while (I2C_status != I2C_I2STAT_M_TX_DAT_ACK && I2C_status != I2C_I2STAT_M_TX_DAT_NACK);  // wait for xmit to finish
-  return 1;
-}
-
-#ifdef __cplusplus
-  }
-#endif
-
-#endif // DIGIPOT_MCP4451 && MKS_SBASE
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.h b/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.h
deleted file mode 100644
index 9b6c62b..0000000
--- a/Marlin/src/HAL/LPC1768/include/digipot_mcp4451_I2C_routines.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * digipot_mcp4451_I2C_routines.h
- * Adapted from https://www-users.cs.york.ac.uk/~pcc/MCP/HAPR-Course-web/CMSIS/examples/html/master_8c_source.html
- */
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-#include <lpc17xx_i2c.h>
-#include <lpc17xx_pinsel.h>
-#include <lpc17xx_libcfg_default.h>
-#include "i2c_util.h"
-
-uint8_t digipot_mcp4451_start(uint8_t sla);
-uint8_t digipot_mcp4451_send_byte(uint8_t data);
-
-#ifdef __cplusplus
-  }
-#endif
diff --git a/Marlin/src/HAL/LPC1768/include/i2c_util.c b/Marlin/src/HAL/LPC1768/include/i2c_util.c
deleted file mode 100644
index 4e24f23..0000000
--- a/Marlin/src/HAL/LPC1768/include/i2c_util.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL_LPC1768/include/i2c_util.c
- */
-
-#ifdef TARGET_LPC1768
-
-#include "i2c_util.h"
-
-#define U8G_I2C_OPT_FAST 16  // from u8g.h
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-void configure_i2c(const uint8_t clock_option) {
-  /**
-   * Init I2C pin connect
-   */
-  PINSEL_CFG_Type PinCfg;
-  PinCfg.OpenDrain = 0;
-  PinCfg.Pinmode = 0;
-  PinCfg.Portnum = 0;
-  #if I2C_MASTER_ID == 0
-    PinCfg.Funcnum = 1;
-    PinCfg.Pinnum = 27;     // SDA0 / D57  AUX-1 ... SCL0 / D58  AUX-1
-  #elif I2C_MASTER_ID == 1
-    PinCfg.Funcnum = 3;
-    PinCfg.Pinnum = 0;      // SDA1 / D20 SCA ... SCL1 / D21 SCL
-  #elif I2C_MASTER_ID == 2
-    PinCfg.Funcnum = 2;
-    PinCfg.Pinnum = 10;     // SDA2 / D38  X_ENABLE_PIN ... SCL2 / D55  X_DIR_PIN
-  #endif
-  PINSEL_ConfigPin(&PinCfg);
-  PinCfg.Pinnum += 1;
-  PINSEL_ConfigPin(&PinCfg);
-
-  // Initialize I2C peripheral
-  I2C_Init(I2CDEV_M, (clock_option & U8G_I2C_OPT_FAST) ? 400000: 100000);  // LCD data rates
-
-  // Enable Master I2C operation
-  I2C_Cmd(I2CDEV_M, I2C_MASTER_MODE, ENABLE);
-}
-
-//////////////////////////////////////////////////////////////////////////////////////
-// These two routines are exact copies of the lpc17xx_i2c.c routines.  Couldn't link to
-// to the lpc17xx_i2c.c routines so had to copy them into this file & rename them.
-
-uint32_t _I2C_Start(LPC_I2C_TypeDef *I2Cx) {
-  // Reset STA, STO, SI
-  I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
-
-  // Enter to Master Transmitter mode
-  I2Cx->I2CONSET = I2C_I2CONSET_STA;
-
-  // Wait for complete
-  while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
-  I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
-  return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
-}
-
-void _I2C_Stop(LPC_I2C_TypeDef *I2Cx) {
-  /* Make sure start bit is not active */
-  if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
-    I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
-
-  I2Cx->I2CONSET = I2C_I2CONSET_STO|I2C_I2CONSET_AA;
-  I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
-}
-
-#ifdef __cplusplus
-  }
-#endif
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/include/i2c_util.h b/Marlin/src/HAL/LPC1768/include/i2c_util.h
deleted file mode 100644
index 1f1c19f..0000000
--- a/Marlin/src/HAL/LPC1768/include/i2c_util.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL_LPC1768/include/i2c_util.h
- */
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#ifndef I2C_MASTER_ID
-  #define I2C_MASTER_ID 1
-#endif
-
-#if I2C_MASTER_ID == 0
-  #define I2CDEV_M LPC_I2C0
-#elif I2C_MASTER_ID == 1
-  #define I2CDEV_M LPC_I2C1
-#elif I2C_MASTER_ID == 2
-  #define I2CDEV_M LPC_I2C2
-#else
-  #error "Master I2C device not defined!"
-#endif
-
-#include <lpc17xx_i2c.h>
-#include <lpc17xx_pinsel.h>
-#include <lpc17xx_libcfg_default.h>
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-void configure_i2c(const uint8_t clock_option);
-
-uint32_t _I2C_Start(LPC_I2C_TypeDef *I2Cx);
-void _I2C_Stop(LPC_I2C_TypeDef *I2Cx);
-
-#define I2C_status (LPC_I2C1->I2STAT & I2C_STAT_CODE_BITMASK)
-
-#ifdef __cplusplus
-  }
-#endif
diff --git a/Marlin/src/HAL/LPC1768/main.cpp b/Marlin/src/HAL/LPC1768/main.cpp
deleted file mode 100644
index 419c997..0000000
--- a/Marlin/src/HAL/LPC1768/main.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include <usb/usb.h>
-#include <usb/usbcfg.h>
-#include <usb/usbhw.h>
-#include <usb/usbcore.h>
-#include <usb/cdc.h>
-#include <usb/cdcuser.h>
-#include <usb/mscuser.h>
-#include <CDCSerial.h>
-#include <usb/mscuser.h>
-
-#include "../../inc/MarlinConfig.h"
-#include "../../core/millis_t.h"
-
-#include "../../sd/cardreader.h"
-
-extern uint32_t MSC_SD_Init(uint8_t pdrv);
-
-extern "C" {
-  #include <debug_frmwrk.h>
-  extern "C" int isLPC1769();
-  extern "C" void disk_timerproc();
-}
-
-void SysTick_Callback() { disk_timerproc(); }
-
-TERN_(POSTMORTEM_DEBUGGING, extern void install_min_serial());
-
-void MarlinHAL::init() {
-
-  // Init LEDs
-  #if PIN_EXISTS(LED)
-    SET_DIR_OUTPUT(LED_PIN);
-    WRITE_PIN_CLR(LED_PIN);
-    #if PIN_EXISTS(LED2)
-      SET_DIR_OUTPUT(LED2_PIN);
-      WRITE_PIN_CLR(LED2_PIN);
-      #if PIN_EXISTS(LED3)
-        SET_DIR_OUTPUT(LED3_PIN);
-        WRITE_PIN_CLR(LED3_PIN);
-        #if PIN_EXISTS(LED4)
-          SET_DIR_OUTPUT(LED4_PIN);
-          WRITE_PIN_CLR(LED4_PIN);
-        #endif
-      #endif
-    #endif
-
-    // Flash status LED 3 times to indicate Marlin has started booting
-    LOOP_L_N(i, 6) {
-      TOGGLE(LED_PIN);
-      delay(100);
-    }
-  #endif
-
-  // Init Servo Pins
-  #define INIT_SERVO(N) OUT_WRITE(SERVO##N##_PIN, LOW)
-  #if HAS_SERVO_0
-    INIT_SERVO(0);
-  #endif
-  #if HAS_SERVO_1
-    INIT_SERVO(1);
-  #endif
-  #if HAS_SERVO_2
-    INIT_SERVO(2);
-  #endif
-  #if HAS_SERVO_3
-    INIT_SERVO(3);
-  #endif
-
-  //debug_frmwrk_init();
-  //_DBG("\n\nDebug running\n");
-  // Initialize the SD card chip select pins as soon as possible
-  #if PIN_EXISTS(SD_SS)
-    OUT_WRITE(SD_SS_PIN, HIGH);
-  #endif
-
-  #if PIN_EXISTS(ONBOARD_SD_CS) && ONBOARD_SD_CS_PIN != SD_SS_PIN
-    OUT_WRITE(ONBOARD_SD_CS_PIN, HIGH);
-  #endif
-
-  #ifdef LPC1768_ENABLE_CLKOUT_12M
-   /**
-    * CLKOUTCFG register
-    * bit 8 (CLKOUT_EN) = enables CLKOUT signal. Disabled for now to prevent glitch when enabling GPIO.
-    * bits 7:4 (CLKOUTDIV) = set to 0 for divider setting of /1
-    * bits 3:0 (CLKOUTSEL) = set to 1 to select main crystal oscillator as CLKOUT source
-    */
-    LPC_SC->CLKOUTCFG = (0<<8)|(0<<4)|(1<<0);
-    // set P1.27 pin to function 01 (CLKOUT)
-    PINSEL_CFG_Type PinCfg;
-    PinCfg.Portnum = 1;
-    PinCfg.Pinnum = 27;
-    PinCfg.Funcnum = 1;    // function 01 (CLKOUT)
-    PinCfg.OpenDrain = 0;  // not open drain
-    PinCfg.Pinmode = 2;    // no pull-up/pull-down
-    PINSEL_ConfigPin(&PinCfg);
-    // now set CLKOUT_EN bit
-    SBI(LPC_SC->CLKOUTCFG, 8);
-  #endif
-
-  USB_Init();                               // USB Initialization
-  USB_Connect(false);                       // USB clear connection
-  delay(1000);                              // Give OS time to notice
-  USB_Connect(true);
-
-  TERN_(HAS_SD_HOST_DRIVE, MSC_SD_Init(0)); // Enable USB SD card access
-
-  const millis_t usb_timeout = millis() + 2000;
-  while (!USB_Configuration && PENDING(millis(), usb_timeout)) {
-    delay(50);
-    idletask();
-    #if PIN_EXISTS(LED)
-      TOGGLE(LED_PIN);     // Flash quickly during USB initialization
-    #endif
-  }
-
-  HAL_timer_init();
-
-  TERN_(POSTMORTEM_DEBUGGING, install_min_serial()); // Install the min serial handler
-}
-
-// HAL idle task
-void MarlinHAL::idletask() {
-  #if HAS_SHARED_MEDIA
-    // If Marlin is using the SD card we need to lock it to prevent access from
-    // a PC via USB.
-    // Other HALs use IS_SD_PRINTING() and IS_SD_FILE_OPEN() to check for access but
-    // this will not reliably detect delete operations. To be safe we will lock
-    // the disk if Marlin has it mounted. Unfortunately there is currently no way
-    // to unmount the disk from the LCD menu.
-    // if (IS_SD_PRINTING() || IS_SD_FILE_OPEN())
-    if (card.isMounted())
-      MSC_Aquire_Lock();
-    else
-      MSC_Release_Lock();
-  #endif
-  // Perform USB stack housekeeping
-  MSC_RunDeferredCommands();
-}
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/pinsDebug.h b/Marlin/src/HAL/LPC1768/pinsDebug.h
deleted file mode 100644
index a2f5c12..0000000
--- a/Marlin/src/HAL/LPC1768/pinsDebug.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Support routines for LPC1768
- */
-
-/**
- * Translation of routines & variables used by pinsDebug.h
- */
-
-#define NUMBER_PINS_TOTAL NUM_DIGITAL_PINS
-#define pwm_details(pin) pin = pin    // do nothing  // print PWM details
-#define pwm_status(pin) false //Print a pin's PWM status. Return true if it's currently a PWM pin.
-#define IS_ANALOG(P) (DIGITAL_PIN_TO_ANALOG_PIN(P) >= 0 ? 1 : 0)
-#define digitalRead_mod(p) extDigitalRead(p)
-#define PRINT_PORT(p)
-#define GET_ARRAY_PIN(p) pin_array[p].pin
-#define PRINT_ARRAY_NAME(x) do{ sprintf_P(buffer, PSTR("%-" STRINGIFY(MAX_NAME_LENGTH) "s"), pin_array[x].name); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN(p) do{ sprintf_P(buffer, PSTR("P%d_%02d"), LPC176x::pin_port(p), LPC176x::pin_bit(p)); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR("_A%d     "), LPC176x::pin_get_adc_channel(pin)); SERIAL_ECHO(buffer); }while(0)
-#define MULTI_NAME_PAD 17 // space needed to be pretty if not first name assigned to a pin
-
-// pins that will cause hang/reset/disconnect in M43 Toggle and Watch utilities
-#ifndef M43_NEVER_TOUCH
-  #define M43_NEVER_TOUCH(Q) ((Q) == P0_29 || (Q) == P0_30 || (Q) == P2_09)  // USB pins
-#endif
-
-bool GET_PINMODE(const pin_t pin) {
-  if (!LPC176x::pin_is_valid(pin) || LPC176x::pin_adc_enabled(pin)) // found an invalid pin or active analog pin
-    return false;
-
-  return LPC176x::gpio_direction(pin);
-}
-
-#define GET_ARRAY_IS_DIGITAL(x) ((bool) pin_array[x].is_digital)
diff --git a/Marlin/src/HAL/LPC1768/spi_pins.h b/Marlin/src/HAL/LPC1768/spi_pins.h
deleted file mode 100644
index e7d7747..0000000
--- a/Marlin/src/HAL/LPC1768/spi_pins.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../core/macros.h"
-
-#if BOTH(SDSUPPORT, HAS_MARLINUI_U8GLIB) && (LCD_PINS_D4 == SD_SCK_PIN || LCD_PINS_ENABLE == SD_MOSI_PIN || DOGLCD_SCK == SD_SCK_PIN || DOGLCD_MOSI == SD_MOSI_PIN)
-  #define LPC_SOFTWARE_SPI  // If the SD card and LCD adapter share the same SPI pins, then software SPI is currently
-                            // needed due to the speed and mode required for communicating with each device being different.
-                            // This requirement can be removed if the SPI access to these devices is updated to use
-                            // spiBeginTransaction.
-#endif
-
-/** onboard SD card */
-//#define SD_SCK_PIN        P0_07
-//#define SD_MISO_PIN       P0_08
-//#define SD_MOSI_PIN       P0_09
-//#define SD_SS_PIN         P0_06
-/** external */
-#ifndef SD_SCK_PIN
-  #define SD_SCK_PIN        P0_15
-#endif
-#ifndef SD_MISO_PIN
-  #define SD_MISO_PIN       P0_17
-#endif
-#ifndef SD_MOSI_PIN
-  #define SD_MOSI_PIN       P0_18
-#endif
-#ifndef SD_SS_PIN
-  #define SD_SS_PIN         P1_23
-#endif
-#if !defined(SDSS) || SDSS == P_NC // gets defaulted in pins.h
-  #undef SDSS
-  #define SDSS          SD_SS_PIN
-#endif
diff --git a/Marlin/src/HAL/LPC1768/tft/tft_spi.cpp b/Marlin/src/HAL/LPC1768/tft/tft_spi.cpp
deleted file mode 100644
index a9847b2..0000000
--- a/Marlin/src/HAL/LPC1768/tft/tft_spi.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../../inc/MarlinConfig.h"
-
-#if HAS_SPI_TFT
-
-#include "tft_spi.h"
-
-SPIClass TFT_SPI::SPIx(1);
-
-void TFT_SPI::Init() {
-  #if PIN_EXISTS(TFT_RESET)
-    OUT_WRITE(TFT_RESET_PIN, HIGH);
-    delay(100);
-  #endif
-
-  #if PIN_EXISTS(TFT_BACKLIGHT)
-    OUT_WRITE(TFT_BACKLIGHT_PIN, HIGH);
-  #endif
-
-  SET_OUTPUT(TFT_DC_PIN);
-  SET_OUTPUT(TFT_CS_PIN);
-  WRITE(TFT_DC_PIN, HIGH);
-  WRITE(TFT_CS_PIN, HIGH);
-
-  /**
-   * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
-   * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
-   * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
-   */
-  #if 0
-    #if SPI_DEVICE == 1
-     #define SPI_CLOCK_MAX SPI_CLOCK_DIV4
-    #else
-     #define SPI_CLOCK_MAX SPI_CLOCK_DIV2
-    #endif
-    uint8_t  clock;
-    uint8_t spiRate = SPI_FULL_SPEED;
-    switch (spiRate) {
-     case SPI_FULL_SPEED:    clock = SPI_CLOCK_MAX ;  break;
-     case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4 ; break;
-     case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8 ; break;
-     case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
-     case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
-     case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
-     default:                clock = SPI_CLOCK_DIV2;  // Default from the SPI library
-    }
-  #endif
-
-  #if TFT_MISO_PIN == BOARD_SPI1_MISO_PIN
-    SPIx.setModule(1);
-  #elif TFT_MISO_PIN == BOARD_SPI2_MISO_PIN
-    SPIx.setModule(2);
-  #endif
-  SPIx.setClock(SPI_CLOCK_MAX_TFT);
-  SPIx.setBitOrder(MSBFIRST);
-  SPIx.setDataMode(SPI_MODE0);
-}
-
-void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
-  SPIx.setDataSize(DataSize);
-  SPIx.begin();
-  WRITE(TFT_CS_PIN, LOW);
-}
-
-uint32_t TFT_SPI::GetID() {
-  uint32_t id;
-  id = ReadID(LCD_READ_ID);
-  if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
-    id = ReadID(LCD_READ_ID4);
-  return id;
-}
-
-uint32_t TFT_SPI::ReadID(uint16_t Reg) {
-  uint32_t data = 0;
-
-  #if PIN_EXISTS(TFT_MISO)
-    uint8_t d = 0;
-    SPIx.setDataSize(DATASIZE_8BIT);
-    SPIx.setClock(SPI_CLOCK_DIV64);
-    SPIx.begin();
-    WRITE(TFT_CS_PIN, LOW);
-    WriteReg(Reg);
-
-    LOOP_L_N(i, 4) {
-      SPIx.read((uint8_t*)&d, 1);
-      data = (data << 8) | d;
-    }
-
-    DataTransferEnd();
-    SPIx.setClock(SPI_CLOCK_MAX_TFT);
-  #endif
-
-  return data >> 7;
-}
-
-bool TFT_SPI::isBusy() { return false; }
-
-void TFT_SPI::Abort() { DataTransferEnd(); }
-
-void TFT_SPI::Transmit(uint16_t Data) { SPIx.transfer(Data); }
-
-void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
-  DataTransferBegin(DATASIZE_16BIT);
-  WRITE(TFT_DC_PIN, HIGH);
-  SPIx.dmaSend(Data, Count, MemoryIncrease);
-  DataTransferEnd();
-}
-
-#endif // HAS_SPI_TFT
diff --git a/Marlin/src/HAL/LPC1768/tft/tft_spi.h b/Marlin/src/HAL/LPC1768/tft/tft_spi.h
deleted file mode 100644
index 4753fdb..0000000
--- a/Marlin/src/HAL/LPC1768/tft/tft_spi.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../../inc/MarlinConfig.h"
-
-#include <SPI.h>
-#include <lpc17xx_ssp.h>
-// #include <lpc17xx_gpdma.h>
-
-#ifndef LCD_READ_ID
-  #define LCD_READ_ID  0x04   // Read display identification information (0xD3 on ILI9341)
-#endif
-#ifndef LCD_READ_ID4
-  #define LCD_READ_ID4 0xD3   // Read display identification information (0xD3 on ILI9341)
-#endif
-
-#define DATASIZE_8BIT    SSP_DATABIT_8
-#define DATASIZE_16BIT   SSP_DATABIT_16
-#define TFT_IO_DRIVER TFT_SPI
-
-#define DMA_MINC_ENABLE 1
-#define DMA_MINC_DISABLE 0
-
-class TFT_SPI {
-private:
-  static uint32_t ReadID(uint16_t Reg);
-  static void Transmit(uint16_t Data);
-  static void TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count);
-
-public:
-  static SPIClass SPIx;
-
-  static void Init();
-  static uint32_t GetID();
-  static bool isBusy();
-  static void Abort();
-
-  static void DataTransferBegin(uint16_t DataWidth = DATASIZE_16BIT);
-  static void DataTransferEnd() { OUT_WRITE(TFT_CS_PIN, HIGH); SPIx.end(); };
-  static void DataTransferAbort();
-
-  static void WriteData(uint16_t Data) { Transmit(Data); }
-  static void WriteReg(uint16_t Reg) { OUT_WRITE(TFT_A0_PIN, LOW); Transmit(Reg); OUT_WRITE(TFT_A0_PIN, HIGH); }
-
-  static void WriteSequence(uint16_t *Data, uint16_t Count) { TransmitDMA(DMA_MINC_ENABLE, Data, Count); }
-  // static void WriteMultiple(uint16_t Color, uint16_t Count) { static uint16_t Data; Data = Color; TransmitDMA(DMA_MINC_DISABLE, &Data, Count); }
-  static void WriteMultiple(uint16_t Color, uint32_t Count) {
-    static uint16_t Data; Data = Color;
-    //LPC dma can only write 0xFFF bytes at once.
-    #define MAX_DMA_SIZE (0xFFF - 1)
-    while (Count > 0) {
-      TransmitDMA(DMA_MINC_DISABLE, &Data, Count > MAX_DMA_SIZE ? MAX_DMA_SIZE : Count);
-      Count = Count > MAX_DMA_SIZE ? Count - MAX_DMA_SIZE : 0;
-    }
-    #undef MAX_DMA_SIZE
-  }
-};
diff --git a/Marlin/src/HAL/LPC1768/tft/xpt2046.cpp b/Marlin/src/HAL/LPC1768/tft/xpt2046.cpp
deleted file mode 100644
index 9c1e158..0000000
--- a/Marlin/src/HAL/LPC1768/tft/xpt2046.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../../inc/MarlinConfig.h"
-
-#if HAS_TFT_XPT2046 || HAS_RES_TOUCH_BUTTONS
-
-#include "xpt2046.h"
-#include <SPI.h>
-
-uint16_t delta(uint16_t a, uint16_t b) { return a > b ? a - b : b - a; }
-
-#if ENABLED(TOUCH_BUTTONS_HW_SPI)
-  #include <SPI.h>
-
-  SPIClass XPT2046::SPIx(TOUCH_BUTTONS_HW_SPI_DEVICE);
-
-  static void touch_spi_init(uint8_t spiRate) {
-    XPT2046::SPIx.setModule(TOUCH_BUTTONS_HW_SPI_DEVICE);
-    XPT2046::SPIx.setClock(SPI_CLOCK_DIV128);
-    XPT2046::SPIx.setBitOrder(MSBFIRST);
-    XPT2046::SPIx.setDataMode(SPI_MODE0);
-    XPT2046::SPIx.setDataSize(DATA_SIZE_8BIT);
-  }
-#endif
-
-void XPT2046::Init() {
-  SET_INPUT(TOUCH_MISO_PIN);
-  SET_OUTPUT(TOUCH_MOSI_PIN);
-  SET_OUTPUT(TOUCH_SCK_PIN);
-  OUT_WRITE(TOUCH_CS_PIN, HIGH);
-
-  #if PIN_EXISTS(TOUCH_INT)
-    // Optional Pendrive interrupt pin
-    SET_INPUT(TOUCH_INT_PIN);
-  #endif
-
-  TERN_(TOUCH_BUTTONS_HW_SPI, touch_spi_init(SPI_SPEED_6));
-
-  // Read once to enable pendrive status pin
-  getRawData(XPT2046_X);
-}
-
-bool XPT2046::isTouched() {
-  return isBusy() ? false : (
-    #if PIN_EXISTS(TOUCH_INT)
-      READ(TOUCH_INT_PIN) != HIGH
-    #else
-      getRawData(XPT2046_Z1) >= XPT2046_Z1_THRESHOLD
-    #endif
-  );
-}
-
-bool XPT2046::getRawPoint(int16_t *x, int16_t *y) {
-  if (isBusy()) return false;
-  if (!isTouched()) return false;
-  *x = getRawData(XPT2046_X);
-  *y = getRawData(XPT2046_Y);
-  return isTouched();
-}
-
-uint16_t XPT2046::getRawData(const XPTCoordinate coordinate) {
-  uint16_t data[3];
-
-  DataTransferBegin();
-  TERN_(TOUCH_BUTTONS_HW_SPI, SPIx.begin());
-
-  for (uint16_t i = 0; i < 3 ; i++) {
-    IO(coordinate);
-    data[i] = (IO() << 4) | (IO() >> 4);
-  }
-
-  TERN_(TOUCH_BUTTONS_HW_SPI, SPIx.end());
-  DataTransferEnd();
-
-  uint16_t delta01 = delta(data[0], data[1]),
-           delta02 = delta(data[0], data[2]),
-           delta12 = delta(data[1], data[2]);
-
-  if (delta01 > delta02 || delta01 > delta12)
-    data[delta02 > delta12 ? 0 : 1] = data[2];
-
-  return (data[0] + data[1]) >> 1;
-}
-
-uint16_t XPT2046::IO(uint16_t data) {
-  return TERN(TOUCH_BUTTONS_HW_SPI, HardwareIO, SoftwareIO)(data);
-}
-
-extern uint8_t spiTransfer(uint8_t b);
-
-#if ENABLED(TOUCH_BUTTONS_HW_SPI)
-  uint16_t XPT2046::HardwareIO(uint16_t data) {
-    return SPIx.transfer(data & 0xFF);
-  }
-#endif
-
-uint16_t XPT2046::SoftwareIO(uint16_t data) {
-  uint16_t result = 0;
-
-  for (uint8_t j = 0x80; j; j >>= 1) {
-    WRITE(TOUCH_SCK_PIN, LOW);
-    WRITE(TOUCH_MOSI_PIN, data & j ? HIGH : LOW);
-    if (READ(TOUCH_MISO_PIN)) result |= j;
-    WRITE(TOUCH_SCK_PIN, HIGH);
-  }
-  WRITE(TOUCH_SCK_PIN, LOW);
-
-  return result;
-}
-
-#endif // HAS_TFT_XPT2046
diff --git a/Marlin/src/HAL/LPC1768/tft/xpt2046.h b/Marlin/src/HAL/LPC1768/tft/xpt2046.h
deleted file mode 100644
index 7c456cf..0000000
--- a/Marlin/src/HAL/LPC1768/tft/xpt2046.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../../inc/MarlinConfig.h"
-
-#if ENABLED(TOUCH_BUTTONS_HW_SPI)
-  #include <SPI.h>
-#endif
-
-#ifndef TOUCH_MISO_PIN
-  #define TOUCH_MISO_PIN SD_MISO_PIN
-#endif
-#ifndef TOUCH_MOSI_PIN
-  #define TOUCH_MOSI_PIN SD_MOSI_PIN
-#endif
-#ifndef TOUCH_SCK_PIN
-  #define TOUCH_SCK_PIN  SD_SCK_PIN
-#endif
-#ifndef TOUCH_CS_PIN
-  #define TOUCH_CS_PIN   SD_SS_PIN
-#endif
-#ifndef TOUCH_INT_PIN
-  #define TOUCH_INT_PIN  -1
-#endif
-
-#define XPT2046_DFR_MODE        0x00
-#define XPT2046_SER_MODE        0x04
-#define XPT2046_CONTROL         0x80
-
-enum XPTCoordinate : uint8_t {
-  XPT2046_X  = 0x10 | XPT2046_CONTROL | XPT2046_DFR_MODE,
-  XPT2046_Y  = 0x50 | XPT2046_CONTROL | XPT2046_DFR_MODE,
-  XPT2046_Z1 = 0x30 | XPT2046_CONTROL | XPT2046_DFR_MODE,
-  XPT2046_Z2 = 0x40 | XPT2046_CONTROL | XPT2046_DFR_MODE,
-};
-
-#ifndef XPT2046_Z1_THRESHOLD
-  #define XPT2046_Z1_THRESHOLD 10
-#endif
-
-class XPT2046 {
-private:
-  static bool isBusy() { return false; }
-
-  static uint16_t getRawData(const XPTCoordinate coordinate);
-  static bool isTouched();
-
-  static void DataTransferBegin() { WRITE(TOUCH_CS_PIN, LOW); };
-  static void DataTransferEnd() { WRITE(TOUCH_CS_PIN, HIGH); };
-  #if ENABLED(TOUCH_BUTTONS_HW_SPI)
-    static uint16_t HardwareIO(uint16_t data);
-  #endif
-  static uint16_t SoftwareIO(uint16_t data);
-  static uint16_t IO(uint16_t data = 0);
-
-public:
-  #if ENABLED(TOUCH_BUTTONS_HW_SPI)
-    static SPIClass SPIx;
-  #endif
-
-  static void Init();
-  static bool getRawPoint(int16_t *x, int16_t *y);
-};
diff --git a/Marlin/src/HAL/LPC1768/timers.cpp b/Marlin/src/HAL/LPC1768/timers.cpp
deleted file mode 100644
index bbb13f8..0000000
--- a/Marlin/src/HAL/LPC1768/timers.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Description:
- *
- * Timers for LPC1768
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfig.h"
-
-void HAL_timer_init() {
-  SBI(LPC_SC->PCONP, SBIT_TIMER0);  // Power ON Timer 0
-  LPC_TIM0->PR = (HAL_TIMER_RATE) / (STEPPER_TIMER_RATE) - 1; // Use prescaler to set frequency if needed
-
-  SBI(LPC_SC->PCONP, SBIT_TIMER1);  // Power ON Timer 1
-  LPC_TIM1->PR = (HAL_TIMER_RATE) / 1000000 - 1;
-}
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      LPC_TIM0->MCR = _BV(SBIT_MR0I) | _BV(SBIT_MR0R); // Match on MR0, reset on MR0, interrupts when NVIC enables them
-      LPC_TIM0->MR0 = uint32_t(STEPPER_TIMER_RATE) / frequency; // Match value (period) to set frequency
-      LPC_TIM0->TCR = _BV(SBIT_CNTEN); // Counter Enable
-
-      NVIC_SetPriority(TIMER0_IRQn, NVIC_EncodePriority(0, 1, 0));
-      NVIC_EnableIRQ(TIMER0_IRQn);
-      break;
-
-    case MF_TIMER_TEMP:
-      LPC_TIM1->MCR = _BV(SBIT_MR0I) | _BV(SBIT_MR0R); // Match on MR0, reset on MR0, interrupts when NVIC enables them
-      LPC_TIM1->MR0 = uint32_t(TEMP_TIMER_RATE) / frequency;
-      LPC_TIM1->TCR = _BV(SBIT_CNTEN); // Counter Enable
-
-      NVIC_SetPriority(TIMER1_IRQn, NVIC_EncodePriority(0, 2, 0));
-      NVIC_EnableIRQ(TIMER1_IRQn);
-      break;
-
-    default: break;
-  }
-}
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/timers.h b/Marlin/src/HAL/LPC1768/timers.h
deleted file mode 100644
index c6d7bc6..0000000
--- a/Marlin/src/HAL/LPC1768/timers.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL For LPC1768
- */
-
-#include <stdint.h>
-
-#include "../../core/macros.h"
-
-#define SBIT_TIMER0 1
-#define SBIT_TIMER1 2
-
-#define SBIT_CNTEN 0
-
-#define SBIT_MR0I  0 // Timer 0 Interrupt when TC matches MR0
-#define SBIT_MR0R  1 // Timer 0 Reset TC on Match
-#define SBIT_MR0S  2 // Timer 0 Stop TC and PC on Match
-#define SBIT_MR1I  3
-#define SBIT_MR1R  4
-#define SBIT_MR1S  5
-#define SBIT_MR2I  6
-#define SBIT_MR2R  7
-#define SBIT_MR2S  8
-#define SBIT_MR3I  9
-#define SBIT_MR3R 10
-#define SBIT_MR3S 11
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define _HAL_TIMER(T) _CAT(LPC_TIM, T)
-#define _HAL_TIMER_IRQ(T) TIMER##T##_IRQn
-#define __HAL_TIMER_ISR(T) extern "C" void TIMER##T##_IRQHandler()
-#define _HAL_TIMER_ISR(T)  __HAL_TIMER_ISR(T)
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define HAL_TIMER_RATE         ((F_CPU) / 4)  // frequency of timers peripherals
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-#ifndef MF_TIMER_PWM
-  #define MF_TIMER_PWM          3  // Timer Index for PWM
-#endif
-
-#define TEMP_TIMER_RATE        1000000
-#define TEMP_TIMER_FREQUENCY   1000 // temperature interrupt frequency
-
-#define STEPPER_TIMER_RATE     HAL_TIMER_RATE   // frequency of stepper timer (HAL_TIMER_RATE / STEPPER_TIMER_PRESCALE)
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // stepper timer ticks per Âµs
-#define STEPPER_TIMER_PRESCALE (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() _HAL_TIMER_ISR(MF_TIMER_STEP)
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() _HAL_TIMER_ISR(MF_TIMER_TEMP)
-#endif
-
-// Timer references by index
-#define STEP_TIMER_PTR _HAL_TIMER(MF_TIMER_STEP)
-#define TEMP_TIMER_PTR _HAL_TIMER(MF_TIMER_TEMP)
-
-// ------------------------
-// Public functions
-// ------------------------
-void HAL_timer_init();
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: STEP_TIMER_PTR->MR0 = compare; break; // Stepper Timer Match Register 0
-    case MF_TIMER_TEMP: TEMP_TIMER_PTR->MR0 = compare; break; //    Temp Timer Match Register 0
-  }
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return STEP_TIMER_PTR->MR0; // Stepper Timer Match Register 0
-    case MF_TIMER_TEMP: return TEMP_TIMER_PTR->MR0; //    Temp Timer Match Register 0
-  }
-  return 0;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return STEP_TIMER_PTR->TC; // Stepper Timer Count
-    case MF_TIMER_TEMP: return TEMP_TIMER_PTR->TC; //    Temp Timer Count
-  }
-  return 0;
-}
-
-FORCE_INLINE static void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_EnableIRQ(TIMER0_IRQn); break; // Enable interrupt handler
-    case MF_TIMER_TEMP: NVIC_EnableIRQ(TIMER1_IRQn); break; // Enable interrupt handler
-  }
-}
-
-FORCE_INLINE static void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_DisableIRQ(TIMER0_IRQn); break; // Disable interrupt handler
-    case MF_TIMER_TEMP: NVIC_DisableIRQ(TIMER1_IRQn); break; // Disable interrupt handler
-  }
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-}
-
-// This function is missing from CMSIS
-FORCE_INLINE static bool NVIC_GetEnableIRQ(IRQn_Type IRQn) {
-  return TEST(NVIC->ISER[uint32_t(IRQn) >> 5], uint32_t(IRQn) & 0x1F);
-}
-
-FORCE_INLINE static bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return NVIC_GetEnableIRQ(TIMER0_IRQn); // Check if interrupt is enabled or not
-    case MF_TIMER_TEMP: return NVIC_GetEnableIRQ(TIMER1_IRQn); // Check if interrupt is enabled or not
-  }
-  return false;
-}
-
-FORCE_INLINE static void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: SBI(STEP_TIMER_PTR->IR, SBIT_CNTEN); break;
-    case MF_TIMER_TEMP: SBI(TEMP_TIMER_PTR->IR, SBIT_CNTEN); break;
-  }
-}
-
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.cpp b/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.cpp
deleted file mode 100644
index e714c3c..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-// adapted from  I2C/master/master.c example
-//   https://www-users.cs.york.ac.uk/~pcc/MCP/HAPR-Course-web/CMSIS/examples/html/master_8c_source.html
-
-#ifdef TARGET_LPC1768
-
-#include "../include/i2c_util.h"
-#include "../../../core/millis_t.h"
-
-extern int millis();
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-//////////////////////////////////////////////////////////////////////////////////////
-
-#define I2CDEV_S_ADDR   0x78  // From SSD1306 (actual address is 0x3C - shift left 1 with LSB set to 0 to indicate write)
-
-// Send slave address and write bit
-uint8_t u8g_i2c_start(const uint8_t sla) {
-  // Sometimes TX data ACK or NAK status is returned.  That mean the start state didn't
-  // happen which means only the value of the slave address was send.  Keep looping until
-  // the slave address and write bit are actually sent.
-  do{
-    _I2C_Stop(I2CDEV_M); // output stop state on I2C bus
-    _I2C_Start(I2CDEV_M); // output start state on I2C bus
-    while ((I2C_status != I2C_I2STAT_M_TX_START)
-        && (I2C_status != I2C_I2STAT_M_TX_RESTART)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_NACK));  //wait for start to be asserted
-
-    LPC_I2C1->I2CONCLR = I2C_I2CONCLR_STAC; // clear start state before tansmitting slave address
-    LPC_I2C1->I2DAT = I2CDEV_S_ADDR & I2C_I2DAT_BITMASK; // transmit slave address & write bit
-    LPC_I2C1->I2CONSET = I2C_I2CONSET_AA;
-    LPC_I2C1->I2CONCLR = I2C_I2CONCLR_SIC;
-    while ((I2C_status != I2C_I2STAT_M_TX_SLAW_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_SLAW_NACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_ACK)
-        && (I2C_status != I2C_I2STAT_M_TX_DAT_NACK));  //wait for slaw to finish
-  }while ( (I2C_status == I2C_I2STAT_M_TX_DAT_ACK) ||  (I2C_status == I2C_I2STAT_M_TX_DAT_NACK));
-  return 1;
-}
-
-void u8g_i2c_init(const uint8_t clock_option) {
-  configure_i2c(clock_option);
-  u8g_i2c_start(0); // Send slave address and write bit
-}
-
-uint8_t u8g_i2c_send_byte(uint8_t data) {
-  #define I2C_TIMEOUT 3
-  LPC_I2C1->I2DAT = data & I2C_I2DAT_BITMASK; // transmit data
-  LPC_I2C1->I2CONSET = I2C_I2CONSET_AA;
-  LPC_I2C1->I2CONCLR = I2C_I2CONCLR_SIC;
-  const millis_t timeout = millis() + I2C_TIMEOUT;
-  while ((I2C_status != I2C_I2STAT_M_TX_DAT_ACK) && (I2C_status != I2C_I2STAT_M_TX_DAT_NACK) && PENDING(millis(), timeout));  // wait for xmit to finish
-  // had hangs with SH1106 so added time out - have seen temporary screen corruption when this happens
-  return 1;
-}
-
-void u8g_i2c_stop() {
-}
-
-#ifdef __cplusplus
-  }
-#endif
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.h b/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.h
deleted file mode 100644
index 2d976c9..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_I2C_routines.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-void u8g_i2c_init(const uint8_t clock_options);
-//uint8_t u8g_i2c_wait(uint8_t mask, uint8_t pos);
-uint8_t u8g_i2c_start(uint8_t sla);
-uint8_t u8g_i2c_send_byte(uint8_t data);
-void u8g_i2c_stop();
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_defines.h b/Marlin/src/HAL/LPC1768/u8g/LCD_defines.h
deleted file mode 100644
index d226003..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_defines.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * LPC1768 LCD-specific defines
- */
-
-// The following are optional depending on the platform.
-
-// definitions of HAL specific com and device drivers.
-uint8_t u8g_com_HAL_LPC1768_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr);
-uint8_t u8g_com_HAL_LPC1768_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr);
-uint8_t u8g_com_HAL_LPC1768_ST7920_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr);
-uint8_t u8g_com_HAL_LPC1768_ST7920_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr);
-uint8_t u8g_com_HAL_LPC1768_ssd_hw_i2c_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr);
-
-
-// connect U8g com generic com names to the desired driver
-#define U8G_COM_HW_SPI u8g_com_HAL_LPC1768_hw_spi_fn  // use LPC1768 specific hardware SPI routine
-#define U8G_COM_SW_SPI u8g_com_HAL_LPC1768_sw_spi_fn  // use LPC1768 specific software SPI routine
-#define U8G_COM_ST7920_HW_SPI u8g_com_HAL_LPC1768_ST7920_hw_spi_fn
-#define U8G_COM_ST7920_SW_SPI u8g_com_HAL_LPC1768_ST7920_sw_spi_fn
-#define U8G_COM_SSD_I2C u8g_com_HAL_LPC1768_ssd_hw_i2c_fn
-
-// let these default for now
-#define U8G_COM_PARALLEL u8g_com_null_fn
-#define U8G_COM_T6963 u8g_com_null_fn
-#define U8G_COM_FAST_PARALLEL u8g_com_null_fn
-#define U8G_COM_UC_I2C u8g_com_null_fn
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_delay.h b/Marlin/src/HAL/LPC1768/u8g/LCD_delay.h
deleted file mode 100644
index 0b9e2b4..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_delay.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * LCD delay routines - used by all the drivers.
- *
- * These are based on the LPC1768 routines.
- *
- * Couldn't just call exact copies because the overhead
- * results in a one microsecond delay taking about 4ÂµS.
- */
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-void U8g_delay(int msec);
-void u8g_MicroDelay();
-void u8g_10MicroDelay();
-
-#ifdef __cplusplus
-  }
-#endif
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.c b/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.c
deleted file mode 100644
index 466fc80..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.c
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Low level pin manipulation routines - used by all the drivers.
- *
- * These are based on the LPC1768 pinMode, digitalRead & digitalWrite routines.
- *
- * Couldn't just call exact copies because the overhead killed the LCD update speed
- * With an intermediate level the softspi was running in the 10-20kHz range which
- * resulted in using about about 25% of the CPU's time.
- */
-
-#ifdef TARGET_LPC1768
-
-#include <LPC17xx.h>
-#include <lpc17xx_pinsel.h>
-#include "../../../core/macros.h"
-//#include <pinmapping.h>
-
-#define LPC_PORT_OFFSET         (0x0020)
-#define LPC_PIN(pin)            (1UL << pin)
-#define LPC_GPIO(port)          ((volatile LPC_GPIO_TypeDef *)(LPC_GPIO0_BASE + LPC_PORT_OFFSET * port))
-
-#define INPUT 0
-#define OUTPUT 1
-#define INPUT_PULLUP 2
-
-uint8_t LPC1768_PIN_PORT(const uint8_t pin);
-uint8_t LPC1768_PIN_PIN(const uint8_t pin);
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-// I/O functions
-// As defined by Arduino INPUT(0x0), OUTPUT(0x1), INPUT_PULLUP(0x2)
-void pinMode_LCD(uint8_t pin, uint8_t mode) {
-  #define LPC1768_PIN_PORT(pin) ((uint8_t)((pin >> 5) & 0b111))
-  #define LPC1768_PIN_PIN(pin) ((uint8_t)(pin & 0b11111))
-  PINSEL_CFG_Type config = { LPC1768_PIN_PORT(pin),
-                             LPC1768_PIN_PIN(pin),
-                             PINSEL_FUNC_0,
-                             PINSEL_PINMODE_TRISTATE,
-                             PINSEL_PINMODE_NORMAL };
-  switch (mode) {
-    case INPUT:
-      LPC_GPIO(LPC1768_PIN_PORT(pin))->FIODIR &= ~LPC_PIN(LPC1768_PIN_PIN(pin));
-      PINSEL_ConfigPin(&config);
-      break;
-    case OUTPUT:
-      LPC_GPIO(LPC1768_PIN_PORT(pin))->FIODIR |=  LPC_PIN(LPC1768_PIN_PIN(pin));
-      PINSEL_ConfigPin(&config);
-      break;
-    case INPUT_PULLUP:
-      LPC_GPIO(LPC1768_PIN_PORT(pin))->FIODIR &= ~LPC_PIN(LPC1768_PIN_PIN(pin));
-      config.Pinmode = PINSEL_PINMODE_PULLUP;
-      PINSEL_ConfigPin(&config);
-      break;
-    default: break;
-  }
-}
-
-void u8g_SetPinOutput(uint8_t internal_pin_number) {
-   pinMode_LCD(internal_pin_number, 1);  // OUTPUT
-}
-
-void u8g_SetPinInput(uint8_t internal_pin_number) {
-   pinMode_LCD(internal_pin_number, 0);  // INPUT
-}
-
-void u8g_SetPinLevel(uint8_t  pin, uint8_t  pin_status) {
-  #define LPC1768_PIN_PORT(pin) ((uint8_t)((pin >> 5) & 0b111))
-  #define LPC1768_PIN_PIN(pin) ((uint8_t)(pin & 0b11111))
-  if (pin_status)
-    LPC_GPIO(LPC1768_PIN_PORT(pin))->FIOSET = LPC_PIN(LPC1768_PIN_PIN(pin));
-  else
-    LPC_GPIO(LPC1768_PIN_PORT(pin))->FIOCLR = LPC_PIN(LPC1768_PIN_PIN(pin));
-}
-
-uint8_t u8g_GetPinLevel(uint8_t pin) {
-  #define LPC1768_PIN_PORT(pin) ((uint8_t)((pin >> 5) & 0b111))
-  #define LPC1768_PIN_PIN(pin) ((uint8_t)(pin & 0b11111))
-  return (uint32_t)LPC_GPIO(LPC1768_PIN_PORT(pin))->FIOPIN & LPC_PIN(LPC1768_PIN_PIN(pin)) ? 1 : 0;
-}
-
-#ifdef __cplusplus
-  }
-#endif
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.h b/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.h
deleted file mode 100644
index d60d93d..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/LCD_pin_routines.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Low level pin manipulation routines - used by all the drivers.
- *
- * These are based on the LPC1768 pinMode, digitalRead & digitalWrite routines.
- *
- * Couldn't just call exact copies because the overhead killed the LCD update speed
- * With an intermediate level the softspi was running in the 10-20kHz range which
- * resulted in using about about 25% of the CPU's time.
- */
-
-void u8g_SetPinOutput(uint8_t internal_pin_number);
-void u8g_SetPinInput(uint8_t internal_pin_number);
-void u8g_SetPinLevel(uint8_t  pin, uint8_t  pin_status);
-uint8_t u8g_GetPinLevel(uint8_t pin);
diff --git a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_hw_spi.cpp b/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_hw_spi.cpp
deleted file mode 100644
index 0118f92..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_hw_spi.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_msp430_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include <U8glib-HAL.h>
-#include "../../shared/HAL_SPI.h"
-
-#ifndef LCD_SPI_SPEED
-  #ifdef SD_SPI_SPEED
-    #define LCD_SPI_SPEED SD_SPI_SPEED    // Assume SPI speed shared with SD
-  #else
-    #define LCD_SPI_SPEED SPI_FULL_SPEED  // Use full speed if SD speed is not supplied
-  #endif
-#endif
-
-uint8_t u8g_com_HAL_LPC1768_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_INIT:
-      u8g_SetPILevel(u8g, U8G_PI_CS, 1);
-      u8g_SetPILevel(u8g, U8G_PI_A0, 1);
-      u8g_SetPILevel(u8g, U8G_PI_RESET, 1);
-      u8g_SetPIOutput(u8g, U8G_PI_CS);
-      u8g_SetPIOutput(u8g, U8G_PI_A0);
-      u8g_SetPIOutput(u8g, U8G_PI_RESET);
-      u8g_Delay(5);
-      spiBegin();
-      spiInit(LCD_SPI_SPEED);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g_SetPILevel(u8g, U8G_PI_A0, arg_val);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      u8g_SetPILevel(u8g, U8G_PI_CS, (arg_val ? 0 : 1));
-      break;
-
-    case U8G_COM_MSG_RESET:
-      u8g_SetPILevel(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      spiSend((uint8_t)arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          spiSend(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          spiSend(*ptr++);
-          arg_val--;
-        }
-      }
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_ssd_hw_i2c.cpp b/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_ssd_hw_i2c.cpp
deleted file mode 100644
index bf76eaf..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_ssd_hw_i2c.cpp
+++ /dev/null
@@ -1,198 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_arduino_ssd_i2c.c
- *
- * COM interface for Arduino (AND ATmega) and the SSDxxxx chip (SOLOMON) variant
- * I2C protocol
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * Special pin usage:
- * U8G_PI_I2C_OPTION additional options
- * U8G_PI_A0_STATE used to store the last value of the command/data register selection
- * U8G_PI_SET_A0   1: Signal request to update I2C device with new A0_STATE, 0: Do nothing, A0_STATE matches I2C device
- * U8G_PI_SCL    clock line (NOT USED)
- * U8G_PI_SDA    data line (NOT USED)
- *
- * U8G_PI_RESET    reset line (currently disabled, see below)
- *
- * Protocol:
- * SLA, Cmd/Data Selection, Arguments
- * The command/data register is selected by a special instruction byte, which is sent after SLA
- *
- * The continue bit is always 0 so that a (re)start is equired for the change from cmd to/data mode
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include <U8glib-HAL.h>
-
-#define I2C_SLA         (0x3C*2)
-//#define I2C_CMD_MODE  0x080
-#define I2C_CMD_MODE    0x000
-#define I2C_DATA_MODE   0x040
-
-uint8_t u8g_com_ssd_I2C_start_sequence(u8g_t *u8g) {
-  /* are we requested to set the a0 state? */
-  if (u8g->pin_list[U8G_PI_SET_A0] == 0) return 1;
-
-  /* setup bus, might be a repeated start */
-  if (u8g_i2c_start(I2C_SLA) == 0) return 0;
-  if (u8g->pin_list[U8G_PI_A0_STATE] == 0) {
-    if (u8g_i2c_send_byte(I2C_CMD_MODE) == 0) return 0;
-  }
-  else if (u8g_i2c_send_byte(I2C_DATA_MODE) == 0)
-    return 0;
-
-  u8g->pin_list[U8G_PI_SET_A0] = 0;
-  return 1;
-}
-
-uint8_t u8g_com_HAL_LPC1768_ssd_hw_i2c_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      //u8g_com_arduino_digital_write(u8g, U8G_PI_SCL, HIGH);
-      //u8g_com_arduino_digital_write(u8g, U8G_PI_SDA, HIGH);
-      //u8g->pin_list[U8G_PI_A0_STATE] = 0;       /* initial RS state: unknown mode */
-
-      u8g_i2c_init(u8g->pin_list[U8G_PI_I2C_OPTION]);
-      u8g_com_ssd_I2C_start_sequence(u8g);
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-      /* Currently disabled, but it could be enable. Previous restrictions have been removed */
-      /* u8g_com_arduino_digital_write(u8g, U8G_PI_RESET, arg_val); */
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      u8g->pin_list[U8G_PI_A0_STATE] = 0;
-      u8g->pin_list[U8G_PI_SET_A0] = 1;   /* force a0 to set again, also forces start condition */
-      if (arg_val == 0 ) {
-        /* disable chip, send stop condition */
-        u8g_i2c_stop();
-      }
-      else {
-        /* enable, do nothing: any byte writing will trigger the i2c start */
-      }
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      //u8g->pin_list[U8G_PI_SET_A0] = 1;
-      if (u8g_com_ssd_I2C_start_sequence(u8g) == 0) {
-        u8g_i2c_stop();
-        return 0;
-      }
-
-      if (u8g_i2c_send_byte(arg_val) == 0) {
-        u8g_i2c_stop();
-        return 0;
-      }
-      // u8g_i2c_stop();
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        //u8g->pin_list[U8G_PI_SET_A0] = 1;
-        if (u8g_com_ssd_I2C_start_sequence(u8g) == 0) {
-         u8g_i2c_stop();
-         return 0;
-        }
-
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          if (u8g_i2c_send_byte(*ptr++) == 0) {
-            u8g_i2c_stop();
-            return 0;
-          }
-          arg_val--;
-        }
-      }
-      // u8g_i2c_stop();
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ_P: {
-        //u8g->pin_list[U8G_PI_SET_A0] = 1;
-        if (u8g_com_ssd_I2C_start_sequence(u8g) == 0) {
-          u8g_i2c_stop();
-          return 0;
-        }
-
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          if (u8g_i2c_send_byte(u8g_pgm_read(ptr)) == 0)
-            return 0;
-          ptr++;
-          arg_val--;
-        }
-      }
-      // u8g_i2c_stop();
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g->pin_list[U8G_PI_A0_STATE] = arg_val;
-      u8g->pin_list[U8G_PI_SET_A0] = 1;   /* force a0 to set again */
-      break;
-
-  } // switch
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_hw_spi.cpp b/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_hw_spi.cpp
deleted file mode 100644
index ce7b338..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_hw_spi.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_LPC1768_st7920_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB
-
-#include <U8glib-HAL.h>
-#include "../../shared/HAL_SPI.h"
-#include "../../shared/Delay.h"
-
-void spiBegin();
-void spiInit(uint8_t spiRate);
-void spiSend(uint8_t b);
-void spiSend(const uint8_t *buf, size_t n);
-
-static uint8_t rs_last_state = 255;
-
-static void u8g_com_LPC1768_st7920_write_byte_hw_spi(uint8_t rs, uint8_t val) {
-
-  if (rs != rs_last_state) {      // Time to send a command/data byte
-    rs_last_state = rs;
-    spiSend(rs ? 0x0FA : 0x0F8);  // Send data or command
-    DELAY_US(40);                 // Give the controller some time: 20 is bad, 30 is OK, 40 is safe
-  }
-
-  spiSend(val & 0xF0);
-  spiSend(val << 4);
-}
-
-uint8_t u8g_com_HAL_LPC1768_ST7920_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      u8g_SetPILevel(u8g, U8G_PI_CS, 0);
-      u8g_SetPIOutput(u8g, U8G_PI_CS);
-      u8g_Delay(5);
-      spiBegin();
-      spiInit(SPI_EIGHTH_SPEED);            // ST7920 max speed is about 1.1 MHz
-      u8g->pin_list[U8G_PI_A0_STATE] = 0;   // initial RS state: command mode
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-      u8g_SetPILevel(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                   // Define cmd (arg_val = 0) or data mode (arg_val = 1)
-      u8g->pin_list[U8G_PI_A0_STATE] = arg_val;
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      u8g_SetPILevel(u8g, U8G_PI_CS, arg_val);  // Note: the ST7920 has an active high chip-select
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      u8g_com_LPC1768_st7920_write_byte_hw_spi(u8g->pin_list[U8G_PI_A0_STATE], arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_LPC1768_st7920_write_byte_hw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_LPC1768_st7920_write_byte_hw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB
-
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_sw_spi.cpp b/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_sw_spi.cpp
deleted file mode 100644
index e159eba..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_st7920_sw_spi.cpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_st7920_hw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2011, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if IS_U8GLIB_ST7920
-
-#include <U8glib-HAL.h>
-#include <SoftwareSPI.h>
-#include "../../shared/Delay.h"
-#include "../../shared/HAL_SPI.h"
-
-#ifndef LCD_SPI_SPEED
-  #define LCD_SPI_SPEED SPI_EIGHTH_SPEED  // About 1 MHz
-#endif
-
-static pin_t SCK_pin_ST7920_HAL, MOSI_pin_ST7920_HAL_HAL;
-static uint8_t SPI_speed = 0;
-
-static void u8g_com_LPC1768_st7920_write_byte_sw_spi(uint8_t rs, uint8_t val) {
-  static uint8_t rs_last_state = 255;
-  if (rs != rs_last_state) {
-    // Transfer Data (FA) or Command (F8)
-    swSpiTransfer(rs ? 0x0FA : 0x0F8, SPI_speed, SCK_pin_ST7920_HAL, -1, MOSI_pin_ST7920_HAL_HAL);
-    rs_last_state = rs;
-    DELAY_US(40); // Give the controller time to process the data: 20 is bad, 30 is OK, 40 is safe
-  }
-  swSpiTransfer(val & 0x0F0, SPI_speed, SCK_pin_ST7920_HAL, -1, MOSI_pin_ST7920_HAL_HAL);
-  swSpiTransfer(val << 4, SPI_speed, SCK_pin_ST7920_HAL, -1, MOSI_pin_ST7920_HAL_HAL);
-}
-
-uint8_t u8g_com_HAL_LPC1768_ST7920_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      SCK_pin_ST7920_HAL = u8g->pin_list[U8G_PI_SCK];
-      MOSI_pin_ST7920_HAL_HAL = u8g->pin_list[U8G_PI_MOSI];
-
-      u8g_SetPIOutput(u8g, U8G_PI_CS);
-      u8g_SetPIOutput(u8g, U8G_PI_SCK);
-      u8g_SetPIOutput(u8g, U8G_PI_MOSI);
-      u8g_Delay(5);
-
-      SPI_speed = swSpiInit(LCD_SPI_SPEED, SCK_pin_ST7920_HAL, MOSI_pin_ST7920_HAL_HAL);
-
-      u8g_SetPILevel(u8g, U8G_PI_CS, 0);
-      u8g_SetPILevel(u8g, U8G_PI_SCK, 0);
-      u8g_SetPILevel(u8g, U8G_PI_MOSI, 0);
-
-      u8g->pin_list[U8G_PI_A0_STATE] = 0;       /* initial RS state: command mode */
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-       if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPILevel(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g->pin_list[U8G_PI_A0_STATE] = arg_val;
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_CS]) u8g_SetPILevel(u8g, U8G_PI_CS, arg_val);  //note: the st7920 has an active high chip select
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      u8g_com_LPC1768_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_LPC1768_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t*) arg_ptr;
-        while (arg_val > 0) {
-          u8g_com_LPC1768_st7920_write_byte_sw_spi(u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-  }
-  return 1;
-}
-
-#endif // IS_U8GLIB_ST7920
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_sw_spi.cpp b/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_sw_spi.cpp
deleted file mode 100644
index f116a9b..0000000
--- a/Marlin/src/HAL/LPC1768/u8g/u8g_com_HAL_LPC1768_sw_spi.cpp
+++ /dev/null
@@ -1,209 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Based on u8g_com_std_sw_spi.c
- *
- * Universal 8bit Graphics Library
- *
- * Copyright (c) 2015, olikraus@gmail.com
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this list
- *    of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice, this
- *    list of conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef TARGET_LPC1768
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_U8GLIB && !IS_U8GLIB_ST7920
-
-#include <SoftwareSPI.h>
-#include "../../shared/HAL_SPI.h"
-
-#ifndef LCD_SPI_SPEED
-  #define LCD_SPI_SPEED SPI_QUARTER_SPEED  // About 2 MHz
-#endif
-
-#include <Arduino.h>
-#include <algorithm>
-#include <LPC17xx.h>
-#include <gpio.h>
-
-#include <U8glib-HAL.h>
-
-uint8_t swSpiTransfer_mode_0(uint8_t b, const uint8_t spi_speed, const pin_t sck_pin, const pin_t miso_pin, const pin_t mosi_pin ) {
-
-  LOOP_L_N(i, 8) {
-    if (spi_speed == 0) {
-      LPC176x::gpio_set(mosi_pin, !!(b & 0x80));
-      LPC176x::gpio_set(sck_pin, HIGH);
-      b <<= 1;
-      if (miso_pin >= 0 && LPC176x::gpio_get(miso_pin)) b |= 1;
-      LPC176x::gpio_set(sck_pin, LOW);
-    }
-    else {
-      const uint8_t state = (b & 0x80) ? HIGH : LOW;
-      LOOP_L_N(j, spi_speed)
-        LPC176x::gpio_set(mosi_pin, state);
-
-      LOOP_L_N(j, spi_speed + (miso_pin >= 0 ? 0 : 1))
-        LPC176x::gpio_set(sck_pin, HIGH);
-
-      b <<= 1;
-      if (miso_pin >= 0 && LPC176x::gpio_get(miso_pin)) b |= 1;
-
-      LOOP_L_N(j, spi_speed)
-        LPC176x::gpio_set(sck_pin, LOW);
-    }
-  }
-
-  return b;
-}
-
-uint8_t swSpiTransfer_mode_3(uint8_t b, const uint8_t spi_speed, const pin_t sck_pin, const pin_t miso_pin, const pin_t mosi_pin ) {
-
-  LOOP_L_N(i, 8) {
-    const uint8_t state = (b & 0x80) ? HIGH : LOW;
-    if (spi_speed == 0) {
-      LPC176x::gpio_set(sck_pin, LOW);
-      LPC176x::gpio_set(mosi_pin, state);
-      LPC176x::gpio_set(mosi_pin, state);  // need some setup time
-      LPC176x::gpio_set(sck_pin, HIGH);
-    }
-    else {
-      LOOP_L_N(j, spi_speed + (miso_pin >= 0 ? 0 : 1))
-        LPC176x::gpio_set(sck_pin, LOW);
-
-      LOOP_L_N(j, spi_speed)
-        LPC176x::gpio_set(mosi_pin, state);
-
-      LOOP_L_N(j, spi_speed)
-        LPC176x::gpio_set(sck_pin, HIGH);
-    }
-    b <<= 1;
-    if (miso_pin >= 0 && LPC176x::gpio_get(miso_pin)) b |= 1;
-  }
-
-  return b;
-}
-
-static uint8_t SPI_speed = 0;
-
-static void u8g_sw_spi_HAL_LPC1768_shift_out(uint8_t dataPin, uint8_t clockPin, uint8_t val) {
-  #if EITHER(FYSETC_MINI_12864, MKS_MINI_12864)
-    swSpiTransfer_mode_3(val, SPI_speed, clockPin, -1, dataPin);
-  #else
-    swSpiTransfer_mode_0(val, SPI_speed, clockPin, -1, dataPin);
-  #endif
-}
-
-uint8_t u8g_com_HAL_LPC1768_sw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr) {
-  switch (msg) {
-    case U8G_COM_MSG_INIT:
-      u8g_SetPIOutput(u8g, U8G_PI_SCK);
-      u8g_SetPIOutput(u8g, U8G_PI_MOSI);
-      u8g_SetPIOutput(u8g, U8G_PI_CS);
-      u8g_SetPIOutput(u8g, U8G_PI_A0);
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPIOutput(u8g, U8G_PI_RESET);
-      SPI_speed = swSpiInit(LCD_SPI_SPEED, u8g->pin_list[U8G_PI_SCK], u8g->pin_list[U8G_PI_MOSI]);
-      u8g_SetPILevel(u8g, U8G_PI_SCK, 0);
-      u8g_SetPILevel(u8g, U8G_PI_MOSI, 0);
-      break;
-
-    case U8G_COM_MSG_STOP:
-      break;
-
-    case U8G_COM_MSG_RESET:
-      if (U8G_PIN_NONE != u8g->pin_list[U8G_PI_RESET]) u8g_SetPILevel(u8g, U8G_PI_RESET, arg_val);
-      break;
-
-    case U8G_COM_MSG_CHIP_SELECT:
-      #if EITHER(FYSETC_MINI_12864, MKS_MINI_12864)  // LCD SPI is running mode 3 while SD card is running mode 0
-        if (arg_val) {                               //   SCK idle state needs to be set to the proper idle state before
-                                                     //   the next chip select goes active
-          u8g_SetPILevel(u8g, U8G_PI_SCK, 1);        // Set SCK to mode 3 idle state before CS goes active
-          u8g_SetPILevel(u8g, U8G_PI_CS, LOW);
-        }
-        else {
-          u8g_SetPILevel(u8g, U8G_PI_CS, HIGH);
-          u8g_SetPILevel(u8g, U8G_PI_SCK, 0);  // Set SCK to mode 0 idle state after CS goes inactive
-        }
-      #else
-        u8g_SetPILevel(u8g, U8G_PI_CS, !arg_val);
-      #endif
-      break;
-
-    case U8G_COM_MSG_WRITE_BYTE:
-      u8g_sw_spi_HAL_LPC1768_shift_out(u8g->pin_list[U8G_PI_MOSI], u8g->pin_list[U8G_PI_SCK], arg_val);
-      break;
-
-    case U8G_COM_MSG_WRITE_SEQ: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          u8g_sw_spi_HAL_LPC1768_shift_out(u8g->pin_list[U8G_PI_MOSI], u8g->pin_list[U8G_PI_SCK], *ptr++);
-          arg_val--;
-        }
-      }
-      break;
-
-      case U8G_COM_MSG_WRITE_SEQ_P: {
-        uint8_t *ptr = (uint8_t *)arg_ptr;
-        while (arg_val > 0) {
-          u8g_sw_spi_HAL_LPC1768_shift_out(u8g->pin_list[U8G_PI_MOSI], u8g->pin_list[U8G_PI_SCK], u8g_pgm_read(ptr));
-          ptr++;
-          arg_val--;
-        }
-      }
-      break;
-
-    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
-      u8g_SetPILevel(u8g, U8G_PI_A0, arg_val);
-      break;
-  }
-  return 1;
-}
-
-#endif // HAS_MARLINUI_U8GLIB && !IS_U8GLIB_ST7920
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/upload_extra_script.py b/Marlin/src/HAL/LPC1768/upload_extra_script.py
deleted file mode 100755
index 3e23c63..0000000
--- a/Marlin/src/HAL/LPC1768/upload_extra_script.py
+++ /dev/null
@@ -1,135 +0,0 @@
-#
-# upload_extra_script.py
-# set the output_port
-#  if target_filename is found then that drive is used
-#  else if target_drive is found then that drive is used
-#
-from __future__ import print_function
-
-import pioutil
-if pioutil.is_pio_build():
-
-	target_filename = "FIRMWARE.CUR"
-	target_drive = "REARM"
-
-	import platform
-
-	current_OS = platform.system()
-	Import("env")
-
-	def print_error(e):
-		print('\nUnable to find destination disk (%s)\n' \
-			  'Please select it in platformio.ini using the upload_port keyword ' \
-			  '(https://docs.platformio.org/en/latest/projectconf/section_env_upload.html) ' \
-			  'or copy the firmware (.pio/build/%s/firmware.bin) manually to the appropriate disk\n' \
-			  %(e, env.get('PIOENV')))
-
-	def before_upload(source, target, env):
-		try:
-			from pathlib import Path
-  			#
-			# Find a disk for upload
-			#
-			upload_disk = 'Disk not found'
-			target_file_found = False
-			target_drive_found = False
-			if current_OS == 'Windows':
-				#
-				# platformio.ini will accept this for a Windows upload port designation: 'upload_port = L:'
-				#   Windows - doesn't care about the disk's name, only cares about the drive letter
-				import subprocess,string
-				from ctypes import windll
-				from pathlib import PureWindowsPath
-
-				# getting list of drives
-				# https://stackoverflow.com/questions/827371/is-there-a-way-to-list-all-the-available-drive-letters-in-python
-				drives = []
-				bitmask = windll.kernel32.GetLogicalDrives()
-				for letter in string.ascii_uppercase:
-					if bitmask & 1:
-						drives.append(letter)
-					bitmask >>= 1
-
-				for drive in drives:
-					final_drive_name = drive + ':'
-					# print ('disc check: {}'.format(final_drive_name))
-					try:
-						volume_info = str(subprocess.check_output('cmd /C dir ' + final_drive_name, stderr=subprocess.STDOUT))
-					except Exception as e:
-						print ('error:{}'.format(e))
-						continue
-					else:
-						if target_drive in volume_info and not target_file_found:  # set upload if not found target file yet
-							target_drive_found = True
-							upload_disk = PureWindowsPath(final_drive_name)
-						if target_filename in volume_info:
-							if not target_file_found:
-								upload_disk = PureWindowsPath(final_drive_name)
-							target_file_found = True
-
-			elif current_OS == 'Linux':
-				#
-				# platformio.ini will accept this for a Linux upload port designation: 'upload_port = /media/media_name/drive'
-				#
-				import getpass
-				user = getpass.getuser()
-				mpath = Path('media', user)
-				drives = [ x for x in mpath.iterdir() if x.is_dir() ]
-				if target_drive in drives:  # If target drive is found, use it.
-					target_drive_found = True
-					upload_disk = mpath / target_drive
-				else:
-					for drive in drives:
-						try:
-							fpath = mpath / drive
-							files = [ x for x in fpath.iterdir() if x.is_file() ]
-						except:
-							continue
-						else:
-							if target_filename in files:
-								upload_disk = mpath / drive
-								target_file_found = True
-								break
-				#
-				# set upload_port to drive if found
-				#
-
-				if target_file_found or target_drive_found:
-					env.Replace(
-						UPLOAD_FLAGS="-P$UPLOAD_PORT"
-					)
-
-			elif current_OS == 'Darwin':  # MAC
-				#
-				# platformio.ini will accept this for a OSX upload port designation: 'upload_port = /media/media_name/drive'
-				#
-				dpath = Path('/Volumes')  # human readable names
-				drives = [ x for x in dpath.iterdir() ]
-				if target_drive in drives and not target_file_found:  # set upload if not found target file yet
-					target_drive_found = True
-					upload_disk = dpath / target_drive
-				for drive in drives:
-					try:
-						fpath = dpath / drive   # will get an error if the drive is protected
-						files = [ x for x in fpath.iterdir() ]
-					except:
-						continue
-					else:
-						if target_filename in files:
-							if not target_file_found:
-								upload_disk = dpath / drive
-							target_file_found = True
-
-			#
-			# Set upload_port to drive if found
-			#
-			if target_file_found or target_drive_found:
-				env.Replace(UPLOAD_PORT=str(upload_disk))
-				print('\nUpload disk: ', upload_disk, '\n')
-			else:
-				print_error('Autodetect Error')
-
-		except Exception as e:
-			print_error(str(e))
-
-	env.AddPreAction("upload", before_upload)
diff --git a/Marlin/src/HAL/LPC1768/usb_serial.cpp b/Marlin/src/HAL/LPC1768/usb_serial.cpp
deleted file mode 100644
index 3c1fce5..0000000
--- a/Marlin/src/HAL/LPC1768/usb_serial.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef TARGET_LPC1768
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if ENABLED(EMERGENCY_PARSER)
-
-#include "../../feature/e_parser.h"
-
-EmergencyParser::State emergency_state;
-
-bool CDC_RecvCallback(const char c) {
-  emergency_parser.update(emergency_state, c);
-  return true;
-}
-
-#endif // EMERGENCY_PARSER
-#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/win_usb_driver/lpc176x_usb_driver.inf b/Marlin/src/HAL/LPC1768/win_usb_driver/lpc176x_usb_driver.inf
deleted file mode 100644
index 4732eb8..0000000
--- a/Marlin/src/HAL/LPC1768/win_usb_driver/lpc176x_usb_driver.inf
+++ /dev/null
@@ -1,36 +0,0 @@
-[Version]
-Signature="$Windows NT$"
-Class=Ports
-ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}
-Provider=%PROVIDER%
-DriverVer =04/14/2008, 5.1.2600.5512
-
-[Manufacturer]
-%PROVIDER%=DeviceList,ntamd64
-
-
-[DeviceList]
-%DESCRIPTION%=LPC1768USB, USB\VID_1D50&PID_6029&MI_00
-
-[DeviceList.ntamd64]
-%DESCRIPTION%=LPC1768USB, USB\VID_1D50&PID_6029&MI_00
-
-
-[LPC1768USB]
-include=mdmcpq.inf
-CopyFiles=FakeModemCopyFileSection
-AddReg=LowerFilterAddReg,SerialPropPageAddReg
-
-[LPC1768USB.Services]
-include=mdmcpq.inf
-AddService=usbser, 0x00000002, LowerFilter_Service_Inst
-
-[SerialPropPageAddReg]
-HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"
-
-
-[Strings]
-PROVIDER   = "marlinfw.org"
-DRIVER.SVC = "Marlin USB Driver"
-DESCRIPTION= "Marlin USB Serial"
-COMPOSITE  = "Marlin USB VCOM"
\ No newline at end of file
diff --git a/Marlin/src/HAL/SAMD51/HAL.cpp b/Marlin/src/HAL/SAMD51/HAL.cpp
deleted file mode 100644
index bd1c98b..0000000
--- a/Marlin/src/HAL/SAMD51/HAL.cpp
+++ /dev/null
@@ -1,690 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __SAMD51__
-
-#include "../../inc/MarlinConfig.h"
-#include <Adafruit_ZeroDMA.h>
-#include <wiring_private.h>
-
-#ifdef ADAFRUIT_GRAND_CENTRAL_M4
-  #if USING_HW_SERIALUSB
-    DefaultSerial1 MSerial0(false, Serial);
-  #endif
-  #if USING_HW_SERIAL0
-    DefaultSerial2 MSerial1(false, Serial1);
-  #endif
-  #if USING_HW_SERIAL1
-    DefaultSerial3 MSerial2(false, Serial2);
-  #endif
-  #if USING_HW_SERIAL2
-    DefaultSerial4 MSerial3(false, Serial3);
-  #endif
-  #if USING_HW_SERIAL3
-    DefaultSerial5 MSerial4(false, Serial4);
-  #endif
-#endif
-
-#define GET_TEMP_0_ADC()          TERN(HAS_TEMP_ADC_0,        PIN_TO_ADC(TEMP_0_PIN),       -1)
-#define GET_TEMP_1_ADC()          TERN(HAS_TEMP_ADC_1,        PIN_TO_ADC(TEMP_1_PIN),       -1)
-#define GET_TEMP_2_ADC()          TERN(HAS_TEMP_ADC_2,        PIN_TO_ADC(TEMP_2_PIN),       -1)
-#define GET_TEMP_3_ADC()          TERN(HAS_TEMP_ADC_3,        PIN_TO_ADC(TEMP_3_PIN),       -1)
-#define GET_TEMP_4_ADC()          TERN(HAS_TEMP_ADC_4,        PIN_TO_ADC(TEMP_4_PIN),       -1)
-#define GET_TEMP_5_ADC()          TERN(HAS_TEMP_ADC_5,        PIN_TO_ADC(TEMP_5_PIN),       -1)
-#define GET_TEMP_6_ADC()          TERN(HAS_TEMP_ADC_6,        PIN_TO_ADC(TEMP_6_PIN),       -1)
-#define GET_TEMP_7_ADC()          TERN(HAS_TEMP_ADC_7,        PIN_TO_ADC(TEMP_7_PIN),       -1)
-#define GET_BED_ADC()             TERN(HAS_TEMP_ADC_BED,      PIN_TO_ADC(TEMP_BED_PIN),     -1)
-#define GET_CHAMBER_ADC()         TERN(HAS_TEMP_ADC_CHAMBER,  PIN_TO_ADC(TEMP_CHAMBER_PIN), -1)
-#define GET_PROBE_ADC()           TERN(HAS_TEMP_ADC_PROBE,    PIN_TO_ADC(TEMP_PROBE_PIN),   -1)
-#define GET_COOLER_ADC()          TERN(HAS_TEMP_ADC_COOLER,   PIN_TO_ADC(TEMP_COOLER_PIN),  -1)
-#define GET_BOARD_ADC()           TERN(HAS_TEMP_ADC_BOARD,    PIN_TO_ADC(TEMP_BOARD_PIN),   -1)
-#define GET_FILAMENT_WIDTH_ADC()  TERN(FILAMENT_WIDTH_SENSOR, PIN_TO_ADC(FILWIDTH_PIN),     -1)
-#define GET_BUTTONS_ADC()         TERN(HAS_ADC_BUTTONS,       PIN_TO_ADC(ADC_KEYPAD_PIN),   -1)
-#define GET_JOY_ADC_X()           TERN(HAS_JOY_ADC_X,         PIN_TO_ADC(JOY_X_PIN),        -1)
-#define GET_JOY_ADC_Y()           TERN(HAS_JOY_ADC_Y,         PIN_TO_ADC(JOY_Y_PIN),        -1)
-#define GET_JOY_ADC_Z()           TERN(HAS_JOY_ADC_Z,         PIN_TO_ADC(JOY_Z_PIN),        -1)
-
-#define IS_ADC_REQUIRED(n) ( \
-     GET_TEMP_0_ADC() == n || GET_TEMP_1_ADC() == n || GET_TEMP_2_ADC() == n || GET_TEMP_3_ADC() == n \
-  || GET_TEMP_4_ADC() == n || GET_TEMP_5_ADC() == n || GET_TEMP_6_ADC() == n || GET_TEMP_7_ADC() == n \
-  || GET_BED_ADC() == n \
-  || GET_CHAMBER_ADC() == n \
-  || GET_PROBE_ADC() == n \
-  || GET_COOLER_ADC() == n \
-  || GET_BOARD_ADC() == n \
-  || GET_FILAMENT_WIDTH_ADC() == n \
-  || GET_BUTTONS_ADC() == n \
-  || GET_JOY_ADC_X() == n || GET_JOY_ADC_Y() == n || GET_JOY_ADC_Z() == n \
-)
-
-#if IS_ADC_REQUIRED(0)
-  #define ADC0_IS_REQUIRED 1
-  #define FIRST_ADC     0
-#else
-  #define FIRST_ADC     1
-#endif
-#if IS_ADC_REQUIRED(1)
-  #define ADC1_IS_REQUIRED 1
-  #define LAST_ADC      1
-#else
-  #define LAST_ADC      0
-#endif
-#if ADC0_IS_REQUIRED || ADC1_IS_REQUIRED
-  #define ADC_IS_REQUIRED 1
-  #define DMA_IS_REQUIRED 1
-#endif
-
-enum ADCIndex {
-  #if GET_TEMP_0_ADC() == 0
-    TEMP_0,
-  #endif
-  #if GET_TEMP_1_ADC() == 0
-    TEMP_1,
-  #endif
-  #if GET_TEMP_2_ADC() == 0
-    TEMP_2,
-  #endif
-  #if GET_TEMP_3_ADC() == 0
-    TEMP_3,
-  #endif
-  #if GET_TEMP_4_ADC() == 0
-    TEMP_4,
-  #endif
-  #if GET_TEMP_5_ADC() == 0
-    TEMP_5,
-  #endif
-  #if GET_TEMP_6_ADC() == 0
-    TEMP_6,
-  #endif
-  #if GET_TEMP_7_ADC() == 0
-    TEMP_7,
-  #endif
-  #if GET_BED_ADC() == 0
-    TEMP_BED,
-  #endif
-  #if GET_CHAMBER_ADC() == 0
-    TEMP_CHAMBER,
-  #endif
-  #if GET_PROBE_ADC() == 0
-    TEMP_PROBE,
-  #endif
-  #if GET_COOLER_ADC() == 0
-    TEMP_COOLER,
-  #endif
-  #if GET_BOARD_ADC() == 0
-    TEMP_BOARD,
-  #endif
-  #if GET_FILAMENT_WIDTH_ADC() == 0
-    FILWIDTH,
-  #endif
-  #if GET_BUTTONS_ADC() == 0
-    ADC_KEY,
-  #endif
-  #if GET_JOY_ADC_X() == 0
-    JOY_X,
-  #endif
-  #if GET_JOY_ADC_Y() == 0
-    JOY_Y,
-  #endif
-  #if GET_JOY_ADC_Z() == 0
-    JOY_Z,
-  #endif
-  #if GET_TEMP_0_ADC() == 1
-    TEMP_0,
-  #endif
-  #if GET_TEMP_1_ADC() == 1
-    TEMP_1,
-  #endif
-  #if GET_TEMP_2_ADC() == 1
-    TEMP_2,
-  #endif
-  #if GET_TEMP_3_ADC() == 1
-    TEMP_3,
-  #endif
-  #if GET_TEMP_4_ADC() == 1
-    TEMP_4,
-  #endif
-  #if GET_TEMP_5_ADC() == 1
-    TEMP_5,
-  #endif
-  #if GET_TEMP_6_ADC() == 1
-    TEMP_6,
-  #endif
-  #if GET_TEMP_7_ADC() == 1
-    TEMP_7,
-  #endif
-  #if GET_BED_ADC() == 1
-    TEMP_BED,
-  #endif
-  #if GET_CHAMBER_ADC() == 1
-    TEMP_CHAMBER,
-  #endif
-  #if GET_PROBE_ADC() == 1
-    TEMP_PROBE,
-  #endif
-  #if GET_COOLER_ADC() == 1
-    TEMP_COOLER,
-  #endif
-  #if GET_BOARD_ADC() == 1
-    TEMP_BOARD,
-  #endif
-  #if GET_FILAMENT_WIDTH_ADC() == 1
-    FILWIDTH,
-  #endif
-  #if GET_BUTTONS_ADC() == 1
-    ADC_KEY,
-  #endif
-  #if GET_JOY_ADC_X() == 1
-    JOY_X,
-  #endif
-  #if GET_JOY_ADC_Y() == 1
-    JOY_Y,
-  #endif
-  #if GET_JOY_ADC_Z() == 1
-    JOY_Z,
-  #endif
-  ADC_COUNT
-};
-
-#if ENABLED(USE_WATCHDOG)
-
-  #define WDT_TIMEOUT_REG TERN(WATCHDOG_DURATION_8S, WDT_CONFIG_PER_CYC8192, WDT_CONFIG_PER_CYC4096) // 4 or 8 second timeout
-
-  void MarlinHAL::watchdog_init() {
-    // The low-power oscillator used by the WDT runs at 32,768 Hz with
-    // a 1:32 prescale, thus 1024 Hz, though probably not super precise.
-
-    // Setup WDT clocks
-    MCLK->APBAMASK.bit.OSC32KCTRL_ = true;
-    MCLK->APBAMASK.bit.WDT_ = true;
-    OSC32KCTRL->OSCULP32K.bit.EN1K = true;  // Enable out 1K (this is what WDT uses)
-
-    WDT->CTRLA.bit.ENABLE = false;          // Disable watchdog for config
-    SYNC(WDT->SYNCBUSY.bit.ENABLE);
-
-    WDT->INTENCLR.reg = WDT_INTENCLR_EW;    // Disable early warning interrupt
-    WDT->CONFIG.reg = WDT_TIMEOUT_REG;      // Set a 4s or 8s period for chip reset
-
-    hal.watchdog_refresh();
-
-    WDT->CTRLA.reg = WDT_CTRLA_ENABLE;      // Start watchdog now in normal mode
-    SYNC(WDT->SYNCBUSY.bit.ENABLE);
-  }
-
-  // Reset watchdog. MUST be called at least every 4 seconds after the
-  // first watchdog_init or SAMD will go into emergency procedures.
-  void MarlinHAL::watchdog_refresh() {
-    SYNC(WDT->SYNCBUSY.bit.CLEAR);        // Test first if previous is 'ongoing' to save time waiting for command execution
-    WDT->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
-  }
-
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-#if DMA_IS_REQUIRED
-
-  // Struct must be 32 bits aligned because of DMA accesses but fields needs to be 8 bits packed
-  typedef struct  __attribute__((aligned(4), packed)) {
-    ADC_INPUTCTRL_Type INPUTCTRL;
-  } HAL_DMA_DAC_Registers;    // DMA transferred registers
-
-#endif
-
-// ------------------------
-// Private Variables
-// ------------------------
-
-#if ADC_IS_REQUIRED
-
-  // Pins used by ADC inputs. Order must be ADC0 inputs first then ADC1
-  static constexpr uint8_t adc_pins[ADC_COUNT] = {
-    // ADC0 pins
-    #if GET_TEMP_0_ADC() == 0
-      TEMP_0_PIN,
-    #endif
-    #if GET_TEMP_1_ADC() == 0
-      TEMP_1_PIN,
-    #endif
-    #if GET_TEMP_2_ADC() == 0
-      TEMP_2_PIN,
-    #endif
-    #if GET_TEMP_3_ADC() == 0
-      TEMP_3_PIN,
-    #endif
-    #if GET_TEMP_4_ADC() == 0
-      TEMP_4_PIN,
-    #endif
-    #if GET_TEMP_5_ADC() == 0
-      TEMP_5_PIN,
-    #endif
-    #if GET_TEMP_6_ADC() == 0
-      TEMP_6_PIN,
-    #endif
-    #if GET_TEMP_7_ADC() == 0
-      TEMP_7_PIN,
-    #endif
-    #if GET_BED_ADC() == 0
-      TEMP_BED_PIN,
-    #endif
-    #if GET_CHAMBER_ADC() == 0
-      TEMP_CHAMBER_PIN,
-    #endif
-    #if GET_PROBE_ADC() == 0
-      TEMP_PROBE_PIN,
-    #endif
-    #if GET_COOLER_ADC() == 0
-      TEMP_COOLER_PIN,
-    #endif
-    #if GET_BOARD_ADC() == 0
-      TEMP_BOARD_PIN,
-    #endif
-    #if GET_FILAMENT_WIDTH_ADC() == 0
-      FILWIDTH_PIN,
-    #endif
-    #if GET_BUTTONS_ADC() == 0
-      ADC_KEYPAD_PIN,
-    #endif
-    #if GET_JOY_ADC_X() == 0
-      JOY_X_PIN,
-    #endif
-    #if GET_JOY_ADC_Y() == 0
-      JOY_Y_PIN,
-    #endif
-    #if GET_JOY_ADC_Z() == 0
-      JOY_Z_PIN,
-    #endif
-    // ADC1 pins
-    #if GET_TEMP_0_ADC() == 1
-      TEMP_0_PIN,
-    #endif
-    #if GET_TEMP_1_ADC() == 1
-      TEMP_1_PIN,
-    #endif
-    #if GET_TEMP_2_ADC() == 1
-      TEMP_2_PIN,
-    #endif
-    #if GET_TEMP_3_ADC() == 1
-      TEMP_3_PIN,
-    #endif
-    #if GET_TEMP_4_ADC() == 1
-      TEMP_4_PIN,
-    #endif
-    #if GET_TEMP_5_ADC() == 1
-      TEMP_5_PIN,
-    #endif
-    #if GET_TEMP_6_ADC() == 1
-      TEMP_6_PIN,
-    #endif
-    #if GET_TEMP_7_ADC() == 1
-      TEMP_7_PIN,
-    #endif
-    #if GET_BED_ADC() == 1
-      TEMP_BED_PIN,
-    #endif
-    #if GET_CHAMBER_ADC() == 1
-      TEMP_CHAMBER_PIN,
-    #endif
-    #if GET_PROBE_ADC() == 1
-      TEMP_PROBE_PIN,
-    #endif
-    #if GET_COOLER_ADC() == 1
-      TEMP_COOLER_PIN,
-    #endif
-    #if GET_BOARD_ADC() == 1
-      TEMP_BOARD_PIN,
-    #endif
-    #if GET_FILAMENT_WIDTH_ADC() == 1
-      FILWIDTH_PIN,
-    #endif
-    #if GET_BUTTONS_ADC() == 1
-      ADC_KEYPAD_PIN,
-    #endif
-    #if GET_JOY_ADC_X() == 1
-      JOY_X_PIN,
-    #endif
-    #if GET_JOY_ADC_Y() == 1
-      JOY_Y_PIN,
-    #endif
-    #if GET_JOY_ADC_Z() == 1
-      JOY_Z_PIN,
-    #endif
-  };
-
-  static uint16_t adc_results[ADC_COUNT];
-
-  #if ADC0_IS_REQUIRED
-    Adafruit_ZeroDMA adc0DMAProgram, adc0DMARead;
-
-    static constexpr HAL_DMA_DAC_Registers adc0_dma_regs_list[ADC_COUNT] = {
-      #if GET_TEMP_0_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_0_PIN) },
-      #endif
-      #if GET_TEMP_1_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_1_PIN) },
-      #endif
-      #if GET_TEMP_2_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_2_PIN) },
-      #endif
-      #if GET_TEMP_3_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_3_PIN) },
-      #endif
-      #if GET_TEMP_4_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_4_PIN) },
-      #endif
-      #if GET_TEMP_5_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_5_PIN) },
-      #endif
-      #if GET_TEMP_6_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_6_PIN) },
-      #endif
-      #if GET_TEMP_7_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_7_PIN) },
-      #endif
-      #if GET_BED_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_BED_PIN) },
-      #endif
-      #if GET_CHAMBER_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_CHAMBER_PIN) },
-      #endif
-      #if GET_PROBE_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_PROBE_PIN) },
-      #endif
-      #if GET_COOLER_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_COOLER_PIN) },
-      #endif
-      #if GET_BOARD_ADC() == 0
-        { PIN_TO_INPUTCTRL(TEMP_BOARD_PIN) },
-      #endif
-      #if GET_FILAMENT_WIDTH_ADC() == 0
-        { PIN_TO_INPUTCTRL(FILWIDTH_PIN) },
-      #endif
-      #if GET_BUTTONS_ADC() == 0
-        { PIN_TO_INPUTCTRL(ADC_KEYPAD_PIN) },
-      #endif
-      #if GET_JOY_ADC_X() == 0
-        { PIN_TO_INPUTCTRL(JOY_X_PIN) },
-      #endif
-      #if GET_JOY_ADC_Y() == 0
-        { PIN_TO_INPUTCTRL(JOY_Y_PIN) },
-      #endif
-      #if GET_JOY_ADC_Z() == 0
-        { PIN_TO_INPUTCTRL(JOY_Z_PIN) },
-      #endif
-    };
-
-    #define ADC0_AINCOUNT   COUNT(adc0_dma_regs_list)
-  #endif // ADC0_IS_REQUIRED
-
-  #if ADC1_IS_REQUIRED
-    Adafruit_ZeroDMA adc1DMAProgram, adc1DMARead;
-
-    static constexpr HAL_DMA_DAC_Registers adc1_dma_regs_list[ADC_COUNT] = {
-      #if GET_TEMP_0_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_0_PIN) },
-      #endif
-      #if GET_TEMP_1_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_1_PIN) },
-      #endif
-      #if GET_TEMP_2_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_2_PIN) },
-      #endif
-      #if GET_TEMP_3_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_3_PIN) },
-      #endif
-      #if GET_TEMP_4_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_4_PIN) },
-      #endif
-      #if GET_TEMP_5_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_5_PIN) },
-      #endif
-      #if GET_TEMP_6_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_6_PIN) },
-      #endif
-      #if GET_TEMP_7_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_7_PIN) },
-      #endif
-      #if GET_BED_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_BED_PIN) },
-      #endif
-      #if GET_CHAMBER_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_CHAMBER_PIN) },
-      #endif
-      #if GET_PROBE_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_PROBE_PIN) },
-      #endif
-      #if GET_COOLER_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_COOLER_PIN) },
-      #endif
-      #if GET_BOARD_ADC() == 1
-        { PIN_TO_INPUTCTRL(TEMP_BOARD_PIN) },
-      #endif
-      #if GET_FILAMENT_WIDTH_ADC() == 1
-        { PIN_TO_INPUTCTRL(FILWIDTH_PIN) },
-      #endif
-      #if GET_BUTTONS_ADC() == 1
-        { PIN_TO_INPUTCTRL(ADC_KEYPAD_PIN) },
-      #endif
-      #if GET_JOY_ADC_X() == 1
-        { PIN_TO_INPUTCTRL(JOY_X_PIN) },
-      #endif
-      #if GET_JOY_ADC_Y() == 1
-        { PIN_TO_INPUTCTRL(JOY_Y_PIN) },
-      #endif
-      #if GET_JOY_ADC_Z() == 1
-        { PIN_TO_INPUTCTRL(JOY_Z_PIN) },
-      #endif
-    };
-
-    #define ADC1_AINCOUNT   COUNT(adc1_dma_regs_list)
-  #endif // ADC1_IS_REQUIRED
-
-#endif // ADC_IS_REQUIRED
-
-// ------------------------
-// Private functions
-// ------------------------
-
-void MarlinHAL::dma_init() {
-
-  #if DMA_IS_REQUIRED
-
-    DmacDescriptor *descriptor;
-
-    #if ADC0_IS_REQUIRED
-      adc0DMAProgram.setTrigger(ADC0_DMAC_ID_SEQ);
-      adc0DMAProgram.setAction(DMA_TRIGGER_ACTON_BEAT);
-      adc0DMAProgram.loop(true);
-      if (adc0DMAProgram.allocate() == DMA_STATUS_OK) {
-        descriptor = adc0DMAProgram.addDescriptor(
-          (void *)adc0_dma_regs_list,         // SRC
-          (void *)&ADC0->DSEQDATA.reg,        // DEST
-          sizeof(adc0_dma_regs_list) / 4,     // CNT
-          DMA_BEAT_SIZE_WORD,
-          true,                               // SRCINC
-          false,                              // DSTINC
-          DMA_ADDRESS_INCREMENT_STEP_SIZE_1,  // STEPSIZE
-          DMA_STEPSEL_SRC                     // STEPSEL
-        );
-        if (descriptor)
-          descriptor->BTCTRL.bit.EVOSEL = DMA_EVENT_OUTPUT_BEAT;
-        adc0DMAProgram.startJob();
-      }
-
-      adc0DMARead.setTrigger(ADC0_DMAC_ID_RESRDY);
-      adc0DMARead.setAction(DMA_TRIGGER_ACTON_BEAT);
-      adc0DMARead.loop(true);
-      if (adc0DMARead.allocate() == DMA_STATUS_OK) {
-        adc0DMARead.addDescriptor(
-          (void *)&ADC0->RESULT.reg,          // SRC
-          &adc_results,                       // DEST
-          ADC0_AINCOUNT,                      // CNT
-          DMA_BEAT_SIZE_HWORD,
-          false,                              // SRCINC
-          true,                               // DSTINC
-          DMA_ADDRESS_INCREMENT_STEP_SIZE_1,  // STEPSIZE
-          DMA_STEPSEL_DST                     // STEPSEL
-        );
-        adc0DMARead.startJob();
-      }
-    #endif
-    #if ADC1_IS_REQUIRED
-      adc1DMAProgram.setTrigger(ADC1_DMAC_ID_SEQ);
-      adc1DMAProgram.setAction(DMA_TRIGGER_ACTON_BEAT);
-      adc1DMAProgram.loop(true);
-      if (adc1DMAProgram.allocate() == DMA_STATUS_OK) {
-        descriptor = adc1DMAProgram.addDescriptor(
-          (void *)adc1_dma_regs_list,         // SRC
-          (void *)&ADC1->DSEQDATA.reg,        // DEST
-          sizeof(adc1_dma_regs_list) / 4,     // CNT
-          DMA_BEAT_SIZE_WORD,
-          true,                               // SRCINC
-          false,                              // DSTINC
-          DMA_ADDRESS_INCREMENT_STEP_SIZE_1,  // STEPSIZE
-          DMA_STEPSEL_SRC                     // STEPSEL
-        );
-        if (descriptor)
-          descriptor->BTCTRL.bit.EVOSEL = DMA_EVENT_OUTPUT_BEAT;
-        adc1DMAProgram.startJob();
-      }
-
-      adc1DMARead.setTrigger(ADC1_DMAC_ID_RESRDY);
-      adc1DMARead.setAction(DMA_TRIGGER_ACTON_BEAT);
-      adc1DMARead.loop(true);
-      if (adc1DMARead.allocate() == DMA_STATUS_OK) {
-        adc1DMARead.addDescriptor(
-          (void *)&ADC1->RESULT.reg,          // SRC
-          &adc_results[ADC0_AINCOUNT],        // DEST
-          ADC1_AINCOUNT,                      // CNT
-          DMA_BEAT_SIZE_HWORD,
-          false,                              // SRCINC
-          true,                               // DSTINC
-          DMA_ADDRESS_INCREMENT_STEP_SIZE_1,  // STEPSIZE
-          DMA_STEPSEL_DST                     // STEPSEL
-        );
-        adc1DMARead.startJob();
-      }
-    #endif
-
-    DMAC->PRICTRL0.bit.RRLVLEN0 = true;                         // Activate round robin for DMA channels required by ADCs
-
-  #endif // DMA_IS_REQUIRED
-}
-
-// ------------------------
-// Public functions
-// ------------------------
-
-// HAL initialization task
-void MarlinHAL::init() {
-  TERN_(DMA_IS_REQUIRED, dma_init());
-  #if ENABLED(SDSUPPORT)
-    #if HAS_SD_DETECT && SD_CONNECTION_IS(ONBOARD)
-      SET_INPUT_PULLUP(SD_DETECT_PIN);
-    #endif
-    OUT_WRITE(SDSS, HIGH);  // Try to set SDSS inactive before any other SPI users start up
-  #endif
-}
-
-#pragma push_macro("WDT")
-#undef WDT    // Required to be able to use '.bit.WDT'. Compiler wrongly replace struct field with WDT define
-uint8_t MarlinHAL::get_reset_source() {
-  RSTC_RCAUSE_Type resetCause;
-
-  resetCause.reg = REG_RSTC_RCAUSE;
-  if (resetCause.bit.POR)                                   return RST_POWER_ON;
-  else if (resetCause.bit.EXT)                              return RST_EXTERNAL;
-  else if (resetCause.bit.BODCORE || resetCause.bit.BODVDD) return RST_BROWN_OUT;
-  else if (resetCause.bit.WDT)                              return RST_WATCHDOG;
-  else if (resetCause.bit.SYST || resetCause.bit.NVM)       return RST_SOFTWARE;
-  else if (resetCause.bit.BACKUP)                           return RST_BACKUP;
-  return 0;
-}
-#pragma pop_macro("WDT")
-
-void MarlinHAL::reboot() { NVIC_SystemReset(); }
-
-extern "C" {
-  void * _sbrk(int incr);
-
-  extern unsigned int __bss_end__; // end of bss section
-}
-
-// Return free memory between end of heap (or end bss) and whatever is current
-int freeMemory() {
-  int free_memory, heap_end = (int)_sbrk(0);
-  return (int)&free_memory - (heap_end ?: (int)&__bss_end__);
-}
-
-// ------------------------
-// ADC
-// ------------------------
-
-uint16_t MarlinHAL::adc_result;
-
-void MarlinHAL::adc_init() {
-  #if ADC_IS_REQUIRED
-    memset(adc_results, 0xFF, sizeof(adc_results));                         // Fill result with invalid values
-
-    LOOP_L_N(pi, COUNT(adc_pins))
-      pinPeripheral(adc_pins[pi], PIO_ANALOG);
-
-    LOOP_S_LE_N(ai, FIRST_ADC, LAST_ADC) {
-      Adc* adc = ((Adc*[])ADC_INSTS)[ai];
-
-      // ADC clock setup
-      GCLK->PCHCTRL[ADC0_GCLK_ID + ai].bit.CHEN = false;
-      SYNC(GCLK->PCHCTRL[ADC0_GCLK_ID + ai].bit.CHEN);
-      GCLK->PCHCTRL[ADC0_GCLK_ID + ai].reg = GCLK_PCHCTRL_GEN_GCLK1 | GCLK_PCHCTRL_CHEN;   // 48MHz startup code programmed
-      SYNC(!GCLK->PCHCTRL[ADC0_GCLK_ID + ai].bit.CHEN);
-      adc->CTRLA.bit.PRESCALER = ADC_CTRLA_PRESCALER_DIV32_Val;             // 1.5MHZ adc clock
-
-      // ADC setup
-      // Preloaded data (fixed for all ADC instances hence not loaded by DMA)
-      adc->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_AREFA_Val;               // VRefA pin
-      SYNC(adc->SYNCBUSY.bit.REFCTRL);
-      adc->CTRLB.bit.RESSEL = ADC_CTRLB_RESSEL_10BIT_Val;                   // ... ADC_CTRLB_RESSEL_16BIT_Val
-      SYNC(adc->SYNCBUSY.bit.CTRLB);
-      adc->SAMPCTRL.bit.SAMPLEN = (6 - 1);                                  // Sampling clocks
-      //adc->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_16 | ADC_AVGCTRL_ADJRES(4);  // 16 Accumulated conversions and shift 4 to get oversampled 12 bits result
-      //SYNC(adc->SYNCBUSY.bit.AVGCTRL);
-
-      // Registers loaded by DMA
-      adc->DSEQCTRL.bit.INPUTCTRL = true;
-      adc->DSEQCTRL.bit.AUTOSTART = true;                                   // Start conversion after DMA sequence
-
-      adc->CTRLA.bit.ENABLE = true;                                         // Enable ADC
-      SYNC(adc->SYNCBUSY.bit.ENABLE);
-    }
-  #endif // ADC_IS_REQUIRED
-}
-
-void MarlinHAL::adc_start(const pin_t pin) {
-  #if ADC_IS_REQUIRED
-    LOOP_L_N(pi, COUNT(adc_pins))
-      if (pin == adc_pins[pi]) { adc_result = adc_results[pi]; return; }
-  #endif
-
-  adc_result = 0xFFFF;
-}
-
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/HAL.h b/Marlin/src/HAL/SAMD51/HAL.h
deleted file mode 100644
index 79ba802..0000000
--- a/Marlin/src/HAL/SAMD51/HAL.h
+++ /dev/null
@@ -1,216 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define CPU_32_BIT
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-#include "fastio.h"
-
-#ifdef ADAFRUIT_GRAND_CENTRAL_M4
-  #include "MarlinSerial_AGCM4.h"
-
-  // Serial ports
-  typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
-  typedef ForwardSerial1Class< decltype(Serial1) > DefaultSerial2;
-  typedef ForwardSerial1Class< decltype(Serial2) > DefaultSerial3;
-  typedef ForwardSerial1Class< decltype(Serial3) > DefaultSerial4;
-  typedef ForwardSerial1Class< decltype(Serial4) > DefaultSerial5;
-  extern DefaultSerial1 MSerial0;
-  extern DefaultSerial2 MSerial1;
-  extern DefaultSerial3 MSerial2;
-  extern DefaultSerial4 MSerial3;
-  extern DefaultSerial5 MSerial4;
-
-  #define __MSERIAL(X) MSerial##X
-  #define _MSERIAL(X) __MSERIAL(X)
-  #define MSERIAL(X) _MSERIAL(INCREMENT(X))
-
-  #if SERIAL_PORT == -1
-    #define MYSERIAL1 MSerial0
-  #elif WITHIN(SERIAL_PORT, 0, 3)
-    #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-  #else
-    #error "SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-  #endif
-
-  #ifdef SERIAL_PORT_2
-    #if SERIAL_PORT_2 == -1
-      #define MYSERIAL2 MSerial0
-    #elif WITHIN(SERIAL_PORT_2, 0, 3)
-      #define MYSERIAL2 MSERIAL(SERIAL_PORT_2)
-    #else
-      #error "SERIAL_PORT_2 must be from 0 to 3. You can also use -1 if the board supports Native USB."
-    #endif
-  #endif
-
-  #ifdef MMU2_SERIAL_PORT
-    #if MMU2_SERIAL_PORT == -1
-      #define MMU2_SERIAL MSerial0
-    #elif WITHIN(MMU2_SERIAL_PORT, 0, 3)
-      #define MMU2_SERIAL MSERIAL(MMU2_SERIAL_PORT)
-    #else
-      #error "MMU2_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-    #endif
-  #endif
-
-  #ifdef LCD_SERIAL_PORT
-    #if LCD_SERIAL_PORT == -1
-      #define LCD_SERIAL MSerial0
-    #elif WITHIN(LCD_SERIAL_PORT, 0, 3)
-      #define LCD_SERIAL MSERIAL(LCD_SERIAL_PORT)
-    #else
-      #error "LCD_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
-    #endif
-  #endif
-
-#endif // ADAFRUIT_GRAND_CENTRAL_M4
-
-typedef int8_t pin_t;
-
-#define SHARED_SERVOS HAS_SERVOS  // Use shared/servos.cpp
-
-class Servo;
-typedef Servo hal_servo_t;
-
-//
-// Interrupts
-//
-#define CRITICAL_SECTION_START()  const bool irqon = !__get_PRIMASK(); __disable_irq()
-#define CRITICAL_SECTION_END()    if (irqon) __enable_irq()
-
-#define cli() __disable_irq() // Disable interrupts
-#define sei() __enable_irq()  // Enable interrupts
-
-//
-// ADC
-//
-
-//#define HAL_ADC_FILTERED          // Disable Marlin's oversampling. The HAL filters ADC values.
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10      // ... 12
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-//
-// Tone
-//
-void tone(const pin_t _pin, const unsigned int frequency, const unsigned long duration=0);
-void noTone(const pin_t _pin);
-
-// ------------------------
-// Class Utilities
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-#ifdef __cplusplus
-  extern "C" {
-#endif
-
-char *dtostrf(double __val, signed char __width, unsigned char __prec, char *__s);
-
-extern "C" int freeMemory();
-
-#ifdef __cplusplus
-  }
-#endif
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init();          // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return !__get_PRIMASK(); }
-  static void isr_on()  { sei(); }
-  static void isr_off() { cli(); }
-
-  static void delay_ms(const int ms) { delay(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  static uint16_t adc_result;
-
-  // Called by Temperature::init once at startup
-  static void adc_init();
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const uint8_t ch) {}
-
-  // Begin ADC sampling on the given pin. Called from Temperature::isr!
-  static void adc_start(const pin_t pin);
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value() { return adc_result; }
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No option to invert the duty cycle [default = false]
-   * No option to change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-private:
-  static void dma_init();
-};
diff --git a/Marlin/src/HAL/SAMD51/HAL_SPI.cpp b/Marlin/src/HAL/SAMD51/HAL_SPI.cpp
deleted file mode 100644
index 77f4d5e..0000000
--- a/Marlin/src/HAL/SAMD51/HAL_SPI.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Hardware and software SPI implementations are included in this file.
- *
- * Control of the slave select pin(s) is handled by the calling routines and
- * SAMD51 let hardware SPI handling to remove SS from its logic.
- */
-
-#ifdef __SAMD51__
-
-// --------------------------------------------------------------------------
-// Includes
-// --------------------------------------------------------------------------
-
-#include "../../inc/MarlinConfig.h"
-#include <SPI.h>
-
-// --------------------------------------------------------------------------
-// Public functions
-// --------------------------------------------------------------------------
-
-#if EITHER(SOFTWARE_SPI, FORCE_SOFT_SPI)
-
-  // ------------------------
-  // Software SPI
-  // ------------------------
-  #error "Software SPI not supported for SAMD51. Use Hardware SPI."
-
-#else // !SOFTWARE_SPI
-
-  #ifdef ADAFRUIT_GRAND_CENTRAL_M4
-    #if SD_CONNECTION_IS(ONBOARD)
-      #define sdSPI SDCARD_SPI
-    #else
-      #define sdSPI SPI
-    #endif
-  #endif
-
-  static SPISettings spiConfig;
-
-  // ------------------------
-  // Hardware SPI
-  // ------------------------
-  void spiBegin() {
-    spiInit(SPI_HALF_SPEED);
-  }
-
-  void spiInit(uint8_t spiRate) {
-    // Use datarates Marlin uses
-    uint32_t clock;
-    switch (spiRate) {
-      case SPI_FULL_SPEED:      clock = 8000000; break;
-      case SPI_HALF_SPEED:      clock = 4000000; break;
-      case SPI_QUARTER_SPEED:   clock = 2000000; break;
-      case SPI_EIGHTH_SPEED:    clock = 1000000; break;
-      case SPI_SIXTEENTH_SPEED: clock =  500000; break;
-      case SPI_SPEED_5:         clock =  250000; break;
-      case SPI_SPEED_6:         clock =  125000; break;
-      default:                  clock = 4000000; break; // Default from the SPI library
-    }
-    spiConfig = SPISettings(clock, MSBFIRST, SPI_MODE0);
-    sdSPI.begin();
-  }
-
-  /**
-   * @brief  Receives a single byte from the SPI port.
-   *
-   * @return Byte received
-   *
-   * @details
-   */
-  uint8_t spiRec() {
-    sdSPI.beginTransaction(spiConfig);
-    uint8_t returnByte = sdSPI.transfer(0xFF);
-    sdSPI.endTransaction();
-    return returnByte;
-  }
-
-  /**
-   * @brief  Receives a number of bytes from the SPI port to a buffer
-   *
-   * @param  buf   Pointer to starting address of buffer to write to.
-   * @param  nbyte Number of bytes to receive.
-   * @return Nothing
-   */
-  void spiRead(uint8_t *buf, uint16_t nbyte) {
-    if (nbyte == 0) return;
-    memset(buf, 0xFF, nbyte);
-    sdSPI.beginTransaction(spiConfig);
-    sdSPI.transfer(buf, nbyte);
-    sdSPI.endTransaction();
-  }
-
-  /**
-   * @brief  Sends a single byte on SPI port
-   *
-   * @param  b Byte to send
-   *
-   * @details
-   */
-  void spiSend(uint8_t b) {
-    sdSPI.beginTransaction(spiConfig);
-    sdSPI.transfer(b);
-    sdSPI.endTransaction();
-  }
-
-  /**
-   * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
-   *
-   * @param  buf   Pointer with buffer start address
-   * @return Nothing
-   *
-   * @details Uses DMA
-   */
-  void spiSendBlock(uint8_t token, const uint8_t *buf) {
-    sdSPI.beginTransaction(spiConfig);
-    sdSPI.transfer(token);
-    sdSPI.transfer((uint8_t*)buf, nullptr, 512);
-    sdSPI.endTransaction();
-  }
-
-  void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-    spiConfig = SPISettings(spiClock, (BitOrder)bitOrder, dataMode);
-    sdSPI.beginTransaction(spiConfig);
-  }
-#endif // !SOFTWARE_SPI
-
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/MarlinSPI.h b/Marlin/src/HAL/SAMD51/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/SAMD51/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.cpp b/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.cpp
deleted file mode 100644
index a16ea2f..0000000
--- a/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef ADAFRUIT_GRAND_CENTRAL_M4
-
-/**
- * Framework doesn't define some serials to save sercom resources
- * hence if these are used I need to define them
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if USING_HW_SERIAL1
-  UartT Serial2(false, &sercom4, PIN_SERIAL2_RX, PIN_SERIAL2_TX, PAD_SERIAL2_RX, PAD_SERIAL2_TX);
-  void SERCOM4_0_Handler() { Serial2.IrqHandler(); }
-  void SERCOM4_1_Handler() { Serial2.IrqHandler(); }
-  void SERCOM4_2_Handler() { Serial2.IrqHandler(); }
-  void SERCOM4_3_Handler() { Serial2.IrqHandler(); }
-#endif
-
-#if USING_HW_SERIAL2
-  UartT Serial3(false, &sercom1, PIN_SERIAL3_RX, PIN_SERIAL3_TX, PAD_SERIAL3_RX, PAD_SERIAL3_TX);
-  void SERCOM1_0_Handler() { Serial3.IrqHandler(); }
-  void SERCOM1_1_Handler() { Serial3.IrqHandler(); }
-  void SERCOM1_2_Handler() { Serial3.IrqHandler(); }
-  void SERCOM1_3_Handler() { Serial3.IrqHandler(); }
-#endif
-
-#if USING_HW_SERIAL3
-  UartT Serial4(false, &sercom5, PIN_SERIAL4_RX, PIN_SERIAL4_TX, PAD_SERIAL4_RX, PAD_SERIAL4_TX);
-  void SERCOM5_0_Handler() { Serial4.IrqHandler(); }
-  void SERCOM5_1_Handler() { Serial4.IrqHandler(); }
-  void SERCOM5_2_Handler() { Serial4.IrqHandler(); }
-  void SERCOM5_3_Handler() { Serial4.IrqHandler(); }
-#endif
-
-#endif // ADAFRUIT_GRAND_CENTRAL_M4
diff --git a/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.h b/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.h
deleted file mode 100644
index ac5a379..0000000
--- a/Marlin/src/HAL/SAMD51/MarlinSerial_AGCM4.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include "../../core/serial_hook.h"
-
-typedef Serial1Class<Uart> UartT;
-
-extern UartT Serial2;
-extern UartT Serial3;
-extern UartT Serial4;
diff --git a/Marlin/src/HAL/SAMD51/QSPIFlash.cpp b/Marlin/src/HAL/SAMD51/QSPIFlash.cpp
deleted file mode 100644
index fc21a1a..0000000
--- a/Marlin/src/HAL/SAMD51/QSPIFlash.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(QSPI_EEPROM)
-
-#include "QSPIFlash.h"
-
-#define INVALID_ADDR    0xFFFFFFFF
-#define SECTOR_OF(a)    (a & ~(SFLASH_SECTOR_SIZE - 1))
-#define OFFSET_OF(a)    (a & (SFLASH_SECTOR_SIZE - 1))
-
-Adafruit_SPIFlashBase * QSPIFlash::_flashBase = nullptr;
-uint8_t QSPIFlash::_buf[SFLASH_SECTOR_SIZE];
-uint32_t QSPIFlash::_addr = INVALID_ADDR;
-
-void QSPIFlash::begin() {
-  if (_flashBase) return;
-
-  _flashBase = new Adafruit_SPIFlashBase(new Adafruit_FlashTransport_QSPI());
-  _flashBase->begin(nullptr);
-}
-
-size_t QSPIFlash::size() {
-  return _flashBase->size();
-}
-
-uint8_t QSPIFlash::readByte(const uint32_t address) {
-  if (SECTOR_OF(address) == _addr) return _buf[OFFSET_OF(address)];
-
-  return _flashBase->read8(address);
-}
-
-void QSPIFlash::writeByte(const uint32_t address, const uint8_t value) {
-  uint32_t const sector_addr = SECTOR_OF(address);
-
-  // Page changes, flush old and update new cache
-  if (sector_addr != _addr) {
-    flush();
-    _addr = sector_addr;
-
-    // read a whole page from flash
-    _flashBase->readBuffer(sector_addr, _buf, SFLASH_SECTOR_SIZE);
-  }
-
-  _buf[OFFSET_OF(address)] = value;
-}
-
-void QSPIFlash::flush() {
-  if (_addr == INVALID_ADDR) return;
-
-  _flashBase->eraseSector(_addr / SFLASH_SECTOR_SIZE);
-  _flashBase->writeBuffer(_addr, _buf, SFLASH_SECTOR_SIZE);
-
-  _addr = INVALID_ADDR;
-}
-
-#endif // QSPI_EEPROM
diff --git a/Marlin/src/HAL/SAMD51/QSPIFlash.h b/Marlin/src/HAL/SAMD51/QSPIFlash.h
deleted file mode 100644
index 58822fe..0000000
--- a/Marlin/src/HAL/SAMD51/QSPIFlash.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * @file QSPIFlash.h
- *
- * The MIT License (MIT)
- *
- * Copyright (c) 2019 Ha Thach and Dean Miller for Adafruit Industries LLC
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * Derived from Adafruit_SPIFlash class with no SdFat references
- */
-#pragma once
-
-#include <Adafruit_SPIFlashBase.h>
-
-// This class extends Adafruit_SPIFlashBase by adding caching support.
-//
-// This class will use 4096 Bytes of RAM as a block cache.
-class QSPIFlash {
-  public:
-    static void begin();
-    static size_t size();
-    static uint8_t readByte(const uint32_t address);
-    static void writeByte(const uint32_t address, const uint8_t v);
-    static void flush();
-
-  private:
-    static Adafruit_SPIFlashBase * _flashBase;
-    static uint8_t _buf[SFLASH_SECTOR_SIZE];
-    static uint32_t _addr;
-};
-
-extern QSPIFlash qspi;
diff --git a/Marlin/src/HAL/SAMD51/SAMD51.h b/Marlin/src/HAL/SAMD51/SAMD51.h
deleted file mode 100644
index 7839561..0000000
--- a/Marlin/src/HAL/SAMD51/SAMD51.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define SYNC(sc)    while (sc) {  \
-                      asm("");    \
-                    }
-
-// Get SAMD port/pin from specified arduino pin
-#define GET_SAMD_PORT(P)    _GET_SAMD_PORT(PIN_TO_SAMD_PIN(P))
-#define GET_SAMD_PIN(P)     _GET_SAMD_PIN(PIN_TO_SAMD_PIN(P))
-
-// Get external interrupt line associated to specified arduino pin
-#define PIN_TO_EILINE(P)    _SAMDPORTPIN_TO_EILINE(GET_SAMD_PORT(P), GET_SAMD_PIN(P))
-
-// Get adc/ain associated to specified arduino pin
-#define PIN_TO_ADC(P)       (ANAPIN_TO_ADCAIN(P) >> 8)
-#define PIN_TO_AIN(P)       (ANAPIN_TO_ADCAIN(P) & 0xFF)
-
-// Private defines
-#define PIN_TO_SAMD_PIN(P)    DIO##P##_PIN
-
-#define _GET_SAMD_PORT(P)     ((P) >> 5)
-#define _GET_SAMD_PIN(P)      ((P) & 0x1F)
-
-// Get external interrupt line
-#define _SAMDPORTPIN_TO_EILINE(P,B)   ((P == 0 && WITHIN(B, 0, 31) && B != 8 && B != 26 && B != 28 && B != 29) ? (B) & 0xF    \
-                                       : (P == 1 && (WITHIN(B, 0, 25) || WITHIN(B, 30, 31))) ? (B) & 0xF                      \
-                                       : (P == 1 && WITHIN(B, 26, 29)) ? 12 + (B) - 26                                        \
-                                       : (P == 2 && (WITHIN(B, 0, 6) || WITHIN(B, 10, 31)) && B != 29) ? (B) & 0xF            \
-                                       : (P == 2 && B == 7) ? 9                                                               \
-                                       : (P == 3 && WITHIN(B, 0, 1)) ? (B)                                                    \
-                                       : (P == 3 && WITHIN(B, 8, 12)) ? 3 + (B) - 8                                           \
-                                       : (P == 3 && WITHIN(B, 20, 21)) ? 10 + (B) - 20                                        \
-                                       : -1)
-
-// Get adc/ain
-#define ANAPIN_TO_ADCAIN(P)     _PIN_TO_ADCAIN(ANAPIN_TO_SAMDPIN(P))
-#define _PIN_TO_ADCAIN(P)       _SAMDPORTPIN_TO_ADCAIN(_GET_SAMD_PORT(P), _GET_SAMD_PIN(P))
-
-#define _SAMDPORTPIN_TO_ADCAIN(P,B)       ((P == 0 && WITHIN(B, 2, 3)) ? 0x000 + (B) - 2            \
-                                           : (P == 0 && WITHIN(B, 4, 7)) ? 0x000 + (B)              \
-                                           : (P == 0 && WITHIN(B, 8, 9)) ? 0x100 + 2 + (B) - 8      \
-                                           : (P == 0 && WITHIN(B, 10, 11)) ? 0x000 + (B)            \
-                                           : (P == 1 && WITHIN(B, 0, 3)) ? 0x000 + 12 + (B)         \
-                                           : (P == 1 && WITHIN(B, 4, 7)) ? 0x100 + 6 + (B) - 4      \
-                                           : (P == 1 && WITHIN(B, 8, 9)) ? 0x100 + (B) - 8          \
-                                           : (P == 2 && WITHIN(B, 0, 1)) ? 0x100 + 10 + (B)         \
-                                           : (P == 2 && WITHIN(B, 2, 3)) ? 0x100 + 4 + (B) - 2      \
-                                           : (P == 2 && WITHIN(B, 30, 31)) ? 0x100 + 12 + (B) - 30  \
-                                           : (P == 3 && WITHIN(B, 0, 1)) ? 0x100 + 14 + (B)         \
-                                           : -1)
diff --git a/Marlin/src/HAL/SAMD51/Servo.cpp b/Marlin/src/HAL/SAMD51/Servo.cpp
deleted file mode 100644
index 665322f..0000000
--- a/Marlin/src/HAL/SAMD51/Servo.cpp
+++ /dev/null
@@ -1,217 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * This comes from Arduino library which at the moment is buggy and uncompilable
- */
-
-#ifdef __SAMD51__
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "../shared/servo.h"
-#include "../shared/servo_private.h"
-#include "SAMD51.h"
-
-#define __TC_GCLK_ID(t)         TC##t##_GCLK_ID
-#define _TC_GCLK_ID(t)          __TC_GCLK_ID(t)
-#define TC_GCLK_ID              _TC_GCLK_ID(SERVO_TC)
-
-#define _TC_PRESCALER(d)        TC_CTRLA_PRESCALER_DIV##d##_Val
-#define TC_PRESCALER(d)         _TC_PRESCALER(d)
-
-#define __SERVO_IRQn(t)         TC##t##_IRQn
-#define _SERVO_IRQn(t)          __SERVO_IRQn(t)
-#define SERVO_IRQn              _SERVO_IRQn(SERVO_TC)
-
-#define HAL_SERVO_TIMER_ISR()   TC_HANDLER(SERVO_TC)
-
-#define TIMER_TCCHANNEL(t)      ((t) & 1)
-#define TC_COUNTER_START_VAL    0xFFFF
-
-
-static volatile int8_t currentServoIndex[_Nbr_16timers];    // index for the servo being pulsed for each timer (or -1 if refresh interval)
-
-FORCE_INLINE static uint16_t getTimerCount() {
-  Tc * const tc = timer_config[SERVO_TC].pTc;
-
-  tc->COUNT16.CTRLBSET.reg = TC_CTRLBCLR_CMD_READSYNC;
-  SYNC(tc->COUNT16.SYNCBUSY.bit.CTRLB || tc->COUNT16.SYNCBUSY.bit.COUNT);
-
-  return tc->COUNT16.COUNT.reg;
-}
-
-// ----------------------------
-// Interrupt handler for the TC
-// ----------------------------
-HAL_SERVO_TIMER_ISR() {
-  Tc * const tc = timer_config[SERVO_TC].pTc;
-  const timer16_Sequence_t timer =
-    #ifndef _useTimer1
-      _timer2
-    #elif !defined(_useTimer2)
-      _timer1
-    #else
-      (tc->COUNT16.INTFLAG.reg & tc->COUNT16.INTENSET.reg & TC_INTFLAG_MC0) ? _timer1 : _timer2
-    #endif
-  ;
-  const uint8_t tcChannel = TIMER_TCCHANNEL(timer);
-
-  int8_t cho = currentServoIndex[timer];                // Handle the prior servo first
-  if (cho < 0) {                                        // Servo -1 indicates the refresh interval completed...
-    #if defined(_useTimer1) && defined(_useTimer2)
-      if (currentServoIndex[timer ^ 1] >= 0) {
-        // Wait for both channels
-        // Clear the interrupt
-        tc->COUNT16.INTFLAG.reg = (tcChannel == 0) ? TC_INTFLAG_MC0 : TC_INTFLAG_MC1;
-        return;
-      }
-    #endif
-    tc->COUNT16.COUNT.reg = TC_COUNTER_START_VAL;       // ...so reset the timer
-    SYNC(tc->COUNT16.SYNCBUSY.bit.COUNT);
-  }
-  else if (SERVO_INDEX(timer, cho) < ServoCount)        // prior channel handled?
-    digitalWrite(SERVO(timer, cho).Pin.nbr, LOW);       // pulse the prior channel LOW
-
-  currentServoIndex[timer] = ++cho;                     // go to the next channel (or 0)
-  if (cho < SERVOS_PER_TIMER && SERVO_INDEX(timer, cho) < ServoCount) {
-    if (SERVO(timer, cho).Pin.isActive)                 // activated?
-      digitalWrite(SERVO(timer, cho).Pin.nbr, HIGH);    // yes: pulse HIGH
-
-    tc->COUNT16.CC[tcChannel].reg = getTimerCount() - (uint16_t)SERVO(timer, cho).ticks;
-  }
-  else {
-    // finished all channels so wait for the refresh period to expire before starting over
-    currentServoIndex[timer] = -1;                                          // reset the timer COUNT.reg on the next call
-    const uint16_t cval = getTimerCount() - 256 / (SERVO_TIMER_PRESCALER),  // allow 256 cycles to ensure the next CV not missed
-                   ival = (TC_COUNTER_START_VAL) - (uint16_t)usToTicks(REFRESH_INTERVAL); // at least REFRESH_INTERVAL has elapsed
-    tc->COUNT16.CC[tcChannel].reg = min(cval, ival);
-  }
-  if (tcChannel == 0) {
-    SYNC(tc->COUNT16.SYNCBUSY.bit.CC0);
-    tc->COUNT16.INTFLAG.reg = TC_INTFLAG_MC0; // Clear the interrupt
-  }
-  else {
-    SYNC(tc->COUNT16.SYNCBUSY.bit.CC1);
-    tc->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1; // Clear the interrupt
-  }
-}
-
-void initISR(const timer16_Sequence_t timer) {
-  Tc * const tc = timer_config[SERVO_TC].pTc;
-  const uint8_t tcChannel = TIMER_TCCHANNEL(timer);
-
-  static bool initialized = false;  // Servo TC has been initialized
-  if (!initialized) {
-    NVIC_DisableIRQ(SERVO_IRQn);
-
-    // Disable the timer
-    tc->COUNT16.CTRLA.bit.ENABLE = false;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.ENABLE);
-
-    // Select GCLK0 as timer/counter input clock source
-    GCLK->PCHCTRL[TC_GCLK_ID].bit.CHEN = false;
-    SYNC(GCLK->PCHCTRL[TC_GCLK_ID].bit.CHEN);
-    GCLK->PCHCTRL[TC_GCLK_ID].reg = GCLK_PCHCTRL_GEN_GCLK0 | GCLK_PCHCTRL_CHEN;   // 120MHz startup code programmed
-    SYNC(!GCLK->PCHCTRL[TC_GCLK_ID].bit.CHEN);
-
-    // Reset the timer
-    tc->COUNT16.CTRLA.bit.SWRST = true;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.SWRST);
-    SYNC(tc->COUNT16.CTRLA.bit.SWRST);
-
-    // Set timer counter mode to 16 bits
-    tc->COUNT16.CTRLA.reg = TC_CTRLA_MODE_COUNT16;
-
-    // Set timer counter mode as normal PWM
-    tc->COUNT16.WAVE.bit.WAVEGEN = TCC_WAVE_WAVEGEN_NPWM_Val;
-
-    // Set the prescaler factor
-    tc->COUNT16.CTRLA.bit.PRESCALER = TC_PRESCALER(SERVO_TIMER_PRESCALER);
-
-    // Count down
-    tc->COUNT16.CTRLBSET.reg = TC_CTRLBCLR_DIR;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.CTRLB);
-
-    // Reset all servo indexes
-    memset((void *)currentServoIndex, 0xFF, sizeof(currentServoIndex));
-
-    // Configure interrupt request
-    NVIC_ClearPendingIRQ(SERVO_IRQn);
-    NVIC_SetPriority(SERVO_IRQn, 5);
-    NVIC_EnableIRQ(SERVO_IRQn);
-
-    initialized = true;
-  }
-
-  if (!tc->COUNT16.CTRLA.bit.ENABLE) {
-    // Reset the timer counter
-    tc->COUNT16.COUNT.reg = TC_COUNTER_START_VAL;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.COUNT);
-
-    // Enable the timer and start it
-    tc->COUNT16.CTRLA.bit.ENABLE = true;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.ENABLE);
-  }
-  // First interrupt request after 1 ms
-  tc->COUNT16.CC[tcChannel].reg = getTimerCount() - (uint16_t)usToTicks(1000UL);
-
-  if (tcChannel == 0 ) {
-    SYNC(tc->COUNT16.SYNCBUSY.bit.CC0);
-
-    // Clear pending match interrupt
-    tc->COUNT16.INTFLAG.reg = TC_INTENSET_MC0;
-    // Enable the match channel interrupt request
-    tc->COUNT16.INTENSET.reg = TC_INTENSET_MC0;
-  }
-  else {
-    SYNC(tc->COUNT16.SYNCBUSY.bit.CC1);
-
-    // Clear pending match interrupt
-    tc->COUNT16.INTFLAG.reg = TC_INTENSET_MC1;
-    // Enable the match channel interrupt request
-    tc->COUNT16.INTENSET.reg = TC_INTENSET_MC1;
-  }
-}
-
-void finISR(const timer16_Sequence_t timer_index) {
-  Tc * const tc = timer_config[SERVO_TC].pTc;
-  const uint8_t tcChannel = TIMER_TCCHANNEL(timer_index);
-
-  // Disable the match channel interrupt request
-  tc->COUNT16.INTENCLR.reg = (tcChannel == 0) ? TC_INTENCLR_MC0 : TC_INTENCLR_MC1;
-
-  if (true
-    #if defined(_useTimer1) && defined(_useTimer2)
-      && (tc->COUNT16.INTENCLR.reg & (TC_INTENCLR_MC0|TC_INTENCLR_MC1)) == 0
-    #endif
-  ) {
-    // Disable the timer if not used
-    tc->COUNT16.CTRLA.bit.ENABLE = false;
-    SYNC(tc->COUNT16.SYNCBUSY.bit.ENABLE);
-  }
-}
-
-#endif // HAS_SERVOS
-
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/ServoTimers.h b/Marlin/src/HAL/SAMD51/ServoTimers.h
deleted file mode 100644
index 948d515..0000000
--- a/Marlin/src/HAL/SAMD51/ServoTimers.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define _useTimer1
-#define _useTimer2
-
-#define TRIM_DURATION           5   // compensation ticks to trim adjust for digitalWrite delays
-#define SERVO_TIMER_PRESCALER   64  // timer prescaler factor to 64 (avoid overflowing 16-bit clock counter, at 120MHz this is 1831 ticks per millisecond
-
-#define SERVO_TC                3
-
-typedef enum {
-  #ifdef _useTimer1
-    _timer1,
-  #endif
-  #ifdef _useTimer2
-    _timer2,
-  #endif
-  _Nbr_16timers
-} timer16_Sequence_t;
diff --git a/Marlin/src/HAL/SAMD51/eeprom_flash.cpp b/Marlin/src/HAL/SAMD51/eeprom_flash.cpp
deleted file mode 100644
index 871bf22..0000000
--- a/Marlin/src/HAL/SAMD51/eeprom_flash.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __SAMD51__
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(FLASH_EEPROM_EMULATION)
-
-#include "../shared/eeprom_api.h"
-
-#define NVMCTRL_CMD(c)    do{                                                 \
-                            SYNC(!NVMCTRL->STATUS.bit.READY);                 \
-                            NVMCTRL->INTFLAG.bit.DONE = true;                 \
-                            NVMCTRL->CTRLB.reg = c | NVMCTRL_CTRLB_CMDEX_KEY; \
-                            SYNC(NVMCTRL->INTFLAG.bit.DONE);                  \
-                          }while(0)
-#define NVMCTRL_FLUSH()   do{                                           \
-                            if (NVMCTRL->SEESTAT.bit.LOAD)              \
-                              NVMCTRL_CMD(NVMCTRL_CTRLB_CMD_SEEFLUSH);  \
-                          }while(0)
-
-size_t PersistentStore::capacity() {
-  const uint8_t psz = NVMCTRL->SEESTAT.bit.PSZ,
-                sblk = NVMCTRL->SEESTAT.bit.SBLK;
-
-  return   (!psz && !sblk)         ? 0
-         : (psz <= 2)              ? (0x200 << psz)
-         : (sblk == 1 || psz == 3) ?  4096
-         : (sblk == 2 || psz == 4) ?  8192
-         : (sblk <= 4 || psz == 5) ? 16384
-         : (sblk >= 9 && psz == 7) ? 65536
-                                   : 32768;
-}
-
-bool PersistentStore::access_start() {
-  NVMCTRL->SEECFG.reg = NVMCTRL_SEECFG_WMODE_BUFFERED;  // Buffered mode and segment reallocation active
-  if (NVMCTRL->SEESTAT.bit.RLOCK)
-    NVMCTRL_CMD(NVMCTRL_CTRLB_CMD_USEE);    // Unlock E2P data write access
-  return true;
-}
-
-bool PersistentStore::access_finish() {
-  NVMCTRL_FLUSH();
-  if (!NVMCTRL->SEESTAT.bit.LOCK)
-    NVMCTRL_CMD(NVMCTRL_CTRLB_CMD_LSEE);    // Lock E2P data write access
-  return true;
-}
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  while (size--) {
-    const uint8_t v = *value;
-    SYNC(NVMCTRL->SEESTAT.bit.BUSY);
-    if (NVMCTRL->INTFLAG.bit.SEESFULL)
-      NVMCTRL_FLUSH();      // Next write will trigger a sector reallocation. I need to flush 'pagebuffer'
-    ((volatile uint8_t *)SEEPROM_ADDR)[pos] = v;
-    SYNC(!NVMCTRL->INTFLAG.bit.SEEWRC);
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  while (size--) {
-    SYNC(NVMCTRL->SEESTAT.bit.BUSY);
-    uint8_t c = ((volatile uint8_t *)SEEPROM_ADDR)[pos];
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-#endif // FLASH_EEPROM_EMULATION
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/eeprom_qspi.cpp b/Marlin/src/HAL/SAMD51/eeprom_qspi.cpp
deleted file mode 100644
index faa7637..0000000
--- a/Marlin/src/HAL/SAMD51/eeprom_qspi.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __SAMD51__
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(QSPI_EEPROM)
-
-#include "../shared/eeprom_api.h"
-
-#include "QSPIFlash.h"
-
-static bool initialized;
-
-size_t PersistentStore::capacity() { return qspi.size(); }
-
-bool PersistentStore::access_start() {
-  if (!initialized) {
-    qspi.begin();
-    initialized = true;
-  }
-  return true;
-}
-
-bool PersistentStore::access_finish() {
-  qspi.flush();
-  return true;
-}
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  while (size--) {
-    const uint8_t v = *value;
-    qspi.writeByte(pos, v);
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  while (size--) {
-    uint8_t c = qspi.readByte(pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-#endif // QSPI_EEPROM
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/eeprom_wired.cpp b/Marlin/src/HAL/SAMD51/eeprom_wired.cpp
deleted file mode 100644
index 3481fe5..0000000
--- a/Marlin/src/HAL/SAMD51/eeprom_wired.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __SAMD51__
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-/**
- * PersistentStore for Arduino-style EEPROM interface
- * with simple implementations supplied by Marlin.
- */
-
-#include "../shared/eeprom_if.h"
-#include "../shared/eeprom_api.h"
-
-#ifndef MARLIN_EEPROM_SIZE
-  #error "MARLIN_EEPROM_SIZE is required for I2C / SPI EEPROM."
-#endif
-size_t PersistentStore::capacity()    { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { eeprom_init(); return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    const uint8_t v = *value;
-    uint8_t * const p = (uint8_t * const)pos;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  while (size--) {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/endstop_interrupts.h b/Marlin/src/HAL/SAMD51/endstop_interrupts.h
deleted file mode 100644
index 2f02f40..0000000
--- a/Marlin/src/HAL/SAMD51/endstop_interrupts.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop interrupts for ATMEL SAMD51 based targets.
- *
- * On SAMD51, all pins support external interrupt capability.
- * Any pin can be used for external interrupts, but there are some restrictions.
- * At most 16 different external interrupts can be used at one time.
- * Further, you canâ€™t just pick any 16 pins to use. This is because every pin on the SAMD51
- * connects to what is called an EXTINT line, and only one pin per EXTINT line can be used for external
- * interrupts at a time
- */
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-#define MATCH_EILINE(P1,P2) (P1 != P2 && PIN_TO_EILINE(P1) == PIN_TO_EILINE(P2))
-#define MATCH_X_MAX_EILINE(P)   TERN0(HAS_X_MAX,  DEFER4(MATCH_EILINE)(P, X_MAX_PIN))
-#define MATCH_X_MIN_EILINE(P)   TERN0(HAS_X_MIN,  DEFER4(MATCH_EILINE)(P, X_MIN_PIN))
-#define MATCH_Y_MAX_EILINE(P)   TERN0(HAS_Y_MAX,  DEFER4(MATCH_EILINE)(P, Y_MAX_PIN))
-#define MATCH_Y_MIN_EILINE(P)   TERN0(HAS_Y_MIN,  DEFER4(MATCH_EILINE)(P, Y_MIN_PIN))
-#define MATCH_Z_MAX_EILINE(P)   TERN0(HAS_Z_MAX,  DEFER4(MATCH_EILINE)(P, Z_MAX_PIN))
-#define MATCH_Z_MIN_EILINE(P)   TERN0(HAS_Z_MIN,  DEFER4(MATCH_EILINE)(P, Z_MIN_PIN))
-#define MATCH_I_MAX_EILINE(P)   TERN0(HAS_I_MAX,  DEFER4(MATCH_EILINE)(P, I_MAX_PIN))
-#define MATCH_I_MIN_EILINE(P)   TERN0(HAS_I_MIN,  DEFER4(MATCH_EILINE)(P, I_MIN_PIN))
-#define MATCH_J_MAX_EILINE(P)   TERN0(HAS_J_MAX,  DEFER4(MATCH_EILINE)(P, J_MAX_PIN))
-#define MATCH_J_MIN_EILINE(P)   TERN0(HAS_J_MIN,  DEFER4(MATCH_EILINE)(P, J_MIN_PIN))
-#define MATCH_K_MAX_EILINE(P)   TERN0(HAS_K_MAX,  DEFER4(MATCH_EILINE)(P, K_MAX_PIN))
-#define MATCH_K_MIN_EILINE(P)   TERN0(HAS_K_MIN,  DEFER4(MATCH_EILINE)(P, K_MIN_PIN))
-#define MATCH_U_MAX_EILINE(P)   TERN0(HAS_U_MAX,  DEFER4(MATCH_EILINE)(P, U_MAX_PIN))
-#define MATCH_U_MIN_EILINE(P)   TERN0(HAS_U_MIN,  DEFER4(MATCH_EILINE)(P, U_MIN_PIN))
-#define MATCH_V_MAX_EILINE(P)   TERN0(HAS_V_MAX,  DEFER4(MATCH_EILINE)(P, V_MAX_PIN))
-#define MATCH_V_MIN_EILINE(P)   TERN0(HAS_V_MIN,  DEFER4(MATCH_EILINE)(P, V_MIN_PIN))
-#define MATCH_W_MAX_EILINE(P)   TERN0(HAS_W_MAX,  DEFER4(MATCH_EILINE)(P, W_MAX_PIN))
-#define MATCH_W_MIN_EILINE(P)   TERN0(HAS_W_MIN,  DEFER4(MATCH_EILINE)(P, W_MIN_PIN))
-#define MATCH_Z2_MAX_EILINE(P)  TERN0(HAS_Z2_MAX, DEFER4(MATCH_EILINE)(P, Z2_MAX_PIN))
-#define MATCH_Z2_MIN_EILINE(P)  TERN0(HAS_Z2_MIN, DEFER4(MATCH_EILINE)(P, Z2_MIN_PIN))
-#define MATCH_Z3_MAX_EILINE(P)  TERN0(HAS_Z3_MAX, DEFER4(MATCH_EILINE)(P, Z3_MAX_PIN))
-#define MATCH_Z3_MIN_EILINE(P)  TERN0(HAS_Z3_MIN, DEFER4(MATCH_EILINE)(P, Z3_MIN_PIN))
-#define MATCH_Z4_MAX_EILINE(P)  TERN0(HAS_Z4_MAX, DEFER4(MATCH_EILINE)(P, Z4_MAX_PIN))
-#define MATCH_Z4_MIN_EILINE(P)  TERN0(HAS_Z4_MIN, DEFER4(MATCH_EILINE)(P, Z4_MIN_PIN))
-#define MATCH_Z_MIN_PROBE_EILINE(P) TERN0(HAS_Z_MIN_PROBE_PIN, DEFER4(MATCH_EILINE)(P, Z_MIN_PROBE_PIN))
-
-#define AVAILABLE_EILINE(P) ( PIN_TO_EILINE(P) != -1    \
-  && !MATCH_X_MAX_EILINE(P) && !MATCH_X_MIN_EILINE(P)   \
-  && !MATCH_Y_MAX_EILINE(P) && !MATCH_Y_MIN_EILINE(P)   \
-  && !MATCH_Z_MAX_EILINE(P) && !MATCH_Z_MIN_EILINE(P)   \
-  && !MATCH_I_MAX_EILINE(P) && !MATCH_I_MIN_EILINE(P)   \
-  && !MATCH_J_MAX_EILINE(P) && !MATCH_J_MIN_EILINE(P)   \
-  && !MATCH_K_MAX_EILINE(P) && !MATCH_K_MIN_EILINE(P)   \
-  && !MATCH_U_MAX_EILINE(P) && !MATCH_U_MIN_EILINE(P)   \
-  && !MATCH_V_MAX_EILINE(P) && !MATCH_V_MIN_EILINE(P)   \
-  && !MATCH_W_MAX_EILINE(P) && !MATCH_W_MIN_EILINE(P)   \
-  && !MATCH_Z2_MAX_EILINE(P) && !MATCH_Z2_MIN_EILINE(P) \
-  && !MATCH_Z3_MAX_EILINE(P) && !MATCH_Z3_MIN_EILINE(P) \
-  && !MATCH_Z4_MAX_EILINE(P) && !MATCH_Z4_MIN_EILINE(P) \
-  && !MATCH_Z_MIN_PROBE_EILINE(P) )
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(P, endstop_ISR, CHANGE)
-  #if HAS_X_MAX
-    #if !AVAILABLE_EILINE(X_MAX_PIN)
-      #error "X_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(X_MAX_PIN);
-  #endif
-  #if HAS_X_MIN
-    #if !AVAILABLE_EILINE(X_MIN_PIN)
-      #error "X_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(X_MIN_PIN);
-  #endif
-  #if HAS_Y_MAX
-    #if !AVAILABLE_EILINE(Y_MAX_PIN)
-      #error "Y_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Y_MAX_PIN);
-  #endif
-  #if HAS_Y_MIN
-    #if !AVAILABLE_EILINE(Y_MIN_PIN)
-      #error "Y_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Y_MIN_PIN);
-  #endif
-  #if HAS_Z_MAX
-    #if !AVAILABLE_EILINE(Z_MAX_PIN)
-      #error "Z_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z_MAX_PIN);
-  #endif
-  #if HAS_Z_MIN
-    #if !AVAILABLE_EILINE(Z_MIN_PIN)
-      #error "Z_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z_MIN_PIN);
-  #endif
-  #if HAS_Z2_MAX
-    #if !AVAILABLE_EILINE(Z2_MAX_PIN)
-      #error "Z2_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z2_MAX_PIN);
-  #endif
-  #if HAS_Z2_MIN
-    #if !AVAILABLE_EILINE(Z2_MIN_PIN)
-      #error "Z2_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z2_MIN_PIN);
-  #endif
-  #if HAS_Z3_MAX
-    #if !AVAILABLE_EILINE(Z3_MAX_PIN)
-      #error "Z3_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z3_MAX_PIN);
-  #endif
-  #if HAS_Z3_MIN
-    #if !AVAILABLE_EILINE(Z3_MIN_PIN)
-      #error "Z3_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z3_MIN_PIN);
-  #endif
-  #if HAS_Z4_MAX
-    #if !AVAILABLE_EILINE(Z4_MAX_PIN)
-      #error "Z4_MAX_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z4_MAX_PIN);
-  #endif
-  #if HAS_Z4_MIN
-    #if !AVAILABLE_EILINE(Z4_MIN_PIN)
-      #error "Z4_MIN_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z4_MIN_PIN);
-  #endif
-  #if HAS_Z_MIN_PROBE_PIN
-    #if !AVAILABLE_EILINE(Z_MIN_PROBE_PIN)
-      #error "Z_MIN_PROBE_PIN has no EXTINT line available."
-    #endif
-    _ATTACH(Z_MIN_PROBE_PIN);
-  #endif
-  #if HAS_I_MAX
-    #if !AVAILABLE_EILINE(I_MAX_PIN)
-      #error "I_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(I_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_I_MIN
-    #if !AVAILABLE_EILINE(I_MIN_PIN)
-      #error "I_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(I_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_J_MAX
-    #if !AVAILABLE_EILINE(J_MAX_PIN)
-      #error "J_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(J_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_J_MIN
-    #if !AVAILABLE_EILINE(J_MIN_PIN)
-      #error "J_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(J_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_K_MAX
-    #if !AVAILABLE_EILINE(K_MAX_PIN)
-      #error "K_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(K_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_K_MIN
-    #if !AVAILABLE_EILINE(K_MIN_PIN)
-      #error "K_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(K_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_U_MAX
-    #if !AVAILABLE_EILINE(U_MAX_PIN)
-      #error "U_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(U_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_U_MIN
-    #if !AVAILABLE_EILINE(U_MIN_PIN)
-      #error "U_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(U_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_V_MAX
-    #if !AVAILABLE_EILINE(V_MAX_PIN)
-      #error "V_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(V_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_V_MIN
-    #if !AVAILABLE_EILINE(V_MIN_PIN)
-      #error "V_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(V_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_W_MAX
-    #if !AVAILABLE_EILINE(W_MAX_PIN)
-      #error "W_MAX_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(W_MAX_PIN, endstop_ISR, CHANGE);
-  #endif
-  #if HAS_W_MIN
-    #if !AVAILABLE_EILINE(W_MIN_PIN)
-      #error "W_MIN_PIN has no EXTINT line available."
-    #endif
-    attachInterrupt(W_MIN_PIN, endstop_ISR, CHANGE);
-  #endif
-}
diff --git a/Marlin/src/HAL/SAMD51/fastio.h b/Marlin/src/HAL/SAMD51/fastio.h
deleted file mode 100644
index 79aede5..0000000
--- a/Marlin/src/HAL/SAMD51/fastio.h
+++ /dev/null
@@ -1,253 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast IO functions for SAMD51
- */
-
-#include "SAMD51.h"
-
-/**
- * Utility functions
- */
-
-#ifndef MASK
-  #define MASK(PIN) _BV(PIN)
-#endif
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(IO); WRITE(IO, HIGH); WRITE(IO, LOW);
- */
-
-// Read a pin
-#define READ(IO)        ((PORT->Group[(EPortType)GET_SAMD_PORT(IO)].IN.reg & MASK(GET_SAMD_PIN(IO))) != 0)
-
-// Write to a pin
-#define WRITE(IO,V)     do{                                                     \
-                          const EPortType port = (EPortType)GET_SAMD_PORT(IO);  \
-                          const uint32_t mask = MASK(GET_SAMD_PIN(IO));         \
-                                                                                \
-                          if (V) PORT->Group[port].OUTSET.reg = mask;           \
-                          else PORT->Group[port].OUTCLR.reg = mask;             \
-                        }while(0)
-
-// Toggle a pin
-#define TOGGLE(IO)      PORT->Group[(EPortType)GET_SAMD_PORT(IO)].OUTTGL.reg = MASK(GET_SAMD_PIN(IO));
-
-// Set pin as input
-#define SET_INPUT(IO)           do{                                                                 \
-                                  const EPortType port = (EPortType)GET_SAMD_PORT(IO);              \
-                                  const uint32_t pin = GET_SAMD_PIN(IO);                            \
-                                                                                                    \
-                                  PORT->Group[port].PINCFG[pin].reg = (uint8_t)(PORT_PINCFG_INEN);  \
-                                  PORT->Group[port].DIRCLR.reg = MASK(pin);                         \
-                                }while(0)
-// Set pin as input with pullup
-#define SET_INPUT_PULLUP(IO)    do{                                                                                       \
-                                  const EPortType port = (EPortType)GET_SAMD_PORT(IO);                                    \
-                                  const uint32_t pin = GET_SAMD_PIN(IO);                                                  \
-                                  const uint32_t mask = MASK(pin);                                                        \
-                                                                                                                          \
-                                  PORT->Group[port].PINCFG[pin].reg = (uint8_t)(PORT_PINCFG_INEN | PORT_PINCFG_PULLEN);   \
-                                  PORT->Group[port].DIRCLR.reg = mask;                                                    \
-                                  PORT->Group[port].OUTSET.reg = mask;                                                    \
-                                }while(0)
-// Set pin as input with pulldown
-#define SET_INPUT_PULLDOWN(IO)  do{                                                                                       \
-                                  const EPortType port = (EPortType)GET_SAMD_PORT(IO);                                    \
-                                  const uint32_t pin = GET_SAMD_PIN(IO);                                                  \
-                                  const uint32_t mask = MASK(pin);                                                        \
-                                                                                                                          \
-                                  PORT->Group[port].PINCFG[pin].reg = (uint8_t)(PORT_PINCFG_INEN | PORT_PINCFG_PULLEN);   \
-                                  PORT->Group[port].DIRCLR.reg = mask;                                                    \
-                                  PORT->Group[port].OUTCLR.reg = mask;                                                    \
-                                }while(0)
-// Set pin as output (push pull)
-#define SET_OUTPUT(IO)          do{                                                                 \
-                                  const EPortType port = (EPortType)GET_SAMD_PORT(IO);              \
-                                  const uint32_t pin = GET_SAMD_PIN(IO);                            \
-                                                                                                    \
-                                  PORT->Group[port].DIRSET.reg = MASK(pin);                         \
-                                  PORT->Group[port].PINCFG[pin].reg = 0;                            \
-                                }while(0)
-// Set pin as output (open drain)
-#define SET_OUTPUT_OD(IO)       do{                                                                   \
-                                  const EPortType port = (EPortType)GET_SAMD_PORT(IO);                \
-                                  const uint32_t pin = GET_SAMD_PIN(IO);                              \
-                                                                                                      \
-                                  PORT->Group[port].PINCFG[pin].reg = (uint8_t)(PORT_PINCFG_PULLEN);  \
-                                  PORT->Group[port].DIRCLR.reg = MASK(pin);                           \
-                                }while(0)
-// Set pin as PWM (push pull)
-#define SET_PWM                 SET_OUTPUT
-// Set pin as PWM (open drain)
-#define SET_PWM_OD              SET_OUTPUT_OD
-
-// check if pin is an output
-#define IS_OUTPUT(IO)            ((PORT->Group[(EPortType)GET_SAMD_PORT(IO)].DIR.reg & MASK(GET_SAMD_PIN(IO))) \
-                                 || (PORT->Group[(EPortType)GET_SAMD_PORT(IO)].PINCFG[GET_SAMD_PIN(IO)].reg & (PORT_PINCFG_INEN | PORT_PINCFG_PULLEN)) == PORT_PINCFG_PULLEN)
-// check if pin is an input
-#define IS_INPUT(IO)            !IS_OUTPUT(IO)
-
-// Shorthand
-#define OUT_WRITE(IO,V)         do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-#define OUT_WRITE_OD(IO,V)      do{ SET_OUTPUT_OD(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)      digitalRead(IO)
-#define extDigitalWrite(IO,V)   digitalWrite(IO,V)
-
-/**
- * Ports and functions
- * Added as necessary or if I feel like it- not a comprehensive list!
- */
-
-#ifdef ADAFRUIT_GRAND_CENTRAL_M4
-
-  /*
-   * Adafruit Grand Central M4 has a lot of PWMs the availables are listed here.
-   * Some of these share the same source and so can't be used in the same time
-   */
-  #define PWM_PIN(P)        (WITHIN(P, 2, 13) || WITHIN(P, 22, 23) || WITHIN(P, 44, 45) || P == 48)
-
-  // Return fulfilled ADCx->INPUTCTRL.reg
-  #define PIN_TO_INPUTCTRL(P)     (  (PIN_TO_AIN(P) == 0) ? ADC_INPUTCTRL_MUXPOS_AIN0   \
-                                   : (PIN_TO_AIN(P) == 1) ? ADC_INPUTCTRL_MUXPOS_AIN1   \
-                                   : (PIN_TO_AIN(P) == 2) ? ADC_INPUTCTRL_MUXPOS_AIN2   \
-                                   : (PIN_TO_AIN(P) == 3) ? ADC_INPUTCTRL_MUXPOS_AIN3   \
-                                   : (PIN_TO_AIN(P) == 4) ? ADC_INPUTCTRL_MUXPOS_AIN4   \
-                                   : (PIN_TO_AIN(P) == 5) ? ADC_INPUTCTRL_MUXPOS_AIN5   \
-                                   : (PIN_TO_AIN(P) == 6) ? ADC_INPUTCTRL_MUXPOS_AIN6   \
-                                   : (PIN_TO_AIN(P) == 7) ? ADC_INPUTCTRL_MUXPOS_AIN7   \
-                                   : (PIN_TO_AIN(P) == 8) ? ADC_INPUTCTRL_MUXPOS_AIN8   \
-                                   : (PIN_TO_AIN(P) == 9) ? ADC_INPUTCTRL_MUXPOS_AIN9   \
-                                   : (PIN_TO_AIN(P) == 10) ? ADC_INPUTCTRL_MUXPOS_AIN10 \
-                                   : (PIN_TO_AIN(P) == 11) ? ADC_INPUTCTRL_MUXPOS_AIN11 \
-                                   : (PIN_TO_AIN(P) == 12) ? ADC_INPUTCTRL_MUXPOS_AIN12 \
-                                   : (PIN_TO_AIN(P) == 13) ? ADC_INPUTCTRL_MUXPOS_AIN13 \
-                                   : (PIN_TO_AIN(P) == 14) ? ADC_INPUTCTRL_MUXPOS_AIN14 \
-                                   : ADC_INPUTCTRL_MUXPOS_AIN15)
-
-  #define ANAPIN_TO_SAMDPIN(P)    (  (P == 0) ? PIN_TO_SAMD_PIN(67)   \
-                                   : (P == 1) ? PIN_TO_SAMD_PIN(68)   \
-                                   : (P == 2) ? PIN_TO_SAMD_PIN(69)   \
-                                   : (P == 3) ? PIN_TO_SAMD_PIN(70)   \
-                                   : (P == 4) ? PIN_TO_SAMD_PIN(71)   \
-                                   : (P == 5) ? PIN_TO_SAMD_PIN(72)   \
-                                   : (P == 6) ? PIN_TO_SAMD_PIN(73)   \
-                                   : (P == 7) ? PIN_TO_SAMD_PIN(74)   \
-                                   : (P == 8) ? PIN_TO_SAMD_PIN(54)   \
-                                   : (P == 9) ? PIN_TO_SAMD_PIN(55)   \
-                                   : (P == 10) ? PIN_TO_SAMD_PIN(56)  \
-                                   : (P == 11) ? PIN_TO_SAMD_PIN(57)  \
-                                   : (P == 12) ? PIN_TO_SAMD_PIN(58)  \
-                                   : (P == 13) ? PIN_TO_SAMD_PIN(59)  \
-                                   : (P == 14) ? PIN_TO_SAMD_PIN(60)  \
-                                   : (P == 15) ? PIN_TO_SAMD_PIN(61)  \
-                                   : (P == 16) ? PIN_TO_SAMD_PIN(12)  \
-                                   : (P == 17) ? PIN_TO_SAMD_PIN(13)  \
-                                   : PIN_TO_SAMD_PIN(9))
-
-  #define digitalPinToAnalogInput(P) (WITHIN(P, 67, 74) ? (P) - 67 : WITHIN(P, 54, 61) ? 8 + (P) - 54 : WITHIN(P, 12, 13) ? 16 + (P) - 12 : P == 9 ? 18 : -1)
-
-  /*
-   * pins
-   */
-
-   // PORTA
-  #define DIO67_PIN   PIN_PA02    // A0
-  #define DIO59_PIN   PIN_PA04    // A13
-  #define DIO68_PIN   PIN_PA05    // A1
-  #define DIO60_PIN   PIN_PA06    // A14
-  #define DIO61_PIN   PIN_PA07    // A15
-  #define DIO26_PIN   PIN_PA12
-  #define DIO27_PIN   PIN_PA13
-  #define DIO28_PIN   PIN_PA14
-  #define DIO23_PIN   PIN_PA15
-  #define DIO37_PIN   PIN_PA16
-  #define DIO36_PIN   PIN_PA17
-  #define DIO35_PIN   PIN_PA18
-  #define DIO34_PIN   PIN_PA19
-  #define DIO33_PIN   PIN_PA20
-  #define DIO32_PIN   PIN_PA21
-  #define DIO31_PIN   PIN_PA22
-  #define DIO30_PIN   PIN_PA23
-  // PORTB
-  #define DIO12_PIN   PIN_PB00    // A16
-  #define DIO13_PIN   PIN_PB01    // A17
-  #define DIO9_PIN    PIN_PB02    // A18
-  #define DIO69_PIN   PIN_PB03    // A2
-  #define DIO74_PIN   PIN_PB04    // A7
-  #define DIO54_PIN   PIN_PB05    // A8
-  #define DIO55_PIN   PIN_PB06    // A9
-  #define DIO56_PIN   PIN_PB07    // A10
-  #define DIO57_PIN   PIN_PB08    // A11
-  #define DIO58_PIN   PIN_PB09    // A12
-  #define DIO18_PIN   PIN_PB12
-  #define DIO19_PIN   PIN_PB13
-  #define DIO39_PIN   PIN_PB14
-  #define DIO38_PIN   PIN_PB15
-  #define DIO14_PIN   PIN_PB16
-  #define DIO15_PIN   PIN_PB17
-  #define DIO8_PIN    PIN_PB18
-  #define DIO29_PIN   PIN_PB19
-  #define DIO20_PIN   PIN_PB20
-  #define DIO21_PIN   PIN_PB21
-  #define DIO10_PIN   PIN_PB22
-  #define DIO11_PIN   PIN_PB23
-  #define DIO1_PIN    PIN_PB24
-  #define DIO0_PIN    PIN_PB25
-  #define DIO83_PIN   PIN_PB28    // SD_CS
-  #define DIO95_PIN   PIN_PB31    // SD_CD
-  // PORTC
-  #define DIO70_PIN   PIN_PC00    // A3
-  #define DIO71_PIN   PIN_PC01    // A4
-  #define DIO72_PIN   PIN_PC02    // A5
-  #define DIO73_PIN   PIN_PC03    // A6
-  #define DIO48_PIN   PIN_PC04
-  #define DIO49_PIN   PIN_PC05
-  #define DIO46_PIN   PIN_PC06
-  #define DIO47_PIN   PIN_PC07
-  #define DIO45_PIN   PIN_PC10
-  #define DIO44_PIN   PIN_PC11
-  #define DIO41_PIN   PIN_PC12
-  #define DIO40_PIN   PIN_PC13
-  #define DIO43_PIN   PIN_PC14
-  #define DIO42_PIN   PIN_PC15
-  #define DIO25_PIN   PIN_PC16
-  #define DIO24_PIN   PIN_PC17
-  #define DIO2_PIN    PIN_PC18
-  #define DIO3_PIN    PIN_PC19
-  #define DIO4_PIN    PIN_PC20
-  #define DIO5_PIN    PIN_PC21
-  #define DIO16_PIN   PIN_PC22
-  #define DIO17_PIN   PIN_PC23
-  #define DIO88_PIN   PIN_PC24    // NEOPIXEL
-  // PORTD
-  #define DIO53_PIN   PIN_PD10
-  #define DIO22_PIN   PIN_PD12
-  #define DIO6_PIN    PIN_PD20
-  #define DIO7_PIN    PIN_PD21
-
-#endif // ADAFRUIT_GRAND_CENTRAL_M4
diff --git a/Marlin/src/HAL/SAMD51/inc/Conditionals_LCD.h b/Marlin/src/HAL/SAMD51/inc/Conditionals_LCD.h
deleted file mode 100644
index 932348c..0000000
--- a/Marlin/src/HAL/SAMD51/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/SAMD51."
-#endif
diff --git a/Marlin/src/HAL/SAMD51/inc/Conditionals_adv.h b/Marlin/src/HAL/SAMD51/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/SAMD51/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/SAMD51/inc/Conditionals_post.h b/Marlin/src/HAL/SAMD51/inc/Conditionals_post.h
deleted file mode 100644
index ce6d3fd..0000000
--- a/Marlin/src/HAL/SAMD51/inc/Conditionals_post.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define FLASH_EEPROM_EMULATION
-#elif EITHER(I2C_EEPROM, SPI_EEPROM)
-  #define USE_SHARED_EEPROM 1
-#endif
diff --git a/Marlin/src/HAL/SAMD51/inc/SanityCheck.h b/Marlin/src/HAL/SAMD51/inc/SanityCheck.h
deleted file mode 100644
index 1b876c9..0000000
--- a/Marlin/src/HAL/SAMD51/inc/SanityCheck.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Test SAMD51 specific configuration values for errors at compile-time.
- */
-
-#if ENABLED(FLASH_EEPROM_EMULATION)
-  #warning "Did you activate the SmartEEPROM? See https://github.com/GMagician/SAMD51-SmartEEprom-Manager/releases"
-#endif
-
-#if defined(ADAFRUIT_GRAND_CENTRAL_M4) && SD_CONNECTION_IS(CUSTOM_CABLE)
-  #error "No custom SD drive cable defined for this board."
-#endif
-
-#if (defined(TEMP_0_SCK_PIN) && defined(TEMP_0_MISO_PIN) && (TEMP_0_SCK_PIN == SCK1 || TEMP_0_MISO_PIN == MISO1)) || \
-    (defined(TEMP_1_SCK_PIN) && defined(TEMP_1_MISO_PIN) && (TEMP_1_SCK_PIN == SCK1 || TEMP_1_MISO_PIN == MISO1))
-  #error "OnBoard SPI BUS can't be shared with other devices."
-#endif
-
-#if SERVO_TC == MF_TIMER_RTC
-  #error "Servos can't use RTC timer"
-#endif
-
-#if ENABLED(EMERGENCY_PARSER)
-  #error "EMERGENCY_PARSER is not yet implemented for SAMD51. Disable EMERGENCY_PARSER to continue."
-#endif
-
-#if ENABLED(SDIO_SUPPORT)
-  #error "SDIO_SUPPORT is not supported on SAMD51."
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on SAMD51."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on AGCM4."
-#endif
diff --git a/Marlin/src/HAL/SAMD51/pinsDebug.h b/Marlin/src/HAL/SAMD51/pinsDebug.h
deleted file mode 100644
index f0a46fd..0000000
--- a/Marlin/src/HAL/SAMD51/pinsDebug.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define NUMBER_PINS_TOTAL PINS_COUNT
-
-#define digitalRead_mod(p) extDigitalRead(p)
-#define PRINT_PORT(p) do{ SERIAL_ECHOPGM("  Port: "); sprintf_P(buffer, PSTR("%c%02ld"), 'A' + g_APinDescription[p].ulPort, g_APinDescription[p].ulPin); SERIAL_ECHO(buffer); }while (0)
-#define PRINT_ARRAY_NAME(x) do{ sprintf_P(buffer, PSTR("%-" STRINGIFY(MAX_NAME_LENGTH) "s"), pin_array[x].name); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN(p) do{ sprintf_P(buffer, PSTR("%3d "), p); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR(" (A%2d)  "), DIGITAL_PIN_TO_ANALOG_PIN(pin)); SERIAL_ECHO(buffer); }while(0)
-#define GET_ARRAY_PIN(p) pin_array[p].pin
-#define GET_ARRAY_IS_DIGITAL(p) pin_array[p].is_digital
-#define VALID_PIN(pin) (pin >= 0 && pin < (int8_t)NUMBER_PINS_TOTAL)
-#define DIGITAL_PIN_TO_ANALOG_PIN(p) digitalPinToAnalogInput(p)
-#define IS_ANALOG(P) (DIGITAL_PIN_TO_ANALOG_PIN(P)!=-1)
-#define pwm_status(pin) digitalPinHasPWM(pin)
-#define MULTI_NAME_PAD 27 // space needed to be pretty if not first name assigned to a pin
-
-// pins that will cause hang/reset/disconnect in M43 Toggle and Watch utilities
-// uses pin index
-#define M43_NEVER_TOUCH(Q) ((Q) >= 75)
-
-bool GET_PINMODE(int8_t pin) {  // 1: output, 0: input
-  const EPortType samdport = g_APinDescription[pin].ulPort;
-  const uint32_t samdpin = g_APinDescription[pin].ulPin;
-  return PORT->Group[samdport].DIR.reg & MASK(samdpin) || (PORT->Group[samdport].PINCFG[samdpin].reg & (PORT_PINCFG_INEN | PORT_PINCFG_PULLEN)) == PORT_PINCFG_PULLEN;
-}
-
-void pwm_details(int32_t pin) {
-  if (pwm_status(pin)) {
-    //uint32_t chan = g_APinDescription[pin].ulPWMChannel TODO when fast pwm is operative;
-    //SERIAL_ECHOPGM("PWM = ", duty);
-  }
-}
-
-/**
- * AGCM4 Board pin |  PORT  | Label
- * ----------------+--------+-------
- *   0             |  PB25  | "RX0"
- *   1             |  PB24  | "TX0"
- *   2             |  PC18  |
- *   3             |  PC19  |
- *   4             |  PC20  |
- *   5             |  PC21  |
- *   6             |  PD20  |
- *   7             |  PD21  |
- *   8             |  PB18  |
- *   9             |  PB2   |
- *  10             |  PB22  |
- *  11             |  PB23  |
- *  12             |  PB0   | "A16"
- *  13             |  PB1   | LED AMBER "L" / "A17"
- *  14             |  PB16  | "TX3"
- *  15             |  PB17  | "RX3"
- *  16             |  PC22  | "TX2"
- *  17             |  PC23  | "RX2"
- *  18             |  PB12  | "TX1" / "A18"
- *  19             |  PB13  | "RX1"
- *  20             |  PB20  | "SDA"
- *  21             |  PB21  | "SCL"
- *  22             |  PD12  |
- *  23             |  PA15  |
- *  24             |  PC17  |
- *  25             |  PC16  |
- *  26             |  PA12  |
- *  27             |  PA13  |
- *  28             |  PA14  |
- *  29             |  PB19  |
- *  30             |  PA23  |
- *  31             |  PA22  |
- *  32             |  PA21  |
- *  33             |  PA20  |
- *  34             |  PA19  |
- *  35             |  PA18  |
- *  36             |  PA17  |
- *  37             |  PA16  |
- *  38             |  PB15  |
- *  39             |  PB14  |
- *  40             |  PC13  |
- *  41             |  PC12  |
- *  42             |  PC15  |
- *  43             |  PC14  |
- *  44             |  PC11  |
- *  45             |  PC10  |
- *  46             |  PC6   |
- *  47             |  PC7   |
- *  48             |  PC4   |
- *  49             |  PC5   |
- *  50             |  PD11  |
- *  51             |  PD8   |
- *  52             |  PD9   |
- *  53             |  PD10  |
- *  54             |  PB5   | "A8"
- *  55             |  PB6   | "A9"
- *  56             |  PB7   | "A10"
- *  57             |  PB8   | "A11"
- *  58             |  PB9   | "A12"
- *  69             |  PA4   | "A13"
- *  60             |  PA6   | "A14"
- *  61             |  PA7   | "A15"
- *  62             |  PB17  |
- *  63             |  PB20  |
- *  64             |  PD11  |
- *  65             |  PD8   |
- *  66             |  PD9   |
- *  67             |  PA2   | "A0" / "DAC0"
- *  68             |  PA5   | "A1" / "DAC1"
- *  69             |  PB3   | "A2"
- *  70             |  PC0   | "A3"
- *  71             |  PC1   | "A4"
- *  72             |  PC2   | "A5"
- *  73             |  PC3   | "A6"
- *  74             |  PB4   | "A7"
- *  75             |  PC31  | LED GREEN "RX"
- *  76             |  PC30  | LED GREEN "TX"
- *  77             |  PA27  | USB: Host enable
- *  78             |  PA24  | USB: D-
- *  79             |  PA25  | USB: D+
- *  80             |  PB29  | SD: MISO
- *  81             |  PB27  | SD: SCK
- *  82             |  PB26  | SD: MOSI
- *  83             |  PB28  | SD: CS
- *  84             |  PA3   | AREF
- *  85             |  PA2   | DAC0 (Duplicate)
- *  86             |  PA5   | DAC1 (Duplicate)
- *  87             |  PB1   | LED AMBER "L" (Duplicate)
- *  88             |  PC24  | NeoPixel
- *  89             |  PB10  | QSPI: SCK
- *  90             |  PB11  | QSPI: CS
- *  91             |  PA8   | QSPI: IO0
- *  92             |  PA9   | QSPI: IO1
- *  93             |  PA10  | QSPI: IO2
- *  94             |  PA11  | QSPI: IO3
- *  95             |  PB31  | SD: DETECT
- */
diff --git a/Marlin/src/HAL/SAMD51/spi_pins.h b/Marlin/src/HAL/SAMD51/spi_pins.h
deleted file mode 100644
index 2a667bc..0000000
--- a/Marlin/src/HAL/SAMD51/spi_pins.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#ifdef ADAFRUIT_GRAND_CENTRAL_M4
-
- /*
-  * AGCM4 Default SPI Pins
-  *
-  *         SS    SCK   MISO   MOSI
-  *       +-------------------------+
-  *  SPI  | 53    52     50     51  |
-  *  SPI1 | 83    81     80     82  |
-  *       +-------------------------+
-  * Any pin can be used for Chip Select (SD_SS_PIN)
-  */
-  #ifndef SD_SCK_PIN
-    #define SD_SCK_PIN    52
-  #endif
-  #ifndef SD_MISO_PIN
-    #define SD_MISO_PIN   50
-  #endif
-  #ifndef SD_MOSI_PIN
-    #define SD_MOSI_PIN   51
-  #endif
-  #ifndef SDSS
-    #define SDSS          53
-  #endif
-
-#else
-
-  #error "Unsupported board!"
-
-#endif
-
-#define SD_SS_PIN     SDSS
diff --git a/Marlin/src/HAL/SAMD51/timers.cpp b/Marlin/src/HAL/SAMD51/timers.cpp
deleted file mode 100644
index 1ad0e36..0000000
--- a/Marlin/src/HAL/SAMD51/timers.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __SAMD51__
-
-// --------------------------------------------------------------------------
-// Includes
-// --------------------------------------------------------------------------
-
-#include "../../inc/MarlinConfig.h"
-#include "ServoTimers.h" // for SERVO_TC
-
-// --------------------------------------------------------------------------
-// Local defines
-// --------------------------------------------------------------------------
-
-#define NUM_HARDWARE_TIMERS 9
-
-// --------------------------------------------------------------------------
-// Private Variables
-// --------------------------------------------------------------------------
-
-const tTimerConfig timer_config[NUM_HARDWARE_TIMERS] = {
-  { {.pTc=TC0},  TC0_IRQn, TC_PRIORITY(0) },  // 0 - stepper (assigned priority 2)
-  { {.pTc=TC1},  TC1_IRQn, TC_PRIORITY(1) },  // 1 - stepper (needed by 32 bit timers)
-  { {.pTc=TC2},  TC2_IRQn, 5              },  // 2 - tone (reserved by framework and fixed assigned priority 5)
-  { {.pTc=TC3},  TC3_IRQn, TC_PRIORITY(3) },  // 3 - servo (assigned priority 1)
-  { {.pTc=TC4},  TC4_IRQn, TC_PRIORITY(4) },  // 4 - software serial (no interrupts used)
-  { {.pTc=TC5},  TC5_IRQn, TC_PRIORITY(5) },
-  { {.pTc=TC6},  TC6_IRQn, TC_PRIORITY(6) },
-  { {.pTc=TC7},  TC7_IRQn, TC_PRIORITY(7) },
-  { {.pRtc=RTC}, RTC_IRQn, TC_PRIORITY(8) }   // 8 - temperature (assigned priority 6)
-};
-
-// --------------------------------------------------------------------------
-// Private functions
-// --------------------------------------------------------------------------
-
-FORCE_INLINE void Disable_Irq(IRQn_Type irq) {
-  NVIC_DisableIRQ(irq);
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-}
-
-// --------------------------------------------------------------------------
-// Public functions
-// --------------------------------------------------------------------------
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-
-  // Disable interrupt, just in case it was already enabled
-  Disable_Irq(irq);
-
-  if (timer_num == MF_TIMER_RTC) {
-    Rtc * const rtc = timer_config[timer_num].pRtc;
-
-    // Disable timer interrupt
-    rtc->MODE0.INTENCLR.reg = RTC_MODE0_INTENCLR_CMP0;
-
-    // RTC clock setup
-    OSC32KCTRL->RTCCTRL.reg = OSC32KCTRL_RTCCTRL_RTCSEL_XOSC32K;  // External 32.768kHz oscillator
-
-    // Stop timer, just in case, to be able to reconfigure it
-    rtc->MODE0.CTRLA.bit.ENABLE = false;
-    SYNC(rtc->MODE0.SYNCBUSY.bit.ENABLE);
-
-    // Mode, reset counter on match
-    rtc->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE_COUNT32 | RTC_MODE0_CTRLA_MATCHCLR;
-
-    // Set compare value
-    rtc->MODE0.COMP[0].reg = (32768 + frequency / 2) / frequency;
-    SYNC(rtc->MODE0.SYNCBUSY.bit.COMP0);
-
-    // Enable interrupt on compare
-    rtc->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;    // reset pending interrupt
-    rtc->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;  // enable compare 0 interrupt
-
-    // And start timer
-    rtc->MODE0.CTRLA.bit.ENABLE = true;
-    SYNC(rtc->MODE0.SYNCBUSY.bit.ENABLE);
-  }
-  else {
-    Tc * const tc = timer_config[timer_num].pTc;
-
-    // Disable timer interrupt
-    tc->COUNT32.INTENCLR.reg = TC_INTENCLR_OVF; // disable overflow interrupt
-
-    // TCn clock setup
-    const uint8_t clockID = GCLK_CLKCTRL_IDs[TCC_INST_NUM + timer_num];   // TC clock are preceded by TCC ones
-    GCLK->PCHCTRL[clockID].bit.CHEN = false;
-    SYNC(GCLK->PCHCTRL[clockID].bit.CHEN);
-    GCLK->PCHCTRL[clockID].reg = GCLK_PCHCTRL_GEN_GCLK0 | GCLK_PCHCTRL_CHEN;   // 120MHz startup code programmed
-    SYNC(!GCLK->PCHCTRL[clockID].bit.CHEN);
-
-    // Stop timer, just in case, to be able to reconfigure it
-    tc->COUNT32.CTRLA.bit.ENABLE = false;
-    SYNC(tc->COUNT32.SYNCBUSY.bit.ENABLE);
-
-    // Reset timer
-    tc->COUNT32.CTRLA.bit.SWRST = true;
-    SYNC(tc->COUNT32.SYNCBUSY.bit.SWRST);
-
-    // Wave mode, reset counter on compare match
-    tc->COUNT32.WAVE.reg = TC_WAVE_WAVEGEN_MFRQ;
-    tc->COUNT32.CTRLA.reg = TC_CTRLA_MODE_COUNT32 | TC_CTRLA_PRESCALER_DIV1;
-    tc->COUNT32.CTRLBCLR.reg = TC_CTRLBCLR_DIR;
-    SYNC(tc->COUNT32.SYNCBUSY.bit.CTRLB);
-
-    // Set compare value
-    tc->COUNT32.CC[0].reg = (HAL_TIMER_RATE) / frequency;
-    tc->COUNT32.COUNT.reg = 0;
-
-    // Enable interrupt on compare
-    tc->COUNT32.INTFLAG.reg = TC_INTFLAG_OVF;   // reset pending interrupt
-    tc->COUNT32.INTENSET.reg = TC_INTENSET_OVF; // enable overflow interrupt
-
-    // And start timer
-    tc->COUNT32.CTRLA.bit.ENABLE = true;
-    SYNC(tc->COUNT32.SYNCBUSY.bit.ENABLE);
-  }
-
-  // Finally, enable IRQ
-  NVIC_SetPriority(irq, timer_config[timer_num].priority);
-  NVIC_EnableIRQ(irq);
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  const IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  NVIC_EnableIRQ(irq);
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  const IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  Disable_Irq(irq);
-}
-
-// missing from CMSIS: Check if interrupt is enabled or not
-static bool NVIC_GetEnabledIRQ(IRQn_Type IRQn) {
-  return TEST(NVIC->ISER[uint32_t(IRQn) >> 5], uint32_t(IRQn) & 0x1F);
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  const IRQn_Type irq = timer_config[timer_num].IRQ_Id;
-  return NVIC_GetEnabledIRQ(irq);
-}
-
-#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/timers.h b/Marlin/src/HAL/SAMD51/timers.h
deleted file mode 100644
index 86e980c..0000000
--- a/Marlin/src/HAL/SAMD51/timers.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <stdint.h>
-
-// --------------------------------------------------------------------------
-// Defines
-// --------------------------------------------------------------------------
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define HAL_TIMER_RATE      F_CPU   // frequency of timers peripherals
-
-#define MF_TIMER_RTC            8   // This is not a TC but a RTC
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0   // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         MF_TIMER_RTC // Timer Index for Temperature
-#endif
-
-#define TEMP_TIMER_FREQUENCY   1000 // temperature interrupt frequency
-
-#define STEPPER_TIMER_RATE          HAL_TIMER_RATE   // frequency of stepper timer (HAL_TIMER_RATE / STEPPER_TIMER_PRESCALE)
-#define STEPPER_TIMER_TICKS_PER_US  (STEPPER_TIMER_RATE / 1000000) // stepper timer ticks per Âµs
-#define STEPPER_TIMER_PRESCALE      (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE          STEPPER_TIMER_RATE
-#define PULSE_TIMER_PRESCALE      STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US  STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT()   HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT()  HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED()               HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT()  HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#define TC_PRIORITY(t)     (  t == SERVO_TC ? 1                              \
-                           : (t == MF_TIMER_STEP || t == MF_TIMER_PULSE) ? 2 \
-                           : (t == MF_TIMER_TEMP) ? 6 : 7 )
-
-#define _TC_HANDLER(t)          void TC##t##_Handler()
-#define TC_HANDLER(t)           _TC_HANDLER(t)
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR()  TC_HANDLER(MF_TIMER_STEP)
-#endif
-#if MF_TIMER_STEP != MF_TIMER_PULSE
-  #define HAL_PULSE_TIMER_ISR() TC_HANDLER(MF_TIMER_PULSE)
-#endif
-#if MF_TIMER_TEMP == MF_TIMER_RTC
-  #define HAL_TEMP_TIMER_ISR()  void RTC_Handler()
-#else
-  #define HAL_TEMP_TIMER_ISR()  TC_HANDLER(MF_TIMER_TEMP)
-#endif
-
-// --------------------------------------------------------------------------
-// Types
-// --------------------------------------------------------------------------
-
-typedef struct {
-  union {
-    Tc  *pTc;
-    Rtc *pRtc;
-  };
-  IRQn_Type   IRQ_Id;
-  uint8_t     priority;
-} tTimerConfig;
-
-// --------------------------------------------------------------------------
-// Public Variables
-// --------------------------------------------------------------------------
-
-extern const tTimerConfig timer_config[];
-
-// --------------------------------------------------------------------------
-// Public functions
-// --------------------------------------------------------------------------
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  // Should never be called with timer MF_TIMER_RTC
-  Tc * const tc = timer_config[timer_num].pTc;
-  tc->COUNT32.CC[0].reg = compare;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  // Should never be called with timer MF_TIMER_RTC
-  Tc * const tc = timer_config[timer_num].pTc;
-  return (hal_timer_t)tc->COUNT32.CC[0].reg;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  // Should never be called with timer MF_TIMER_RTC
-  Tc * const tc = timer_config[timer_num].pTc;
-  tc->COUNT32.CTRLBSET.reg = TC_CTRLBCLR_CMD_READSYNC;
-  SYNC(tc->COUNT32.SYNCBUSY.bit.CTRLB || tc->COUNT32.SYNCBUSY.bit.COUNT);
-  return tc->COUNT32.COUNT.reg;
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-FORCE_INLINE static void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  if (timer_num == MF_TIMER_RTC) {
-    Rtc * const rtc = timer_config[timer_num].pRtc;
-    // Clear interrupt flag
-    rtc->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
-  }
-  else {
-    Tc * const tc = timer_config[timer_num].pTc;
-    // Clear interrupt flag
-    tc->COUNT32.INTFLAG.reg = TC_INTFLAG_OVF;
-  }
-}
-
-#define HAL_timer_isr_epilogue(timer_num)
diff --git a/Marlin/src/HAL/TEENSY31_32/HAL.cpp b/Marlin/src/HAL/TEENSY31_32/HAL.cpp
deleted file mode 100644
index 2892368..0000000
--- a/Marlin/src/HAL/TEENSY31_32/HAL.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL for Teensy 3.2 (MK20DX256)
- */
-
-#ifdef __MK20DX256__
-
-#include "HAL.h"
-#include "../shared/Delay.h"
-
-#include <Wire.h>
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#define _IMPLEMENT_SERIAL(X) DefaultSerial##X MSerial##X(false, Serial##X)
-#define IMPLEMENT_SERIAL(X)  _IMPLEMENT_SERIAL(X)
-#if WITHIN(SERIAL_PORT, 0, 3)
-  IMPLEMENT_SERIAL(SERIAL_PORT);
-#else
-  #error "SERIAL_PORT must be from 0 to 3."
-#endif
-USBSerialType USBSerial(false, SerialUSB);
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-void MarlinHAL::reboot() { _reboot_Teensyduino_(); }
-
-uint8_t MarlinHAL::get_reset_source() {
-  switch (RCM_SRS0) {
-    case 128: return RST_POWER_ON; break;
-    case 64: return RST_EXTERNAL; break;
-    case 32: return RST_WATCHDOG; break;
-    // case 8: return RST_LOSS_OF_LOCK; break;
-    // case 4: return RST_LOSS_OF_CLOCK; break;
-    // case 2: return RST_LOW_VOLTAGE; break;
-  }
-  return 0;
-}
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  #define WDT_TIMEOUT_MS TERN(WATCHDOG_DURATION_8S, 8000, 4000) // 4 or 8 second timeout
-
-  void MarlinHAL::watchdog_init() {
-    WDOG_TOVALH = 0;
-    WDOG_TOVALL = WDT_TIMEOUT_MS;
-    WDOG_STCTRLH = WDOG_STCTRLH_WDOGEN;
-  }
-
-  void MarlinHAL::watchdog_refresh() {
-    // Watchdog refresh sequence
-    WDOG_REFRESH = 0xA602;
-    WDOG_REFRESH = 0xB480;
-  }
-
-#endif
-
-// ------------------------
-// ADC
-// ------------------------
-
-void MarlinHAL::adc_init() {
-  analog_init();
-  while (ADC0_SC3 & ADC_SC3_CAL) {}; // Wait for calibration to finish
-  NVIC_ENABLE_IRQ(IRQ_FTM1);
-}
-
-void MarlinHAL::adc_start(const pin_t pin) {
-  static const uint8_t pin2sc1a[] = {
-      5, 14, 8, 9, 13, 12, 6, 7, 15, 4, 0, 19, 3, 31, // 0-13, we treat them as A0-A13
-      5, 14, 8, 9, 13, 12, 6, 7, 15, 4, // 14-23 (A0-A9)
-      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, // 24-33
-      0+64, 19+64, 3+64, 31+64, // 34-37 (A10-A13)
-      26, 22, 23, 27, 29, 30 // 38-43: temp. sensor, VREF_OUT, A14, bandgap, VREFH, VREFL. A14 isn't connected to anything in Teensy 3.0.
-  };
-  ADC0_SC1A = pin2sc1a[pin];
-}
-
-uint16_t MarlinHAL::adc_value() { return ADC0_RA; }
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-extern "C" {
-  extern char __bss_end;
-  extern char __heap_start;
-  extern void* __brkval;
-
-  int freeMemory() {
-    int free_memory;
-    if ((int)__brkval == 0)
-      free_memory = ((int)&free_memory) - ((int)&__bss_end);
-    else
-      free_memory = ((int)&free_memory) - ((int)__brkval);
-    return free_memory;
-  }
-}
-
-#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/HAL.h b/Marlin/src/HAL/TEENSY31_32/HAL.h
deleted file mode 100644
index a7aa9f0..0000000
--- a/Marlin/src/HAL/TEENSY31_32/HAL.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Teensy 3.2 (MK20DX256)
- */
-
-#define CPU_32_BIT
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-
-#include "fastio.h"
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define IS_32BIT_TEENSY 1
-#define IS_TEENSY_31_32 1
-#ifndef IS_TEENSY31
-  #define IS_TEENSY32 1
-#endif
-
-#define CPU_ST7920_DELAY_1 600
-#define CPU_ST7920_DELAY_2 750
-#define CPU_ST7920_DELAY_3 750
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#include "../../core/serial_hook.h"
-
-#define Serial0 Serial
-#define _DECLARE_SERIAL(X) \
-  typedef ForwardSerial1Class<decltype(Serial##X)> DefaultSerial##X; \
-  extern DefaultSerial##X MSerial##X
-#define DECLARE_SERIAL(X) _DECLARE_SERIAL(X)
-
-typedef ForwardSerial1Class<decltype(SerialUSB)> USBSerialType;
-extern USBSerialType USBSerial;
-
-#define _MSERIAL(X) MSerial##X
-#define MSERIAL(X) _MSERIAL(X)
-
-#if SERIAL_PORT == -1
-  #define MYSERIAL1 USBSerial
-#elif WITHIN(SERIAL_PORT, 0, 3)
-  DECLARE_SERIAL(SERIAL_PORT);
-  #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-#else
-  #error "The required SERIAL_PORT must be from 0 to 3, or -1 for Native USB."
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-class libServo;
-typedef libServo hal_servo_t;
-
-typedef int8_t pin_t;
-
-// ------------------------
-// Interrupts
-// ------------------------
-
-uint32_t __get_PRIMASK(void); // CMSIS
-#define CRITICAL_SECTION_START()  const bool irqon = !__get_PRIMASK(); __disable_irq()
-#define CRITICAL_SECTION_END()    if (irqon) __enable_irq()
-
-// ------------------------
-// ADC
-// ------------------------
-
-#ifndef analogInputToDigitalPin
-  #define analogInputToDigitalPin(p) ((p < 12U) ? (p) + 54U : -1)
-#endif
-
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-// ------------------------
-// Class Utilities
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-extern "C" int freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init() {}        // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return !__get_PRIMASK(); }
-  static void isr_on()  { __enable_irq(); }
-  static void isr_off() { __disable_irq(); }
-
-  static void delay_ms(const int ms) { delay(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  // Called by Temperature::init once at startup
-  static void adc_init();
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const pin_t ch) {}
-
-  // Begin ADC sampling on the given channel. Called from Temperature::isr!
-  static void adc_start(const pin_t ch);
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value();
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No option to invert the duty cycle [default = false]
-   * No option to change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-};
diff --git a/Marlin/src/HAL/TEENSY31_32/HAL_SPI.cpp b/Marlin/src/HAL/TEENSY31_32/HAL_SPI.cpp
deleted file mode 100644
index 415c692..0000000
--- a/Marlin/src/HAL/TEENSY31_32/HAL_SPI.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __MK20DX256__
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-#include <SPI.h>
-#include <pins_arduino.h>
-#include "spi_pins.h"
-
-static SPISettings spiConfig;
-
-/**
- * Standard SPI functions
- */
-
-// Initialize SPI bus
-void spiBegin() {
-  #if PIN_EXISTS(SD_SS)
-    OUT_WRITE(SD_SS_PIN, HIGH);
-  #endif
-  SET_OUTPUT(SD_SCK_PIN);
-  SET_INPUT(SD_MISO_PIN);
-  SET_OUTPUT(SD_MOSI_PIN);
-
-  #if 0 && DISABLED(SOFTWARE_SPI)
-    // set SS high - may be chip select for another SPI device
-    #if SET_SPI_SS_HIGH
-      WRITE(SD_SS_PIN, HIGH);
-    #endif
-    // set a default rate
-    spiInit(SPI_HALF_SPEED); // 1
-  #endif
-}
-
-// Configure SPI for specified SPI speed
-void spiInit(uint8_t spiRate) {
-  // Use data rates Marlin uses
-  uint32_t clock;
-  switch (spiRate) {
-    case SPI_FULL_SPEED:    clock = 10000000; break;
-    case SPI_HALF_SPEED:    clock =  5000000; break;
-    case SPI_QUARTER_SPEED: clock =  2500000; break;
-    case SPI_EIGHTH_SPEED:  clock =  1250000; break;
-    case SPI_SPEED_5:       clock =   625000; break;
-    case SPI_SPEED_6:       clock =   312500; break;
-    default:                clock = 4000000; // Default from the SPI library
-  }
-  spiConfig = SPISettings(clock, MSBFIRST, SPI_MODE0);
-  SPI.begin();
-}
-
-// SPI receive a byte
-uint8_t spiRec() {
-  SPI.beginTransaction(spiConfig);
-  const uint8_t returnByte = SPI.transfer(0xFF);
-  SPI.endTransaction();
-  return returnByte;
-  //SPDR = 0xFF;
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //return SPDR;
-}
-
-// SPI read data
-void spiRead(uint8_t *buf, uint16_t nbyte) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(buf, nbyte);
-  SPI.endTransaction();
-  //if (nbyte-- == 0) return;
-  //  SPDR = 0xFF;
-  //for (uint16_t i = 0; i < nbyte; i++) {
-  //  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //  buf[i] = SPDR;
-  //  SPDR = 0xFF;
-  //}
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //buf[nbyte] = SPDR;
-}
-
-// SPI send a byte
-void spiSend(uint8_t b) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(b);
-  SPI.endTransaction();
-  //SPDR = b;
-  //while (!TEST(SPSR, SPIF)) { /* nada */ }
-}
-
-// SPI send block
-void spiSendBlock(uint8_t token, const uint8_t *buf) {
-  SPI.beginTransaction(spiConfig);
-  SPDR = token;
-  for (uint16_t i = 0; i < 512; i += 2) {
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i];
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i + 1];
-  }
-  while (!TEST(SPSR, SPIF)) { /* nada */ };
-  SPI.endTransaction();
-}
-
-
-// Begin SPI transaction, set clock, bit order, data mode
-void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-  spiConfig = SPISettings(spiClock, bitOrder, dataMode);
-  SPI.beginTransaction(spiConfig);
-}
-
-#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/MarlinSPI.h b/Marlin/src/HAL/TEENSY31_32/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/TEENSY31_32/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/TEENSY31_32/Servo.cpp b/Marlin/src/HAL/TEENSY31_32/Servo.cpp
deleted file mode 100644
index 19d57cf..0000000
--- a/Marlin/src/HAL/TEENSY31_32/Servo.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __MK20DX256__
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "Servo.h"
-
-uint8_t servoPin[MAX_SERVOS] = { 0 };
-
-int8_t libServo::attach(const int inPin) {
-  if (servoIndex >= MAX_SERVOS) return -1;
-  if (inPin > 0) servoPin[servoIndex] = inPin;
-  return super::attach(servoPin[servoIndex]);
-}
-
-int8_t libServo::attach(const int inPin, const int inMin, const int inMax) {
-  if (inPin > 0) servoPin[servoIndex] = inPin;
-  return super::attach(servoPin[servoIndex], inMin, inMax);
-}
-
-void libServo::move(const int value) {
-  constexpr uint16_t servo_delay[] = SERVO_DELAY;
-  static_assert(COUNT(servo_delay) == NUM_SERVOS, "SERVO_DELAY must be an array NUM_SERVOS long.");
-  if (attach(0) >= 0) {
-    write(value);
-    safe_delay(servo_delay[servoIndex]);
-    TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());
-  }
-}
-
-#endif // HAS_SERVOS
-#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/Servo.h b/Marlin/src/HAL/TEENSY31_32/Servo.h
deleted file mode 100644
index 82b601d..0000000
--- a/Marlin/src/HAL/TEENSY31_32/Servo.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <Servo.h>
-
-// Inherit and expand on the official library
-class libServo : public Servo {
-  public:
-    int8_t attach(const int pin);
-    int8_t attach(const int pin, const int min, const int max);
-    void move(const int value);
-  private:
-    typedef Servo super;
-    uint16_t min_ticks;
-    uint16_t max_ticks;
-    uint8_t servoIndex;               // index into the channel data for this servo
-};
diff --git a/Marlin/src/HAL/TEENSY31_32/eeprom.cpp b/Marlin/src/HAL/TEENSY31_32/eeprom.cpp
deleted file mode 100644
index d1ff940..0000000
--- a/Marlin/src/HAL/TEENSY31_32/eeprom.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#ifdef __MK20DX256__
-
-/**
- * HAL PersistentStore for Teensy 3.2 (MK20DX256)
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-#include "../shared/eeprom_api.h"
-#include <avr/eeprom.h>
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-#endif
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/endstop_interrupts.h b/Marlin/src/HAL/TEENSY31_32/endstop_interrupts.h
deleted file mode 100644
index c1bbcb1..0000000
--- a/Marlin/src/HAL/TEENSY31_32/endstop_interrupts.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Endstop Interrupts
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-/**
- *  Endstop interrupts for Due based targets.
- *  On Due, all pins support external interrupt capability.
- */
-
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  TERN_(HAS_X_MAX, _ATTACH(X_MAX_PIN));
-  TERN_(HAS_X_MIN, _ATTACH(X_MIN_PIN));
-  TERN_(HAS_Y_MAX, _ATTACH(Y_MAX_PIN));
-  TERN_(HAS_Y_MIN, _ATTACH(Y_MIN_PIN));
-  TERN_(HAS_Z_MAX, _ATTACH(Z_MAX_PIN));
-  TERN_(HAS_Z_MIN, _ATTACH(Z_MIN_PIN));
-  TERN_(HAS_X2_MAX, _ATTACH(X2_MAX_PIN));
-  TERN_(HAS_X2_MIN, _ATTACH(X2_MIN_PIN));
-  TERN_(HAS_Y2_MAX, _ATTACH(Y2_MAX_PIN));
-  TERN_(HAS_Y2_MIN, _ATTACH(Y2_MIN_PIN));
-  TERN_(HAS_Z2_MAX, _ATTACH(Z2_MAX_PIN));
-  TERN_(HAS_Z2_MIN, _ATTACH(Z2_MIN_PIN));
-  TERN_(HAS_Z3_MAX, _ATTACH(Z3_MAX_PIN));
-  TERN_(HAS_Z3_MIN, _ATTACH(Z3_MIN_PIN));
-  TERN_(HAS_Z4_MAX, _ATTACH(Z4_MAX_PIN));
-  TERN_(HAS_Z4_MIN, _ATTACH(Z4_MIN_PIN));
-  TERN_(HAS_Z_MIN_PROBE_PIN, _ATTACH(Z_MIN_PROBE_PIN));
-  TERN_(HAS_I_MAX, _ATTACH(I_MAX_PIN));
-  TERN_(HAS_I_MIN, _ATTACH(I_MIN_PIN));
-  TERN_(HAS_J_MAX, _ATTACH(J_MAX_PIN));
-  TERN_(HAS_J_MIN, _ATTACH(J_MIN_PIN));
-  TERN_(HAS_K_MAX, _ATTACH(K_MAX_PIN));
-  TERN_(HAS_K_MIN, _ATTACH(K_MIN_PIN));
-  TERN_(HAS_U_MAX, _ATTACH(U_MAX_PIN));
-  TERN_(HAS_U_MIN, _ATTACH(U_MIN_PIN));
-  TERN_(HAS_V_MAX, _ATTACH(V_MAX_PIN));
-  TERN_(HAS_V_MIN, _ATTACH(V_MIN_PIN));
-  TERN_(HAS_W_MAX, _ATTACH(W_MAX_PIN));
-  TERN_(HAS_W_MIN, _ATTACH(W_MIN_PIN));
-}
diff --git a/Marlin/src/HAL/TEENSY31_32/fastio.h b/Marlin/src/HAL/TEENSY31_32/fastio.h
deleted file mode 100644
index 622799e..0000000
--- a/Marlin/src/HAL/TEENSY31_32/fastio.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for Teensy 3.5 and Teensy 3.6
- * Use direct port manipulation to save scads of processor time.
- * Contributed by Triffid_Hunter and modified by Kliment, thinkyhead, Bob-the-Kuhn, et.al.
- */
-
-#ifndef MASK
-  #define MASK(PIN) _BV(PIN)
-#endif
-
-#define GPIO_BITBAND_ADDR(reg, bit) (((uint32_t)&(reg) - 0x40000000) * 32 + (bit) * 4 + 0x42000000)
-#define GPIO_BITBAND(reg, bit) (*(uint32_t *)GPIO_BITBAND_ADDR((reg), (bit)))
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(PIN); WRITE(PIN, HIGH); WRITE(PIN, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html
- */
-
-#define _READ(P) bool(CORE_PIN ## P ## _PINREG & CORE_PIN ## P ## _BITMASK)
-
-#define _WRITE(P,V) do{ \
-  if (V) CORE_PIN ## P ## _PORTSET = CORE_PIN ## P ## _BITMASK; \
-  else CORE_PIN ## P ## _PORTCLEAR = CORE_PIN ## P ## _BITMASK; \
-}while(0)
-
-#define _TOGGLE(P) (*(&(CORE_PIN ## P ## _PORTCLEAR)+1) = CORE_PIN ## P ## _BITMASK)
-
-#define _SET_INPUT(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1); \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 0; \
-}while(0)
-
-#define _SET_OUTPUT(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1)|PORT_PCR_SRE|PORT_PCR_DSE; \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 1; \
-}while(0)
-
-#define _SET_INPUT_PULLUP(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS; \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 0; \
-}while(0)
-
-#define _IS_INPUT(P)    ((CORE_PIN ## P ## _DDRREG & CORE_PIN ## P ## _BITMASK) == 0)
-#define _IS_OUTPUT(P)   ((CORE_PIN ## P ## _DDRREG & CORE_PIN ## P ## _BITMASK) == 0)
-
-#define READ(IO)              _READ(IO)
-
-#define WRITE(IO,V)           _WRITE(IO,V)
-#define TOGGLE(IO)            _TOGGLE(IO)
-
-#define SET_INPUT(IO)         _SET_INPUT(IO)
-#define SET_INPUT_PULLUP(IO)  _SET_INPUT_PULLUP(IO)
-#define SET_INPUT_PULLDOWN    SET_INPUT
-#define SET_OUTPUT(IO)        _SET_OUTPUT(IO)
-#define SET_PWM               SET_OUTPUT
-
-#define IS_INPUT(IO)          _IS_INPUT(IO)
-#define IS_OUTPUT(IO)         _IS_OUTPUT(IO)
-
-#define OUT_WRITE(IO,V)       do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
-
-#define PWM_PIN(P)            digitalPinHasPWM(P)
-
-/**
- * Ports, functions, and pins
- */
-
-#define DIO0_PIN 8
diff --git a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_LCD.h b/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_LCD.h
deleted file mode 100644
index 54ec166..0000000
--- a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/TEENSY31_32."
-#endif
diff --git a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_adv.h b/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_post.h b/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_post.h
deleted file mode 100644
index 998f1dc..0000000
--- a/Marlin/src/HAL/TEENSY31_32/inc/Conditionals_post.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define USE_WIRED_EEPROM 1
-#endif
diff --git a/Marlin/src/HAL/TEENSY31_32/inc/SanityCheck.h b/Marlin/src/HAL/TEENSY31_32/inc/SanityCheck.h
deleted file mode 100644
index dbce187..0000000
--- a/Marlin/src/HAL/TEENSY31_32/inc/SanityCheck.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test TEENSY35_36 specific configuration values for errors at compile-time.
- */
-
-#if ENABLED(EMERGENCY_PARSER)
-  #error "EMERGENCY_PARSER is not yet implemented for Teensy 3.1/3.2. Disable EMERGENCY_PARSER to continue."
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on Teensy 3.1/3.2."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on Teensy 3.1/3.2."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on Teensy 3.1/3.2."
-#endif
-
-#if USING_PULLDOWNS
-  #error "PULLDOWN pin mode is not available on Teensy 3.1/3.2 boards."
-#endif
diff --git a/Marlin/src/HAL/TEENSY31_32/pinsDebug.h b/Marlin/src/HAL/TEENSY31_32/pinsDebug.h
deleted file mode 100644
index d4a91ce..0000000
--- a/Marlin/src/HAL/TEENSY31_32/pinsDebug.h
+++ /dev/null
@@ -1 +0,0 @@
-#error "PINS_DEBUGGING is not yet supported for Teensy 3.1 / 3.2!"
diff --git a/Marlin/src/HAL/TEENSY31_32/spi_pins.h b/Marlin/src/HAL/TEENSY31_32/spi_pins.h
deleted file mode 100644
index 6d0d05f..0000000
--- a/Marlin/src/HAL/TEENSY31_32/spi_pins.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#define SD_SCK_PIN  13
-#define SD_MISO_PIN 12
-#define SD_MOSI_PIN 11
-#define SD_SS_PIN   20 // SDSS // A.28, A.29, B.21, C.26, C.29
diff --git a/Marlin/src/HAL/TEENSY31_32/timers.cpp b/Marlin/src/HAL/TEENSY31_32/timers.cpp
deleted file mode 100644
index f217715..0000000
--- a/Marlin/src/HAL/TEENSY31_32/timers.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Timers for Teensy 3.2 (MK20DX256)
- */
-
-#ifdef __MK20DX256__
-
-#include "../../inc/MarlinConfig.h"
-
-/** \brief Instruction Synchronization Barrier
-  Instruction Synchronization Barrier flushes the pipeline in the processor,
-  so that all instructions following the ISB are fetched from cache or
-  memory, after the instruction has been completed.
-*/
-FORCE_INLINE static void __ISB() {
-  __asm__ __volatile__("isb 0xF":::"memory");
-}
-
-/** \brief Data Synchronization Barrier
-  This function acts as a special kind of Data Memory Barrier.
-  It completes when all explicit memory accesses before this instruction complete.
-*/
-FORCE_INLINE static void __DSB() {
-  __asm__ __volatile__("dsb 0xF":::"memory");
-}
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      FTM0_MODE = FTM_MODE_WPDIS | FTM_MODE_FTMEN;
-      FTM0_SC = 0x00; // Set this to zero before changing the modulus
-      FTM0_CNT = 0x0000; // Reset the count to zero
-      FTM0_MOD = 0xFFFF; // max modulus = 65535
-      FTM0_C0V = (FTM0_TIMER_RATE) / frequency; // Initial FTM Channel 0 compare value
-      FTM0_SC = (FTM_SC_CLKS(0b1) & FTM_SC_CLKS_MASK) | (FTM_SC_PS(FTM0_TIMER_PRESCALE_BITS) & FTM_SC_PS_MASK); // Bus clock 60MHz divided by prescaler 8
-      FTM0_C0SC = FTM_CSC_CHIE | FTM_CSC_MSA | FTM_CSC_ELSA;
-      break;
-    case MF_TIMER_TEMP:
-      FTM1_MODE = FTM_MODE_WPDIS | FTM_MODE_FTMEN; // Disable write protection, Enable FTM1
-      FTM1_SC = 0x00; // Set this to zero before changing the modulus
-      FTM1_CNT = 0x0000; // Reset the count to zero
-      FTM1_MOD = 0xFFFF; // max modulus = 65535
-      FTM1_C0V = (FTM1_TIMER_RATE) / frequency; // Initial FTM Channel 0 compare value 65535
-      FTM1_SC = (FTM_SC_CLKS(0b1) & FTM_SC_CLKS_MASK) | (FTM_SC_PS(FTM1_TIMER_PRESCALE_BITS) & FTM_SC_PS_MASK); // Bus clock 60MHz divided by prescaler 4
-      FTM1_C0SC = FTM_CSC_CHIE | FTM_CSC_MSA | FTM_CSC_ELSA;
-      break;
-  }
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_ENABLE_IRQ(IRQ_FTM0); break;
-    case MF_TIMER_TEMP: NVIC_ENABLE_IRQ(IRQ_FTM1); break;
-  }
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_DISABLE_IRQ(IRQ_FTM0); break;
-    case MF_TIMER_TEMP: NVIC_DISABLE_IRQ(IRQ_FTM1); break;
-  }
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return NVIC_IS_ENABLED(IRQ_FTM0);
-    case MF_TIMER_TEMP: return NVIC_IS_ENABLED(IRQ_FTM1);
-  }
-  return false;
-}
-
-void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      FTM0_CNT = 0x0000;
-      FTM0_SC &= ~FTM_SC_TOF; // Clear FTM Overflow flag
-      FTM0_C0SC &= ~FTM_CSC_CHF; // Clear FTM Channel Compare flag
-      break;
-    case MF_TIMER_TEMP:
-      FTM1_CNT = 0x0000;
-      FTM1_SC &= ~FTM_SC_TOF; // Clear FTM Overflow flag
-      FTM1_C0SC &= ~FTM_CSC_CHF; // Clear FTM Channel Compare flag
-      break;
-  }
-}
-
-#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/timers.h b/Marlin/src/HAL/TEENSY31_32/timers.h
deleted file mode 100644
index 9fcbb6f..0000000
--- a/Marlin/src/HAL/TEENSY31_32/timers.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Timers for Teensy 3.2 (MK20DX256)
- */
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define FTM0_TIMER_PRESCALE 8
-#define FTM1_TIMER_PRESCALE 4
-#define FTM0_TIMER_PRESCALE_BITS 0b011
-#define FTM1_TIMER_PRESCALE_BITS 0b010
-
-#define FTM0_TIMER_RATE (F_BUS / (FTM0_TIMER_PRESCALE)) // 60MHz / 8 = 7500kHz
-#define FTM1_TIMER_RATE (F_BUS / (FTM1_TIMER_PRESCALE)) // 60MHz / 4 = 15MHz
-
-#define HAL_TIMER_RATE         (FTM0_TIMER_RATE)
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-
-#define TEMP_TIMER_FREQUENCY    1000
-
-#define STEPPER_TIMER_RATE     HAL_TIMER_RATE
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000)
-#define STEPPER_TIMER_PRESCALE (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() extern "C" void ftm0_isr() //void TC3_Handler()
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() extern "C" void ftm1_isr() //void TC4_Handler()
-#endif
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: FTM0_C0V = compare; break;
-    case MF_TIMER_TEMP: FTM1_C0V = compare; break;
-  }
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return FTM0_C0V;
-    case MF_TIMER_TEMP: return FTM1_C0V;
-  }
-  return 0;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return FTM0_CNT;
-    case MF_TIMER_TEMP: return FTM1_CNT;
-  }
-  return 0;
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-void HAL_timer_isr_prologue(const uint8_t timer_num);
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/TEENSY35_36/HAL.cpp b/Marlin/src/HAL/TEENSY35_36/HAL.cpp
deleted file mode 100644
index bc02ac1..0000000
--- a/Marlin/src/HAL/TEENSY35_36/HAL.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
-
-#include "HAL.h"
-#include "../shared/Delay.h"
-
-#include <Wire.h>
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#define _IMPLEMENT_SERIAL(X) DefaultSerial##X MSerial##X(false, Serial##X)
-#define IMPLEMENT_SERIAL(X)  _IMPLEMENT_SERIAL(X)
-#if WITHIN(SERIAL_PORT, 0, 3)
-  IMPLEMENT_SERIAL(SERIAL_PORT);
-#endif
-
-USBSerialType USBSerial(false, SerialUSB);
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-void MarlinHAL::reboot() { _reboot_Teensyduino_(); }
-
-uint8_t MarlinHAL::get_reset_source() {
-  switch (RCM_SRS0) {
-    case 128: return RST_POWER_ON; break;
-    case 64: return RST_EXTERNAL; break;
-    case 32: return RST_WATCHDOG; break;
-    // case 8: return RST_LOSS_OF_LOCK; break;
-    // case 4: return RST_LOSS_OF_CLOCK; break;
-    // case 2: return RST_LOW_VOLTAGE; break;
-  }
-  return 0;
-}
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  #define WDT_TIMEOUT_MS TERN(WATCHDOG_DURATION_8S, 8000, 4000) // 4 or 8 second timeout
-
-  void MarlinHAL::watchdog_init() {
-    WDOG_TOVALH = 0;
-    WDOG_TOVALL = WDT_TIMEOUT_MS;
-    WDOG_STCTRLH = WDOG_STCTRLH_WDOGEN;
-  }
-
-  void MarlinHAL::watchdog_refresh() {
-    // Watchdog refresh sequence
-    WDOG_REFRESH = 0xA602;
-    WDOG_REFRESH = 0xB480;
-  }
-
-#endif
-
-// ------------------------
-// ADC
-// ------------------------
-
-int8_t MarlinHAL::adc_select;
-
-void MarlinHAL::adc_init() {
-  analog_init();
-  while (ADC0_SC3 & ADC_SC3_CAL) { /* Wait for calibration to finish */ }
-  while (ADC1_SC3 & ADC_SC3_CAL) { /* Wait for calibration to finish */ }
-  NVIC_ENABLE_IRQ(IRQ_FTM1);
-}
-
-void MarlinHAL::adc_start(const pin_t adc_pin) {
-  static const uint8_t pin2sc1a[] = {
-    5, 14, 8, 9, 13, 12, 6, 7, 15, 4, 3, 19+128, 14+128, 15+128, // 0-13 -> A0-A13
-    5, 14, 8, 9, 13, 12, 6, 7, 15, 4, // 14-23 are A0-A9
-    255, 255, 255, 255, 255, 255, 255, // 24-30 are digital only
-    14+128, 15+128, 17, 18, 4+128, 5+128, 6+128, 7+128, 17+128,  // 31-39 are A12-A20
-    255, 255, 255, 255, 255, 255, 255, 255, 255,  // 40-48 are digital only
-    10+128, 11+128, // 49-50 are A23-A24
-    255, 255, 255, 255, 255, 255, 255, // 51-57 are digital only
-    255, 255, 255, 255, 255, 255, // 58-63 (sd card pins) are digital only
-    3, 19+128, // 64-65 are A10-A11
-    23, 23+128,// 66-67 are A21-A22 (DAC pins)
-    1, 1+128,  // 68-69 are A25-A26 (unused USB host port on Teensy 3.5)
-    26,        // 70 is Temperature Sensor
-    18+128     // 71 is Vref
-  };
-  const uint16_t pin = pin2sc1a[adc_pin];
-  if (pin == 0xFF) {
-    adc_select = -1;    // Digital only
-  }
-  else if (pin & 0x80) {
-    adc_select = 1;
-    ADC1_SC1A = pin & 0x7F;
-  }
-  else {
-    adc_select = 0;
-    ADC0_SC1A = pin;
-  }
-}
-
-uint16_t MarlinHAL::adc_value() {
-  switch (adc_select) {
-    case 0: return ADC0_RA;
-    case 1: return ADC1_RA;
-  }
-  return 0;
-}
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-extern "C" {
-  extern char __bss_end;
-  extern char __heap_start;
-  extern void* __brkval;
-
-  int freeMemory() {
-    int free_memory;
-    if ((int)__brkval == 0)
-      free_memory = ((int)&free_memory) - ((int)&__bss_end);
-    else
-      free_memory = ((int)&free_memory) - ((int)__brkval);
-    return free_memory;
-  }
-}
-
-#endif // __MK64FX512__ || __MK66FX1M0__
diff --git a/Marlin/src/HAL/TEENSY35_36/HAL.h b/Marlin/src/HAL/TEENSY35_36/HAL.h
deleted file mode 100644
index 2a192e4..0000000
--- a/Marlin/src/HAL/TEENSY35_36/HAL.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#define CPU_32_BIT
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-
-#include "fastio.h"
-
-#include <stdint.h>
-#include <util/atomic.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define IS_32BIT_TEENSY 1
-#define IS_TEENSY_35_36 1
-#ifdef __MK66FX1M0__
-  #define IS_TEENSY36 1
-#else // __MK64FX512__
-  #define IS_TEENSY35 1
-#endif
-
-#define CPU_ST7920_DELAY_1 600
-#define CPU_ST7920_DELAY_2 750
-#define CPU_ST7920_DELAY_3 750
-
-#undef sq
-#define sq(x) ((x)*(x))
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#include "../../core/serial_hook.h"
-
-#define Serial0 Serial
-#define _DECLARE_SERIAL(X) \
-  typedef ForwardSerial1Class<decltype(Serial##X)> DefaultSerial##X; \
-  extern DefaultSerial##X MSerial##X
-#define DECLARE_SERIAL(X) _DECLARE_SERIAL(X)
-
-typedef ForwardSerial1Class<decltype(SerialUSB)> USBSerialType;
-extern USBSerialType USBSerial;
-
-#define _MSERIAL(X) MSerial##X
-#define MSERIAL(X) _MSERIAL(X)
-
-#if SERIAL_PORT == -1
-  #define MYSERIAL1 USBSerial
-#elif WITHIN(SERIAL_PORT, 0, 3)
-  #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-  DECLARE_SERIAL(SERIAL_PORT);
-#else
-  #error "SERIAL_PORT must be from 0 to 3, or -1 for Native USB."
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-class libServo;
-typedef libServo hal_servo_t;
-
-typedef int8_t pin_t;
-
-// ------------------------
-// Interrupts
-// ------------------------
-
-#define CRITICAL_SECTION_START()  const bool irqon = !__get_primask(); __disable_irq()
-#define CRITICAL_SECTION_END()    if (irqon) __enable_irq()
-
-// ------------------------
-// ADC
-// ------------------------
-
-#ifndef analogInputToDigitalPin
-  #define analogInputToDigitalPin(p) ((p < 12U) ? (p) + 54U : -1)
-#endif
-
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-extern "C" int freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init() {}        // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return true; }
-  static void isr_on()  { __enable_irq(); }
-  static void isr_off() { __disable_irq(); }
-
-  static void delay_ms(const int ms) { delay(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source() {}
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  static int8_t adc_select;
-
-  // Called by Temperature::init once at startup
-  static void adc_init();
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const pin_t) {}
-
-  // Begin ADC sampling on the given pin. Called from Temperature::isr!
-  static void adc_start(const pin_t pin);
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value();
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No option to invert the duty cycle [default = false]
-   * No option to change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-};
diff --git a/Marlin/src/HAL/TEENSY35_36/HAL_SPI.cpp b/Marlin/src/HAL/TEENSY35_36/HAL_SPI.cpp
deleted file mode 100644
index d80f57b..0000000
--- a/Marlin/src/HAL/TEENSY35_36/HAL_SPI.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL SPI for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-#include <SPI.h>
-#include <pins_arduino.h>
-#include "spi_pins.h"
-
-static SPISettings spiConfig;
-
-void spiBegin() {
-  #if PIN_EXISTS(SD_SS)
-    OUT_WRITE(SD_SS_PIN, HIGH);
-  #endif
-  SET_OUTPUT(SD_SCK_PIN);
-  SET_INPUT(SD_MISO_PIN);
-  SET_OUTPUT(SD_MOSI_PIN);
-
-  #if 0 && DISABLED(SOFTWARE_SPI)
-    // set SS high - may be chip select for another SPI device
-    #if SET_SPI_SS_HIGH
-      WRITE(SD_SS_PIN, HIGH);
-    #endif
-    // set a default rate
-    spiInit(SPI_HALF_SPEED); // 1
-  #endif
-}
-
-void spiInit(uint8_t spiRate) {
-  // Use Marlin data-rates
-  uint32_t clock;
-  switch (spiRate) {
-  case SPI_FULL_SPEED:    clock = 10000000; break;
-  case SPI_HALF_SPEED:    clock =  5000000; break;
-  case SPI_QUARTER_SPEED: clock =  2500000; break;
-  case SPI_EIGHTH_SPEED:  clock =  1250000; break;
-  case SPI_SPEED_5:       clock =   625000; break;
-  case SPI_SPEED_6:       clock =   312500; break;
-  default:
-    clock = 4000000; // Default from the SPI library
-  }
-  spiConfig = SPISettings(clock, MSBFIRST, SPI_MODE0);
-  SPI.begin();
-}
-
-uint8_t spiRec() {
-  SPI.beginTransaction(spiConfig);
-  uint8_t returnByte = SPI.transfer(0xFF);
-  SPI.endTransaction();
-  return returnByte;
-  //SPDR = 0xFF;
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //return SPDR;
-}
-
-void spiRead(uint8_t *buf, uint16_t nbyte) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(buf, nbyte);
-  SPI.endTransaction();
-  //if (nbyte-- == 0) return;
-  //  SPDR = 0xFF;
-  //for (uint16_t i = 0; i < nbyte; i++) {
-  //  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //  buf[i] = SPDR;
-  //  SPDR = 0xFF;
-  //}
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //buf[nbyte] = SPDR;
-}
-
-void spiSend(uint8_t b) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(b);
-  SPI.endTransaction();
-  //SPDR = b;
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-}
-
-void spiSendBlock(uint8_t token, const uint8_t *buf) {
-  SPI.beginTransaction(spiConfig);
-  SPDR = token;
-  for (uint16_t i = 0; i < 512; i += 2) {
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i];
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i + 1];
-  }
-  while (!TEST(SPSR, SPIF)) { /* nada */ };
-  SPI.endTransaction();
-}
-
-// Begin SPI transaction, set clock, bit order, data mode
-void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-  spiConfig = SPISettings(spiClock, bitOrder, dataMode);
-  SPI.beginTransaction(spiConfig);
-}
-
-#endif // __MK64FX512__ || __MK66FX1M0__
diff --git a/Marlin/src/HAL/TEENSY35_36/MarlinSPI.h b/Marlin/src/HAL/TEENSY35_36/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/TEENSY35_36/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/TEENSY35_36/Servo.cpp b/Marlin/src/HAL/TEENSY35_36/Servo.cpp
deleted file mode 100644
index 0338585..0000000
--- a/Marlin/src/HAL/TEENSY35_36/Servo.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Servo for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "Servo.h"
-
-uint8_t servoPin[MAX_SERVOS] = { 0 };
-
-int8_t libServo::attach(const int inPin) {
-  if (servoIndex >= MAX_SERVOS) return -1;
-  if (inPin > 0) servoPin[servoIndex] = inPin;
-  return super::attach(servoPin[servoIndex]);
-}
-
-int8_t libServo::attach(const int inPin, const int inMin, const int inMax) {
-  if (inPin > 0) servoPin[servoIndex] = inPin;
-  return super::attach(servoPin[servoIndex], inMin, inMax);
-}
-
-void libServo::move(const int value) {
-  constexpr uint16_t servo_delay[] = SERVO_DELAY;
-  static_assert(COUNT(servo_delay) == NUM_SERVOS, "SERVO_DELAY must be an array NUM_SERVOS long.");
-  if (attach(0) >= 0) {
-    write(value);
-    safe_delay(servo_delay[servoIndex]);
-    TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());
-  }
-}
-
-#endif // HAS_SERVOS
-#endif // __MK64FX512__ || __MK66FX1M0__
diff --git a/Marlin/src/HAL/TEENSY35_36/Servo.h b/Marlin/src/HAL/TEENSY35_36/Servo.h
deleted file mode 100644
index 719011f..0000000
--- a/Marlin/src/HAL/TEENSY35_36/Servo.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Servo for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#include <Servo.h>
-
-// Inherit and expand on core Servo library
-class libServo : public Servo {
-  public:
-    int8_t attach(const int pin);
-    int8_t attach(const int pin, const int min, const int max);
-    void move(const int value);
-  private:
-    typedef Servo super;
-    uint16_t min_ticks;
-    uint16_t max_ticks;
-    uint8_t servoIndex; // Index into the channel data for this servo
-};
diff --git a/Marlin/src/HAL/TEENSY35_36/eeprom.cpp b/Marlin/src/HAL/TEENSY35_36/eeprom.cpp
deleted file mode 100644
index b80e93b..0000000
--- a/Marlin/src/HAL/TEENSY35_36/eeprom.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- * Copyright (c) 2016 Victor Perez victor_pv@hotmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
-
-/**
- * HAL PersistentStore for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-#include "../shared/eeprom_api.h"
-#include <avr/eeprom.h>
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-#endif
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // __MK64FX512__ || __MK66FX1M0__
diff --git a/Marlin/src/HAL/TEENSY35_36/endstop_interrupts.h b/Marlin/src/HAL/TEENSY35_36/endstop_interrupts.h
deleted file mode 100644
index 48d3bbb..0000000
--- a/Marlin/src/HAL/TEENSY35_36/endstop_interrupts.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Endstop Interrupts for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-/**
- * Endstop interrupts for Due based targets.
- * On Due, all pins support external interrupt capability.
- */
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  TERN_(HAS_X_MAX, _ATTACH(X_MAX_PIN));
-  TERN_(HAS_X_MIN, _ATTACH(X_MIN_PIN));
-  TERN_(HAS_Y_MAX, _ATTACH(Y_MAX_PIN));
-  TERN_(HAS_Y_MIN, _ATTACH(Y_MIN_PIN));
-  TERN_(HAS_Z_MAX, _ATTACH(Z_MAX_PIN));
-  TERN_(HAS_Z_MIN, _ATTACH(Z_MIN_PIN));
-  TERN_(HAS_X2_MAX, _ATTACH(X2_MAX_PIN));
-  TERN_(HAS_X2_MIN, _ATTACH(X2_MIN_PIN));
-  TERN_(HAS_Y2_MAX, _ATTACH(Y2_MAX_PIN));
-  TERN_(HAS_Y2_MIN, _ATTACH(Y2_MIN_PIN));
-  TERN_(HAS_Z2_MAX, _ATTACH(Z2_MAX_PIN));
-  TERN_(HAS_Z2_MIN, _ATTACH(Z2_MIN_PIN));
-  TERN_(HAS_Z3_MAX, _ATTACH(Z3_MAX_PIN));
-  TERN_(HAS_Z3_MIN, _ATTACH(Z3_MIN_PIN));
-  TERN_(HAS_Z4_MAX, _ATTACH(Z4_MAX_PIN));
-  TERN_(HAS_Z4_MIN, _ATTACH(Z4_MIN_PIN));
-  TERN_(HAS_Z_MIN_PROBE_PIN, _ATTACH(Z_MIN_PROBE_PIN));
-  TERN_(HAS_I_MAX, _ATTACH(I_MAX_PIN));
-  TERN_(HAS_I_MIN, _ATTACH(I_MIN_PIN));
-  TERN_(HAS_J_MAX, _ATTACH(J_MAX_PIN));
-  TERN_(HAS_J_MIN, _ATTACH(J_MIN_PIN));
-  TERN_(HAS_K_MAX, _ATTACH(K_MAX_PIN));
-  TERN_(HAS_K_MIN, _ATTACH(K_MIN_PIN));
-  TERN_(HAS_U_MAX, _ATTACH(U_MAX_PIN));
-  TERN_(HAS_U_MIN, _ATTACH(U_MIN_PIN));
-  TERN_(HAS_V_MAX, _ATTACH(V_MAX_PIN));
-  TERN_(HAS_V_MIN, _ATTACH(V_MIN_PIN));
-  TERN_(HAS_W_MAX, _ATTACH(W_MAX_PIN));
-  TERN_(HAS_W_MIN, _ATTACH(W_MIN_PIN));
-}
diff --git a/Marlin/src/HAL/TEENSY35_36/fastio.h b/Marlin/src/HAL/TEENSY35_36/fastio.h
deleted file mode 100644
index 622799e..0000000
--- a/Marlin/src/HAL/TEENSY35_36/fastio.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O Routines for Teensy 3.5 and Teensy 3.6
- * Use direct port manipulation to save scads of processor time.
- * Contributed by Triffid_Hunter and modified by Kliment, thinkyhead, Bob-the-Kuhn, et.al.
- */
-
-#ifndef MASK
-  #define MASK(PIN) _BV(PIN)
-#endif
-
-#define GPIO_BITBAND_ADDR(reg, bit) (((uint32_t)&(reg) - 0x40000000) * 32 + (bit) * 4 + 0x42000000)
-#define GPIO_BITBAND(reg, bit) (*(uint32_t *)GPIO_BITBAND_ADDR((reg), (bit)))
-
-/**
- * Magic I/O routines
- *
- * Now you can simply SET_OUTPUT(PIN); WRITE(PIN, HIGH); WRITE(PIN, LOW);
- *
- * Why double up on these macros? see https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html
- */
-
-#define _READ(P) bool(CORE_PIN ## P ## _PINREG & CORE_PIN ## P ## _BITMASK)
-
-#define _WRITE(P,V) do{ \
-  if (V) CORE_PIN ## P ## _PORTSET = CORE_PIN ## P ## _BITMASK; \
-  else CORE_PIN ## P ## _PORTCLEAR = CORE_PIN ## P ## _BITMASK; \
-}while(0)
-
-#define _TOGGLE(P) (*(&(CORE_PIN ## P ## _PORTCLEAR)+1) = CORE_PIN ## P ## _BITMASK)
-
-#define _SET_INPUT(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1); \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 0; \
-}while(0)
-
-#define _SET_OUTPUT(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1)|PORT_PCR_SRE|PORT_PCR_DSE; \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 1; \
-}while(0)
-
-#define _SET_INPUT_PULLUP(P) do{ \
-  CORE_PIN ## P ## _CONFIG = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS; \
-  GPIO_BITBAND(CORE_PIN ## P ## _DDRREG , CORE_PIN ## P ## _BIT) = 0; \
-}while(0)
-
-#define _IS_INPUT(P)    ((CORE_PIN ## P ## _DDRREG & CORE_PIN ## P ## _BITMASK) == 0)
-#define _IS_OUTPUT(P)   ((CORE_PIN ## P ## _DDRREG & CORE_PIN ## P ## _BITMASK) == 0)
-
-#define READ(IO)              _READ(IO)
-
-#define WRITE(IO,V)           _WRITE(IO,V)
-#define TOGGLE(IO)            _TOGGLE(IO)
-
-#define SET_INPUT(IO)         _SET_INPUT(IO)
-#define SET_INPUT_PULLUP(IO)  _SET_INPUT_PULLUP(IO)
-#define SET_INPUT_PULLDOWN    SET_INPUT
-#define SET_OUTPUT(IO)        _SET_OUTPUT(IO)
-#define SET_PWM               SET_OUTPUT
-
-#define IS_INPUT(IO)          _IS_INPUT(IO)
-#define IS_OUTPUT(IO)         _IS_OUTPUT(IO)
-
-#define OUT_WRITE(IO,V)       do{ SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
-
-#define PWM_PIN(P)            digitalPinHasPWM(P)
-
-/**
- * Ports, functions, and pins
- */
-
-#define DIO0_PIN 8
diff --git a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_LCD.h b/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_LCD.h
deleted file mode 100644
index 632ee53..0000000
--- a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/TEENSY35_36."
-#endif
diff --git a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_adv.h b/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_post.h b/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_post.h
deleted file mode 100644
index 998f1dc..0000000
--- a/Marlin/src/HAL/TEENSY35_36/inc/Conditionals_post.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define USE_WIRED_EEPROM 1
-#endif
diff --git a/Marlin/src/HAL/TEENSY35_36/inc/SanityCheck.h b/Marlin/src/HAL/TEENSY35_36/inc/SanityCheck.h
deleted file mode 100644
index 3308707..0000000
--- a/Marlin/src/HAL/TEENSY35_36/inc/SanityCheck.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test TEENSY35_36 specific configuration values for errors at compile-time.
- */
-
-#if ENABLED(EMERGENCY_PARSER)
-  #error "EMERGENCY_PARSER is not yet implemented for Teensy 3.5/3.6. Disable EMERGENCY_PARSER to continue."
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on Teensy 3.5/3.6."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on Teensy 3.5/3.6."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on Teensy 3.5/3.6."
-#endif
-
-#if USING_PULLDOWNS
-  #error "PULLDOWN pin mode is not available on Teensy 3.5/3.6 boards."
-#endif
diff --git a/Marlin/src/HAL/TEENSY35_36/pinsDebug.h b/Marlin/src/HAL/TEENSY35_36/pinsDebug.h
deleted file mode 100644
index 7a2e1d6..0000000
--- a/Marlin/src/HAL/TEENSY35_36/pinsDebug.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Pins Debugging for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#define NUMBER_PINS_TOTAL NUM_DIGITAL_PINS
-#define MULTI_NAME_PAD 16 // space needed to be pretty if not first name assigned to a pin
-
-#define FTM0_CH0_PIN 22
-#define FTM0_CH1_PIN 23
-#define FTM0_CH2_PIN  9
-#define FTM0_CH3_PIN 10
-#define FTM0_CH4_PIN  6
-#define FTM0_CH5_PIN 20
-#define FTM0_CH6_PIN 21
-#define FTM0_CH7_PIN  5
-#define FTM1_CH0_PIN  3
-#define FTM1_CH1_PIN  4
-#define FTM2_CH0_PIN 29
-#define FTM2_CH1_PIN 30
-#define FTM3_CH0_PIN  2
-#define FTM3_CH1_PIN 14
-#define FTM3_CH2_PIN  7
-#define FTM3_CH3_PIN  8
-#define FTM3_CH4_PIN 35
-#define FTM3_CH5_PIN 36
-#define FTM3_CH6_PIN 37
-#define FTM3_CH7_PIN 38
-#ifdef __MK66FX1M0__ // Teensy3.6
-  #define TPM1_CH0_PIN 16
-  #define TPM1_CH1_PIN 17
-#endif
-
-#define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && (P) <= analogInputToDigitalPin(9)) || ((P) >= analogInputToDigitalPin(12) && (P) <= analogInputToDigitalPin(20))
-
-void HAL_print_analog_pin(char buffer[], int8_t pin) {
-  if (pin <= 23)      sprintf_P(buffer, PSTR("(A%2d)  "), int(pin - 14));
-  else if (pin <= 39) sprintf_P(buffer, PSTR("(A%2d)  "), int(pin - 19));
-}
-
-void HAL_analog_pin_state(char buffer[], int8_t pin) {
-  if (pin <= 23)      sprintf_P(buffer, PSTR("Analog in =% 5d"), analogRead(pin - 14));
-  else if (pin <= 39) sprintf_P(buffer, PSTR("Analog in =% 5d"), analogRead(pin - 19));
-}
-
-#define PWM_PRINT(V) do{ sprintf_P(buffer, PSTR("PWM:  %4d"), 22); SERIAL_ECHO(buffer); }while(0)
-#define FTM_CASE(N,Z) \
-  case FTM##N##_CH##Z##_PIN: \
-    if (FTM##N##_C##Z##V) { \
-      PWM_PRINT(FTM##N##_C##Z##V); \
-      return true; \
-    } else return false
-
-/**
- * Print a pin's PWM status.
- * Return true if it's currently a PWM pin.
- */
-bool HAL_pwm_status(int8_t pin) {
-  char buffer[20];   // for the sprintf statements
-  switch (pin) {
-    FTM_CASE(0,0);
-    FTM_CASE(0,1);
-    FTM_CASE(0,2);
-    FTM_CASE(0,3);
-    FTM_CASE(0,4);
-    FTM_CASE(0,5);
-    FTM_CASE(0,6);
-    FTM_CASE(0,7);
-    FTM_CASE(1,0);
-    FTM_CASE(1,1);
-    FTM_CASE(2,0);
-    FTM_CASE(2,1);
-    FTM_CASE(3,0);
-    FTM_CASE(3,1);
-    FTM_CASE(3,2);
-    FTM_CASE(3,3);
-    FTM_CASE(3,4);
-    FTM_CASE(3,5);
-    FTM_CASE(3,6);
-    FTM_CASE(3,7);
-
-    case NOT_ON_TIMER:
-    default:
-      return false;
-  }
-  SERIAL_ECHOPGM("  ");
-}
-
-static void HAL_pwm_details(uint8_t pin) { /* TODO */ }
diff --git a/Marlin/src/HAL/TEENSY35_36/spi_pins.h b/Marlin/src/HAL/TEENSY35_36/spi_pins.h
deleted file mode 100644
index cfffdc9..0000000
--- a/Marlin/src/HAL/TEENSY35_36/spi_pins.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL SPI Pins for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#define SD_SCK_PIN   13
-#define SD_MISO_PIN  12
-#define SD_MOSI_PIN  11
-#define SD_SS_PIN 20 // SDSS // A.28, A.29, B.21, C.26, C.29
diff --git a/Marlin/src/HAL/TEENSY35_36/timers.cpp b/Marlin/src/HAL/TEENSY35_36/timers.cpp
deleted file mode 100644
index 39095fb..0000000
--- a/Marlin/src/HAL/TEENSY35_36/timers.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Timers for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
-
-#include "../../inc/MarlinConfig.h"
-
-/** \brief Instruction Synchronization Barrier
-  Instruction Synchronization Barrier flushes the pipeline in the processor,
-  so that all instructions following the ISB are fetched from cache or
-  memory, after the instruction has been completed.
-*/
-FORCE_INLINE static void __ISB() {
-  __asm__ __volatile__("isb 0xF":::"memory");
-}
-
-/** \brief Data Synchronization Barrier
-  This function acts as a special kind of Data Memory Barrier.
-  It completes when all explicit memory accesses before this instruction complete.
-*/
-FORCE_INLINE static void __DSB() {
-  __asm__ __volatile__("dsb 0xF":::"memory");
-}
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      FTM0_MODE = FTM_MODE_WPDIS | FTM_MODE_FTMEN;
-      FTM0_SC = 0x00; // Set this to zero before changing the modulus
-      FTM0_CNT = 0x0000; // Reset the count to zero
-      FTM0_MOD = 0xFFFF; // max modulus = 65535
-      FTM0_C0V = (FTM0_TIMER_RATE) / frequency; // Initial FTM Channel 0 compare value
-      FTM0_SC = (FTM_SC_CLKS(0b1) & FTM_SC_CLKS_MASK) | (FTM_SC_PS(FTM0_TIMER_PRESCALE_BITS) & FTM_SC_PS_MASK); // Bus clock 60MHz divided by prescaler 8
-      FTM0_C0SC = FTM_CSC_CHIE | FTM_CSC_MSA | FTM_CSC_ELSA;
-      break;
-    case MF_TIMER_TEMP:
-      FTM1_MODE = FTM_MODE_WPDIS | FTM_MODE_FTMEN; // Disable write protection, Enable FTM1
-      FTM1_SC = 0x00; // Set this to zero before changing the modulus
-      FTM1_CNT = 0x0000; // Reset the count to zero
-      FTM1_MOD = 0xFFFF; // max modulus = 65535
-      FTM1_C0V = (FTM1_TIMER_RATE) / frequency; // Initial FTM Channel 0 compare value 65535
-      FTM1_SC = (FTM_SC_CLKS(0b1) & FTM_SC_CLKS_MASK) | (FTM_SC_PS(FTM1_TIMER_PRESCALE_BITS) & FTM_SC_PS_MASK); // Bus clock 60MHz divided by prescaler 4
-      FTM1_C0SC = FTM_CSC_CHIE | FTM_CSC_MSA | FTM_CSC_ELSA;
-      break;
-  }
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_ENABLE_IRQ(IRQ_FTM0); break;
-    case MF_TIMER_TEMP: NVIC_ENABLE_IRQ(IRQ_FTM1); break;
-  }
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_DISABLE_IRQ(IRQ_FTM0); break;
-    case MF_TIMER_TEMP: NVIC_DISABLE_IRQ(IRQ_FTM1); break;
-  }
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  __DSB();
-  __ISB();
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return NVIC_IS_ENABLED(IRQ_FTM0);
-    case MF_TIMER_TEMP: return NVIC_IS_ENABLED(IRQ_FTM1);
-  }
-  return false;
-}
-
-void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      FTM0_CNT = 0x0000;
-      FTM0_SC &= ~FTM_SC_TOF; // Clear FTM Overflow flag
-      FTM0_C0SC &= ~FTM_CSC_CHF; // Clear FTM Channel Compare flag
-      break;
-    case MF_TIMER_TEMP:
-      FTM1_CNT = 0x0000;
-      FTM1_SC &= ~FTM_SC_TOF; // Clear FTM Overflow flag
-      FTM1_C0SC &= ~FTM_CSC_CHF; // Clear FTM Channel Compare flag
-      break;
-  }
-}
-
-#endif // Teensy3.5 or Teensy3.6
diff --git a/Marlin/src/HAL/TEENSY35_36/timers.h b/Marlin/src/HAL/TEENSY35_36/timers.h
deleted file mode 100644
index 8af79d7..0000000
--- a/Marlin/src/HAL/TEENSY35_36/timers.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Timers for Teensy 3.5 (MK64FX512) and Teensy 3.6 (MK66FX1M0)
- */
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFF
-
-#define FTM0_TIMER_PRESCALE 8
-#define FTM1_TIMER_PRESCALE 4
-#define FTM0_TIMER_PRESCALE_BITS 0b011
-#define FTM1_TIMER_PRESCALE_BITS 0b010
-
-#define FTM0_TIMER_RATE (F_BUS / FTM0_TIMER_PRESCALE) // 60MHz / 8 = 7500kHz
-#define FTM1_TIMER_RATE (F_BUS / FTM1_TIMER_PRESCALE) // 60MHz / 4 = 15MHz
-
-#define HAL_TIMER_RATE         (FTM0_TIMER_RATE)
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-
-#define TEMP_TIMER_FREQUENCY    1000
-
-#define STEPPER_TIMER_RATE     HAL_TIMER_RATE
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000)
-#define STEPPER_TIMER_PRESCALE (CYCLES_PER_MICROSECOND / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() extern "C" void ftm0_isr() //void TC3_Handler()
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() extern "C" void ftm1_isr() //void TC4_Handler()
-#endif
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: FTM0_C0V = compare; break;
-    case MF_TIMER_TEMP: FTM1_C0V = compare; break;
-  }
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return FTM0_C0V;
-    case MF_TIMER_TEMP: return FTM1_C0V;
-  }
-  return 0;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return FTM0_CNT;
-    case MF_TIMER_TEMP: return FTM1_CNT;
-  }
-  return 0;
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-void HAL_timer_isr_prologue(const uint8_t timer_num);
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/Marlin/src/HAL/TEENSY40_41/HAL.cpp b/Marlin/src/HAL/TEENSY40_41/HAL.cpp
deleted file mode 100644
index 1d02ab8..0000000
--- a/Marlin/src/HAL/TEENSY40_41/HAL.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL for Teensy 4.0 / 4.1 (IMXRT1062)
- */
-
-#ifdef __IMXRT1062__
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-#include "../shared/Delay.h"
-#include "timers.h"
-#include <Wire.h>
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#define _IMPLEMENT_SERIAL(X) DefaultSerial##X MSerial##X(false, Serial##X)
-#define IMPLEMENT_SERIAL(X)  _IMPLEMENT_SERIAL(X)
-#if WITHIN(SERIAL_PORT, 0, 3)
-  IMPLEMENT_SERIAL(SERIAL_PORT);
-#endif
-USBSerialType USBSerial(false, SerialUSB);
-
-// ------------------------
-// FastIO
-// ------------------------
-
-bool is_output(pin_t pin) {
-  const struct digital_pin_bitband_and_config_table_struct *p;
-  p = digital_pin_to_info_PGM + pin;
-  return (*(p->reg + 1) & p->mask);
-}
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-void MarlinHAL::reboot() { _reboot_Teensyduino_(); }
-
-uint8_t MarlinHAL::get_reset_source() {
-  switch (SRC_SRSR & 0xFF) {
-    case 1: return RST_POWER_ON; break;
-    case 2: return RST_SOFTWARE; break;
-    case 4: return RST_EXTERNAL; break;
-    //case 8: return RST_BROWN_OUT; break;
-    case 16: return RST_WATCHDOG; break;
-    case 64: return RST_JTAG; break;
-    //case 128: return RST_OVERTEMP; break;
-  }
-  return 0;
-}
-
-void MarlinHAL::clear_reset_source() {
-  uint32_t reset_source = SRC_SRSR;
-  SRC_SRSR = reset_source;
-}
-
-// ------------------------
-// Watchdog Timer
-// ------------------------
-
-#if ENABLED(USE_WATCHDOG)
-
-  #define WDT_TIMEOUT TERN(WATCHDOG_DURATION_8S, 8, 4) // 4 or 8 second timeout
-
-  constexpr uint8_t timeoutval = (WDT_TIMEOUT - 0.5f) / 0.5f;
-
-  void MarlinHAL::watchdog_init() {
-    CCM_CCGR3 |= CCM_CCGR3_WDOG1(3);  // enable WDOG1 clocks
-    WDOG1_WMCR = 0;                   // disable power down PDE
-    WDOG1_WCR |= WDOG_WCR_SRS | WDOG_WCR_WT(timeoutval);
-    WDOG1_WCR |= WDOG_WCR_WDE | WDOG_WCR_WDT | WDOG_WCR_SRE;
-  }
-
-  void MarlinHAL::watchdog_refresh() {
-    // Watchdog refresh sequence
-    WDOG1_WSR = 0x5555;
-    WDOG1_WSR = 0xAAAA;
-  }
-
-#endif
-
-// ------------------------
-// ADC
-// ------------------------
-
-int8_t MarlinHAL::adc_select;
-
-void MarlinHAL::adc_init() {
-  analog_init();
-  while (ADC1_GC & ADC_GC_CAL) { /* wait */ }
-  while (ADC2_GC & ADC_GC_CAL) { /* wait */ }
-}
-
-void MarlinHAL::adc_start(const pin_t adc_pin) {
-  static const uint8_t pin2sc1a[] = {
-    0x07,  // 0/A0  AD_B1_02
-    0x08,  // 1/A1  AD_B1_03
-    0x0C,  // 2/A2  AD_B1_07
-    0x0B,  // 3/A3  AD_B1_06
-    0x06,  // 4/A4  AD_B1_01
-    0x05,  // 5/A5  AD_B1_00
-    0x0F,  // 6/A6  AD_B1_10
-    0x00,  // 7/A7  AD_B1_11
-    0x0D,  // 8/A8  AD_B1_08
-    0x0E,  // 9/A9  AD_B1_09
-    0x01,  // 24/A10 AD_B0_12
-    0x02,  // 25/A11 AD_B0_13
-    0x83,  // 26/A12 AD_B1_14 - only on ADC2, 3
-    0x84,  // 27/A13 AD_B1_15 - only on ADC2, 4
-    0x07,  // 14/A0  AD_B1_02
-    0x08,  // 15/A1  AD_B1_03
-    0x0C,  // 16/A2  AD_B1_07
-    0x0B,  // 17/A3  AD_B1_06
-    0x06,  // 18/A4  AD_B1_01
-    0x05,  // 19/A5  AD_B1_00
-    0x0F,  // 20/A6  AD_B1_10
-    0x00,  // 21/A7  AD_B1_11
-    0x0D,  // 22/A8  AD_B1_08
-    0x0E,  // 23/A9  AD_B1_09
-    0x01,  // 24/A10 AD_B0_12
-    0x02,  // 25/A11 AD_B0_13
-    0x83,  // 26/A12 AD_B1_14 - only on ADC2, 3
-    0x84,  // 27/A13 AD_B1_15 - only on ADC2, 4
-    #ifdef ARDUINO_TEENSY41
-      0xFF,  // 28
-      0xFF,  // 29
-      0xFF,  // 30
-      0xFF,  // 31
-      0xFF,  // 32
-      0xFF,  // 33
-      0xFF,  // 34
-      0xFF,  // 35
-      0xFF,  // 36
-      0xFF,  // 37
-      0x81,  // 38/A14 AD_B1_12 - only on ADC2, 1
-      0x82,  // 39/A15 AD_B1_13 - only on ADC2, 2
-      0x09,  // 40/A16 AD_B1_04
-      0x0A,  // 41/A17 AD_B1_05
-    #endif
-  };
-  const uint16_t pin = pin2sc1a[adc_pin];
-  if (pin == 0xFF) {
-    adc_select = -1; // Digital only
-  }
-  else if (pin & 0x80) {
-    adc_select = 1;
-    ADC2_HC0 = pin & 0x7F;
-  }
-  else {
-    adc_select = 0;
-    ADC1_HC0 = pin;
-  }
-}
-
-uint16_t MarlinHAL::adc_value() {
-  switch (adc_select) {
-    case 0:
-      while (!(ADC1_HS & ADC_HS_COCO0)) { /* wait */ }
-      return ADC1_R0;
-    case 1:
-      while (!(ADC2_HS & ADC_HS_COCO0)) { /* wait */ }
-      return ADC2_R0;
-  }
-  return 0;
-}
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#define __bss_end _ebss
-
-extern "C" {
-  extern char __bss_end;
-  extern char __heap_start;
-  extern void* __brkval;
-
-  // Doesn't work on Teensy 4.x
-  uint32_t freeMemory() {
-    uint32_t free_memory;
-    free_memory = ((uint32_t)&free_memory) - (((uint32_t)__brkval) ?: ((uint32_t)&__bss_end));
-    return free_memory;
-  }
-}
-
-#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/HAL.h b/Marlin/src/HAL/TEENSY40_41/HAL.h
deleted file mode 100644
index c54a2e8..0000000
--- a/Marlin/src/HAL/TEENSY40_41/HAL.h
+++ /dev/null
@@ -1,219 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#define CPU_32_BIT
-
-#include "../shared/Marduino.h"
-#include "../shared/math_32bit.h"
-#include "../shared/HAL_SPI.h"
-
-#include "fastio.h"
-
-#include <stdint.h>
-#include <util/atomic.h>
-
-#if HAS_ETHERNET
-  #include "../../feature/ethernet.h"
-#endif
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define IS_32BIT_TEENSY 1
-#define IS_TEENSY_40_41 1
-#ifndef IS_TEENSY40
-  #define IS_TEENSY41 1
-#endif
-
-#define CPU_ST7920_DELAY_1 600
-#define CPU_ST7920_DELAY_2 750
-#define CPU_ST7920_DELAY_3 750
-
-#undef sq
-#define sq(x) ((x)*(x))
-
-// Don't place string constants in PROGMEM
-#undef PSTR
-#define PSTR(str) ({static const char *data = (str); &data[0];})
-
-// ------------------------
-// Serial ports
-// ------------------------
-
-#include "../../core/serial_hook.h"
-
-#define Serial0 Serial
-#define _DECLARE_SERIAL(X) \
-  typedef ForwardSerial1Class<decltype(Serial##X)> DefaultSerial##X; \
-  extern DefaultSerial##X MSerial##X
-#define DECLARE_SERIAL(X) _DECLARE_SERIAL(X)
-
-typedef ForwardSerial1Class<decltype(SerialUSB)> USBSerialType;
-extern USBSerialType USBSerial;
-
-#define _MSERIAL(X) MSerial##X
-#define MSERIAL(X) _MSERIAL(X)
-
-#if SERIAL_PORT == -1
-  #define MYSERIAL1 SerialUSB
-#elif WITHIN(SERIAL_PORT, 0, 8)
-  DECLARE_SERIAL(SERIAL_PORT);
-  #define MYSERIAL1 MSERIAL(SERIAL_PORT)
-#else
-  #error "The required SERIAL_PORT must be from 0 to 8, or -1 for Native USB."
-#endif
-
-#ifdef SERIAL_PORT_2
-  #if SERIAL_PORT_2 == -1
-    #define MYSERIAL2 usbSerial
-  #elif SERIAL_PORT_2 == -2
-    #define MYSERIAL2 ethernet.telnetClient
-  #elif WITHIN(SERIAL_PORT_2, 0, 8)
-    #define MYSERIAL2 MSERIAL(SERIAL_PORT_2)
-  #else
-    #error "SERIAL_PORT_2 must be from 0 to 8, or -1 for Native USB, or -2 for Ethernet."
-  #endif
-#endif
-
-// ------------------------
-// Types
-// ------------------------
-
-class libServo;
-typedef libServo hal_servo_t;
-
-typedef int8_t pin_t;
-
-// ------------------------
-// Interrupts
-// ------------------------
-
-#define CRITICAL_SECTION_START()  const bool irqon = !__get_primask(); __disable_irq()
-#define CRITICAL_SECTION_END()    if (irqon) __enable_irq()
-
-// ------------------------
-// ADC
-// ------------------------
-
-#ifndef analogInputToDigitalPin
-  #define analogInputToDigitalPin(p) ((p < 12U) ? (p) + 54U : -1)
-#endif
-
-#define HAL_ADC_VREF         3.3
-#define HAL_ADC_RESOLUTION  10
-#define HAL_ADC_FILTERED      // turn off ADC oversampling
-
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
-
-// FastIO
-bool is_output(pin_t pin);
-
-// ------------------------
-// Free Memory Accessor
-// ------------------------
-
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
-
-extern "C" uint32_t freeMemory();
-
-#pragma GCC diagnostic pop
-
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
-
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
-
-  // Watchdog
-  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
-  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
-
-  static void init() {}        // Called early in setup()
-  static void init_board() {}  // Called less early in setup()
-  static void reboot();        // Restart the firmware from 0x0
-
-  // Interrupts
-  static bool isr_state() { return !__get_primask(); }
-  static void isr_on()  { __enable_irq(); }
-  static void isr_off() { __disable_irq(); }
-
-  static void delay_ms(const int ms) { delay(ms); }
-
-  // Tasks, called from idle()
-  static void idletask() {}
-
-  // Reset
-  static uint8_t get_reset_source();
-  static void clear_reset_source();
-
-  // Free SRAM
-  static int freeMemory() { return ::freeMemory(); }
-
-  //
-  // ADC Methods
-  //
-
-  static int8_t adc_select;
-
-  // Called by Temperature::init once at startup
-  static void adc_init();
-
-  // Called by Temperature::init for each sensor at startup
-  static void adc_enable(const pin_t pin) {}
-
-  // Begin ADC sampling on the given pin. Called from Temperature::isr!
-  static void adc_start(const pin_t pin);
-
-  // Is the ADC ready for reading?
-  static bool adc_ready() { return true; }
-
-  // The current value of the ADC register
-  static uint16_t adc_value();
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * No option to invert the duty cycle [default = false]
-   * No option to change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t=255, const bool=false) {
-    analogWrite(pin, v);
-  }
-
-};
diff --git a/Marlin/src/HAL/TEENSY40_41/HAL_SPI.cpp b/Marlin/src/HAL/TEENSY40_41/HAL_SPI.cpp
deleted file mode 100644
index 9dcb812..0000000
--- a/Marlin/src/HAL/TEENSY40_41/HAL_SPI.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL SPI for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#ifdef __IMXRT1062__
-
-#include "../../inc/MarlinConfig.h"
-#include "HAL.h"
-
-#include <SPI.h>
-#include <pins_arduino.h>
-#include "spi_pins.h"
-
-static SPISettings spiConfig;
-
-// ------------------------
-// Public functions
-// ------------------------
-
-#if ENABLED(SOFTWARE_SPI)
-  // ------------------------
-  // Software SPI
-  // ------------------------
-  #error "Software SPI not supported for Teensy 4. Use Hardware SPI."
-#else
-
-// ------------------------
-// Hardware SPI
-// ------------------------
-
-void spiBegin() {
-  #if PIN_EXISTS(SD_SS)
-    OUT_WRITE(SD_SS_PIN, HIGH);
-  #endif
-  //SET_OUTPUT(SD_SCK_PIN);
-  //SET_INPUT(SD_MISO_PIN);
-  //SET_OUTPUT(SD_MOSI_PIN);
-
-  #if 0 && DISABLED(SOFTWARE_SPI)
-    // set SS high - may be chip select for another SPI device
-    #if SET_SPI_SS_HIGH
-      WRITE(SD_SS_PIN, HIGH);
-    #endif
-    // set a default rate
-    spiInit(SPI_HALF_SPEED); // 1
-  #endif
-}
-
-void spiInit(uint8_t spiRate) {
-  // Use Marlin data-rates
-  uint32_t clock;
-  switch (spiRate) {
-  case SPI_FULL_SPEED:    clock = 10000000; break;
-  case SPI_HALF_SPEED:    clock =  5000000; break;
-  case SPI_QUARTER_SPEED: clock =  2500000; break;
-  case SPI_EIGHTH_SPEED:  clock =  1250000; break;
-  case SPI_SPEED_5:       clock =   625000; break;
-  case SPI_SPEED_6:       clock =   312500; break;
-  default:
-    clock = 4000000; // Default from the SPI library
-  }
-  spiConfig = SPISettings(clock, MSBFIRST, SPI_MODE0);
-  SPI.begin();
-}
-
-uint8_t spiRec() {
-  SPI.beginTransaction(spiConfig);
-  uint8_t returnByte = SPI.transfer(0xFF);
-  SPI.endTransaction();
-  return returnByte;
-  //SPDR = 0xFF;
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //return SPDR;
-}
-
-void spiRead(uint8_t *buf, uint16_t nbyte) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(buf, nbyte);
-  SPI.endTransaction();
-  //if (nbyte-- == 0) return;
-  //  SPDR = 0xFF;
-  //for (uint16_t i = 0; i < nbyte; i++) {
-  //  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //  buf[i] = SPDR;
-  //  SPDR = 0xFF;
-  //}
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-  //buf[nbyte] = SPDR;
-}
-
-void spiSend(uint8_t b) {
-  SPI.beginTransaction(spiConfig);
-  SPI.transfer(b);
-  SPI.endTransaction();
-  //SPDR = b;
-  //while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }
-}
-
-void spiSendBlock(uint8_t token, const uint8_t *buf) {
-  SPI.beginTransaction(spiConfig);
-  SPDR = token;
-  for (uint16_t i = 0; i < 512; i += 2) {
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i];
-    while (!TEST(SPSR, SPIF)) { /* nada */ };
-    SPDR = buf[i + 1];
-  }
-  while (!TEST(SPSR, SPIF)) { /* nada */ };
-  SPI.endTransaction();
-}
-
-// Begin SPI transaction, set clock, bit order, data mode
-void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {
-  spiConfig = SPISettings(spiClock, bitOrder, dataMode);
-  SPI.beginTransaction(spiConfig);
-}
-
-#endif // SOFTWARE_SPI
-#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/MarlinSPI.h b/Marlin/src/HAL/TEENSY40_41/MarlinSPI.h
deleted file mode 100644
index 0c447ba..0000000
--- a/Marlin/src/HAL/TEENSY40_41/MarlinSPI.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#include <SPI.h>
-
-using MarlinSPI = SPIClass;
diff --git a/Marlin/src/HAL/TEENSY40_41/Servo.cpp b/Marlin/src/HAL/TEENSY40_41/Servo.cpp
deleted file mode 100644
index ffb1102..0000000
--- a/Marlin/src/HAL/TEENSY40_41/Servo.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Servo for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#ifdef __IMXRT1062__
-
-#include "../../inc/MarlinConfig.h"
-
-#if HAS_SERVOS
-
-#include "Servo.h"
-
-int8_t libServo::attach(const int inPin) {
-  if (inPin > 0) servoPin = inPin;
-  return super::attach(servoPin);
-}
-
-int8_t libServo::attach(const int inPin, const int inMin, const int inMax) {
-  if (inPin > 0) servoPin = inPin;
-  return super::attach(servoPin, inMin, inMax);
-}
-
-void libServo::move(const int value) {
-  constexpr uint16_t servo_delay[] = SERVO_DELAY;
-  static_assert(COUNT(servo_delay) == NUM_SERVOS, "SERVO_DELAY must be an array NUM_SERVOS long.");
-  if (attach(0) >= 0) {
-    write(value);
-    safe_delay(servo_delay[servoIndex]);
-    TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());
-  }
-}
-
-void libServo::detach() {
-  // PWMServo library does not have detach() function
-  //super::detach();
-}
-
-#endif // HAS_SERVOS
-#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/Servo.h b/Marlin/src/HAL/TEENSY40_41/Servo.h
deleted file mode 100644
index 699fd70..0000000
--- a/Marlin/src/HAL/TEENSY40_41/Servo.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Servo for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#include <PWMServo.h>
-
-// Inherit and expand on core Servo library
-class libServo : public PWMServo {
-  public:
-    int8_t attach(const int pin);
-    int8_t attach(const int pin, const int min, const int max);
-    void move(const int value);
-    void detach(void);
-  private:
-    typedef PWMServo super;
-    uint8_t servoPin;
-    uint16_t min_ticks;
-    uint16_t max_ticks;
-    uint8_t servoIndex; // Index into the channel data for this servo
-};
diff --git a/Marlin/src/HAL/TEENSY40_41/eeprom.cpp b/Marlin/src/HAL/TEENSY40_41/eeprom.cpp
deleted file mode 100644
index 3cd376e..0000000
--- a/Marlin/src/HAL/TEENSY40_41/eeprom.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- *
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- * Copyright (c) 2016 Victor Perez victor_pv@hotmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#ifdef __IMXRT1062__
-
-/**
- * HAL PersistentStore for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if USE_WIRED_EEPROM
-
-#include "../shared/eeprom_api.h"
-#include <avr/eeprom.h>
-
-#ifndef MARLIN_EEPROM_SIZE
-  #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-#endif
-size_t PersistentStore::capacity() { return MARLIN_EEPROM_SIZE; }
-
-bool PersistentStore::access_start()  { return true; }
-bool PersistentStore::access_finish() { return true; }
-
-bool PersistentStore::write_data(int &pos, const uint8_t *value, size_t size, uint16_t *crc) {
-  uint16_t written = 0;
-  while (size--) {
-    uint8_t * const p = (uint8_t * const)pos;
-    uint8_t v = *value;
-    if (v != eeprom_read_byte(p)) { // EEPROM has only ~100,000 write cycles, so only write bytes that have changed!
-      eeprom_write_byte(p, v);
-      if (++written & 0x7F) delay(2); else safe_delay(2); // Avoid triggering watchdog during long EEPROM writes
-      if (eeprom_read_byte(p) != v) {
-        SERIAL_ECHO_MSG(STR_ERR_EEPROM_WRITE);
-        return true;
-      }
-    }
-    crc16(crc, &v, 1);
-    pos++;
-    value++;
-  }
-  return false;
-}
-
-bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {
-  do {
-    uint8_t c = eeprom_read_byte((uint8_t*)pos);
-    if (writing) *value = c;
-    crc16(crc, &c, 1);
-    pos++;
-    value++;
-  } while (--size);
-  return false;
-}
-
-#endif // USE_WIRED_EEPROM
-#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/endstop_interrupts.h b/Marlin/src/HAL/TEENSY40_41/endstop_interrupts.h
deleted file mode 100644
index 4c3ddec..0000000
--- a/Marlin/src/HAL/TEENSY40_41/endstop_interrupts.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Endstop Interrupts for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- *
- * Without endstop interrupts the endstop pins must be polled continually in
- * the temperature-ISR via endstops.update(), most of the time finding no change.
- * With this feature endstops.update() is called only when we know that at
- * least one endstop has changed state, saving valuable CPU cycles.
- *
- * This feature only works when all used endstop pins can generate an 'external interrupt'.
- *
- * Test whether pins issue interrupts on your board by flashing 'pin_interrupt_test.ino'.
- * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
- */
-
-#include "../../module/endstops.h"
-
-// One ISR for all EXT-Interrupts
-void endstop_ISR() { endstops.update(); }
-
-/**
- * Endstop interrupts for Due based targets.
- * On Due, all pins support external interrupt capability.
- */
-void setup_endstop_interrupts() {
-  #define _ATTACH(P) attachInterrupt(digitalPinToInterrupt(P), endstop_ISR, CHANGE)
-  TERN_(HAS_X_MAX, _ATTACH(X_MAX_PIN));
-  TERN_(HAS_X_MIN, _ATTACH(X_MIN_PIN));
-  TERN_(HAS_Y_MAX, _ATTACH(Y_MAX_PIN));
-  TERN_(HAS_Y_MIN, _ATTACH(Y_MIN_PIN));
-  TERN_(HAS_Z_MAX, _ATTACH(Z_MAX_PIN));
-  TERN_(HAS_Z_MIN, _ATTACH(Z_MIN_PIN));
-  TERN_(HAS_X2_MAX, _ATTACH(X2_MAX_PIN));
-  TERN_(HAS_X2_MIN, _ATTACH(X2_MIN_PIN));
-  TERN_(HAS_Y2_MAX, _ATTACH(Y2_MAX_PIN));
-  TERN_(HAS_Y2_MIN, _ATTACH(Y2_MIN_PIN));
-  TERN_(HAS_Z2_MAX, _ATTACH(Z2_MAX_PIN));
-  TERN_(HAS_Z2_MIN, _ATTACH(Z2_MIN_PIN));
-  TERN_(HAS_Z3_MAX, _ATTACH(Z3_MAX_PIN));
-  TERN_(HAS_Z3_MIN, _ATTACH(Z3_MIN_PIN));
-  TERN_(HAS_Z4_MAX, _ATTACH(Z4_MAX_PIN));
-  TERN_(HAS_Z4_MIN, _ATTACH(Z4_MIN_PIN));
-  TERN_(HAS_Z_MIN_PROBE_PIN, _ATTACH(Z_MIN_PROBE_PIN));
-  TERN_(HAS_I_MAX, _ATTACH(I_MAX_PIN));
-  TERN_(HAS_I_MIN, _ATTACH(I_MIN_PIN));
-  TERN_(HAS_J_MAX, _ATTACH(J_MAX_PIN));
-  TERN_(HAS_J_MIN, _ATTACH(J_MIN_PIN));
-  TERN_(HAS_K_MAX, _ATTACH(K_MAX_PIN));
-  TERN_(HAS_K_MIN, _ATTACH(K_MIN_PIN));
-}
diff --git a/Marlin/src/HAL/TEENSY40_41/fastio.h b/Marlin/src/HAL/TEENSY40_41/fastio.h
deleted file mode 100644
index 52f991d..0000000
--- a/Marlin/src/HAL/TEENSY40_41/fastio.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- * Copyright (c) 2017 Victor Perez
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Fast I/O interfaces for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- * These use GPIO functions instead of Direct Port Manipulation, as on AVR.
- */
-
-#ifndef PWM
-  #define PWM OUTPUT
-#endif
-
-#define READ(IO)                digitalRead(IO)
-#define WRITE(IO,V)             digitalWrite(IO,V)
-
-#define _GET_MODE(IO)           !is_output(IO)
-#define _SET_MODE(IO,M)         pinMode(IO, M)
-#define _SET_OUTPUT(IO)         pinMode(IO, OUTPUT)                               /*!< Output Push Pull Mode & GPIO_NOPULL   */
-
-#define OUT_WRITE(IO,V)         do{ _SET_OUTPUT(IO); WRITE(IO,V); }while(0)
-
-#define SET_INPUT(IO)           _SET_MODE(IO, INPUT)                              /*!< Input Floating Mode                   */
-#define SET_INPUT_PULLUP(IO)    _SET_MODE(IO, INPUT_PULLUP)                       /*!< Input with Pull-up activation         */
-#define SET_INPUT_PULLDOWN(IO)  _SET_MODE(IO, INPUT_PULLDOWN)                     /*!< Input with Pull-down activation       */
-#define SET_OUTPUT(IO)          OUT_WRITE(IO, LOW)
-#define SET_PWM(IO)             _SET_MODE(IO, PWM)
-
-#define TOGGLE(IO)              OUT_WRITE(IO, !READ(IO))
-
-#define IS_INPUT(IO)            !is_output(IO)
-#define IS_OUTPUT(IO)           is_output(IO)
-
-#define PWM_PIN(P)            digitalPinHasPWM(P)
-
-// digitalRead/Write wrappers
-#define extDigitalRead(IO)    digitalRead(IO)
-#define extDigitalWrite(IO,V) digitalWrite(IO,V)
diff --git a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_LCD.h b/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_LCD.h
deleted file mode 100644
index 6a85409..0000000
--- a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_LCD.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if HAS_SPI_TFT || HAS_FSMC_TFT
-  #error "Sorry! TFT displays are not available for HAL/TEENSY40_41."
-#endif
diff --git a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_adv.h b/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_adv.h
deleted file mode 100644
index 5f1c4b1..0000000
--- a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_adv.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
diff --git a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_post.h b/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_post.h
deleted file mode 100644
index 998f1dc..0000000
--- a/Marlin/src/HAL/TEENSY40_41/inc/Conditionals_post.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-#if USE_FALLBACK_EEPROM
-  #define USE_WIRED_EEPROM 1
-#endif
diff --git a/Marlin/src/HAL/TEENSY40_41/inc/SanityCheck.h b/Marlin/src/HAL/TEENSY40_41/inc/SanityCheck.h
deleted file mode 100644
index 3d2668d..0000000
--- a/Marlin/src/HAL/TEENSY40_41/inc/SanityCheck.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * Test TEENSY41 specific configuration values for errors at compile-time.
- */
-
-#if ENABLED(EMERGENCY_PARSER)
-  #error "EMERGENCY_PARSER is not yet implemented for Teensy 4.0/4.1. Disable EMERGENCY_PARSER to continue."
-#endif
-
-#if ENABLED(FAST_PWM_FAN) || SPINDLE_LASER_FREQUENCY
-  #error "Features requiring Hardware PWM (FAST_PWM_FAN, SPINDLE_LASER_FREQUENCY) are not yet supported on Teensy 4.0/4.1."
-#endif
-
-#if HAS_TMC_SW_SERIAL
-  #error "TMC220x Software Serial is not supported on Teensy 4.0/4.1."
-#endif
-
-#if ENABLED(POSTMORTEM_DEBUGGING)
-  #error "POSTMORTEM_DEBUGGING is not yet supported on Teensy 4.0/4.1."
-#endif
diff --git a/Marlin/src/HAL/TEENSY40_41/pinsDebug.h b/Marlin/src/HAL/TEENSY40_41/pinsDebug.h
deleted file mode 100644
index 94b85ea..0000000
--- a/Marlin/src/HAL/TEENSY40_41/pinsDebug.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Pins Debugging for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#warning "PINS_DEBUGGING is not fully supported for Teensy 4.0 / 4.1 so 'M43' may cause hangs."
-
-#define NUMBER_PINS_TOTAL NUM_DIGITAL_PINS
-
-#define digitalRead_mod(p) extDigitalRead(p)  // AVR digitalRead disabled PWM before it read the pin
-#define PRINT_PORT(p)
-#define PRINT_ARRAY_NAME(x) do{ sprintf_P(buffer, PSTR("%-" STRINGIFY(MAX_NAME_LENGTH) "s"), pin_array[x].name); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN(p) do{ sprintf_P(buffer, PSTR("%02d"), p); SERIAL_ECHO(buffer); }while(0)
-#define PRINT_PIN_ANALOG(p) do{ sprintf_P(buffer, PSTR(" (A%2d)  "), DIGITAL_PIN_TO_ANALOG_PIN(pin)); SERIAL_ECHO(buffer); }while(0)
-#define GET_ARRAY_PIN(p) pin_array[p].pin
-#define GET_ARRAY_IS_DIGITAL(p) pin_array[p].is_digital
-#define VALID_PIN(pin) (pin >= 0 && pin < (int8_t)NUMBER_PINS_TOTAL ? 1 : 0)
-#define DIGITAL_PIN_TO_ANALOG_PIN(p) int(p - analogInputToDigitalPin(0))
-#define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && (P) <= analogInputToDigitalPin(13)) || ((P) >= analogInputToDigitalPin(14) && (P) <= analogInputToDigitalPin(17))
-#define pwm_status(pin) HAL_pwm_status(pin)
-#define GET_PINMODE(PIN) (VALID_PIN(pin) && IS_OUTPUT(pin))
-#define MULTI_NAME_PAD 16 // space needed to be pretty if not first name assigned to a pin
-
-struct pwm_pin_info_struct {
-  uint8_t type;    // 0=no pwm, 1=flexpwm, 2=quad
-  uint8_t module;  // 0-3, 0-3
-  uint8_t channel; // 0=X, 1=A, 2=B
-  uint8_t muxval;  //
-};
-
-#define M(a, b) ((((a) - 1) << 4) | (b))
-
-const struct pwm_pin_info_struct pwm_pin_info[] = {
-  {1, M(1, 1), 0, 4},  // FlexPWM1_1_X   0  // AD_B0_03
-  {1, M(1, 0), 0, 4},  // FlexPWM1_0_X   1  // AD_B0_02
-  {1, M(4, 2), 1, 1},  // FlexPWM4_2_A   2  // EMC_04
-  {1, M(4, 2), 2, 1},  // FlexPWM4_2_B   3  // EMC_05
-  {1, M(2, 0), 1, 1},  // FlexPWM2_0_A   4  // EMC_06
-  {1, M(2, 1), 1, 1},  // FlexPWM2_1_A   5  // EMC_08
-  {1, M(2, 2), 1, 2},  // FlexPWM2_2_A   6  // B0_10
-  {1, M(1, 3), 2, 6},  // FlexPWM1_3_B   7  // B1_01
-  {1, M(1, 3), 1, 6},  // FlexPWM1_3_A   8  // B1_00
-  {1, M(2, 2), 2, 2},  // FlexPWM2_2_B   9  // B0_11
-  {2, M(1, 0), 0, 1},  // QuadTimer1_0  10  // B0_00
-  {2, M(1, 2), 0, 1},  // QuadTimer1_2  11  // B0_02
-  {2, M(1, 1), 0, 1},  // QuadTimer1_1  12  // B0_01
-  {2, M(2, 0), 0, 1},  // QuadTimer2_0  13  // B0_03
-  {2, M(3, 2), 0, 1},  // QuadTimer3_2  14  // AD_B1_02
-  {2, M(3, 3), 0, 1},  // QuadTimer3_3  15  // AD_B1_03
-  {0, M(1, 0), 0, 0},
-  {0, M(1, 0), 0, 0},
-  {2, M(3, 1), 0, 1},  // QuadTimer3_1  18  // AD_B1_01
-  {2, M(3, 0), 0, 1},  // QuadTimer3_0  19  // AD_B1_00
-  {0, M(1, 0), 0, 0},
-  {0, M(1, 0), 0, 0},
-  {1, M(4, 0), 1, 1},  // FlexPWM4_0_A  22  // AD_B1_08
-  {1, M(4, 1), 1, 1},  // FlexPWM4_1_A  23  // AD_B1_09
-  {1, M(1, 2), 0, 4},  // FlexPWM1_2_X  24  // AD_B0_12
-  {1, M(1, 3), 0, 4},  // FlexPWM1_3_X  25  // AD_B0_13
-  {0, M(1, 0), 0, 0},
-  {0, M(1, 0), 0, 0},
-  {1, M(3, 1), 2, 1},  // FlexPWM3_1_B  28  // EMC_32
-  {1, M(3, 1), 1, 1},  // FlexPWM3_1_A  29  // EMC_31
-  {0, M(1, 0), 0, 0},
-  {0, M(1, 0), 0, 0},
-  {0, M(1, 0), 0, 0},
-  {1, M(2, 0), 2, 1},  // FlexPWM2_0_B  33  // EMC_07
-  #ifdef ARDUINO_TEENSY40
-    {1, M(1, 1), 2, 1},  // FlexPWM1_1_B  34  // SD_B0_03
-    {1, M(1, 1), 1, 1},  // FlexPWM1_1_A  35  // SD_B0_02
-    {1, M(1, 0), 2, 1},  // FlexPWM1_0_B  36  // SD_B0_01
-    {1, M(1, 0), 1, 1},  // FlexPWM1_0_A  37  // SD_B0_00
-    {1, M(1, 2), 2, 1},  // FlexPWM1_2_B  38  // SD_B0_05
-    {1, M(1, 2), 1, 1},  // FlexPWM1_2_A  39  // SD_B0_04
-  #endif
-  #ifdef ARDUINO_TEENSY41
-    {0, M(1, 0), 0, 0},
-    {0, M(1, 0), 0, 0},
-    {1, M(2, 3), 1, 6},  // FlexPWM2_3_A  36  // B1_00
-    {1, M(2, 3), 2, 6},  // FlexPWM2_3_B  37  // B1_01
-    {0, M(1, 0), 0, 0},
-    {0, M(1, 0), 0, 0},
-    {0, M(1, 0), 0, 0},
-    {0, M(1, 0), 0, 0},
-    {1, M(1, 1), 2, 1},  // FlexPWM1_1_B  42  // SD_B0_03
-    {1, M(1, 1), 1, 1},  // FlexPWM1_1_A  43  // SD_B0_02
-    {1, M(1, 0), 2, 1},  // FlexPWM1_0_B  44  // SD_B0_01
-    {1, M(1, 0), 1, 1},  // FlexPWM1_0_A  45  // SD_B0_00
-    {1, M(1, 2), 2, 1},  // FlexPWM1_2_B  46  // SD_B0_05
-    {1, M(1, 2), 1, 1},  // FlexPWM1_2_A  47  // SD_B0_04
-    {0, M(1, 0), 0, 0},  // duplicate FlexPWM1_0_B
-    {0, M(1, 0), 0, 0},  // duplicate FlexPWM1_2_A
-    {0, M(1, 0), 0, 0},  // duplicate FlexPWM1_2_B
-    {1, M(3, 3), 2, 1},  // FlexPWM3_3_B  51  // EMC_22
-    {0, M(1, 0), 0, 0},  // duplicate FlexPWM1_1_B
-    {0, M(1, 0), 0, 0},  // duplicate FlexPWM1_1_A
-    {1, M(3, 0), 1, 1},  // FlexPWM3_0_A  53  // EMC_29
-  #endif
-};
-
-void HAL_print_analog_pin(char buffer[], int8_t pin) {
-  if (pin <= 23)      sprintf_P(buffer, PSTR("(A%2d)  "), int(pin - 14));
-  else if (pin <= 41) sprintf_P(buffer, PSTR("(A%2d)  "), int(pin - 24));
-}
-
-void HAL_analog_pin_state(char buffer[], int8_t pin) {
-  if (pin <= 23)      sprintf_P(buffer, PSTR("Analog in =% 5d"), analogRead(pin - 14));
-  else if (pin <= 41) sprintf_P(buffer, PSTR("Analog in =% 5d"), analogRead(pin - 24));
-}
-
-#define PWM_PRINT(V) do{ sprintf_P(buffer, PSTR("PWM:  %4d"), V); SERIAL_ECHO(buffer); }while(0)
-
-/**
- * Print a pin's PWM status.
- * Return true if it's currently a PWM pin.
- */
-bool HAL_pwm_status(int8_t pin) {
-  char buffer[20];   // for the sprintf statements
-  const struct pwm_pin_info_struct *info;
-
-  if (pin >= CORE_NUM_DIGITAL) return 0;
-  info = pwm_pin_info + pin;
-
-  if (info->type == 0) return 0;
-
-  /* TODO decode pwm value from timers */
-  // for now just indicate if output is set as pwm
-  PWM_PRINT(*(portConfigRegister(pin)) == info->muxval);
-  return (*(portConfigRegister(pin)) == info->muxval);
-}
-
-static void pwm_details(uint8_t pin) { /* TODO */ }
diff --git a/Marlin/src/HAL/TEENSY40_41/spi_pins.h b/Marlin/src/HAL/TEENSY40_41/spi_pins.h
deleted file mode 100644
index ba4a2c7..0000000
--- a/Marlin/src/HAL/TEENSY40_41/spi_pins.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL SPI Pins for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#define SD_SCK_PIN   13
-#define SD_MISO_PIN  12
-#define SD_MOSI_PIN  11
-#define SD_SS_PIN    20 // SDSS // A.28, A.29, B.21, C.26, C.29
diff --git a/Marlin/src/HAL/TEENSY40_41/timers.cpp b/Marlin/src/HAL/TEENSY40_41/timers.cpp
deleted file mode 100644
index ed99f65..0000000
--- a/Marlin/src/HAL/TEENSY40_41/timers.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * HAL Timers for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#ifdef __IMXRT1062__
-
-#include "../../inc/MarlinConfig.h"
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency) {
-  switch (timer_num) {
-    case MF_TIMER_STEP:
-      CCM_CSCMR1 &= ~CCM_CSCMR1_PERCLK_CLK_SEL; // turn off 24mhz mode
-      CCM_CCGR1 |= CCM_CCGR1_GPT1_BUS(CCM_CCGR_ON);
-
-      GPT1_CR = 0;                   // disable timer
-      GPT1_SR = 0x3F;                // clear all prior status
-      GPT1_PR = GPT1_TIMER_PRESCALE - 1;
-      GPT1_CR |= GPT_CR_CLKSRC(1);   //clock selection #1 (peripheral clock = 150 MHz)
-      GPT1_CR |= GPT_CR_ENMOD;       //reset count to zero before enabling
-      GPT1_CR |= GPT_CR_OM1(1);      // toggle mode
-      GPT1_OCR1 = (GPT1_TIMER_RATE / frequency) -1; // Initial compare value
-      GPT1_IR = GPT_IR_OF1IE;        // Compare3 value
-      GPT1_CR |= GPT_CR_EN;          //enable GPT2 counting at 150 MHz
-
-      OUT_WRITE(15, HIGH);
-      attachInterruptVector(IRQ_GPT1, &stepTC_Handler);
-      NVIC_SET_PRIORITY(IRQ_GPT1, 16);
-      break;
-    case MF_TIMER_TEMP:
-      CCM_CSCMR1 &= ~CCM_CSCMR1_PERCLK_CLK_SEL; // turn off 24mhz mode
-      CCM_CCGR0 |= CCM_CCGR0_GPT2_BUS(CCM_CCGR_ON);
-
-      GPT2_CR = 0;                   // disable timer
-      GPT2_SR = 0x3F;                // clear all prior status
-      GPT2_PR = GPT2_TIMER_PRESCALE - 1;
-      GPT2_CR |= GPT_CR_CLKSRC(1);   //clock selection #1 (peripheral clock = 150 MHz)
-      GPT2_CR |= GPT_CR_ENMOD;       //reset count to zero before enabling
-      GPT2_CR |= GPT_CR_OM1(1);      // toggle mode
-      GPT2_OCR1 = (GPT2_TIMER_RATE / frequency) -1; // Initial compare value
-      GPT2_IR = GPT_IR_OF1IE;        // Compare3 value
-      GPT2_CR |= GPT_CR_EN;          //enable GPT2 counting at 150 MHz
-
-      OUT_WRITE(14, HIGH);
-      attachInterruptVector(IRQ_GPT2, &tempTC_Handler);
-      NVIC_SET_PRIORITY(IRQ_GPT2, 32);
-      break;
-  }
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_ENABLE_IRQ(IRQ_GPT1); break;
-    case MF_TIMER_TEMP: NVIC_ENABLE_IRQ(IRQ_GPT2); break;
-  }
-}
-
-void HAL_timer_disable_interrupt(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: NVIC_DISABLE_IRQ(IRQ_GPT1); break;
-    case MF_TIMER_TEMP: NVIC_DISABLE_IRQ(IRQ_GPT2); break;
-  }
-
-  // We NEED memory barriers to ensure Interrupts are actually disabled!
-  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
-  asm volatile("dsb");
-}
-
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return (NVIC_IS_ENABLED(IRQ_GPT1));
-    case MF_TIMER_TEMP: return (NVIC_IS_ENABLED(IRQ_GPT2));
-  }
-  return false;
-}
-
-void HAL_timer_isr_prologue(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: GPT1_SR = GPT_IR_OF1IE; break; // clear OF3 bit
-    case MF_TIMER_TEMP: GPT2_SR = GPT_IR_OF1IE; break; // clear OF3 bit
-  }
-  asm volatile("dsb");
-}
-
-#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/timers.h b/Marlin/src/HAL/TEENSY40_41/timers.h
deleted file mode 100644
index 77fe095..0000000
--- a/Marlin/src/HAL/TEENSY40_41/timers.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
- * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#pragma once
-
-/**
- * HAL Timers for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
- */
-
-#include <stdint.h>
-
-// ------------------------
-// Defines
-// ------------------------
-
-#define FORCE_INLINE __attribute__((always_inline)) inline
-
-typedef uint32_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFFFFFE
-
-#define GPT_TIMER_RATE F_BUS_ACTUAL   // 150MHz
-
-#define GPT1_TIMER_PRESCALE 2
-#define GPT2_TIMER_PRESCALE 10
-
-#define GPT1_TIMER_RATE (GPT_TIMER_RATE / GPT1_TIMER_PRESCALE) // 75MHz
-#define GPT2_TIMER_RATE (GPT_TIMER_RATE / GPT2_TIMER_PRESCALE) // 15MHz
-
-#ifndef MF_TIMER_STEP
-  #define MF_TIMER_STEP         0  // Timer Index for Stepper
-#endif
-#ifndef MF_TIMER_PULSE
-  #define MF_TIMER_PULSE        MF_TIMER_STEP
-#endif
-#ifndef MF_TIMER_TEMP
-  #define MF_TIMER_TEMP         1  // Timer Index for Temperature
-#endif
-
-#define TEMP_TIMER_RATE        1000000
-#define TEMP_TIMER_FREQUENCY   1000
-
-#define STEPPER_TIMER_RATE     GPT1_TIMER_RATE
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000)
-#define STEPPER_TIMER_PRESCALE ((GPT_TIMER_RATE / 1000000) / STEPPER_TIMER_TICKS_PER_US)
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_STEP)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_STEP)
-#define STEPPER_ISR_ENABLED() HAL_timer_interrupt_enabled(MF_TIMER_STEP)
-
-#define ENABLE_TEMPERATURE_INTERRUPT() HAL_timer_enable_interrupt(MF_TIMER_TEMP)
-#define DISABLE_TEMPERATURE_INTERRUPT() HAL_timer_disable_interrupt(MF_TIMER_TEMP)
-
-#ifndef HAL_STEP_TIMER_ISR
-  #define HAL_STEP_TIMER_ISR() extern "C" void stepTC_Handler() // GPT1_Handler()
-#endif
-#ifndef HAL_TEMP_TIMER_ISR
-  #define HAL_TEMP_TIMER_ISR() extern "C" void tempTC_Handler() // GPT2_Handler()
-#endif
-
-extern "C" {
-  void stepTC_Handler();
-  void tempTC_Handler();
-}
-
-void HAL_timer_start(const uint8_t timer_num, const uint32_t frequency);
-
-FORCE_INLINE static void HAL_timer_set_compare(const uint8_t timer_num, const hal_timer_t compare) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: GPT1_OCR1 = compare - 1; break;
-    case MF_TIMER_TEMP: GPT2_OCR1 = compare - 1; break;
-  }
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_compare(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return GPT1_OCR1;
-    case MF_TIMER_TEMP: return GPT2_OCR1;
-  }
-  return 0;
-}
-
-FORCE_INLINE static hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {
-  switch (timer_num) {
-    case MF_TIMER_STEP: return GPT1_CNT;
-    case MF_TIMER_TEMP: return GPT2_CNT;
-  }
-  return 0;
-}
-
-void HAL_timer_enable_interrupt(const uint8_t timer_num);
-void HAL_timer_disable_interrupt(const uint8_t timer_num);
-bool HAL_timer_interrupt_enabled(const uint8_t timer_num);
-
-void HAL_timer_isr_prologue(const uint8_t timer_num);
-//void HAL_timer_isr_epilogue(const uint8_t timer_num) {}
-#define HAL_timer_isr_epilogue(T) NOOP
diff --git a/README.md b/README.md
index fb1e881..46f952a 100644
--- a/README.md
+++ b/README.md
@@ -1,101 +1,19 @@
-<p align="center"><img src="buildroot/share/pixmaps/logo/marlin-outrun-nf-500.png" height="250" alt="MarlinFirmware's logo" /></p>
+# V1CNC_SkrPro_Dual_2209 - 2.1.1 - 515D
 
-<h1 align="center">Marlin 3D Printer Firmware</h1>
+### Preconfigured V1 Engineering firmware.
 
-<p align="center">
-    <a href="/LICENSE"><img alt="GPL-V3.0 License" src="https://img.shields.io/github/license/marlinfirmware/marlin.svg"></a>
-    <a href="https://github.com/MarlinFirmware/Marlin/graphs/contributors"><img alt="Contributors" src="https://img.shields.io/github/contributors/marlinfirmware/marlin.svg"></a>
-    <a href="https://github.com/MarlinFirmware/Marlin/releases"><img alt="Last Release Date" src="https://img.shields.io/github/release-date/MarlinFirmware/Marlin"></a>
-    <a href="https://github.com/MarlinFirmware/Marlin/actions"><img alt="CI Status" src="https://github.com/MarlinFirmware/Marlin/actions/workflows/test-builds.yml/badge.svg"></a>
-    <a href="https://github.com/sponsors/thinkyhead"><img alt="GitHub Sponsors" src="https://img.shields.io/github/sponsors/thinkyhead?color=db61a2"></a>
-    <br />
-    <a href="https://twitter.com/MarlinFirmware"><img alt="Follow MarlinFirmware on Twitter" src="https://img.shields.io/twitter/follow/MarlinFirmware?style=social&logo=twitter"></a>
-</p>
+This firmware has been automatically configured based on scripts from the
+[MarlinBuilder](https://github.com/jeffeb3/MarlinBuilder) repo.
 
-Additional documentation can be found at the [Marlin Home Page](https://marlinfw.org/).
-Please test this firmware and let us know if it misbehaves in any way. Volunteers are standing by!
+### Configuration Notes
 
-## Marlin 2.1
+(See the git diff for more detailed, exact changes from Marlin)
 
-Marlin 2.1 continues to support both 32-bit ARM and 8-bit AVR boards while adding support for up to 9 coordinated axes and to up to 8 extruders.
-
-Download earlier versions of Marlin on the [Releases page](https://github.com/MarlinFirmware/Marlin/releases).
-
-## Example Configurations
-
-Before building Marlin you'll need to configure it for your specific hardware. Your vendor should have already provided source code with configurations for the installed firmware, but if you ever decide to upgrade you'll need updated configuration files. Marlin users have contributed dozens of tested example configurations to get you started. Visit the [MarlinFirmware/Configurations](https://github.com/MarlinFirmware/Configurations) repository to find the right configuration for your hardware.
-
-## Building Marlin 2.1
-
-To build Marlin 2.1 you'll need [Arduino IDE 1.8.8 or newer](https://www.arduino.cc/en/main/software) or [PlatformIO](http://docs.platformio.org/en/latest/ide.html#platformio-ide). Detailed build and install instructions are posted at:
-
-  - [Installing Marlin (Arduino)](http://marlinfw.org/docs/basics/install_arduino.html)
-  - [Installing Marlin (VSCode)](http://marlinfw.org/docs/basics/install_platformio_vscode.html).
-
-## Hardware Abstraction Layer (HAL)
-
-Marlin 2.0 introduced a layer of abstraction to allow all the existing high-level code to be built for 32-bit platforms while still retaining full 8-bit AVR compatibility. Retaining AVR compatibility and a single code-base is important to us, because we want to make sure that features and patches get as much testing and attention as possible, and that all platforms always benefit from the latest improvements.
-
-### Supported Platforms
-
-  Platform|MCU|Example Boards
-  --------|---|-------
-  [Arduino AVR](https://www.arduino.cc/)|ATmega|RAMPS, Melzi, RAMBo
-  [Teensy++ 2.0](https://www.microchip.com/en-us/product/AT90USB1286)|AT90USB1286|Printrboard
-  [Arduino Due](https://www.arduino.cc/en/Guide/ArduinoDue)|SAM3X8E|RAMPS-FD, RADDS, RAMPS4DUE
-  [ESP32](https://github.com/espressif/arduino-esp32)|ESP32|FYSETC E4, E4d@BOX, MRR
-  [LPC1768](https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/lpc1700-cortex-m3/512-kb-flash-64-kb-sram-ethernet-usb-lqfp100-package:LPC1768FBD100)|ARMÂ® Cortex-M3|MKS SBASE, Re-ARM, Selena Compact
-  [LPC1769](https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/lpc1700-cortex-m3/512-kb-flash-64-kb-sram-ethernet-usb-lqfp100-package:LPC1769FBD100)|ARMÂ® Cortex-M3|Smoothieboard, Azteeg X5 mini, TH3D EZBoard
-  [STM32F103](https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html)|ARMÂ® Cortex-M3|Malyan M200, GTM32 Pro, MKS Robin, BTT SKR Mini
-  [STM32F401](https://www.st.com/en/microcontrollers-microprocessors/stm32f401.html)|ARMÂ® Cortex-M4|ARMED, Rumba32, SKR Pro, Lerdge, FYSETC S6, Artillery Ruby
-  [STM32F7x6](https://www.st.com/en/microcontrollers-microprocessors/stm32f7x6.html)|ARMÂ® Cortex-M7|The Borg, RemRam V1
-  [STM32G0B1RET6](https://www.st.com/en/microcontrollers-microprocessors/stm32g0x1.html)|ARMÂ® Cortex-M0+|BigTreeTech SKR mini E3 V3.0
-  [STM32H743xIT6](https://www.st.com/en/microcontrollers-microprocessors/stm32h743-753.html)|ARMÂ® Cortex-M7|BigTreeTech SKR V3.0, SKR EZ V3.0, SKR SE BX V2.0/V3.0
-  [SAMD51P20A](https://www.adafruit.com/product/4064)|ARMÂ® Cortex-M4|Adafruit Grand Central M4
-  [Teensy 3.5](https://www.pjrc.com/store/teensy35.html)|ARMÂ® Cortex-M4|
-  [Teensy 3.6](https://www.pjrc.com/store/teensy36.html)|ARMÂ® Cortex-M4|
-  [Teensy 4.0](https://www.pjrc.com/store/teensy40.html)|ARMÂ® Cortex-M7|
-  [Teensy 4.1](https://www.pjrc.com/store/teensy41.html)|ARMÂ® Cortex-M7|
-  Linux Native|x86/ARM/etc.|Raspberry Pi
-
-## Submitting Patches
-
-- Submit **Bug Fixes** as Pull Requests to the ([bugfix-2.1.x](https://github.com/MarlinFirmware/Marlin/tree/bugfix-2.1.x)) branch.
-- Follow the [Coding Standards](http://marlinfw.org/docs/development/coding_standards.html) to gain points with the maintainers.
-- Please submit your questions and concerns to the [Issue Queue](https://github.com/MarlinFirmware/Marlin/issues).
-
-## Marlin Support
-
-The Issue Queue is reserved for Bug Reports and Feature Requests. To get help with configuration and troubleshooting, please use the following resources:
-
-- [Marlin Documentation](https://marlinfw.org) - Official Marlin documentation
-- [Marlin Discord](https://discord.gg/n5NJ59y) - Discuss issues with Marlin users and developers
-- Facebook Group ["Marlin Firmware"](https://www.facebook.com/groups/1049718498464482/)
-- RepRap.org [Marlin Forum](https://forums.reprap.org/list.php?415)
-- Facebook Group ["Marlin Firmware for 3D Printers"](https://www.facebook.com/groups/3Dtechtalk/)
-- [Marlin Configuration](https://www.youtube.com/results?search_query=marlin+configuration) on YouTube
-
-## Contributors
-
-Marlin is constantly improving thanks to a huge number of contributors from all over the world bringing their specialties and talents. Huge thanks are due to [all the contributors](https://github.com/MarlinFirmware/Marlin/graphs/contributors) who regularly patch up bugs, help direct traffic, and basically keep Marlin from falling apart. Marlin's continued existence would not be possible without them.
-
-## Administration
-
-Regular users can open and close their own issues, but only the administrators can do project-related things like add labels, merge changes, set milestones, and kick trolls. The current Marlin admin team consists of:
-
- - Scott Lahteine [[@thinkyhead](https://github.com/thinkyhead)] - USA - Project Maintainer &nbsp; [ðŸ’¸ Donate](https://www.thinkyhead.com/donate-to-marlin)
- - Roxanne Neufeld [[@Roxy-3D](https://github.com/Roxy-3D)] - USA
- - Keith Bennett [[@thisiskeithb](https://github.com/thisiskeithb)] - USA &nbsp; [ðŸ’¸ Donate](https://github.com/sponsors/thisiskeithb)
- - Peter Ellens [[@ellensp](https://github.com/ellensp)] - New Zealand  &nbsp; [ðŸ’¸ Donate](https://ko-fi.com/ellensp)
- - Victor Oliveira [[@rhapsodyv](https://github.com/rhapsodyv)] - Brazil
- - Chris Pepper [[@p3p](https://github.com/p3p)] - UK
- - Jason Smith [[@sjasonsmith](https://github.com/sjasonsmith)] - USA
- - Luu Lac [[@shitcreek](https://github.com/shitcreek)] - USA
- - Bob Kuhn [[@Bob-the-Kuhn](https://github.com/Bob-the-Kuhn)] - USA
- - Erik van der Zalm [[@ErikZalm](https://github.com/ErikZalm)] - Netherlands &nbsp; [ðŸ’¸ Donate](https://flattr.com/submit/auto?user_id=ErikZalm&url=https://github.com/MarlinFirmware/Marlin&title=Marlin&language=&tags=github&category=software)
-
-## License
-
-Marlin is published under the [GPL license](/LICENSE) because we believe in open development. The GPL comes with both rights and obligations. Whether you use Marlin firmware as the driver for your open or closed-source product, you must keep Marlin open, and you must provide your compatible Marlin source code to end users upon request. The most straightforward way to comply with the Marlin license is to make a fork of Marlin on Github, perform your modifications, and direct users to your modified fork.
-
-While we can't prevent the use of this code in products (3D printers, CNC, etc.) that are closed source or crippled by a patent, we would prefer that you choose another firmware or, better yet, make your own.
+- Configured for CNC
+- Custom LCD commands
+- Configured for Skr Pro v1.2
+- Configured for TMC2209
+- Configured for TFT35 E3 V3
+- Configured for Dual XY
+- Configured for Skr Pro v1.2 dual
+- Configured for laser settings
diff --git a/platformio.ini b/platformio.ini
index 751543c..5b4a2c5 100644
--- a/platformio.ini
+++ b/platformio.ini
@@ -13,7 +13,7 @@
 [platformio]
 src_dir      = Marlin
 boards_dir   = buildroot/share/PlatformIO/boards
-default_envs = mega2560
+default_envs = BIGTREE_SKR_PRO
 include_dir  = Marlin
 extra_configs =
     Marlin/config.ini

